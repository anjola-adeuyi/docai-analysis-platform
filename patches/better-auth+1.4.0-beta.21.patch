diff --git a/node_modules/better-auth/dist/access-6c2-Np4U.mjs.bak b/node_modules/better-auth/dist/access-6c2-Np4U.mjs.bak
new file mode 100644
index 0000000..4aa83c0
--- /dev/null
+++ b/node_modules/better-auth/dist/access-6c2-Np4U.mjs.bak
@@ -0,0 +1,45 @@
+import { BetterAuthError } from "@better-auth/core/error";
+
+//#region src/plugins/access/access.ts
+function role(statements) {
+	return {
+		authorize(request, connector = "AND") {
+			let success = false;
+			for (const [requestedResource, requestedActions] of Object.entries(request)) {
+				const allowedActions = statements[requestedResource];
+				if (!allowedActions) return {
+					success: false,
+					error: `You are not allowed to access resource: ${requestedResource}`
+				};
+				if (Array.isArray(requestedActions)) success = requestedActions.every((requestedAction) => allowedActions.includes(requestedAction));
+				else if (typeof requestedActions === "object") {
+					const actions = requestedActions;
+					if (actions.connector === "OR") success = actions.actions.some((requestedAction) => allowedActions.includes(requestedAction));
+					else success = actions.actions.every((requestedAction) => allowedActions.includes(requestedAction));
+				} else throw new BetterAuthError("Invalid access control request");
+				if (success && connector === "OR") return { success };
+				if (!success && connector === "AND") return {
+					success: false,
+					error: `unauthorized to access resource "${requestedResource}"`
+				};
+			}
+			if (success) return { success };
+			return {
+				success: false,
+				error: "Not authorized"
+			};
+		},
+		statements
+	};
+}
+function createAccessControl(s) {
+	return {
+		newRole(statements) {
+			return role(statements);
+		},
+		statements: s
+	};
+}
+
+//#endregion
+export { role as n, createAccessControl as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/access-BYnrn7CR.mjs.bak b/node_modules/better-auth/dist/access-BYnrn7CR.mjs.bak
new file mode 100644
index 0000000..ff55998
--- /dev/null
+++ b/node_modules/better-auth/dist/access-BYnrn7CR.mjs.bak
@@ -0,0 +1,51 @@
+import { t as createAccessControl } from "./access-6c2-Np4U.mjs";
+
+//#region src/plugins/admin/access/statement.ts
+const defaultStatements = {
+	user: [
+		"create",
+		"list",
+		"set-role",
+		"ban",
+		"impersonate",
+		"delete",
+		"set-password",
+		"get",
+		"update"
+	],
+	session: [
+		"list",
+		"revoke",
+		"delete"
+	]
+};
+const defaultAc = createAccessControl(defaultStatements);
+const adminAc = defaultAc.newRole({
+	user: [
+		"create",
+		"list",
+		"set-role",
+		"ban",
+		"impersonate",
+		"delete",
+		"set-password",
+		"get",
+		"update"
+	],
+	session: [
+		"list",
+		"revoke",
+		"delete"
+	]
+});
+const userAc = defaultAc.newRole({
+	user: [],
+	session: []
+});
+const defaultRoles = {
+	admin: adminAc,
+	user: userAc
+};
+
+//#endregion
+export { userAc as a, defaultStatements as i, defaultAc as n, defaultRoles as r, adminAc as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/access-HdxSBEa0.mjs.bak b/node_modules/better-auth/dist/access-HdxSBEa0.mjs.bak
new file mode 100644
index 0000000..17357c0
--- /dev/null
+++ b/node_modules/better-auth/dist/access-HdxSBEa0.mjs.bak
@@ -0,0 +1,79 @@
+import { t as createAccessControl } from "./access-6c2-Np4U.mjs";
+
+//#region src/plugins/organization/access/statement.ts
+const defaultStatements = {
+	organization: ["update", "delete"],
+	member: [
+		"create",
+		"update",
+		"delete"
+	],
+	invitation: ["create", "cancel"],
+	team: [
+		"create",
+		"update",
+		"delete"
+	],
+	ac: [
+		"create",
+		"read",
+		"update",
+		"delete"
+	]
+};
+const defaultAc = createAccessControl(defaultStatements);
+const adminAc = defaultAc.newRole({
+	organization: ["update"],
+	invitation: ["create", "cancel"],
+	member: [
+		"create",
+		"update",
+		"delete"
+	],
+	team: [
+		"create",
+		"update",
+		"delete"
+	],
+	ac: [
+		"create",
+		"read",
+		"update",
+		"delete"
+	]
+});
+const ownerAc = defaultAc.newRole({
+	organization: ["update", "delete"],
+	member: [
+		"create",
+		"update",
+		"delete"
+	],
+	invitation: ["create", "cancel"],
+	team: [
+		"create",
+		"update",
+		"delete"
+	],
+	ac: [
+		"create",
+		"read",
+		"update",
+		"delete"
+	]
+});
+const memberAc = defaultAc.newRole({
+	organization: [],
+	member: [],
+	invitation: [],
+	team: [],
+	ac: ["read"]
+});
+const defaultRoles = {
+	admin: adminAc,
+	owner: ownerAc,
+	member: memberAc
+};
+
+//#endregion
+export { memberAc as a, defaultStatements as i, defaultAc as n, ownerAc as o, defaultRoles as r, adminAc as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapter-factory-znqU8768.mjs.bak b/node_modules/better-auth/dist/adapter-factory-znqU8768.mjs.bak
new file mode 100644
index 0000000..8e0c3c3
--- /dev/null
+++ b/node_modules/better-auth/dist/adapter-factory-znqU8768.mjs.bak
@@ -0,0 +1,822 @@
+import { a as getAuthTables, i as initGetDefaultModelName, n as initGetFieldName, r as initGetDefaultFieldName, t as initGetModelName } from "./get-model-name-nJd9iPTo.mjs";
+import { t as generateId } from "./utils-F62c-ieM.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { TTY_COLORS, getColorDepth, logger } from "@better-auth/core/env";
+import { BetterAuthError } from "@better-auth/core/error";
+
+//#region src/adapters/utils.ts
+function withApplyDefault(value, field, action) {
+	if (action === "update") {
+		if (value === void 0 && field.onUpdate !== void 0) {
+			if (typeof field.onUpdate === "function") return field.onUpdate();
+			return field.onUpdate;
+		}
+		return value;
+	}
+	if (action === "create") {
+		if (value === void 0 || field.required === true && value === null) {
+			if (field.defaultValue !== void 0) {
+				if (typeof field.defaultValue === "function") return field.defaultValue();
+				return field.defaultValue;
+			}
+		}
+	}
+	return value;
+}
+
+//#endregion
+//#region src/adapters/adapter-factory/get-id-field.ts
+const initGetIdField = ({ usePlural, schema, disableIdGeneration, options, customIdGenerator, supportsUUIDs }) => {
+	const getDefaultModelName = initGetDefaultModelName({
+		usePlural,
+		schema
+	});
+	const idField = ({ customModelName, forceAllowId }) => {
+		const useNumberId = options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial";
+		const useUUIDs = options.advanced?.database?.generateId === "uuid";
+		let shouldGenerateId = (() => {
+			if (disableIdGeneration) return false;
+			else if (useNumberId && !forceAllowId) return false;
+			else if (useUUIDs) return !supportsUUIDs;
+			else return true;
+		})();
+		const model = getDefaultModelName(customModelName ?? "id");
+		return {
+			type: useNumberId ? "number" : "string",
+			required: shouldGenerateId ? true : false,
+			...shouldGenerateId ? { defaultValue() {
+				if (disableIdGeneration) return void 0;
+				let generateId$1 = options.advanced?.database?.generateId;
+				if (options.advanced?.generateId !== void 0) {
+					logger.warn("Your Better Auth config includes advanced.generateId which is deprecated. Please use advanced.database.generateId instead. This will be removed in future releases.");
+					generateId$1 = options.advanced?.generateId;
+				}
+				if (generateId$1 === false || useNumberId) return void 0;
+				if (typeof generateId$1 === "function") return generateId$1({ model });
+				if (customIdGenerator) return customIdGenerator({ model });
+				if (generateId$1 === "uuid") return crypto.randomUUID();
+				return generateId();
+			} } : {},
+			transform: {
+				input: (value) => {
+					if (!value) return void 0;
+					if (useNumberId) {
+						const numberValue = Number(value);
+						if (isNaN(numberValue)) return;
+						return numberValue;
+					}
+					if (useUUIDs) {
+						if (shouldGenerateId && !forceAllowId) return value;
+						if (disableIdGeneration) return void 0;
+						if (supportsUUIDs) return void 0;
+						if (forceAllowId && typeof value === "string") if (/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value)) return value;
+						else {
+							const stack = (/* @__PURE__ */ new Error()).stack?.split("\n").filter((_, i) => i !== 1).join("\n").replace("Error:", "");
+							logger.warn("[Adapter Factory] - Invalid UUID value for field `id` provided when `forceAllowId` is true. Generating a new UUID.", stack);
+						}
+						if (typeof value !== "string" && !supportsUUIDs) return crypto.randomUUID();
+						return;
+					}
+					return value;
+				},
+				output: (value) => {
+					if (!value) return void 0;
+					return String(value);
+				}
+			}
+		};
+	};
+	return idField;
+};
+
+//#endregion
+//#region src/adapters/adapter-factory/get-field-attributes.ts
+const initGetFieldAttributes = ({ usePlural, schema, options, customIdGenerator, disableIdGeneration }) => {
+	const getDefaultModelName = initGetDefaultModelName({
+		usePlural,
+		schema
+	});
+	const getDefaultFieldName = initGetDefaultFieldName({
+		usePlural,
+		schema
+	});
+	const idField = initGetIdField({
+		usePlural,
+		schema,
+		options,
+		customIdGenerator,
+		disableIdGeneration
+	});
+	const getFieldAttributes = ({ model, field }) => {
+		const defaultModelName = getDefaultModelName(model);
+		const defaultFieldName = getDefaultFieldName({
+			field,
+			model: defaultModelName
+		});
+		const fields = schema[defaultModelName].fields;
+		fields.id = idField({ customModelName: defaultModelName });
+		const fieldAttributes = fields[defaultFieldName];
+		if (!fieldAttributes) throw new BetterAuthError(`Field ${field} not found in model ${model}`);
+		return fieldAttributes;
+	};
+	return getFieldAttributes;
+};
+
+//#endregion
+//#region src/adapters/adapter-factory/index.ts
+let debugLogs = [];
+let transactionId = -1;
+const createAsIsTransaction = (adapter) => (fn) => fn(adapter);
+const createAdapterFactory = ({ adapter: customAdapter, config: cfg }) => (options) => {
+	const uniqueAdapterFactoryInstanceId = Math.random().toString(36).substring(2, 15);
+	const config = {
+		...cfg,
+		supportsBooleans: cfg.supportsBooleans ?? true,
+		supportsDates: cfg.supportsDates ?? true,
+		supportsJSON: cfg.supportsJSON ?? false,
+		adapterName: cfg.adapterName ?? cfg.adapterId,
+		supportsNumericIds: cfg.supportsNumericIds ?? true,
+		supportsUUIDs: cfg.supportsUUIDs ?? false,
+		transaction: cfg.transaction ?? false,
+		disableTransformInput: cfg.disableTransformInput ?? false,
+		disableTransformOutput: cfg.disableTransformOutput ?? false,
+		disableTransformJoin: cfg.disableTransformJoin ?? false
+	};
+	if ((options.advanced?.database?.useNumberId === true || options.advanced?.database?.generateId === "serial") && config.supportsNumericIds === false) throw new BetterAuthError(`[${config.adapterName}] Your database or database adapter does not support numeric ids. Please disable "useNumberId" in your config.`);
+	const schema = getAuthTables(options);
+	const debugLog = (...args) => {
+		if (config.debugLogs === true || typeof config.debugLogs === "object") {
+			if (typeof config.debugLogs === "object" && "isRunningAdapterTests" in config.debugLogs) {
+				if (config.debugLogs.isRunningAdapterTests) {
+					args.shift();
+					debugLogs.push({
+						instance: uniqueAdapterFactoryInstanceId,
+						args
+					});
+				}
+				return;
+			}
+			if (typeof config.debugLogs === "object" && config.debugLogs.logCondition && !config.debugLogs.logCondition?.()) return;
+			if (typeof args[0] === "object" && "method" in args[0]) {
+				const method = args.shift().method;
+				if (typeof config.debugLogs === "object") {
+					if (method === "create" && !config.debugLogs.create) return;
+					else if (method === "update" && !config.debugLogs.update) return;
+					else if (method === "updateMany" && !config.debugLogs.updateMany) return;
+					else if (method === "findOne" && !config.debugLogs.findOne) return;
+					else if (method === "findMany" && !config.debugLogs.findMany) return;
+					else if (method === "delete" && !config.debugLogs.delete) return;
+					else if (method === "deleteMany" && !config.debugLogs.deleteMany) return;
+					else if (method === "count" && !config.debugLogs.count) return;
+				}
+				logger.info(`[${config.adapterName}]`, ...args);
+			} else logger.info(`[${config.adapterName}]`, ...args);
+		}
+	};
+	const getDefaultModelName = initGetDefaultModelName({
+		usePlural: config.usePlural,
+		schema
+	});
+	const getDefaultFieldName = initGetDefaultFieldName({
+		usePlural: config.usePlural,
+		schema
+	});
+	const getModelName = initGetModelName({
+		usePlural: config.usePlural,
+		schema
+	});
+	const getFieldName = initGetFieldName({
+		schema,
+		usePlural: config.usePlural
+	});
+	const idField = initGetIdField({
+		schema,
+		options,
+		usePlural: config.usePlural,
+		disableIdGeneration: config.disableIdGeneration,
+		customIdGenerator: config.customIdGenerator,
+		supportsUUIDs: config.supportsUUIDs
+	});
+	const getFieldAttributes = initGetFieldAttributes({
+		schema,
+		options,
+		usePlural: config.usePlural,
+		disableIdGeneration: config.disableIdGeneration,
+		customIdGenerator: config.customIdGenerator
+	});
+	const transformInput = async (data, defaultModelName, action, forceAllowId) => {
+		const transformedData = {};
+		const fields = schema[defaultModelName].fields;
+		const newMappedKeys = config.mapKeysTransformInput ?? {};
+		const useNumberId = options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial";
+		fields.id = idField({
+			customModelName: defaultModelName,
+			forceAllowId: forceAllowId && "id" in data
+		});
+		for (const field in fields) {
+			let value = data[field];
+			const fieldAttributes = fields[field];
+			let newFieldName = newMappedKeys[field] || fields[field].fieldName || field;
+			if (value === void 0 && (fieldAttributes.defaultValue === void 0 && !fieldAttributes.transform?.input && !(action === "update" && fieldAttributes.onUpdate) || action === "update" && !fieldAttributes.onUpdate)) continue;
+			if (fieldAttributes && fieldAttributes.type === "date" && !(value instanceof Date) && typeof value === "string") try {
+				value = new Date(value);
+			} catch {
+				logger.error("[Adapter Factory] Failed to convert string to date", {
+					value,
+					field
+				});
+			}
+			let newValue = withApplyDefault(value, fieldAttributes, action);
+			if (fieldAttributes.transform?.input) newValue = await fieldAttributes.transform.input(newValue);
+			if (fieldAttributes.references?.field === "id" && useNumberId) if (Array.isArray(newValue)) newValue = newValue.map((x) => x !== null ? Number(x) : null);
+			else newValue = newValue !== null ? Number(newValue) : null;
+			else if (config.supportsJSON === false && typeof newValue === "object" && fieldAttributes.type === "json") newValue = JSON.stringify(newValue);
+			else if (config.supportsDates === false && newValue instanceof Date && fieldAttributes.type === "date") newValue = newValue.toISOString();
+			else if (config.supportsBooleans === false && typeof newValue === "boolean") newValue = newValue ? 1 : 0;
+			if (config.customTransformInput) newValue = config.customTransformInput({
+				data: newValue,
+				action,
+				field: newFieldName,
+				fieldAttributes,
+				model: getModelName(defaultModelName),
+				schema,
+				options
+			});
+			if (newValue !== void 0) transformedData[newFieldName] = newValue;
+		}
+		return transformedData;
+	};
+	const transformOutput = async (data, unsafe_model, select = [], join) => {
+		const transformSingleOutput = async (data$1, unsafe_model$1, select$1 = []) => {
+			if (!data$1) return null;
+			const newMappedKeys = config.mapKeysTransformOutput ?? {};
+			const transformedData$1 = {};
+			const tableSchema = schema[getDefaultModelName(unsafe_model$1)].fields;
+			const idKey = Object.entries(newMappedKeys).find(([_, v]) => v === "id")?.[0];
+			tableSchema[idKey ?? "id"] = { type: options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial" ? "number" : "string" };
+			for (const key in tableSchema) {
+				if (select$1.length && !select$1.includes(key)) continue;
+				const field = tableSchema[key];
+				if (field) {
+					const originalKey = field.fieldName || key;
+					let newValue = data$1[Object.entries(newMappedKeys).find(([_, v]) => v === originalKey)?.[0] || originalKey];
+					if (field.transform?.output) newValue = await field.transform.output(newValue);
+					let newFieldName = newMappedKeys[key] || key;
+					if (originalKey === "id" || field.references?.field === "id") {
+						if (typeof newValue !== "undefined" && newValue !== null) newValue = String(newValue);
+					} else if (config.supportsJSON === false && typeof newValue === "string" && field.type === "json") newValue = safeJSONParse(newValue);
+					else if (config.supportsDates === false && typeof newValue === "string" && field.type === "date") newValue = new Date(newValue);
+					else if (config.supportsBooleans === false && typeof newValue === "number" && field.type === "boolean") newValue = newValue === 1;
+					if (config.customTransformOutput) newValue = config.customTransformOutput({
+						data: newValue,
+						field: newFieldName,
+						fieldAttributes: field,
+						select: select$1,
+						model: getModelName(unsafe_model$1),
+						schema,
+						options
+					});
+					transformedData$1[newFieldName] = newValue;
+				}
+			}
+			return transformedData$1;
+		};
+		if (!join || Object.keys(join).length === 0) return await transformSingleOutput(data, unsafe_model, select);
+		unsafe_model = getDefaultModelName(unsafe_model);
+		let transformedData = await transformSingleOutput(data, unsafe_model, select);
+		const requiredModels = Object.entries(join).map(([model, joinConfig]) => ({
+			modelName: getModelName(model),
+			defaultModelName: getDefaultModelName(model),
+			joinConfig
+		}));
+		if (!data) return null;
+		for (const { modelName, defaultModelName, joinConfig } of requiredModels) {
+			let joinedData = await (async () => {
+				if (options.experimental?.joins) return data[modelName];
+				else return await handleFallbackJoin({
+					baseModel: unsafe_model,
+					baseData: transformedData,
+					joinModel: modelName,
+					specificJoinConfig: joinConfig
+				});
+			})();
+			if (joinedData === void 0 || joinedData === null) joinedData = joinConfig.relation === "one-to-one" ? null : [];
+			if (joinConfig.relation === "one-to-many" && !Array.isArray(joinedData)) joinedData = [joinedData];
+			let transformed = [];
+			if (Array.isArray(joinedData)) for (const item of joinedData) {
+				const transformedItem = await transformSingleOutput(item, modelName, []);
+				transformed.push(transformedItem);
+			}
+			else {
+				const transformedItem = await transformSingleOutput(joinedData, modelName, []);
+				transformed.push(transformedItem);
+			}
+			transformedData[defaultModelName] = (joinConfig.relation === "one-to-one" ? transformed[0] : transformed) ?? null;
+		}
+		return transformedData;
+	};
+	const transformWhereClause = ({ model, where }) => {
+		if (!where) return void 0;
+		const newMappedKeys = config.mapKeysTransformInput ?? {};
+		return where.map((w) => {
+			const { field: unsafe_field, value, operator = "eq", connector = "AND" } = w;
+			if (operator === "in") {
+				if (!Array.isArray(value)) throw new BetterAuthError("Value must be an array");
+			}
+			let newValue = value;
+			const defaultModelName = getDefaultModelName(model);
+			const defaultFieldName = getDefaultFieldName({
+				field: unsafe_field,
+				model
+			});
+			const fieldName = newMappedKeys[defaultFieldName] || getFieldName({
+				field: defaultFieldName,
+				model: defaultModelName
+			});
+			const fieldAttr = getFieldAttributes({
+				field: defaultFieldName,
+				model: defaultModelName
+			});
+			const useNumberId = options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial";
+			if (defaultFieldName === "id" || fieldAttr.references?.field === "id") {
+				if (useNumberId) if (Array.isArray(value)) newValue = value.map(Number);
+				else newValue = Number(value);
+			}
+			if (fieldAttr.type === "date" && value instanceof Date && !config.supportsDates) newValue = value.toISOString();
+			if (fieldAttr.type === "boolean" && typeof value === "boolean" && !config.supportsBooleans) newValue = value ? 1 : 0;
+			if (fieldAttr.type === "json" && typeof value === "object" && !config.supportsJSON) try {
+				newValue = JSON.stringify(value);
+			} catch (error) {
+				throw new Error(`Failed to stringify JSON value for field ${fieldName}`, { cause: error });
+			}
+			return {
+				operator,
+				connector,
+				field: fieldName,
+				value: newValue
+			};
+		});
+	};
+	const transformJoinClause = (baseModel, unsanitizedJoin, select) => {
+		if (!unsanitizedJoin) return void 0;
+		if (Object.keys(unsanitizedJoin).length === 0) return void 0;
+		const transformedJoin = {};
+		for (const [model, join] of Object.entries(unsanitizedJoin)) {
+			if (!join) continue;
+			const defaultModelName = getDefaultModelName(model);
+			const defaultBaseModelName = getDefaultModelName(baseModel);
+			let foreignKeys = Object.entries(schema[defaultModelName].fields).filter(([field, fieldAttributes]) => fieldAttributes.references && getDefaultModelName(fieldAttributes.references.model) === defaultBaseModelName);
+			let isForwardJoin = true;
+			if (!foreignKeys.length) {
+				foreignKeys = Object.entries(schema[defaultBaseModelName].fields).filter(([field, fieldAttributes]) => fieldAttributes.references && getDefaultModelName(fieldAttributes.references.model) === defaultModelName);
+				isForwardJoin = false;
+			}
+			if (!foreignKeys.length) throw new BetterAuthError(`No foreign key found for model ${model} and base model ${baseModel} while performing join operation.`);
+			else if (foreignKeys.length > 1) throw new BetterAuthError(`Multiple foreign keys found for model ${model} and base model ${baseModel} while performing join operation. Only one foreign key is supported.`);
+			const [foreignKey, foreignKeyAttributes] = foreignKeys[0];
+			if (!foreignKeyAttributes.references) throw new BetterAuthError(`No references found for foreign key ${foreignKey} on model ${model} while performing join operation.`);
+			let from;
+			let to;
+			let requiredSelectField;
+			if (isForwardJoin) {
+				requiredSelectField = foreignKeyAttributes.references.field;
+				from = getFieldName({
+					model: baseModel,
+					field: requiredSelectField
+				});
+				to = getFieldName({
+					model,
+					field: foreignKey
+				});
+			} else {
+				requiredSelectField = foreignKey;
+				from = getFieldName({
+					model: baseModel,
+					field: requiredSelectField
+				});
+				to = getFieldName({
+					model,
+					field: foreignKeyAttributes.references.field
+				});
+			}
+			if (select && !select.includes(requiredSelectField)) select.push(requiredSelectField);
+			const isUnique = to === "id" ? true : foreignKeyAttributes.unique ?? false;
+			let limit = options.advanced?.database?.defaultFindManyLimit ?? 100;
+			if (isUnique) limit = 1;
+			else if (typeof join === "object" && typeof join.limit === "number") limit = join.limit;
+			transformedJoin[getModelName(model)] = {
+				on: {
+					from,
+					to
+				},
+				limit,
+				relation: isUnique ? "one-to-one" : "one-to-many"
+			};
+		}
+		return {
+			join: transformedJoin,
+			select
+		};
+	};
+	/**
+	* Handle joins by making separate queries and combining results (fallback for adapters that don't support native joins).
+	*/
+	const handleFallbackJoin = async ({ baseModel, baseData, joinModel, specificJoinConfig: joinConfig }) => {
+		if (!baseData) return baseData;
+		const modelName = getModelName(joinModel);
+		const field = joinConfig.on.to;
+		const value = baseData[getDefaultFieldName({
+			field: joinConfig.on.from,
+			model: baseModel
+		})];
+		if (value === null || value === void 0) return joinConfig.relation === "one-to-one" ? null : [];
+		let result;
+		const where = transformWhereClause({
+			model: modelName,
+			where: [{
+				field,
+				value,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		try {
+			if (joinConfig.relation === "one-to-one") result = await adapterInstance.findOne({
+				model: modelName,
+				where
+			});
+			else {
+				const limit = joinConfig.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
+				result = await adapterInstance.findMany({
+					model: modelName,
+					where,
+					limit
+				});
+			}
+		} catch (error) {
+			logger.error(`Failed to query fallback join for model ${modelName}:`, {
+				where,
+				limit: joinConfig.limit
+			});
+			console.error(error);
+			throw error;
+		}
+		return result;
+	};
+	const adapterInstance = customAdapter({
+		options,
+		schema,
+		debugLog,
+		getFieldName,
+		getModelName,
+		getDefaultModelName,
+		getDefaultFieldName,
+		getFieldAttributes,
+		transformInput,
+		transformOutput,
+		transformWhereClause
+	});
+	let lazyLoadTransaction = null;
+	const adapter = {
+		transaction: async (cb) => {
+			if (!lazyLoadTransaction) if (!config.transaction) lazyLoadTransaction = createAsIsTransaction(adapter);
+			else {
+				logger.debug(`[${config.adapterName}] - Using provided transaction implementation.`);
+				lazyLoadTransaction = config.transaction;
+			}
+			return lazyLoadTransaction(cb);
+		},
+		create: async ({ data: unsafeData, model: unsafeModel, select, forceAllowId = false }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			const model = getModelName(unsafeModel);
+			unsafeModel = getDefaultModelName(unsafeModel);
+			if ("id" in unsafeData && typeof unsafeData.id !== "undefined" && !forceAllowId) {
+				logger.warn(`[${config.adapterName}] - You are trying to create a record with an id. This is not allowed as we handle id generation for you, unless you pass in the \`forceAllowId\` parameter. The id will be ignored.`);
+				const stack = (/* @__PURE__ */ new Error()).stack?.split("\n").filter((_, i) => i !== 1).join("\n").replace("Error:", "Create method with `id` being called at:");
+				console.log(stack);
+				unsafeData.id = void 0;
+			}
+			debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("create")} ${formatAction("Unsafe Input")}:`, {
+				model,
+				data: unsafeData
+			});
+			let data = unsafeData;
+			if (!config.disableTransformInput) data = await transformInput(unsafeData, unsafeModel, "create", forceAllowId);
+			debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("create")} ${formatAction("Parsed Input")}:`, {
+				model,
+				data
+			});
+			const res = await adapterInstance.create({
+				data,
+				model
+			});
+			debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("create")} ${formatAction("DB Result")}:`, {
+				model,
+				res
+			});
+			let transformed = res;
+			if (!config.disableTransformOutput) transformed = await transformOutput(res, unsafeModel, select, void 0);
+			debugLog({ method: "create" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("create")} ${formatAction("Parsed Result")}:`, {
+				model,
+				data: transformed
+			});
+			return transformed;
+		},
+		update: async ({ model: unsafeModel, where: unsafeWhere, update: unsafeData }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			unsafeModel = getDefaultModelName(unsafeModel);
+			const model = getModelName(unsafeModel);
+			const where = transformWhereClause({
+				model: unsafeModel,
+				where: unsafeWhere
+			});
+			debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("update")} ${formatAction("Unsafe Input")}:`, {
+				model,
+				data: unsafeData
+			});
+			let data = unsafeData;
+			if (!config.disableTransformInput) data = await transformInput(unsafeData, unsafeModel, "update");
+			debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("update")} ${formatAction("Parsed Input")}:`, {
+				model,
+				data
+			});
+			const res = await adapterInstance.update({
+				model,
+				where,
+				update: data
+			});
+			debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("update")} ${formatAction("DB Result")}:`, {
+				model,
+				data: res
+			});
+			let transformed = res;
+			if (!config.disableTransformOutput) transformed = await transformOutput(res, unsafeModel, void 0, void 0);
+			debugLog({ method: "update" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("update")} ${formatAction("Parsed Result")}:`, {
+				model,
+				data: transformed
+			});
+			return transformed;
+		},
+		updateMany: async ({ model: unsafeModel, where: unsafeWhere, update: unsafeData }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			const model = getModelName(unsafeModel);
+			const where = transformWhereClause({
+				model: unsafeModel,
+				where: unsafeWhere
+			});
+			unsafeModel = getDefaultModelName(unsafeModel);
+			debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`, `${formatMethod("updateMany")} ${formatAction("Unsafe Input")}:`, {
+				model,
+				data: unsafeData
+			});
+			let data = unsafeData;
+			if (!config.disableTransformInput) data = await transformInput(unsafeData, unsafeModel, "update");
+			debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`, `${formatMethod("updateMany")} ${formatAction("Parsed Input")}:`, {
+				model,
+				data
+			});
+			const updatedCount = await adapterInstance.updateMany({
+				model,
+				where,
+				update: data
+			});
+			debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`, `${formatMethod("updateMany")} ${formatAction("DB Result")}:`, {
+				model,
+				data: updatedCount
+			});
+			debugLog({ method: "updateMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`, `${formatMethod("updateMany")} ${formatAction("Parsed Result")}:`, {
+				model,
+				data: updatedCount
+			});
+			return updatedCount;
+		},
+		findOne: async ({ model: unsafeModel, where: unsafeWhere, select, join: unsafeJoin }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			const model = getModelName(unsafeModel);
+			const where = transformWhereClause({
+				model: unsafeModel,
+				where: unsafeWhere
+			});
+			unsafeModel = getDefaultModelName(unsafeModel);
+			let join;
+			let passJoinToAdapter = true;
+			if (!config.disableTransformJoin) {
+				const result = transformJoinClause(unsafeModel, unsafeJoin, select);
+				if (result) {
+					join = result.join;
+					select = result.select;
+				}
+				if (!options.experimental?.joins && join && Object.keys(join).length > 0) passJoinToAdapter = false;
+			} else join = unsafeJoin;
+			debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`, `${formatMethod("findOne")}:`, {
+				model,
+				where,
+				select,
+				join
+			});
+			const res = await adapterInstance.findOne({
+				model,
+				where,
+				select,
+				join: passJoinToAdapter ? join : void 0
+			});
+			debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`, `${formatMethod("findOne")} ${formatAction("DB Result")}:`, {
+				model,
+				data: res
+			});
+			let transformed = res;
+			if (!config.disableTransformOutput) transformed = await transformOutput(res, unsafeModel, select, join);
+			debugLog({ method: "findOne" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`, `${formatMethod("findOne")} ${formatAction("Parsed Result")}:`, {
+				model,
+				data: transformed
+			});
+			return transformed;
+		},
+		findMany: async ({ model: unsafeModel, where: unsafeWhere, limit: unsafeLimit, sortBy, offset, join: unsafeJoin }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			const limit = unsafeLimit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
+			const model = getModelName(unsafeModel);
+			const where = transformWhereClause({
+				model: unsafeModel,
+				where: unsafeWhere
+			});
+			unsafeModel = getDefaultModelName(unsafeModel);
+			let join;
+			let passJoinToAdapter = true;
+			if (!config.disableTransformJoin) {
+				const result = transformJoinClause(unsafeModel, unsafeJoin, void 0);
+				if (result) join = result.join;
+				if (!options.experimental?.joins && join && Object.keys(join).length > 0) passJoinToAdapter = false;
+			} else join = unsafeJoin;
+			debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`, `${formatMethod("findMany")}:`, {
+				model,
+				where,
+				limit,
+				sortBy,
+				offset,
+				join
+			});
+			const res = await adapterInstance.findMany({
+				model,
+				where,
+				limit,
+				sortBy,
+				offset,
+				join: passJoinToAdapter ? join : void 0
+			});
+			debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`, `${formatMethod("findMany")} ${formatAction("DB Result")}:`, {
+				model,
+				data: res
+			});
+			let transformed = res;
+			if (!config.disableTransformOutput) transformed = await Promise.all(res.map(async (r) => {
+				return await transformOutput(r, unsafeModel, void 0, join);
+			}));
+			debugLog({ method: "findMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`, `${formatMethod("findMany")} ${formatAction("Parsed Result")}:`, {
+				model,
+				data: transformed
+			});
+			return transformed;
+		},
+		delete: async ({ model: unsafeModel, where: unsafeWhere }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			const model = getModelName(unsafeModel);
+			const where = transformWhereClause({
+				model: unsafeModel,
+				where: unsafeWhere
+			});
+			unsafeModel = getDefaultModelName(unsafeModel);
+			debugLog({ method: "delete" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("delete")}:`, {
+				model,
+				where
+			});
+			await adapterInstance.delete({
+				model,
+				where
+			});
+			debugLog({ method: "delete" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("delete")} ${formatAction("DB Result")}:`, { model });
+		},
+		deleteMany: async ({ model: unsafeModel, where: unsafeWhere }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			const model = getModelName(unsafeModel);
+			const where = transformWhereClause({
+				model: unsafeModel,
+				where: unsafeWhere
+			});
+			unsafeModel = getDefaultModelName(unsafeModel);
+			debugLog({ method: "deleteMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("deleteMany")} ${formatAction("DeleteMany")}:`, {
+				model,
+				where
+			});
+			const res = await adapterInstance.deleteMany({
+				model,
+				where
+			});
+			debugLog({ method: "deleteMany" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("deleteMany")} ${formatAction("DB Result")}:`, {
+				model,
+				data: res
+			});
+			return res;
+		},
+		count: async ({ model: unsafeModel, where: unsafeWhere }) => {
+			transactionId++;
+			let thisTransactionId = transactionId;
+			const model = getModelName(unsafeModel);
+			const where = transformWhereClause({
+				model: unsafeModel,
+				where: unsafeWhere
+			});
+			unsafeModel = getDefaultModelName(unsafeModel);
+			debugLog({ method: "count" }, `${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`, `${formatMethod("count")}:`, {
+				model,
+				where
+			});
+			const res = await adapterInstance.count({
+				model,
+				where
+			});
+			debugLog({ method: "count" }, `${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`, `${formatMethod("count")}:`, {
+				model,
+				data: res
+			});
+			return res;
+		},
+		createSchema: adapterInstance.createSchema ? async (_, file) => {
+			const tables = getAuthTables(options);
+			if (options.secondaryStorage && !options.session?.storeSessionInDatabase) delete tables.session;
+			if (options.rateLimit && options.rateLimit.storage === "database" && (typeof options.rateLimit.enabled === "undefined" || options.rateLimit.enabled === true)) tables.ratelimit = {
+				modelName: options.rateLimit.modelName ?? "ratelimit",
+				fields: {
+					key: {
+						type: "string",
+						unique: true,
+						required: true,
+						fieldName: options.rateLimit.fields?.key ?? "key"
+					},
+					count: {
+						type: "number",
+						required: true,
+						fieldName: options.rateLimit.fields?.count ?? "count"
+					},
+					lastRequest: {
+						type: "number",
+						required: true,
+						bigint: true,
+						defaultValue: () => Date.now(),
+						fieldName: options.rateLimit.fields?.lastRequest ?? "lastRequest"
+					}
+				}
+			};
+			return adapterInstance.createSchema({
+				file,
+				tables
+			});
+		} : void 0,
+		options: {
+			adapterConfig: config,
+			...adapterInstance.options ?? {}
+		},
+		id: config.adapterId,
+		...config.debugLogs?.isRunningAdapterTests ? { adapterTestDebugLogs: {
+			resetDebugLogs() {
+				debugLogs = debugLogs.filter((log) => log.instance !== uniqueAdapterFactoryInstanceId);
+			},
+			printDebugLogs() {
+				const separator = `â”€`.repeat(80);
+				const logs = debugLogs.filter((log$1) => log$1.instance === uniqueAdapterFactoryInstanceId);
+				if (logs.length === 0) return;
+				let log = logs.reverse().map((log$1) => {
+					log$1.args[0] = `\n${log$1.args[0]}`;
+					return [...log$1.args, "\n"];
+				}).reduce((prev, curr) => {
+					return [...curr, ...prev];
+				}, [`\n${separator}`]);
+				console.log(...log);
+			}
+		} } : {}
+	};
+	return adapter;
+};
+function formatTransactionId(transactionId$1) {
+	if (getColorDepth() < 8) return `#${transactionId$1}`;
+	return `${TTY_COLORS.fg.magenta}#${transactionId$1}${TTY_COLORS.reset}`;
+}
+function formatStep(step, total) {
+	return `${TTY_COLORS.bg.black}${TTY_COLORS.fg.yellow}[${step}/${total}]${TTY_COLORS.reset}`;
+}
+function formatMethod(method) {
+	return `${TTY_COLORS.bright}${method}${TTY_COLORS.reset}`;
+}
+function formatAction(action) {
+	return `${TTY_COLORS.dim}(${action})${TTY_COLORS.reset}`;
+}
+
+//#endregion
+export { initGetFieldAttributes as n, initGetIdField as r, createAdapterFactory as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapters/drizzle-adapter/index.mjs.bak b/node_modules/better-auth/dist/adapters/drizzle-adapter/index.mjs.bak
new file mode 100644
index 0000000..ba4a32b
--- /dev/null
+++ b/node_modules/better-auth/dist/adapters/drizzle-adapter/index.mjs.bak
@@ -0,0 +1,286 @@
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../json-BS-nL3f-.mjs";
+import { t as createAdapterFactory } from "../../adapter-factory-znqU8768.mjs";
+import { logger } from "@better-auth/core/env";
+import { BetterAuthError } from "@better-auth/core/error";
+import { and, asc, count, desc, eq, gt, gte, inArray, like, lt, lte, ne, notInArray, or, sql } from "drizzle-orm";
+
+//#region src/adapters/drizzle-adapter/drizzle-adapter.ts
+const drizzleAdapter = (db, config) => {
+	let lazyOptions = null;
+	const createCustomAdapter = (db$1) => ({ getFieldName, options }) => {
+		function getSchema(model) {
+			const schema = config.schema || db$1._.fullSchema;
+			if (!schema) throw new BetterAuthError("Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.");
+			const schemaModel = schema[model];
+			if (!schemaModel) throw new BetterAuthError(`[# Drizzle Adapter]: The model "${model}" was not found in the schema object. Please pass the schema directly to the adapter options.`);
+			return schemaModel;
+		}
+		const withReturning = async (model, builder, data, where) => {
+			if (config.provider !== "mysql") return (await builder.returning())[0];
+			await builder.execute();
+			const schemaModel = getSchema(model);
+			const builderVal = builder.config?.values;
+			if (where?.length) {
+				const clause = convertWhereClause(where.map((w) => {
+					if (data[w.field] !== void 0) return {
+						...w,
+						value: data[w.field]
+					};
+					return w;
+				}), model);
+				return (await db$1.select().from(schemaModel).where(...clause))[0];
+			} else if (builderVal && builderVal[0]?.id?.value) {
+				let tId = builderVal[0]?.id?.value;
+				if (!tId) tId = (await db$1.select({ id: sql`LAST_INSERT_ID()` }).from(schemaModel).orderBy(desc(schemaModel.id)).limit(1))[0].id;
+				return (await db$1.select().from(schemaModel).where(eq(schemaModel.id, tId)).limit(1).execute())[0];
+			} else if (data.id) return (await db$1.select().from(schemaModel).where(eq(schemaModel.id, data.id)).limit(1).execute())[0];
+			else {
+				if (!("id" in schemaModel)) throw new BetterAuthError(`The model "${model}" does not have an "id" field. Please use the "id" field as your primary key.`);
+				return (await db$1.select().from(schemaModel).orderBy(desc(schemaModel.id)).limit(1).execute())[0];
+			}
+		};
+		function convertWhereClause(where, model) {
+			const schemaModel = getSchema(model);
+			if (!where) return [];
+			if (where.length === 1) {
+				const w = where[0];
+				if (!w) return [];
+				const field = getFieldName({
+					model,
+					field: w.field
+				});
+				if (!schemaModel[field]) throw new BetterAuthError(`The field "${w.field}" does not exist in the schema for the model "${model}". Please update your schema.`);
+				if (w.operator === "in") {
+					if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
+					return [inArray(schemaModel[field], w.value)];
+				}
+				if (w.operator === "not_in") {
+					if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "not_in" operator.`);
+					return [notInArray(schemaModel[field], w.value)];
+				}
+				if (w.operator === "contains") return [like(schemaModel[field], `%${w.value}%`)];
+				if (w.operator === "starts_with") return [like(schemaModel[field], `${w.value}%`)];
+				if (w.operator === "ends_with") return [like(schemaModel[field], `%${w.value}`)];
+				if (w.operator === "lt") return [lt(schemaModel[field], w.value)];
+				if (w.operator === "lte") return [lte(schemaModel[field], w.value)];
+				if (w.operator === "ne") return [ne(schemaModel[field], w.value)];
+				if (w.operator === "gt") return [gt(schemaModel[field], w.value)];
+				if (w.operator === "gte") return [gte(schemaModel[field], w.value)];
+				return [eq(schemaModel[field], w.value)];
+			}
+			const andGroup = where.filter((w) => w.connector === "AND" || !w.connector);
+			const orGroup = where.filter((w) => w.connector === "OR");
+			const andClause = and(...andGroup.map((w) => {
+				const field = getFieldName({
+					model,
+					field: w.field
+				});
+				if (w.operator === "in") {
+					if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
+					return inArray(schemaModel[field], w.value);
+				}
+				if (w.operator === "not_in") {
+					if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "not_in" operator.`);
+					return notInArray(schemaModel[field], w.value);
+				}
+				if (w.operator === "contains") return like(schemaModel[field], `%${w.value}%`);
+				if (w.operator === "starts_with") return like(schemaModel[field], `${w.value}%`);
+				if (w.operator === "ends_with") return like(schemaModel[field], `%${w.value}`);
+				if (w.operator === "lt") return lt(schemaModel[field], w.value);
+				if (w.operator === "lte") return lte(schemaModel[field], w.value);
+				if (w.operator === "gt") return gt(schemaModel[field], w.value);
+				if (w.operator === "gte") return gte(schemaModel[field], w.value);
+				if (w.operator === "ne") return ne(schemaModel[field], w.value);
+				return eq(schemaModel[field], w.value);
+			}));
+			const orClause = or(...orGroup.map((w) => {
+				const field = getFieldName({
+					model,
+					field: w.field
+				});
+				if (w.operator === "in") {
+					if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "in" operator.`);
+					return inArray(schemaModel[field], w.value);
+				}
+				if (w.operator === "not_in") {
+					if (!Array.isArray(w.value)) throw new BetterAuthError(`The value for the field "${w.field}" must be an array when using the "not_in" operator.`);
+					return notInArray(schemaModel[field], w.value);
+				}
+				if (w.operator === "contains") return like(schemaModel[field], `%${w.value}%`);
+				if (w.operator === "starts_with") return like(schemaModel[field], `${w.value}%`);
+				if (w.operator === "ends_with") return like(schemaModel[field], `%${w.value}`);
+				if (w.operator === "lt") return lt(schemaModel[field], w.value);
+				if (w.operator === "lte") return lte(schemaModel[field], w.value);
+				if (w.operator === "gt") return gt(schemaModel[field], w.value);
+				if (w.operator === "gte") return gte(schemaModel[field], w.value);
+				if (w.operator === "ne") return ne(schemaModel[field], w.value);
+				return eq(schemaModel[field], w.value);
+			}));
+			const clause = [];
+			if (andGroup.length) clause.push(andClause);
+			if (orGroup.length) clause.push(orClause);
+			return clause;
+		}
+		function checkMissingFields(schema, model, values) {
+			if (!schema) throw new BetterAuthError("Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.");
+			for (const key in values) if (!schema[key]) throw new BetterAuthError(`The field "${key}" does not exist in the "${model}" schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli generate".`);
+		}
+		return {
+			async create({ model, data: values }) {
+				const schemaModel = getSchema(model);
+				checkMissingFields(schemaModel, model, values);
+				return await withReturning(model, db$1.insert(schemaModel).values(values), values);
+			},
+			async findOne({ model, where, join }) {
+				const schemaModel = getSchema(model);
+				const clause = convertWhereClause(where, model);
+				if (options.experimental?.joins) if (!db$1.query || !db$1.query[model]) {
+					logger.error(`[# Drizzle Adapter]: The model "${model}" was not found in the query object. Please update your schema to include relations or re-generate using "npx auth generate".`);
+					logger.info("Falling back to regular query");
+				} else {
+					let includes;
+					const pluralJoinResults = [];
+					if (join) {
+						includes = {};
+						const joinEntries = Object.entries(join);
+						for (const [model$1, joinAttr] of joinEntries) {
+							const limit = joinAttr.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
+							const isUnique = joinAttr.relation === "one-to-one";
+							includes[`${model$1}${isUnique ? "" : "s"}`] = isUnique ? true : { limit };
+							if (!isUnique) pluralJoinResults.push(`${model$1}s`);
+						}
+					}
+					const res$1 = await db$1.query[model].findFirst({
+						where: clause[0],
+						with: includes
+					});
+					if (res$1) for (const pluralJoinResult of pluralJoinResults) {
+						const singularJoinResultName = pluralJoinResult.slice(0, -1);
+						res$1[singularJoinResultName] = res$1[pluralJoinResult];
+						delete res$1[pluralJoinResult];
+					}
+					return res$1;
+				}
+				const res = await db$1.select().from(schemaModel).where(...clause);
+				if (!res.length) return null;
+				return res[0];
+			},
+			async findMany({ model, where, sortBy, limit, offset, join }) {
+				const schemaModel = getSchema(model);
+				const clause = where ? convertWhereClause(where, model) : [];
+				const sortFn = sortBy?.direction === "desc" ? desc : asc;
+				if (options.experimental?.joins) if (!db$1.query[model]) {
+					logger.error(`[# Drizzle Adapter]: The model "${model}" was not found in the query object. Please update your schema to include relations or re-generate using "npx auth generate".`);
+					logger.info("Falling back to regular query");
+				} else {
+					let includes;
+					const pluralJoinResults = [];
+					if (join) {
+						includes = {};
+						const joinEntries = Object.entries(join);
+						for (const [model$1, joinAttr] of joinEntries) {
+							const isUnique = joinAttr.relation === "one-to-one";
+							const limit$1 = joinAttr.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
+							includes[`${model$1}${isUnique ? "" : "s"}`] = isUnique ? true : { limit: limit$1 };
+							if (!isUnique) pluralJoinResults.push(`${model$1}s`);
+						}
+					}
+					let orderBy = void 0;
+					if (sortBy?.field) orderBy = [sortFn(schemaModel[getFieldName({
+						model,
+						field: sortBy?.field
+					})])];
+					let res = await db$1.query[model].findMany({
+						where: clause[0],
+						with: includes,
+						limit: limit ?? 100,
+						offset: offset ?? 0,
+						orderBy
+					});
+					if (res) for (const item of res) for (const pluralJoinResult of pluralJoinResults) {
+						const singularJoinResultName = pluralJoinResult.slice(0, -1);
+						item[singularJoinResultName] = item[pluralJoinResult];
+						delete item[pluralJoinResult];
+					}
+					return res;
+				}
+				let builder = db$1.select().from(schemaModel);
+				const effectiveLimit = limit ?? 100;
+				const effectiveOffset = offset ?? 0;
+				builder = builder.limit(effectiveLimit);
+				builder = builder.offset(effectiveOffset);
+				if (sortBy?.field) builder = builder.orderBy(sortFn(schemaModel[getFieldName({
+					model,
+					field: sortBy?.field
+				})]));
+				return await builder.where(...clause);
+			},
+			async count({ model, where }) {
+				const schemaModel = getSchema(model);
+				const clause = where ? convertWhereClause(where, model) : [];
+				return (await db$1.select({ count: count() }).from(schemaModel).where(...clause))[0].count;
+			},
+			async update({ model, where, update: values }) {
+				const schemaModel = getSchema(model);
+				const clause = convertWhereClause(where, model);
+				return await withReturning(model, db$1.update(schemaModel).set(values).where(...clause), values, where);
+			},
+			async updateMany({ model, where, update: values }) {
+				const schemaModel = getSchema(model);
+				const clause = convertWhereClause(where, model);
+				return await db$1.update(schemaModel).set(values).where(...clause);
+			},
+			async delete({ model, where }) {
+				const schemaModel = getSchema(model);
+				const clause = convertWhereClause(where, model);
+				return await db$1.delete(schemaModel).where(...clause);
+			},
+			async deleteMany({ model, where }) {
+				const schemaModel = getSchema(model);
+				const clause = convertWhereClause(where, model);
+				const res = await db$1.delete(schemaModel).where(...clause);
+				let count$1 = 0;
+				if (res && "rowCount" in res) count$1 = res.rowCount;
+				else if (Array.isArray(res)) count$1 = res.length;
+				else if (res && ("affectedRows" in res || "rowsAffected" in res || "changes" in res)) count$1 = res.affectedRows ?? res.rowsAffected ?? res.changes;
+				if (typeof count$1 !== "number") logger.error("[Drizzle Adapter] The result of the deleteMany operation is not a number. This is likely a bug in the adapter. Please report this issue to the Better Auth team.", {
+					res,
+					model,
+					where
+				});
+				return count$1;
+			},
+			options: config
+		};
+	};
+	let adapterOptions = null;
+	adapterOptions = {
+		config: {
+			adapterId: "drizzle",
+			adapterName: "Drizzle Adapter",
+			usePlural: config.usePlural ?? false,
+			debugLogs: config.debugLogs ?? false,
+			supportsUUIDs: config.provider === "pg" ? true : false,
+			transaction: config.transaction ?? false ? (cb) => db.transaction((tx) => {
+				return cb(createAdapterFactory({
+					config: adapterOptions.config,
+					adapter: createCustomAdapter(tx)
+				})(lazyOptions));
+			}) : false
+		},
+		adapter: createCustomAdapter(db)
+	};
+	const adapter = createAdapterFactory(adapterOptions);
+	return (options) => {
+		lazyOptions = options;
+		return adapter(options);
+	};
+};
+
+//#endregion
+export { drizzleAdapter };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapters/index.mjs.bak b/node_modules/better-auth/dist/adapters/index.mjs.bak
new file mode 100644
index 0000000..b6daa89
--- /dev/null
+++ b/node_modules/better-auth/dist/adapters/index.mjs.bak
@@ -0,0 +1,18 @@
+import { i as initGetDefaultModelName, n as initGetFieldName, r as initGetDefaultFieldName, t as initGetModelName } from "../get-model-name-nJd9iPTo.mjs";
+import "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import "../json-BS-nL3f-.mjs";
+import { n as initGetFieldAttributes, r as initGetIdField, t as createAdapterFactory } from "../adapter-factory-znqU8768.mjs";
+
+export * from "@better-auth/core/db/adapter"
+
+//#region src/adapters/index.ts
+/**
+* @deprecated Use `createAdapterFactory` instead. This export will be removed in the next major version.
+*/
+const createAdapter = createAdapterFactory;
+
+//#endregion
+export { createAdapter, createAdapterFactory, initGetDefaultFieldName, initGetDefaultModelName, initGetFieldAttributes, initGetFieldName, initGetIdField, initGetModelName };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapters/kysely-adapter/index.mjs.bak b/node_modules/better-auth/dist/adapters/kysely-adapter/index.mjs.bak
new file mode 100644
index 0000000..a9b4744
--- /dev/null
+++ b/node_modules/better-auth/dist/adapters/kysely-adapter/index.mjs.bak
@@ -0,0 +1,297 @@
+import { n as getKyselyDatabaseType, t as createKyselyAdapter } from "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../json-BS-nL3f-.mjs";
+import { t as createAdapterFactory } from "../../adapter-factory-znqU8768.mjs";
+import { sql } from "kysely";
+
+//#region src/adapters/kysely-adapter/kysely-adapter.ts
+const kyselyAdapter = (db, config) => {
+	let lazyOptions = null;
+	const createCustomAdapter = (db$1) => {
+		return ({ getFieldName, schema, getDefaultFieldName, getDefaultModelName, getFieldAttributes, getModelName }) => {
+			const selectAllJoins = (join) => {
+				const allSelects = [];
+				const allSelectsStr = [];
+				if (join) for (const [joinModel, _] of Object.entries(join)) {
+					const fields = schema[getDefaultModelName(joinModel)]?.fields;
+					if (!fields) continue;
+					fields.id = { type: "string" };
+					for (const [field, fieldAttr] of Object.entries(fields)) {
+						allSelects.push(sql`${sql.ref(`join_${joinModel}`)}.${sql.ref(fieldAttr.fieldName || field)} as ${sql.ref(`_joined_${joinModel}_${fieldAttr.fieldName || field}`)}`);
+						allSelectsStr.push({
+							joinModel,
+							fieldName: fieldAttr.fieldName || field
+						});
+					}
+				}
+				return {
+					allSelectsStr,
+					allSelects
+				};
+			};
+			const withReturning = async (values, builder, model, where) => {
+				let res;
+				if (config?.type === "mysql") {
+					await builder.execute();
+					const field = values.id ? "id" : where.length > 0 && where[0]?.field ? where[0].field : "id";
+					if (!values.id && where.length === 0) {
+						res = await db$1.selectFrom(model).selectAll().orderBy(getFieldName({
+							model,
+							field
+						}), "desc").limit(1).executeTakeFirst();
+						return res;
+					}
+					const value = values[field] || where[0]?.value;
+					res = await db$1.selectFrom(model).selectAll().orderBy(getFieldName({
+						model,
+						field
+					}), "desc").where(getFieldName({
+						model,
+						field
+					}), "=", value).limit(1).executeTakeFirst();
+					return res;
+				}
+				if (config?.type === "mssql") {
+					res = await builder.outputAll("inserted").executeTakeFirst();
+					return res;
+				}
+				res = await builder.returningAll().executeTakeFirst();
+				return res;
+			};
+			function convertWhereClause(model, w) {
+				if (!w) return {
+					and: null,
+					or: null
+				};
+				const conditions = {
+					and: [],
+					or: []
+				};
+				w.forEach((condition) => {
+					let { field: _field, value: _value, operator = "=", connector = "AND" } = condition;
+					let value = _value;
+					let field = getFieldName({
+						model,
+						field: _field
+					});
+					const expr = (eb) => {
+						const f = `${model}.${field}`;
+						if (operator.toLowerCase() === "in") return eb(f, "in", Array.isArray(value) ? value : [value]);
+						if (operator.toLowerCase() === "not_in") return eb(f, "not in", Array.isArray(value) ? value : [value]);
+						if (operator === "contains") return eb(f, "like", `%${value}%`);
+						if (operator === "starts_with") return eb(f, "like", `${value}%`);
+						if (operator === "ends_with") return eb(f, "like", `%${value}`);
+						if (operator === "eq") return eb(f, "=", value);
+						if (operator === "ne") return eb(f, "<>", value);
+						if (operator === "gt") return eb(f, ">", value);
+						if (operator === "gte") return eb(f, ">=", value);
+						if (operator === "lt") return eb(f, "<", value);
+						if (operator === "lte") return eb(f, "<=", value);
+						return eb(f, operator, value);
+					};
+					if (connector === "OR") conditions.or.push(expr);
+					else conditions.and.push(expr);
+				});
+				return {
+					and: conditions.and.length ? conditions.and : null,
+					or: conditions.or.length ? conditions.or : null
+				};
+			}
+			function processJoinedResults(rows, joinConfig, allSelectsStr) {
+				if (!joinConfig || !rows.length) return rows;
+				const groupedByMainId = /* @__PURE__ */ new Map();
+				for (const currentRow of rows) {
+					const mainModelFields = {};
+					const joinedModelFields = {};
+					for (const [joinModel] of Object.entries(joinConfig)) joinedModelFields[getModelName(joinModel)] = {};
+					for (const [key, value] of Object.entries(currentRow)) {
+						const keyStr = String(key);
+						let assigned = false;
+						for (const { joinModel, fieldName } of allSelectsStr) if (keyStr === `_joined_${joinModel}_${fieldName}`) {
+							joinedModelFields[getModelName(joinModel)][getFieldName({
+								model: joinModel,
+								field: fieldName
+							})] = value;
+							assigned = true;
+							break;
+						}
+						if (!assigned) mainModelFields[key] = value;
+					}
+					const mainId = mainModelFields.id;
+					if (!mainId) continue;
+					if (!groupedByMainId.has(mainId)) {
+						const entry$1 = { ...mainModelFields };
+						for (const [joinModel, joinAttr] of Object.entries(joinConfig)) entry$1[getModelName(joinModel)] = joinAttr.relation === "one-to-one" ? null : [];
+						groupedByMainId.set(mainId, entry$1);
+					}
+					const entry = groupedByMainId.get(mainId);
+					for (const [joinModel, joinAttr] of Object.entries(joinConfig)) {
+						const isUnique = joinAttr.relation === "one-to-one";
+						const limit = joinAttr.limit ?? 100;
+						const joinedObj = joinedModelFields[getModelName(joinModel)];
+						const hasData = joinedObj && Object.keys(joinedObj).length > 0 && Object.values(joinedObj).some((value) => value !== null && value !== void 0);
+						if (isUnique) entry[getModelName(joinModel)] = hasData ? joinedObj : null;
+						else {
+							const joinModelName = getModelName(joinModel);
+							if (Array.isArray(entry[joinModelName]) && hasData) {
+								if (entry[joinModelName].length >= limit) continue;
+								const idFieldName = getFieldName({
+									model: joinModel,
+									field: "id"
+								});
+								const joinedId = joinedObj[idFieldName];
+								if (joinedId) {
+									if (!entry[joinModelName].some((item) => item[idFieldName] === joinedId) && entry[joinModelName].length < limit) entry[joinModelName].push(joinedObj);
+								} else if (entry[joinModelName].length < limit) entry[joinModelName].push(joinedObj);
+							}
+						}
+					}
+				}
+				let result = Array.from(groupedByMainId.values());
+				for (const entry of result) for (const [joinModel, joinAttr] of Object.entries(joinConfig)) if (joinAttr.relation !== "one-to-one") {
+					const joinModelName = getModelName(joinModel);
+					if (Array.isArray(entry[joinModelName])) {
+						const limit = joinAttr.limit ?? 100;
+						if (entry[joinModelName].length > limit) entry[joinModelName] = entry[joinModelName].slice(0, limit);
+					}
+				}
+				return result;
+			}
+			return {
+				async create({ data, model }) {
+					return await withReturning(data, db$1.insertInto(model).values(data), model, []);
+				},
+				async findOne({ model, where, select, join }) {
+					const { and, or } = convertWhereClause(model, where);
+					let query = db$1.selectFrom((eb) => {
+						let b = eb.selectFrom(model);
+						if (and) b = b.where((eb$1) => eb$1.and(and.map((expr) => expr(eb$1))));
+						if (or) b = b.where((eb$1) => eb$1.or(or.map((expr) => expr(eb$1))));
+						return b.selectAll().as(model);
+					}).selectAll(model);
+					if (join) for (const [joinModel, joinAttr] of Object.entries(join)) {
+						let joinQuery = db$1.selectFrom(joinModel).selectAll().as(`join_${joinModel}`);
+						query = query.leftJoin(() => joinQuery, (join$1) => join$1.onRef(`join_${joinModel}.${joinAttr.on.to}`, "=", `${model}.${joinAttr.on.from}`));
+					}
+					const { allSelectsStr, allSelects } = selectAllJoins(join);
+					query = query.select(allSelects);
+					const res = await query.execute();
+					if (!res || !Array.isArray(res) || res.length === 0) return null;
+					const row = res[0];
+					if (join) return processJoinedResults(res, join, allSelectsStr)[0];
+					return row;
+				},
+				async findMany({ model, where, limit, offset, sortBy, join }) {
+					const { and, or } = convertWhereClause(model, where);
+					let query = db$1.selectFrom((eb) => {
+						let b = eb.selectFrom(model);
+						if (config?.type === "mssql") {
+							if (offset !== void 0) {
+								if (!sortBy) b = b.orderBy(getFieldName({
+									model,
+									field: "id"
+								}));
+								b = b.offset(offset).fetch(limit || 100);
+							} else if (limit !== void 0) b = b.top(limit);
+						} else {
+							if (limit !== void 0) b = b.limit(limit);
+							if (offset !== void 0) b = b.offset(offset);
+						}
+						if (sortBy?.field) b = b.orderBy(`${getFieldName({
+							model,
+							field: sortBy.field
+						})}`, sortBy.direction);
+						if (and) b = b.where((eb$1) => eb$1.and(and.map((expr) => expr(eb$1))));
+						if (or) b = b.where((eb$1) => eb$1.or(or.map((expr) => expr(eb$1))));
+						return b.selectAll().as(model);
+					}).selectAll(model);
+					if (join) for (const [joinModel, joinAttr] of Object.entries(join)) {
+						let joinQueryBuilder = db$1.selectFrom(joinModel).selectAll().as(`join_${joinModel}`);
+						query = query.leftJoin(() => joinQueryBuilder, (join$1) => join$1.onRef(`join_${joinModel}.${joinAttr.on.to}`, "=", `${model}.${joinAttr.on.from}`));
+					}
+					const { allSelectsStr, allSelects } = selectAllJoins(join);
+					query = query.select(allSelects);
+					if (sortBy?.field) query = query.orderBy(`${getFieldName({
+						model,
+						field: sortBy.field
+					})}`, sortBy.direction);
+					const res = await query.execute();
+					if (!res) return [];
+					if (join) return processJoinedResults(res, join, allSelectsStr);
+					return res;
+				},
+				async update({ model, where, update: values }) {
+					const { and, or } = convertWhereClause(model, where);
+					let query = db$1.updateTable(model).set(values);
+					if (and) query = query.where((eb) => eb.and(and.map((expr) => expr(eb))));
+					if (or) query = query.where((eb) => eb.or(or.map((expr) => expr(eb))));
+					return await withReturning(values, query, model, where);
+				},
+				async updateMany({ model, where, update: values }) {
+					const { and, or } = convertWhereClause(model, where);
+					let query = db$1.updateTable(model).set(values);
+					if (and) query = query.where((eb) => eb.and(and.map((expr) => expr(eb))));
+					if (or) query = query.where((eb) => eb.or(or.map((expr) => expr(eb))));
+					return (await query.execute()).length;
+				},
+				async count({ model, where }) {
+					const { and, or } = convertWhereClause(model, where);
+					let query = db$1.selectFrom(model).select(db$1.fn.count("id").as("count"));
+					if (and) query = query.where((eb) => eb.and(and.map((expr) => expr(eb))));
+					if (or) query = query.where((eb) => eb.or(or.map((expr) => expr(eb))));
+					const res = await query.execute();
+					if (typeof res[0].count === "number") return res[0].count;
+					if (typeof res[0].count === "bigint") return Number(res[0].count);
+					return parseInt(res[0].count);
+				},
+				async delete({ model, where }) {
+					const { and, or } = convertWhereClause(model, where);
+					let query = db$1.deleteFrom(model);
+					if (and) query = query.where((eb) => eb.and(and.map((expr) => expr(eb))));
+					if (or) query = query.where((eb) => eb.or(or.map((expr) => expr(eb))));
+					await query.execute();
+				},
+				async deleteMany({ model, where }) {
+					const { and, or } = convertWhereClause(model, where);
+					let query = db$1.deleteFrom(model);
+					if (and) query = query.where((eb) => eb.and(and.map((expr) => expr(eb))));
+					if (or) query = query.where((eb) => eb.or(or.map((expr) => expr(eb))));
+					return (await query.execute()).length;
+				},
+				options: config
+			};
+		};
+	};
+	let adapterOptions = null;
+	adapterOptions = {
+		config: {
+			adapterId: "kysely",
+			adapterName: "Kysely Adapter",
+			usePlural: config?.usePlural,
+			debugLogs: config?.debugLogs,
+			supportsBooleans: config?.type === "sqlite" || config?.type === "mssql" || config?.type === "mysql" || !config?.type ? false : true,
+			supportsDates: config?.type === "sqlite" || config?.type === "mssql" || !config?.type ? false : true,
+			supportsJSON: false,
+			supportsUUIDs: config?.type === "postgres" ? true : false,
+			transaction: config?.transaction ? (cb) => db.transaction().execute((trx) => {
+				return cb(createAdapterFactory({
+					config: adapterOptions.config,
+					adapter: createCustomAdapter(trx)
+				})(lazyOptions));
+			}) : false
+		},
+		adapter: createCustomAdapter(db)
+	};
+	const adapter = createAdapterFactory(adapterOptions);
+	return (options) => {
+		lazyOptions = options;
+		return adapter(options);
+	};
+};
+
+//#endregion
+export { createKyselyAdapter, getKyselyDatabaseType, kyselyAdapter };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapters/memory-adapter/index.mjs.bak b/node_modules/better-auth/dist/adapters/memory-adapter/index.mjs.bak
new file mode 100644
index 0000000..cc91b82
--- /dev/null
+++ b/node_modules/better-auth/dist/adapters/memory-adapter/index.mjs.bak
@@ -0,0 +1,218 @@
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../json-BS-nL3f-.mjs";
+import { t as createAdapterFactory } from "../../adapter-factory-znqU8768.mjs";
+import { logger } from "@better-auth/core/env";
+
+//#region src/adapters/memory-adapter/memory-adapter.ts
+const memoryAdapter = (db, config) => {
+	let lazyOptions = null;
+	let adapterCreator = createAdapterFactory({
+		config: {
+			adapterId: "memory",
+			adapterName: "Memory Adapter",
+			usePlural: false,
+			debugLogs: config?.debugLogs || false,
+			customTransformInput(props) {
+				if ((props.options.advanced?.database?.useNumberId || props.options.advanced?.database?.generateId === "serial") && props.field === "id" && props.action === "create") return db[props.model].length + 1;
+				return props.data;
+			},
+			transaction: async (cb) => {
+				let clone = structuredClone(db);
+				try {
+					return await cb(adapterCreator(lazyOptions));
+				} catch (error) {
+					Object.keys(db).forEach((key) => {
+						db[key] = clone[key];
+					});
+					throw error;
+				}
+			}
+		},
+		adapter: ({ getFieldName, options, getModelName }) => {
+			const applySortToRecords = (records, sortBy, model) => {
+				if (!sortBy) return records;
+				return records.sort((a, b) => {
+					const field = getFieldName({
+						model,
+						field: sortBy.field
+					});
+					const aValue = a[field];
+					const bValue = b[field];
+					let comparison = 0;
+					if (aValue == null && bValue == null) comparison = 0;
+					else if (aValue == null) comparison = -1;
+					else if (bValue == null) comparison = 1;
+					else if (typeof aValue === "string" && typeof bValue === "string") comparison = aValue.localeCompare(bValue);
+					else if (aValue instanceof Date && bValue instanceof Date) comparison = aValue.getTime() - bValue.getTime();
+					else if (typeof aValue === "number" && typeof bValue === "number") comparison = aValue - bValue;
+					else if (typeof aValue === "boolean" && typeof bValue === "boolean") comparison = aValue === bValue ? 0 : aValue ? 1 : -1;
+					else comparison = String(aValue).localeCompare(String(bValue));
+					return sortBy.direction === "asc" ? comparison : -comparison;
+				});
+			};
+			function convertWhereClause(where, model, join) {
+				const execute = (where$1, model$1) => {
+					const table = db[model$1];
+					if (!table) {
+						logger.error(`[MemoryAdapter] Model ${model$1} not found in the DB`, Object.keys(db));
+						throw new Error(`Model ${model$1} not found`);
+					}
+					const evalClause = (record, clause) => {
+						const { field, value, operator } = clause;
+						switch (operator) {
+							case "in":
+								if (!Array.isArray(value)) throw new Error("Value must be an array");
+								return value.includes(record[field]);
+							case "not_in":
+								if (!Array.isArray(value)) throw new Error("Value must be an array");
+								return !value.includes(record[field]);
+							case "contains": return record[field].includes(value);
+							case "starts_with": return record[field].startsWith(value);
+							case "ends_with": return record[field].endsWith(value);
+							case "ne": return record[field] !== value;
+							case "gt": return value != null && Boolean(record[field] > value);
+							case "gte": return value != null && Boolean(record[field] >= value);
+							case "lt": return value != null && Boolean(record[field] < value);
+							case "lte": return value != null && Boolean(record[field] <= value);
+							default: return record[field] === value;
+						}
+					};
+					return table.filter((record) => {
+						if (!where$1.length || where$1.length === 0) return true;
+						let result = evalClause(record, where$1[0]);
+						for (const clause of where$1) {
+							const clauseResult = evalClause(record, clause);
+							if (clause.connector === "OR") result = result || clauseResult;
+							else result = result && clauseResult;
+						}
+						return result;
+					});
+				};
+				if (!join) return execute(where, model);
+				const baseRecords = execute(where, model);
+				const grouped = /* @__PURE__ */ new Map();
+				const seenIds = /* @__PURE__ */ new Map();
+				for (const baseRecord of baseRecords) {
+					const baseId = String(baseRecord.id);
+					if (!grouped.has(baseId)) {
+						const nested = { ...baseRecord };
+						for (const [joinModel, joinAttr] of Object.entries(join)) {
+							const joinModelName = getModelName(joinModel);
+							if (joinAttr.relation === "one-to-one") nested[joinModelName] = null;
+							else {
+								nested[joinModelName] = [];
+								seenIds.set(`${baseId}-${joinModel}`, /* @__PURE__ */ new Set());
+							}
+						}
+						grouped.set(baseId, nested);
+					}
+					const nestedEntry = grouped.get(baseId);
+					for (const [joinModel, joinAttr] of Object.entries(join)) {
+						const joinModelName = getModelName(joinModel);
+						const joinTable = db[joinModelName];
+						if (!joinTable) {
+							logger.error(`[MemoryAdapter] JoinOption model ${joinModelName} not found in the DB`, Object.keys(db));
+							throw new Error(`JoinOption model ${joinModelName} not found`);
+						}
+						const matchingRecords = joinTable.filter((joinRecord) => joinRecord[joinAttr.on.to] === baseRecord[joinAttr.on.from]);
+						if (joinAttr.relation === "one-to-one") nestedEntry[joinModelName] = matchingRecords[0] || null;
+						else {
+							const seenSet = seenIds.get(`${baseId}-${joinModel}`);
+							const limit = joinAttr.limit ?? 100;
+							let count = 0;
+							for (const matchingRecord of matchingRecords) {
+								if (count >= limit) break;
+								if (!seenSet.has(matchingRecord.id)) {
+									nestedEntry[joinModelName].push(matchingRecord);
+									seenSet.add(matchingRecord.id);
+									count++;
+								}
+							}
+						}
+					}
+				}
+				return Array.from(grouped.values());
+			}
+			return {
+				create: async ({ model, data }) => {
+					if (options.advanced?.database?.useNumberId || options.advanced?.database?.generateId === "serial") data.id = db[getModelName(model)].length + 1;
+					if (!db[model]) db[model] = [];
+					db[model].push(data);
+					return data;
+				},
+				findOne: async ({ model, where, join }) => {
+					const res = convertWhereClause(where, model, join);
+					if (join) {
+						const resArray = res;
+						if (!resArray.length) return null;
+						return resArray[0];
+					}
+					return res[0] || null;
+				},
+				findMany: async ({ model, where, sortBy, limit, offset, join }) => {
+					let res = convertWhereClause(where || [], model, join);
+					if (join) {
+						const resArray = res;
+						if (!resArray.length) return [];
+						applySortToRecords(resArray, sortBy, model);
+						let paginatedRecords = resArray;
+						if (offset !== void 0) paginatedRecords = paginatedRecords.slice(offset);
+						if (limit !== void 0) paginatedRecords = paginatedRecords.slice(0, limit);
+						return paginatedRecords;
+					}
+					let table = applySortToRecords(res, sortBy, model);
+					if (offset !== void 0) table = table.slice(offset);
+					if (limit !== void 0) table = table.slice(0, limit);
+					return table || [];
+				},
+				count: async ({ model, where }) => {
+					if (where) return convertWhereClause(where, model).length;
+					return db[model].length;
+				},
+				update: async ({ model, where, update }) => {
+					const res = convertWhereClause(where, model);
+					res.forEach((record) => {
+						Object.assign(record, update);
+					});
+					return res[0] || null;
+				},
+				delete: async ({ model, where }) => {
+					const table = db[model];
+					const res = convertWhereClause(where, model);
+					db[model] = table.filter((record) => !res.includes(record));
+				},
+				deleteMany: async ({ model, where }) => {
+					const table = db[model];
+					const res = convertWhereClause(where, model);
+					let count = 0;
+					db[model] = table.filter((record) => {
+						if (res.includes(record)) {
+							count++;
+							return false;
+						}
+						return !res.includes(record);
+					});
+					return count;
+				},
+				updateMany({ model, where, update }) {
+					const res = convertWhereClause(where, model);
+					res.forEach((record) => {
+						Object.assign(record, update);
+					});
+					return res[0] || null;
+				}
+			};
+		}
+	});
+	return (options) => {
+		lazyOptions = options;
+		return adapterCreator(options);
+	};
+};
+
+//#endregion
+export { memoryAdapter };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapters/mongodb-adapter/index.mjs.bak b/node_modules/better-auth/dist/adapters/mongodb-adapter/index.mjs.bak
new file mode 100644
index 0000000..5753a33
--- /dev/null
+++ b/node_modules/better-auth/dist/adapters/mongodb-adapter/index.mjs.bak
@@ -0,0 +1,395 @@
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../json-BS-nL3f-.mjs";
+import { t as createAdapterFactory } from "../../adapter-factory-znqU8768.mjs";
+import { ObjectId } from "mongodb";
+
+//#region src/adapters/mongodb-adapter/mongodb-adapter.ts
+const mongodbAdapter = (db, config) => {
+	let lazyOptions;
+	const getCustomIdGenerator = (options) => {
+		const generator = options.advanced?.database?.generateId || options.advanced?.generateId;
+		if (typeof generator === "function") return generator;
+	};
+	const createCustomAdapter = (db$1, session) => ({ getFieldAttributes, getFieldName, schema, getDefaultModelName, options }) => {
+		const customIdGen = getCustomIdGenerator(options);
+		function serializeID({ field, value, model }) {
+			if (customIdGen) return value;
+			model = getDefaultModelName(model);
+			if (field === "id" || field === "_id" || schema[model].fields[field]?.references?.field === "id") {
+				if (value === null || value === void 0) return value;
+				if (typeof value !== "string") {
+					if (value instanceof ObjectId) return value;
+					if (Array.isArray(value)) return value.map((v) => {
+						if (v === null || v === void 0) return v;
+						if (typeof v === "string") try {
+							return new ObjectId(v);
+						} catch (e) {
+							return v;
+						}
+						if (v instanceof ObjectId) return v;
+						throw new Error("Invalid id value, recieved: " + JSON.stringify(v));
+					});
+					throw new Error("Invalid id value, recieved: " + JSON.stringify(value));
+				}
+				try {
+					return new ObjectId(value);
+				} catch (e) {
+					return value;
+				}
+			}
+			return value;
+		}
+		function convertWhereClause({ where, model }) {
+			if (!where.length) return {};
+			const conditions = where.map((w) => {
+				const { field: field_, value, operator = "eq", connector = "AND" } = w;
+				let condition;
+				let field = getFieldName({
+					model,
+					field: field_
+				});
+				if (field === "id") field = "_id";
+				switch (operator.toLowerCase()) {
+					case "eq":
+						condition = { [field]: serializeID({
+							field,
+							value,
+							model
+						}) };
+						break;
+					case "in":
+						condition = { [field]: { $in: Array.isArray(value) ? value.map((v) => serializeID({
+							field,
+							value: v,
+							model
+						})) : [serializeID({
+							field,
+							value,
+							model
+						})] } };
+						break;
+					case "not_in":
+						condition = { [field]: { $nin: Array.isArray(value) ? value.map((v) => serializeID({
+							field,
+							value: v,
+							model
+						})) : [serializeID({
+							field,
+							value,
+							model
+						})] } };
+						break;
+					case "gt":
+						condition = { [field]: { $gt: serializeID({
+							field,
+							value,
+							model
+						}) } };
+						break;
+					case "gte":
+						condition = { [field]: { $gte: serializeID({
+							field,
+							value,
+							model
+						}) } };
+						break;
+					case "lt":
+						condition = { [field]: { $lt: serializeID({
+							field,
+							value,
+							model
+						}) } };
+						break;
+					case "lte":
+						condition = { [field]: { $lte: serializeID({
+							field,
+							value,
+							model
+						}) } };
+						break;
+					case "ne":
+						condition = { [field]: { $ne: serializeID({
+							field,
+							value,
+							model
+						}) } };
+						break;
+					case "contains":
+						condition = { [field]: { $regex: `.*${escapeForMongoRegex(value)}.*` } };
+						break;
+					case "starts_with":
+						condition = { [field]: { $regex: `^${escapeForMongoRegex(value)}` } };
+						break;
+					case "ends_with":
+						condition = { [field]: { $regex: `${escapeForMongoRegex(value)}$` } };
+						break;
+					default: throw new Error(`Unsupported operator: ${operator}`);
+				}
+				return {
+					condition,
+					connector
+				};
+			});
+			if (conditions.length === 1) return conditions[0].condition;
+			const andConditions = conditions.filter((c) => c.connector === "AND").map((c) => c.condition);
+			const orConditions = conditions.filter((c) => c.connector === "OR").map((c) => c.condition);
+			let clause = {};
+			if (andConditions.length) clause = {
+				...clause,
+				$and: andConditions
+			};
+			if (orConditions.length) clause = {
+				...clause,
+				$or: orConditions
+			};
+			return clause;
+		}
+		return {
+			async create({ model, data: values }) {
+				return {
+					_id: (await db$1.collection(model).insertOne(values, { session })).insertedId.toString(),
+					...values
+				};
+			},
+			async findOne({ model, where, select, join }) {
+				const pipeline = [where ? { $match: convertWhereClause({
+					where,
+					model
+				}) } : { $match: {} }];
+				if (join) for (const [joinedModel, joinConfig] of Object.entries(join)) {
+					const localField = getFieldName({
+						field: joinConfig.on.from,
+						model
+					});
+					const foreignField = getFieldName({
+						field: joinConfig.on.to,
+						model: joinedModel
+					});
+					const localFieldName = localField === "id" ? "_id" : localField;
+					const foreignFieldName = foreignField === "id" ? "_id" : foreignField;
+					const isUnique = (schema[getDefaultModelName(joinedModel)]?.fields[joinConfig.on.to])?.unique === true;
+					const shouldLimit = !isUnique && joinConfig.limit !== void 0;
+					let limit = joinConfig.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
+					if (shouldLimit && limit > 0) {
+						const foreignFieldRef = `$${foreignFieldName}`;
+						pipeline.push({ $lookup: {
+							from: joinedModel,
+							let: { localFieldValue: `$${localFieldName}` },
+							pipeline: [{ $match: { $expr: { $eq: [foreignFieldRef, "$$localFieldValue"] } } }, { $limit: limit }],
+							as: joinedModel
+						} });
+					} else pipeline.push({ $lookup: {
+						from: joinedModel,
+						localField: localFieldName,
+						foreignField: foreignFieldName,
+						as: joinedModel
+					} });
+					if (isUnique) pipeline.push({ $unwind: {
+						path: `$${joinedModel}`,
+						preserveNullAndEmptyArrays: true
+					} });
+				}
+				if (select) {
+					const projection = {};
+					select.forEach((field) => {
+						projection[getFieldName({
+							field,
+							model
+						})] = 1;
+					});
+					if (join) for (const joinedModel of Object.keys(join)) projection[joinedModel] = 1;
+					pipeline.push({ $project: projection });
+				}
+				pipeline.push({ $limit: 1 });
+				const res = await db$1.collection(model).aggregate(pipeline, { session }).toArray();
+				if (!res || res.length === 0) return null;
+				return res[0];
+			},
+			async findMany({ model, where, limit, offset, sortBy, join }) {
+				const pipeline = [where ? { $match: convertWhereClause({
+					where,
+					model
+				}) } : { $match: {} }];
+				if (join) for (const [joinedModel, joinConfig] of Object.entries(join)) {
+					const localField = getFieldName({
+						field: joinConfig.on.from,
+						model
+					});
+					const foreignField = getFieldName({
+						field: joinConfig.on.to,
+						model: joinedModel
+					});
+					const localFieldName = localField === "id" ? "_id" : localField;
+					const foreignFieldName = foreignField === "id" ? "_id" : foreignField;
+					const isUnique = getFieldAttributes({
+						model: joinedModel,
+						field: joinConfig.on.to
+					})?.unique === true;
+					const shouldLimit = joinConfig.relation !== "one-to-one" && joinConfig.limit !== void 0;
+					let limit$1 = joinConfig.limit ?? options.advanced?.database?.defaultFindManyLimit ?? 100;
+					if (shouldLimit && limit$1 > 0) {
+						const foreignFieldRef = `$${foreignFieldName}`;
+						pipeline.push({ $lookup: {
+							from: joinedModel,
+							let: { localFieldValue: `$${localFieldName}` },
+							pipeline: [{ $match: { $expr: { $eq: [foreignFieldRef, "$$localFieldValue"] } } }, { $limit: limit$1 }],
+							as: joinedModel
+						} });
+					} else pipeline.push({ $lookup: {
+						from: joinedModel,
+						localField: localFieldName,
+						foreignField: foreignFieldName,
+						as: joinedModel
+					} });
+					if (isUnique) pipeline.push({ $unwind: {
+						path: `$${joinedModel}`,
+						preserveNullAndEmptyArrays: true
+					} });
+				}
+				if (sortBy) pipeline.push({ $sort: { [getFieldName({
+					field: sortBy.field,
+					model
+				})]: sortBy.direction === "desc" ? -1 : 1 } });
+				if (offset) pipeline.push({ $skip: offset });
+				if (limit) pipeline.push({ $limit: limit });
+				return await db$1.collection(model).aggregate(pipeline, { session }).toArray();
+			},
+			async count({ model, where }) {
+				const pipeline = [where ? { $match: convertWhereClause({
+					where,
+					model
+				}) } : { $match: {} }, { $count: "total" }];
+				const res = await db$1.collection(model).aggregate(pipeline, { session }).toArray();
+				if (!res || res.length === 0) return 0;
+				return res[0]?.total ?? 0;
+			},
+			async update({ model, where, update: values }) {
+				const clause = convertWhereClause({
+					where,
+					model
+				});
+				const res = await db$1.collection(model).findOneAndUpdate(clause, { $set: values }, {
+					session,
+					returnDocument: "after"
+				});
+				if (!res) return null;
+				return res;
+			},
+			async updateMany({ model, where, update: values }) {
+				const clause = convertWhereClause({
+					where,
+					model
+				});
+				return (await db$1.collection(model).updateMany(clause, { $set: values }, { session })).modifiedCount;
+			},
+			async delete({ model, where }) {
+				const clause = convertWhereClause({
+					where,
+					model
+				});
+				await db$1.collection(model).deleteOne(clause, { session });
+			},
+			async deleteMany({ model, where }) {
+				const clause = convertWhereClause({
+					where,
+					model
+				});
+				return (await db$1.collection(model).deleteMany(clause, { session })).deletedCount;
+			}
+		};
+	};
+	let lazyAdapter = null;
+	let adapterOptions = null;
+	adapterOptions = {
+		config: {
+			adapterId: "mongodb-adapter",
+			adapterName: "MongoDB Adapter",
+			usePlural: config?.usePlural ?? false,
+			debugLogs: config?.debugLogs ?? false,
+			mapKeysTransformInput: { id: "_id" },
+			mapKeysTransformOutput: { _id: "id" },
+			supportsNumericIds: false,
+			transaction: config?.client && (config?.transaction ?? true) ? async (cb) => {
+				if (!config.client) return cb(lazyAdapter(lazyOptions));
+				const session = config.client.startSession();
+				try {
+					session.startTransaction();
+					const result = await cb(createAdapterFactory({
+						config: adapterOptions.config,
+						adapter: createCustomAdapter(db, session)
+					})(lazyOptions));
+					await session.commitTransaction();
+					return result;
+				} catch (err) {
+					await session.abortTransaction();
+					throw err;
+				} finally {
+					await session.endSession();
+				}
+			} : false,
+			customTransformInput({ action, data, field, fieldAttributes, schema, model, options }) {
+				const customIdGen = getCustomIdGenerator(options);
+				if (field === "_id" || fieldAttributes.references?.field === "id") {
+					if (customIdGen) return data;
+					if (action === "update") return data;
+					if (Array.isArray(data)) return data.map((v) => {
+						if (typeof v === "string") try {
+							return new ObjectId(v);
+						} catch (error) {
+							return v;
+						}
+						return v;
+					});
+					if (typeof data === "string") try {
+						return new ObjectId(data);
+					} catch (error) {
+						return new ObjectId();
+					}
+					if (fieldAttributes?.references?.field === "id" && !fieldAttributes?.required && data === null) return null;
+					return new ObjectId();
+				}
+				return data;
+			},
+			customTransformOutput({ data, field, fieldAttributes }) {
+				if (field === "id" || fieldAttributes.references?.field === "id") {
+					if (data instanceof ObjectId) return data.toHexString();
+					if (Array.isArray(data)) return data.map((v) => {
+						if (v instanceof ObjectId) return v.toHexString();
+						return v;
+					});
+					return data;
+				}
+				return data;
+			},
+			customIdGenerator() {
+				return new ObjectId().toString();
+			}
+		},
+		adapter: createCustomAdapter(db)
+	};
+	lazyAdapter = createAdapterFactory(adapterOptions);
+	return (options) => {
+		lazyOptions = options;
+		return lazyAdapter(options);
+	};
+};
+/**
+* Safely escape user input for use in a MongoDB regex.
+* This ensures the resulting pattern is treated as literal text,
+* and not as a regex with special syntax.
+*
+* @param input - The input string to escape. Any type that isn't a string will be converted to an empty string.
+* @param maxLength - The maximum length of the input string to escape. Defaults to 256. This is to prevent DOS attacks.
+* @returns The escaped string.
+*/
+function escapeForMongoRegex(input, maxLength = 256) {
+	if (typeof input !== "string") return "";
+	return input.slice(0, maxLength).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+}
+
+//#endregion
+export { mongodbAdapter };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapters/prisma-adapter/index.mjs.bak b/node_modules/better-auth/dist/adapters/prisma-adapter/index.mjs.bak
new file mode 100644
index 0000000..a68819c
--- /dev/null
+++ b/node_modules/better-auth/dist/adapters/prisma-adapter/index.mjs.bak
@@ -0,0 +1,221 @@
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../json-BS-nL3f-.mjs";
+import { t as createAdapterFactory } from "../../adapter-factory-znqU8768.mjs";
+import { BetterAuthError } from "@better-auth/core/error";
+
+//#region src/adapters/prisma-adapter/prisma-adapter.ts
+const prismaAdapter = (prisma, config) => {
+	let lazyOptions = null;
+	const createCustomAdapter = (prisma$1) => ({ getFieldName, getModelName, getFieldAttributes, getDefaultModelName, schema }) => {
+		const db = prisma$1;
+		const convertSelect = (select, model, join) => {
+			if (!select && !join) return void 0;
+			let result = {};
+			if (select) for (const field of select) result[getFieldName({
+				model,
+				field
+			})] = true;
+			if (join) {
+				if (!select) {
+					const fields = schema[getDefaultModelName(model)]?.fields || {};
+					fields.id = { type: "string" };
+					for (const field of Object.keys(fields)) result[getFieldName({
+						model,
+						field
+					})] = true;
+				}
+				for (const [joinModel, joinAttr] of Object.entries(join)) {
+					const key = getJoinKeyName(model, getModelName(joinModel), schema);
+					if (joinAttr.relation === "one-to-one") result[key] = true;
+					else result[key] = { take: joinAttr.limit };
+				}
+			}
+			return result;
+		};
+		/**
+		* Build the join key name based on whether the foreign field is unique or not.
+		* If unique, use singular. Otherwise, pluralize (add 's').
+		*/
+		const getJoinKeyName = (baseModel, joinedModel, schema$1) => {
+			try {
+				const defaultBaseModelName = getDefaultModelName(baseModel);
+				const defaultJoinedModelName = getDefaultModelName(joinedModel);
+				const key = getModelName(joinedModel).toLowerCase();
+				let foreignKeys = Object.entries(schema$1[defaultJoinedModelName]?.fields || {}).filter(([_field, fieldAttributes]) => fieldAttributes.references && getDefaultModelName(fieldAttributes.references.model) === defaultBaseModelName);
+				if (foreignKeys.length > 0) {
+					const [_foreignKey, foreignKeyAttributes] = foreignKeys[0];
+					return foreignKeyAttributes?.unique === true ? key : `${key}s`;
+				}
+				foreignKeys = Object.entries(schema$1[defaultBaseModelName]?.fields || {}).filter(([_field, fieldAttributes]) => fieldAttributes.references && getDefaultModelName(fieldAttributes.references.model) === defaultJoinedModelName);
+				if (foreignKeys.length > 0) return key;
+			} catch {}
+			return `${getModelName(joinedModel).toLowerCase()}s`;
+		};
+		function operatorToPrismaOperator(operator) {
+			switch (operator) {
+				case "starts_with": return "startsWith";
+				case "ends_with": return "endsWith";
+				case "ne": return "not";
+				case "not_in": return "notIn";
+				default: return operator;
+			}
+		}
+		const convertWhereClause = (model, where) => {
+			if (!where || !where.length) return {};
+			const buildSingleCondition = (w) => {
+				const fieldName = getFieldName({
+					model,
+					field: w.field
+				});
+				if (w.operator === "ne" && w.value === null) return {};
+				if ((w.operator === "in" || w.operator === "not_in") && Array.isArray(w.value)) {
+					const filtered = w.value.filter((v) => v != null);
+					if (filtered.length === 0) if (w.operator === "in") return { AND: [{ [fieldName]: { equals: "__never__" } }, { [fieldName]: { not: "__never__" } }] };
+					else return {};
+					const prismaOp = operatorToPrismaOperator(w.operator);
+					return { [fieldName]: { [prismaOp]: filtered } };
+				}
+				if (w.operator === "eq" || !w.operator) return { [fieldName]: w.value };
+				return { [fieldName]: { [operatorToPrismaOperator(w.operator)]: w.value } };
+			};
+			if (where.length === 1) {
+				const w = where[0];
+				if (!w) return;
+				return buildSingleCondition(w);
+			}
+			const and = where.filter((w) => w.connector === "AND" || !w.connector);
+			const or = where.filter((w) => w.connector === "OR");
+			const andClause = and.map((w) => buildSingleCondition(w));
+			const orClause = or.map((w) => buildSingleCondition(w));
+			return {
+				...andClause.length ? { AND: andClause } : {},
+				...orClause.length ? { OR: orClause } : {}
+			};
+		};
+		return {
+			async create({ model, data: values, select }) {
+				if (!db[model]) throw new BetterAuthError(`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
+				return await db[model].create({
+					data: values,
+					select: convertSelect(select, model)
+				});
+			},
+			async findOne({ model, where, select, join }) {
+				const whereClause = convertWhereClause(model, where);
+				if (!db[model]) throw new BetterAuthError(`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
+				let map = /* @__PURE__ */ new Map();
+				if (join) for (const [joinModel, value] of Object.entries(join)) {
+					const key = getJoinKeyName(model, joinModel, schema);
+					map.set(key, getModelName(joinModel));
+				}
+				const selects = convertSelect(select, model, join);
+				let result = (await db[model].findMany({
+					where: whereClause,
+					select: selects,
+					take: 1
+				}))[0];
+				if (join && result) for (const [includeKey, originalKey] of map.entries()) {
+					if (includeKey === originalKey) continue;
+					if (includeKey in result) {
+						result[originalKey] = result[includeKey];
+						delete result[includeKey];
+					}
+				}
+				return result;
+			},
+			async findMany({ model, where, limit, offset, sortBy, join }) {
+				const whereClause = convertWhereClause(model, where);
+				if (!db[model]) throw new BetterAuthError(`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
+				let map = /* @__PURE__ */ new Map();
+				if (join) for (const [joinModel, value] of Object.entries(join)) {
+					const key = getJoinKeyName(model, joinModel, schema);
+					map.set(key, getModelName(joinModel));
+				}
+				const selects = convertSelect(void 0, model, join);
+				const result = await db[model].findMany({
+					where: whereClause,
+					take: limit || 100,
+					skip: offset || 0,
+					...sortBy?.field ? { orderBy: { [getFieldName({
+						model,
+						field: sortBy.field
+					})]: sortBy.direction === "desc" ? "desc" : "asc" } } : {},
+					select: selects
+				});
+				if (join && Array.isArray(result)) for (const item of result) for (const [includeKey, originalKey] of map.entries()) {
+					if (includeKey === originalKey) continue;
+					if (includeKey in item) {
+						item[originalKey] = item[includeKey];
+						delete item[includeKey];
+					}
+				}
+				return result;
+			},
+			async count({ model, where }) {
+				const whereClause = convertWhereClause(model, where);
+				if (!db[model]) throw new BetterAuthError(`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
+				return await db[model].count({ where: whereClause });
+			},
+			async update({ model, where, update }) {
+				if (!db[model]) throw new BetterAuthError(`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`);
+				const whereClause = convertWhereClause(model, where);
+				return await db[model].update({
+					where: whereClause,
+					data: update
+				});
+			},
+			async updateMany({ model, where, update }) {
+				const whereClause = convertWhereClause(model, where);
+				const result = await db[model].updateMany({
+					where: whereClause,
+					data: update
+				});
+				return result ? result.count : 0;
+			},
+			async delete({ model, where }) {
+				const whereClause = convertWhereClause(model, where);
+				try {
+					await db[model].delete({ where: whereClause });
+				} catch (e) {
+					if (e?.meta?.cause === "Record to delete does not exist.") return;
+					console.log(e);
+				}
+			},
+			async deleteMany({ model, where }) {
+				const whereClause = convertWhereClause(model, where);
+				const result = await db[model].deleteMany({ where: whereClause });
+				return result ? result.count : 0;
+			},
+			options: config
+		};
+	};
+	let adapterOptions = null;
+	adapterOptions = {
+		config: {
+			adapterId: "prisma",
+			adapterName: "Prisma Adapter",
+			usePlural: config.usePlural ?? false,
+			debugLogs: config.debugLogs ?? false,
+			supportsUUIDs: config.provider === "postgresql" ? true : false,
+			transaction: config.transaction ?? false ? (cb) => prisma.$transaction((tx) => {
+				return cb(createAdapterFactory({
+					config: adapterOptions.config,
+					adapter: createCustomAdapter(tx)
+				})(lazyOptions));
+			}) : false
+		},
+		adapter: createCustomAdapter(prisma)
+	};
+	const adapter = createAdapterFactory(adapterOptions);
+	return (options) => {
+		lazyOptions = options;
+		return adapter(options);
+	};
+};
+
+//#endregion
+export { prismaAdapter };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/adapters/test.mjs.bak b/node_modules/better-auth/dist/adapters/test.mjs.bak
new file mode 100644
index 0000000..3a2e0c6
--- /dev/null
+++ b/node_modules/better-auth/dist/adapters/test.mjs.bak
@@ -0,0 +1,793 @@
+import { t as generateId } from "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import { beforeAll, describe, expect, test } from "vitest";
+
+//#region src/adapters/test.ts
+const adapterTests = {
+	CREATE_MODEL: "create model",
+	CREATE_MODEL_SHOULD_ALWAYS_RETURN_AN_ID: "create model should always return an id",
+	FIND_MODEL: "find model",
+	FIND_MODEL_WITHOUT_ID: "find model without id",
+	FIND_MODEL_WITH_SELECT: "find model with select",
+	FIND_MODEL_WITH_MODIFIED_FIELD_NAME: "find model with modified field name",
+	UPDATE_MODEL: "update model",
+	SHOULD_FIND_MANY: "should find many",
+	SHOULD_FIND_MANY_WITH_WHERE: "should find many with where",
+	SHOULD_FIND_MANY_WITH_OPERATORS: "should find many with operators",
+	SHOULD_WORK_WITH_REFERENCE_FIELDS: "should work with reference fields",
+	SHOULD_FIND_MANY_WITH_NOT_IN_OPERATOR: "should find many with not in operator",
+	SHOULD_FIND_MANY_WITH_SORT_BY: "should find many with sortBy",
+	SHOULD_FIND_MANY_WITH_LIMIT: "should find many with limit",
+	SHOULD_FIND_MANY_WITH_OFFSET: "should find many with offset",
+	SHOULD_UPDATE_WITH_MULTIPLE_WHERE: "should update with multiple where",
+	DELETE_MODEL: "delete model",
+	SHOULD_DELETE_MANY: "should delete many",
+	SHOULD_NOT_THROW_ON_DELETE_RECORD_NOT_FOUND: "shouldn't throw on delete record not found",
+	SHOULD_NOT_THROW_ON_RECORD_NOT_FOUND: "shouldn't throw on record not found",
+	SHOULD_FIND_MANY_WITH_CONTAINS_OPERATOR: "should find many with contains operator",
+	SHOULD_SEARCH_USERS_WITH_STARTS_WITH: "should search users with startsWith",
+	SHOULD_SEARCH_USERS_WITH_ENDS_WITH: "should search users with endsWith",
+	SHOULD_PREFER_GENERATE_ID_IF_PROVIDED: "should prefer generateId if provided",
+	SHOULD_ROLLBACK_FAILING_TRANSACTION: "should rollback failing transaction",
+	SHOULD_RETURN_TRANSACTION_RESULT: "should return transaction result",
+	SHOULD_FIND_MANY_WITH_CONNECTORS: "should find many with connectors"
+};
+const { ...numberIdAdapterTestsCopy } = adapterTests;
+const numberIdAdapterTests = {
+	...numberIdAdapterTestsCopy,
+	SHOULD_RETURN_A_NUMBER_ID_AS_A_RESULT: "Should return a number id as a result",
+	SHOULD_INCREMENT_THE_ID_BY_1: "Should increment the id by 1"
+};
+delete numberIdAdapterTests.SHOULD_NOT_THROW_ON_DELETE_RECORD_NOT_FOUND;
+/**
+* @deprecated Use `testAdapter` instead.
+*/
+function adapterTest({ getAdapter, disableTests: disabledTests, testPrefix }, internalOptions) {
+	console.warn("This test function is deprecated and will be removed in the future. Use `testAdapter` instead.");
+	const adapter = async () => await getAdapter(internalOptions?.predefinedOptions);
+	async function resetDebugLogs() {
+		(await adapter())?.adapterTestDebugLogs?.resetDebugLogs();
+	}
+	async function printDebugLogs() {
+		(await adapter())?.adapterTestDebugLogs?.printDebugLogs();
+	}
+	const testRunId = Date.now().toString(36) + Math.random().toString(36).substring(2, 5);
+	const getUniqueEmail = (base) => `${testRunId}_${base}`;
+	let user = {
+		name: "user",
+		email: getUniqueEmail("user@email.com"),
+		emailVerified: true,
+		createdAt: /* @__PURE__ */ new Date(),
+		updatedAt: /* @__PURE__ */ new Date()
+	};
+	test.skipIf(disabledTests?.CREATE_MODEL)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.CREATE_MODEL}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const res = await (await adapter()).create({
+			model: "user",
+			data: user
+		});
+		user.id = res.id;
+		expect({
+			name: res.name,
+			email: res.email
+		}).toEqual({
+			name: user.name,
+			email: user.email
+		});
+	});
+	test.skipIf(disabledTests?.CREATE_MODEL_SHOULD_ALWAYS_RETURN_AN_ID)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.CREATE_MODEL_SHOULD_ALWAYS_RETURN_AN_ID}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const res = await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "test-name-without-id",
+				email: getUniqueEmail("test-email-without-id@email.com")
+			}
+		});
+		expect(res).toHaveProperty("id");
+		expect(typeof res?.id).toEqual("string");
+	});
+	test.skipIf(disabledTests?.FIND_MODEL)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.FIND_MODEL}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const res = await (await adapter()).findOne({
+			model: "user",
+			where: [{
+				field: "id",
+				value: user.id
+			}]
+		});
+		expect({
+			name: res?.name,
+			email: res?.email
+		}).toEqual({
+			name: user.name,
+			email: user.email
+		});
+	});
+	test.skipIf(disabledTests?.FIND_MODEL_WITHOUT_ID)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.FIND_MODEL_WITHOUT_ID}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const res = await (await adapter()).findOne({
+			model: "user",
+			where: [{
+				field: "email",
+				value: user.email
+			}]
+		});
+		expect({
+			name: res?.name,
+			email: res?.email
+		}).toEqual({
+			name: user.name,
+			email: user.email
+		});
+	});
+	test.skipIf(disabledTests?.FIND_MODEL_WITH_MODIFIED_FIELD_NAME)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.FIND_MODEL_WITH_MODIFIED_FIELD_NAME}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const email = getUniqueEmail("test-email-with-modified-field@email.com");
+		const adapter$1 = await getAdapter(Object.assign({ user: { fields: { email: "email_address" } } }, internalOptions?.predefinedOptions));
+		expect((await adapter$1.create({
+			model: "user",
+			data: {
+				email,
+				name: "test-name-with-modified-field",
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		})).email).toEqual(email);
+		const res = await adapter$1.findOne({
+			model: "user",
+			where: [{
+				field: "email",
+				value: email
+			}]
+		});
+		expect(res).not.toBeNull();
+		expect(res?.email).toEqual(email);
+	});
+	test.skipIf(disabledTests?.FIND_MODEL_WITH_SELECT)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.FIND_MODEL_WITH_SELECT}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		expect(await (await adapter()).findOne({
+			model: "user",
+			where: [{
+				field: "id",
+				value: user.id
+			}],
+			select: ["email"]
+		})).toEqual({ email: user.email });
+	});
+	test.skipIf(disabledTests?.UPDATE_MODEL)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.UPDATE_MODEL}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const newEmail = getUniqueEmail("updated@email.com");
+		expect(await (await adapter()).update({
+			model: "user",
+			where: [{
+				field: "id",
+				value: user.id
+			}],
+			update: { email: newEmail }
+		})).toMatchObject({
+			email: newEmail,
+			name: user.name
+		});
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		expect((await (await adapter()).findMany({ model: "user" })).length).toBe(3);
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_WHERE)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_WHERE}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const user$1 = await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "user2",
+				email: getUniqueEmail("test@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "id",
+				value: user$1.id
+			}]
+		})).length).toBe(1);
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_OPERATORS)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_OPERATORS}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const newUser = await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "user",
+				email: getUniqueEmail("test-email2@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "id",
+				operator: "in",
+				value: [user.id, newUser.id]
+			}]
+		})).length).toBe(2);
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_NOT_IN_OPERATOR)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_NOT_IN_OPERATOR}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const newUser3 = await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "user",
+				email: getUniqueEmail("test-email3@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({ model: "user" })).length).toBe(6);
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "id",
+				operator: "not_in",
+				value: [user.id, newUser3.id]
+			}]
+		})).length).toBe(4);
+		await (await adapter()).delete({
+			model: "user",
+			where: [{
+				field: "id",
+				value: newUser3.id
+			}]
+		});
+	});
+	test.skipIf(disabledTests?.SHOULD_WORK_WITH_REFERENCE_FIELDS)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_WORK_WITH_REFERENCE_FIELDS}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		let token = null;
+		const user$1 = await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "user",
+				email: getUniqueEmail("my-email@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		token = (await (await adapter()).create({
+			model: "session",
+			data: {
+				token: generateId(),
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				userId: user$1.id,
+				expiresAt: /* @__PURE__ */ new Date()
+			}
+		})).token;
+		const res = await (await adapter()).findOne({
+			model: "session",
+			where: [{
+				field: "userId",
+				value: user$1.id
+			}]
+		});
+		const resToken = await (await adapter()).findOne({
+			model: "session",
+			where: [{
+				field: "token",
+				value: token
+			}]
+		});
+		expect(res).toMatchObject({ userId: user$1.id });
+		expect(resToken).toMatchObject({ userId: user$1.id });
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_SORT_BY)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_SORT_BY}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "a",
+				email: getUniqueEmail("a@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			sortBy: {
+				field: "name",
+				direction: "asc"
+			}
+		}))[0].name).toBe("a");
+		const res2 = await (await adapter()).findMany({
+			model: "user",
+			sortBy: {
+				field: "name",
+				direction: "desc"
+			}
+		});
+		expect(res2[res2.length - 1].name).toBe("a");
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_LIMIT)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_LIMIT}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			limit: 1
+		})).length).toBe(1);
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_OFFSET)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_OFFSET}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			offset: 2
+		})).length).toBe(5);
+	});
+	test.skipIf(disabledTests?.SHOULD_UPDATE_WITH_MULTIPLE_WHERE)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_UPDATE_WITH_MULTIPLE_WHERE}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const currentEmail = getUniqueEmail("updated@email.com");
+		await (await adapter()).updateMany({
+			model: "user",
+			where: [{
+				field: "name",
+				value: user.name
+			}, {
+				field: "email",
+				value: currentEmail
+			}],
+			update: { email: getUniqueEmail("updated2@email.com") }
+		});
+		expect(await (await adapter()).findOne({
+			model: "user",
+			where: [{
+				field: "email",
+				value: getUniqueEmail("updated2@email.com")
+			}]
+		})).toMatchObject({
+			name: user.name,
+			email: getUniqueEmail("updated2@email.com")
+		});
+	});
+	test.skipIf(disabledTests?.DELETE_MODEL)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.DELETE_MODEL}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		await (await adapter()).delete({
+			model: "user",
+			where: [{
+				field: "id",
+				value: user.id
+			}]
+		});
+		expect(await (await adapter()).findOne({
+			model: "user",
+			where: [{
+				field: "id",
+				value: user.id
+			}]
+		})).toBeNull();
+	});
+	test.skipIf(disabledTests?.SHOULD_DELETE_MANY)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_DELETE_MANY}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		for (const i of [
+			"to-be-delete-1",
+			"to-be-delete-2",
+			"to-be-delete-3"
+		]) await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "to-be-deleted",
+				email: getUniqueEmail(`email@test-${i}.com`),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "name",
+				value: "to-be-deleted"
+			}]
+		})).length).toBe(3);
+		await (await adapter()).deleteMany({
+			model: "user",
+			where: [{
+				field: "name",
+				value: "to-be-deleted"
+			}]
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "name",
+				value: "to-be-deleted"
+			}]
+		})).length).toBe(0);
+	});
+	test.skipIf(disabledTests?.SHOULD_NOT_THROW_ON_DELETE_RECORD_NOT_FOUND)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_NOT_THROW_ON_DELETE_RECORD_NOT_FOUND}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		await (await adapter()).delete({
+			model: "user",
+			where: [{
+				field: "id",
+				value: "100000"
+			}]
+		});
+	});
+	test.skipIf(disabledTests?.SHOULD_NOT_THROW_ON_RECORD_NOT_FOUND)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_NOT_THROW_ON_RECORD_NOT_FOUND}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		expect(await (await adapter()).findOne({
+			model: "user",
+			where: [{
+				field: "id",
+				value: "100000"
+			}]
+		})).toBeNull();
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_CONTAINS_OPERATOR)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_CONTAINS_OPERATOR}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "name",
+				operator: "contains",
+				value: "user2"
+			}]
+		})).length).toBe(1);
+	});
+	test.skipIf(disabledTests?.SHOULD_SEARCH_USERS_WITH_STARTS_WITH)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_SEARCH_USERS_WITH_STARTS_WITH}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "user_starts",
+				email: getUniqueEmail("startswith1@test.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "user2_starts",
+				email: getUniqueEmail("startswith2@test.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "user3_starts",
+				email: getUniqueEmail("startswith3@test.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "name",
+				operator: "starts_with",
+				value: "user"
+			}]
+		})).length).toBeGreaterThanOrEqual(3);
+	});
+	test.skipIf(disabledTests?.SHOULD_SEARCH_USERS_WITH_ENDS_WITH)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_SEARCH_USERS_WITH_ENDS_WITH}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "tester2",
+				email: getUniqueEmail("endswith@test.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "name",
+				operator: "ends_with",
+				value: "ter2"
+			}]
+		})).length).toBe(1);
+	});
+	test.skipIf(disabledTests?.SHOULD_PREFER_GENERATE_ID_IF_PROVIDED)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_PREFER_GENERATE_ID_IF_PROVIDED}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		expect((await (await getAdapter(Object.assign({ advanced: { database: { generateId: () => "mocked-id" } } }, internalOptions?.predefinedOptions))).create({
+			model: "user",
+			data: {
+				name: "user4",
+				email: getUniqueEmail("user4@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		})).id).toBe("mocked-id");
+	});
+	test.skipIf(disabledTests?.SHOULD_ROLLBACK_FAILING_TRANSACTION)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_ROLLBACK_FAILING_TRANSACTION}`, async ({ onTestFailed, skip }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const customAdapter = await adapter();
+		if (!customAdapter?.options?.adapterConfig.transaction) {
+			skip(`Skipping test: ${customAdapter?.options?.adapterConfig.adapterName || "Adapter"}
+					 does not support transactions`);
+			return;
+		}
+		const user5 = {
+			name: "user5",
+			email: getUniqueEmail("user5@email.com"),
+			emailVerified: true,
+			createdAt: /* @__PURE__ */ new Date(),
+			updatedAt: /* @__PURE__ */ new Date()
+		};
+		const user6 = {
+			name: "user6",
+			email: getUniqueEmail("user6@email.com"),
+			emailVerified: true,
+			createdAt: /* @__PURE__ */ new Date(),
+			updatedAt: /* @__PURE__ */ new Date()
+		};
+		await expect(customAdapter.transaction(async (tx) => {
+			await tx.create({
+				model: "user",
+				data: user5
+			});
+			throw new Error("Simulated failure");
+		})).rejects.toThrow("Simulated failure");
+		await expect(customAdapter.findMany({
+			model: "user",
+			where: [{
+				field: "email",
+				value: user5.email,
+				connector: "OR"
+			}, {
+				field: "email",
+				value: user6.email,
+				connector: "OR"
+			}]
+		})).resolves.toEqual([]);
+	});
+	test.skipIf(disabledTests?.SHOULD_RETURN_TRANSACTION_RESULT)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_RETURN_TRANSACTION_RESULT}`, async ({ onTestFailed, skip }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		const customAdapter = await adapter();
+		if (!customAdapter?.options?.adapterConfig.transaction) {
+			skip(`Skipping test: ${customAdapter?.options?.adapterConfig.adapterName || "Adapter"}
+					 does not support transactions`);
+			return;
+		}
+		expect(await customAdapter.transaction(async (tx) => {
+			return (await tx.create({
+				model: "user",
+				data: {
+					name: "user6",
+					email: getUniqueEmail("user6@email.com"),
+					emailVerified: true,
+					createdAt: /* @__PURE__ */ new Date(),
+					updatedAt: /* @__PURE__ */ new Date()
+				}
+			})).email;
+		})).toEqual(getUniqueEmail("user6@email.com"));
+	});
+	test.skipIf(disabledTests?.SHOULD_FIND_MANY_WITH_CONNECTORS)(`${testPrefix ? `${testPrefix} - ` : ""}${adapterTests.SHOULD_FIND_MANY_WITH_CONNECTORS}`, async ({ onTestFailed }) => {
+		await resetDebugLogs();
+		onTestFailed(async () => {
+			await printDebugLogs();
+		});
+		await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "connector-user1",
+				email: getUniqueEmail("connector-user1@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		await (await adapter()).create({
+			model: "user",
+			data: {
+				name: "con-user2",
+				email: getUniqueEmail("connector-user2@email.com"),
+				emailVerified: true,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			}
+		});
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "name",
+				value: "con-user2",
+				connector: "AND"
+			}, {
+				field: "email",
+				value: getUniqueEmail("connector-user2@email.com"),
+				connector: "AND"
+			}]
+		})).length).toBe(1);
+		expect((await (await adapter()).findMany({
+			model: "user",
+			where: [{
+				field: "name",
+				value: "connector-user1",
+				connector: "OR"
+			}, {
+				field: "name",
+				value: "con-user2",
+				connector: "OR"
+			}]
+		})).length).toBe(2);
+	});
+}
+function runAdapterTest(opts) {
+	return adapterTest(opts);
+}
+function runNumberIdAdapterTest(opts) {
+	const cleanup = [];
+	const testRunId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
+	const getUniqueEmail = (base) => `${testRunId}_${base}`;
+	const adapter = async () => await opts.getAdapter({ advanced: { database: { generateId: "serial" } } });
+	describe("Should run number id specific tests", async () => {
+		let idNumber = -1;
+		async function resetDebugLogs() {
+			(await adapter())?.adapterTestDebugLogs?.resetDebugLogs();
+		}
+		async function printDebugLogs() {
+			(await adapter())?.adapterTestDebugLogs?.printDebugLogs();
+		}
+		test.skipIf(opts.disableTests?.SHOULD_RETURN_A_NUMBER_ID_AS_A_RESULT)(`${opts.testPrefix ? `${opts.testPrefix} - ` : ""}${numberIdAdapterTests.SHOULD_RETURN_A_NUMBER_ID_AS_A_RESULT}`, async ({ onTestFailed }) => {
+			await resetDebugLogs();
+			onTestFailed(async () => {
+				await printDebugLogs();
+			});
+			const res = await (await adapter()).create({
+				model: "user",
+				data: {
+					name: "user",
+					email: getUniqueEmail("number-user@email.com")
+				}
+			});
+			cleanup.push({
+				modelName: "user",
+				id: res.id
+			});
+			expect(typeof res.id).toBe("string");
+			expect(parseInt(res.id)).toBeGreaterThan(0);
+			idNumber = parseInt(res.id);
+		});
+		test.skipIf(opts.disableTests?.SHOULD_INCREMENT_THE_ID_BY_1)(`${opts.testPrefix ? `${opts.testPrefix} - ` : ""}${numberIdAdapterTests.SHOULD_INCREMENT_THE_ID_BY_1}`, async ({ onTestFailed }) => {
+			await resetDebugLogs();
+			onTestFailed(async () => {
+				console.log(`ID number from last create: ${idNumber}`);
+				await printDebugLogs();
+			});
+			const res = await (await adapter()).create({
+				model: "user",
+				data: {
+					name: "user2",
+					email: getUniqueEmail("number-user2@email.com")
+				}
+			});
+			cleanup.push({
+				modelName: "user",
+				id: res.id
+			});
+			expect(parseInt(res.id)).toBe(idNumber + 1);
+		});
+	});
+	describe("Should run normal adapter tests with number id enabled", async () => {
+		beforeAll(async () => {
+			for (const { modelName, id } of cleanup) await (await adapter()).delete({
+				model: modelName,
+				where: [{
+					field: "id",
+					value: id
+				}]
+			});
+		});
+		await adapterTest({
+			...opts,
+			disableTests: {
+				...opts.disableTests,
+				SHOULD_PREFER_GENERATE_ID_IF_PROVIDED: true
+			}
+		}, { predefinedOptions: { advanced: { database: { generateId: "serial" } } } });
+	});
+}
+function recoverProcessTZ() {
+	const originalTZ = process.env.TZ;
+	return { [Symbol.dispose]: () => {
+		process.env.TZ = originalTZ;
+	} };
+}
+
+//#endregion
+export { recoverProcessTZ, runAdapterTest, runNumberIdAdapterTest };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/admin-CJ3jncSX.mjs b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs
index 46394e3..5b875aa 100644
--- a/node_modules/better-auth/dist/admin-CJ3jncSX.mjs
+++ b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs
@@ -137,8 +137,8 @@ const admin = (options) => {
 			setRole: createAuthEndpoint("/admin/set-role", {
 				method: "POST",
 				body: z.object({
-					userId: z.coerce.string().meta({ description: "The user id" }),
-					role: z.union([z.string().meta({ description: "The role to set. `admin` or `user` by default" }), z.array(z.string().meta({ description: "The roles to set. `admin` or `user` by default" }))]).meta({ description: "The role to set, this can be a string or an array of strings. Eg: `admin` or `[admin, user]`" })
+					userId: z.coerce.string(),
+					role: z.union([z.string(), z.array(z.string())])
 				}),
 				requireHeaders: true,
 				use: [adminMiddleware],
@@ -174,7 +174,7 @@ const admin = (options) => {
 			}),
 			getUser: createAuthEndpoint("/admin/get-user", {
 				method: "GET",
-				query: z.object({ id: z.string().meta({ description: "The id of the User" }) }),
+				query: z.object({ id: z.string() }),
 				use: [adminMiddleware],
 				metadata: { openapi: {
 					operationId: "getUser",
@@ -206,11 +206,11 @@ const admin = (options) => {
 			createUser: createAuthEndpoint("/admin/create-user", {
 				method: "POST",
 				body: z.object({
-					email: z.string().meta({ description: "The email of the user" }),
-					password: z.string().meta({ description: "The password of the user" }),
-					name: z.string().meta({ description: "The name of the user" }),
-					role: z.union([z.string().meta({ description: "The role of the user" }), z.array(z.string().meta({ description: "The roles of user" }))]).optional().meta({ description: `A string or array of strings representing the roles to apply to the new user. Eg: \"user\"` }),
-					data: z.record(z.string(), z.any()).optional().meta({ description: "Extra fields for the user. Including custom additional fields." })
+					email: z.string(),
+					password: z.string(),
+					name: z.string(),
+					role: z.union([z.string(), z.array(z.string())]).optional(),
+					data: z.record(z.string(), z.any()).optional()
 				}),
 				metadata: {
 					openapi: {
@@ -239,7 +239,7 @@ const admin = (options) => {
 					})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS });
 				}
 				const email = ctx.body.email.toLowerCase();
-				if (!z.email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
 				if (await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
 				const user = await ctx.context.internalAdapter.createUser({
 					email,
@@ -260,8 +260,8 @@ const admin = (options) => {
 			adminUpdateUser: createAuthEndpoint("/admin/update-user", {
 				method: "POST",
 				body: z.object({
-					userId: z.coerce.string().meta({ description: "The user id" }),
-					data: z.record(z.any(), z.any()).meta({ description: "The user data to update" })
+					userId: z.coerce.string(),
+					data: z.record(z.any(), z.any())
 				}),
 				use: [adminMiddleware],
 				metadata: { openapi: {
@@ -295,19 +295,19 @@ const admin = (options) => {
 				method: "GET",
 				use: [adminMiddleware],
 				query: z.object({
-					searchValue: z.string().optional().meta({ description: "The value to search for. Eg: \"some name\"" }),
-					searchField: z.enum(["email", "name"]).meta({ description: "The field to search in, defaults to email. Can be `email` or `name`. Eg: \"name\"" }).optional(),
+					searchValue: z.string().optional(),
+					searchField: z.enum(["email", "name"]).optional(),
 					searchOperator: z.enum([
 						"contains",
 						"starts_with",
 						"ends_with"
-					]).meta({ description: "The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. Eg: \"contains\"" }).optional(),
-					limit: z.string().meta({ description: "The number of users to return" }).or(z.number()).optional(),
-					offset: z.string().meta({ description: "The offset to start from" }).or(z.number()).optional(),
-					sortBy: z.string().meta({ description: "The field to sort by" }).optional(),
-					sortDirection: z.enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
-					filterField: z.string().meta({ description: "The field to filter by" }).optional(),
-					filterValue: z.string().meta({ description: "The value to filter by" }).or(z.number()).or(z.boolean()).optional(),
+					]).optional(),
+					limit: z.string().or(z.number()).optional(),
+					offset: z.string().or(z.number()).optional(),
+					sortBy: z.string().optional(),
+					sortDirection: z.enum(["asc", "desc"]).optional(),
+					filterField: z.string().optional(),
+					filterValue: z.string().or(z.number()).or(z.boolean()).optional(),
 					filterOperator: z.enum([
 						"eq",
 						"ne",
@@ -316,7 +316,7 @@ const admin = (options) => {
 						"gt",
 						"gte",
 						"contains"
-					]).meta({ description: "The operator to use for the filter" }).optional()
+					]).optional()
 				}),
 				metadata: { openapi: {
 					operationId: "listUsers",
@@ -380,7 +380,7 @@ const admin = (options) => {
 			listUserSessions: createAuthEndpoint("/admin/list-user-sessions", {
 				method: "POST",
 				use: [adminMiddleware],
-				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				body: z.object({ userId: z.coerce.string() }),
 				metadata: { openapi: {
 					operationId: "listUserSessions",
 					summary: "List user sessions",
@@ -408,7 +408,7 @@ const admin = (options) => {
 			}),
 			unbanUser: createAuthEndpoint("/admin/unban-user", {
 				method: "POST",
-				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				body: z.object({ userId: z.coerce.string() }),
 				use: [adminMiddleware],
 				metadata: { openapi: {
 					operationId: "unbanUser",
@@ -441,9 +441,9 @@ const admin = (options) => {
 			banUser: createAuthEndpoint("/admin/ban-user", {
 				method: "POST",
 				body: z.object({
-					userId: z.coerce.string().meta({ description: "The user id" }),
-					banReason: z.string().meta({ description: "The reason for the ban" }).optional(),
-					banExpiresIn: z.number().meta({ description: "The number of seconds until the ban expires" }).optional()
+					userId: z.coerce.string(),
+					banReason: z.string().optional(),
+					banExpiresIn: z.number().optional()
 				}),
 				use: [adminMiddleware],
 				metadata: { openapi: {
@@ -479,7 +479,7 @@ const admin = (options) => {
 			}),
 			impersonateUser: createAuthEndpoint("/admin/impersonate-user", {
 				method: "POST",
-				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				body: z.object({ userId: z.coerce.string() }),
 				use: [adminMiddleware],
 				metadata: { openapi: {
 					operationId: "impersonateUser",
@@ -545,7 +545,7 @@ const admin = (options) => {
 			}),
 			revokeUserSession: createAuthEndpoint("/admin/revoke-user-session", {
 				method: "POST",
-				body: z.object({ sessionToken: z.string().meta({ description: "The session token" }) }),
+				body: z.object({ sessionToken: z.string() }),
 				use: [adminMiddleware],
 				metadata: { openapi: {
 					operationId: "revokeUserSession",
@@ -572,7 +572,7 @@ const admin = (options) => {
 			}),
 			revokeUserSessions: createAuthEndpoint("/admin/revoke-user-sessions", {
 				method: "POST",
-				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				body: z.object({ userId: z.coerce.string() }),
 				use: [adminMiddleware],
 				metadata: { openapi: {
 					operationId: "revokeUserSessions",
@@ -599,7 +599,7 @@ const admin = (options) => {
 			}),
 			removeUser: createAuthEndpoint("/admin/remove-user", {
 				method: "POST",
-				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				body: z.object({ userId: z.coerce.string() }),
 				use: [adminMiddleware],
 				metadata: { openapi: {
 					operationId: "removeUser",
@@ -629,8 +629,8 @@ const admin = (options) => {
 			setUserPassword: createAuthEndpoint("/admin/set-user-password", {
 				method: "POST",
 				body: z.object({
-					newPassword: z.string().nonempty("newPassword cannot be empty").meta({ description: "The new password" }),
-					userId: z.coerce.string().nonempty("userId cannot be empty").meta({ description: "The user id" })
+					newPassword: z.string().nonempty("newPassword cannot be empty"),
+					userId: z.coerce.string().nonempty("userId cannot be empty")
 				}),
 				use: [adminMiddleware],
 				metadata: { openapi: {
@@ -670,8 +670,8 @@ const admin = (options) => {
 			userHasPermission: createAuthEndpoint("/admin/has-permission", {
 				method: "POST",
 				body: z.object({
-					userId: z.coerce.string().optional().meta({ description: `The user id. Eg: "user-id"` }),
-					role: z.string().optional().meta({ description: `The role to check permission for. Eg: "admin"` })
+					userId: z.coerce.string().optional(),
+					role: z.string().optional()
 				}).and(z.union([z.object({
 					permission: z.record(z.string(), z.array(z.string())),
 					permissions: z.undefined()
diff --git a/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak
new file mode 100644
index 0000000..e13b98b
--- /dev/null
+++ b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak
@@ -0,0 +1,743 @@
+import { l as parseUserOutput, t as mergeSchema, u as getDate } from "./schema-BevzneML.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie, n as deleteSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx } from "./session-Efap-vxj.mjs";
+import { t as getEndpointResponse } from "./plugin-helper-RJJBTOba.mjs";
+import { t as hasPermission } from "./has-permission-DhpFBOUO.mjs";
+import "@better-auth/core/db";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/admin/error-codes.ts
+const ADMIN_ERROR_CODES = defineErrorCodes({
+	FAILED_TO_CREATE_USER: "Failed to create user",
+	USER_ALREADY_EXISTS: "User already exists.",
+	USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
+	YOU_CANNOT_BAN_YOURSELF: "You cannot ban yourself",
+	YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE: "You are not allowed to change users role",
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS: "You are not allowed to create users",
+	YOU_ARE_NOT_ALLOWED_TO_LIST_USERS: "You are not allowed to list users",
+	YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS: "You are not allowed to list users sessions",
+	YOU_ARE_NOT_ALLOWED_TO_BAN_USERS: "You are not allowed to ban users",
+	YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS: "You are not allowed to impersonate users",
+	YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS: "You are not allowed to revoke users sessions",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS: "You are not allowed to delete users",
+	YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD: "You are not allowed to set users password",
+	BANNED_USER: "You have been banned from this application",
+	YOU_ARE_NOT_ALLOWED_TO_GET_USER: "You are not allowed to get user",
+	NO_DATA_TO_UPDATE: "No data to update",
+	YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS: "You are not allowed to update users",
+	YOU_CANNOT_REMOVE_YOURSELF: "You cannot remove yourself",
+	YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE: "You are not allowed to set a non-existent role value"
+});
+
+//#endregion
+//#region src/plugins/admin/schema.ts
+const schema = {
+	user: { fields: {
+		role: {
+			type: "string",
+			required: false,
+			input: false
+		},
+		banned: {
+			type: "boolean",
+			defaultValue: false,
+			required: false,
+			input: false
+		},
+		banReason: {
+			type: "string",
+			required: false,
+			input: false
+		},
+		banExpires: {
+			type: "date",
+			required: false,
+			input: false
+		}
+	} },
+	session: { fields: { impersonatedBy: {
+		type: "string",
+		required: false
+	} } }
+};
+
+//#endregion
+//#region src/plugins/admin/admin.ts
+function parseRoles(roles) {
+	return Array.isArray(roles) ? roles.join(",") : roles;
+}
+const admin = (options) => {
+	const opts = {
+		defaultRole: options?.defaultRole ?? "user",
+		adminRoles: options?.adminRoles ?? ["admin"],
+		bannedUserMessage: options?.bannedUserMessage ?? "You have been banned from this application. Please contact support if you believe this is an error.",
+		...options
+	};
+	/**
+	* Ensures a valid session, if not will throw.
+	* Will also provide additional types on the user to include role types.
+	*/
+	const adminMiddleware = createAuthMiddleware(async (ctx) => {
+		const session = await getSessionFromCtx(ctx);
+		if (!session) throw new APIError("UNAUTHORIZED");
+		return { session };
+	});
+	return {
+		id: "admin",
+		init() {
+			return { options: { databaseHooks: {
+				user: { create: { async before(user) {
+					return { data: {
+						role: options?.defaultRole ?? "user",
+						...user
+					} };
+				} } },
+				session: { create: { async before(session, ctx) {
+					if (!ctx) return;
+					const user = await ctx.context.internalAdapter.findUserById(session.userId);
+					if (user.banned) {
+						if (user.banExpires && new Date(user.banExpires).getTime() < Date.now()) {
+							await ctx.context.internalAdapter.updateUser(session.userId, {
+								banned: false,
+								banReason: null,
+								banExpires: null
+							});
+							return;
+						}
+						if (ctx && (ctx.path.startsWith("/callback") || ctx.path.startsWith("/oauth2/callback"))) {
+							const redirectURI = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
+							throw ctx.redirect(`${redirectURI}?error=banned&error_description=${opts.bannedUserMessage}`);
+						}
+						throw new APIError("FORBIDDEN", {
+							message: opts.bannedUserMessage,
+							code: "BANNED_USER"
+						});
+					}
+				} } }
+			} } };
+		},
+		hooks: { after: [{
+			matcher(context) {
+				return context.path === "/list-sessions";
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const response = await getEndpointResponse(ctx);
+				if (!response) return;
+				const newJson = response.filter((session) => {
+					return !session.impersonatedBy;
+				});
+				return ctx.json(newJson);
+			})
+		}] },
+		endpoints: {
+			setRole: createAuthEndpoint("/admin/set-role", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string().meta({ description: "The user id" }),
+					role: z.union([z.string().meta({ description: "The role to set. `admin` or `user` by default" }), z.array(z.string().meta({ description: "The roles to set. `admin` or `user` by default" }))]).meta({ description: "The role to set, this can be a string or an array of strings. Eg: `admin` or `[admin, user]`" })
+				}),
+				requireHeaders: true,
+				use: [adminMiddleware],
+				metadata: {
+					openapi: {
+						operationId: "setUserRole",
+						summary: "Set the role of a user",
+						description: "Set the role of a user",
+						responses: { 200: {
+							description: "User role updated",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { user: { $ref: "#/components/schemas/User" } }
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["set-role"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });
+				const roles = opts.roles;
+				if (roles) {
+					const inputRoles = Array.isArray(ctx.body.role) ? ctx.body.role : [ctx.body.role];
+					for (const role of inputRoles) if (!roles[role]) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });
+				}
+				const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, { role: parseRoles(ctx.body.role) });
+				return ctx.json({ user: updatedUser });
+			}),
+			getUser: createAuthEndpoint("/admin/get-user", {
+				method: "GET",
+				query: z.object({ id: z.string().meta({ description: "The id of the User" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "getUser",
+					summary: "Get an existing user",
+					description: "Get an existing user",
+					responses: { 200: {
+						description: "User",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { id } = ctx.query;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["get"] }
+				})) throw ctx.error("FORBIDDEN", {
+					message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_USER,
+					code: "YOU_ARE_NOT_ALLOWED_TO_GET_USER"
+				});
+				const user = await ctx.context.internalAdapter.findUserById(id);
+				if (!user) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				return parseUserOutput(ctx.context.options, user);
+			}),
+			createUser: createAuthEndpoint("/admin/create-user", {
+				method: "POST",
+				body: z.object({
+					email: z.string().meta({ description: "The email of the user" }),
+					password: z.string().meta({ description: "The password of the user" }),
+					name: z.string().meta({ description: "The name of the user" }),
+					role: z.union([z.string().meta({ description: "The role of the user" }), z.array(z.string().meta({ description: "The roles of user" }))]).optional().meta({ description: `A string or array of strings representing the roles to apply to the new user. Eg: \"user\"` }),
+					data: z.record(z.string(), z.any()).optional().meta({ description: "Extra fields for the user. Including custom additional fields." })
+				}),
+				metadata: {
+					openapi: {
+						operationId: "createUser",
+						summary: "Create a new user",
+						description: "Create a new user",
+						responses: { 200: {
+							description: "User created",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { user: { $ref: "#/components/schemas/User" } }
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				const session = await getSessionFromCtx(ctx);
+				if (!session && (ctx.request || ctx.headers)) throw ctx.error("UNAUTHORIZED");
+				if (session) {
+					if (!hasPermission({
+						userId: session.user.id,
+						role: session.user.role,
+						options: opts,
+						permissions: { user: ["create"] }
+					})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS });
+				}
+				const email = ctx.body.email.toLowerCase();
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				if (await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
+				const user = await ctx.context.internalAdapter.createUser({
+					email,
+					name: ctx.body.name,
+					role: (ctx.body.role && parseRoles(ctx.body.role)) ?? options?.defaultRole ?? "user",
+					...ctx.body.data
+				});
+				if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
+				const hashedPassword = await ctx.context.password.hash(ctx.body.password);
+				await ctx.context.internalAdapter.linkAccount({
+					accountId: user.id,
+					providerId: "credential",
+					password: hashedPassword,
+					userId: user.id
+				});
+				return ctx.json({ user });
+			}),
+			adminUpdateUser: createAuthEndpoint("/admin/update-user", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string().meta({ description: "The user id" }),
+					data: z.record(z.any(), z.any()).meta({ description: "The user data to update" })
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "updateUser",
+					summary: "Update a user",
+					description: "Update a user's details",
+					responses: { 200: {
+						description: "User updated",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["update"] }
+				})) throw ctx.error("FORBIDDEN", {
+					message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS,
+					code: "YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS"
+				});
+				if (Object.keys(ctx.body.data).length === 0) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.NO_DATA_TO_UPDATE });
+				if (ctx.body.data?.role) ctx.body.data.role = parseRoles(ctx.body.data.role);
+				const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, ctx.body.data);
+				return ctx.json(updatedUser);
+			}),
+			listUsers: createAuthEndpoint("/admin/list-users", {
+				method: "GET",
+				use: [adminMiddleware],
+				query: z.object({
+					searchValue: z.string().optional().meta({ description: "The value to search for. Eg: \"some name\"" }),
+					searchField: z.enum(["email", "name"]).meta({ description: "The field to search in, defaults to email. Can be `email` or `name`. Eg: \"name\"" }).optional(),
+					searchOperator: z.enum([
+						"contains",
+						"starts_with",
+						"ends_with"
+					]).meta({ description: "The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. Eg: \"contains\"" }).optional(),
+					limit: z.string().meta({ description: "The number of users to return" }).or(z.number()).optional(),
+					offset: z.string().meta({ description: "The offset to start from" }).or(z.number()).optional(),
+					sortBy: z.string().meta({ description: "The field to sort by" }).optional(),
+					sortDirection: z.enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
+					filterField: z.string().meta({ description: "The field to filter by" }).optional(),
+					filterValue: z.string().meta({ description: "The value to filter by" }).or(z.number()).or(z.boolean()).optional(),
+					filterOperator: z.enum([
+						"eq",
+						"ne",
+						"lt",
+						"lte",
+						"gt",
+						"gte",
+						"contains"
+					]).meta({ description: "The operator to use for the filter" }).optional()
+				}),
+				metadata: { openapi: {
+					operationId: "listUsers",
+					summary: "List users",
+					description: "List users",
+					responses: { 200: {
+						description: "List of users",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								users: {
+									type: "array",
+									items: { $ref: "#/components/schemas/User" }
+								},
+								total: { type: "number" },
+								limit: { type: "number" },
+								offset: { type: "number" }
+							},
+							required: ["users", "total"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["list"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS });
+				const where = [];
+				if (ctx.query?.searchValue) where.push({
+					field: ctx.query.searchField || "email",
+					operator: ctx.query.searchOperator || "contains",
+					value: ctx.query.searchValue
+				});
+				if (ctx.query?.filterValue) where.push({
+					field: ctx.query.filterField || "email",
+					operator: ctx.query.filterOperator || "eq",
+					value: ctx.query.filterValue
+				});
+				try {
+					const users = await ctx.context.internalAdapter.listUsers(Number(ctx.query?.limit) || void 0, Number(ctx.query?.offset) || void 0, ctx.query?.sortBy ? {
+						field: ctx.query.sortBy,
+						direction: ctx.query.sortDirection || "asc"
+					} : void 0, where.length ? where : void 0);
+					const total = await ctx.context.internalAdapter.countTotalUsers(where.length ? where : void 0);
+					return ctx.json({
+						users,
+						total,
+						limit: Number(ctx.query?.limit) || void 0,
+						offset: Number(ctx.query?.offset) || void 0
+					});
+				} catch (e) {
+					return ctx.json({
+						users: [],
+						total: 0
+					});
+				}
+			}),
+			listUserSessions: createAuthEndpoint("/admin/list-user-sessions", {
+				method: "POST",
+				use: [adminMiddleware],
+				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				metadata: { openapi: {
+					operationId: "listUserSessions",
+					summary: "List user sessions",
+					description: "List user sessions",
+					responses: { 200: {
+						description: "List of user sessions",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { sessions: {
+								type: "array",
+								items: { $ref: "#/components/schemas/Session" }
+							} }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["list"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS });
+				return { sessions: await ctx.context.internalAdapter.listSessions(ctx.body.userId) };
+			}),
+			unbanUser: createAuthEndpoint("/admin/unban-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "unbanUser",
+					summary: "Unban a user",
+					description: "Unban a user",
+					responses: { 200: {
+						description: "User unbanned",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["ban"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
+				const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
+					banned: false,
+					banExpires: null,
+					banReason: null,
+					updatedAt: /* @__PURE__ */ new Date()
+				});
+				return ctx.json({ user });
+			}),
+			banUser: createAuthEndpoint("/admin/ban-user", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string().meta({ description: "The user id" }),
+					banReason: z.string().meta({ description: "The reason for the ban" }).optional(),
+					banExpiresIn: z.number().meta({ description: "The number of seconds until the ban expires" }).optional()
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "banUser",
+					summary: "Ban a user",
+					description: "Ban a user",
+					responses: { 200: {
+						description: "User banned",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["ban"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
+				if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_BAN_YOURSELF });
+				const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
+					banned: true,
+					banReason: ctx.body.banReason || options?.defaultBanReason || "No reason",
+					banExpires: ctx.body.banExpiresIn ? getDate(ctx.body.banExpiresIn, "sec") : options?.defaultBanExpiresIn ? getDate(options.defaultBanExpiresIn, "sec") : void 0,
+					updatedAt: /* @__PURE__ */ new Date()
+				});
+				await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
+				return ctx.json({ user });
+			}),
+			impersonateUser: createAuthEndpoint("/admin/impersonate-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "impersonateUser",
+					summary: "Impersonate a user",
+					description: "Impersonate a user",
+					responses: { 200: {
+						description: "Impersonation session created",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								session: { $ref: "#/components/schemas/Session" },
+								user: { $ref: "#/components/schemas/User" }
+							}
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["impersonate"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS });
+				const targetUser = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+				if (!targetUser) throw new APIError("NOT_FOUND", { message: "User not found" });
+				const session = await ctx.context.internalAdapter.createSession(targetUser.id, true, {
+					impersonatedBy: ctx.context.session.user.id,
+					expiresAt: options?.impersonationSessionDuration ? getDate(options.impersonationSessionDuration, "sec") : getDate(3600, "sec")
+				}, true);
+				if (!session) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
+				const authCookies = ctx.context.authCookies;
+				deleteSessionCookie(ctx);
+				const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
+				const adminCookieProp = ctx.context.createAuthCookie("admin_session");
+				await ctx.setSignedCookie(adminCookieProp.name, `${ctx.context.session.session.token}:${dontRememberMeCookie || ""}`, ctx.context.secret, authCookies.sessionToken.options);
+				await setSessionCookie(ctx, {
+					session,
+					user: targetUser
+				}, true);
+				return ctx.json({
+					session,
+					user: targetUser
+				});
+			}),
+			stopImpersonating: createAuthEndpoint("/admin/stop-impersonating", {
+				method: "POST",
+				requireHeaders: true
+			}, async (ctx) => {
+				const session = await getSessionFromCtx(ctx);
+				if (!session) throw new APIError("UNAUTHORIZED");
+				if (!session.session.impersonatedBy) throw new APIError("BAD_REQUEST", { message: "You are not impersonating anyone" });
+				const user = await ctx.context.internalAdapter.findUserById(session.session.impersonatedBy);
+				if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find user" });
+				const adminCookieName = ctx.context.createAuthCookie("admin_session").name;
+				const adminCookie = await ctx.getSignedCookie(adminCookieName, ctx.context.secret);
+				if (!adminCookie) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
+				const [adminSessionToken, dontRememberMeCookie] = adminCookie?.split(":");
+				const adminSession = await ctx.context.internalAdapter.findSession(adminSessionToken);
+				if (!adminSession || adminSession.session.userId !== user.id) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
+				await ctx.context.internalAdapter.deleteSession(session.session.token);
+				await setSessionCookie(ctx, adminSession, !!dontRememberMeCookie);
+				return ctx.json(adminSession);
+			}),
+			revokeUserSession: createAuthEndpoint("/admin/revoke-user-session", {
+				method: "POST",
+				body: z.object({ sessionToken: z.string().meta({ description: "The session token" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "revokeUserSession",
+					summary: "Revoke a user session",
+					description: "Revoke a user session",
+					responses: { 200: {
+						description: "Session revoked",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["revoke"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
+				await ctx.context.internalAdapter.deleteSession(ctx.body.sessionToken);
+				return ctx.json({ success: true });
+			}),
+			revokeUserSessions: createAuthEndpoint("/admin/revoke-user-sessions", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "revokeUserSessions",
+					summary: "Revoke all user sessions",
+					description: "Revoke all user sessions",
+					responses: { 200: {
+						description: "Sessions revoked",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["revoke"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
+				await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
+				return ctx.json({ success: true });
+			}),
+			removeUser: createAuthEndpoint("/admin/remove-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string().meta({ description: "The user id" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "removeUser",
+					summary: "Remove a user",
+					description: "Delete a user and all their sessions and accounts. Cannot be undone.",
+					responses: { 200: {
+						description: "User removed",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["delete"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS });
+				if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_REMOVE_YOURSELF });
+				if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: "User not found" });
+				await ctx.context.internalAdapter.deleteUser(ctx.body.userId);
+				return ctx.json({ success: true });
+			}),
+			setUserPassword: createAuthEndpoint("/admin/set-user-password", {
+				method: "POST",
+				body: z.object({
+					newPassword: z.string().nonempty("newPassword cannot be empty").meta({ description: "The new password" }),
+					userId: z.coerce.string().nonempty("userId cannot be empty").meta({ description: "The user id" })
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "setUserPassword",
+					summary: "Set a user's password",
+					description: "Set a user's password",
+					responses: { 200: {
+						description: "Password set",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["set-password"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD });
+				const { newPassword, userId } = ctx.body;
+				const minPasswordLength = ctx.context.password.config.minPasswordLength;
+				if (newPassword.length < minPasswordLength) {
+					ctx.context.logger.error("Password is too short");
+					throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
+				}
+				const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
+				if (newPassword.length > maxPasswordLength) {
+					ctx.context.logger.error("Password is too long");
+					throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
+				}
+				const hashedPassword = await ctx.context.password.hash(newPassword);
+				await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);
+				return ctx.json({ status: true });
+			}),
+			userHasPermission: createAuthEndpoint("/admin/has-permission", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string().optional().meta({ description: `The user id. Eg: "user-id"` }),
+					role: z.string().optional().meta({ description: `The role to check permission for. Eg: "admin"` })
+				}).and(z.union([z.object({
+					permission: z.record(z.string(), z.array(z.string())),
+					permissions: z.undefined()
+				}), z.object({
+					permission: z.undefined(),
+					permissions: z.record(z.string(), z.array(z.string()))
+				})])),
+				metadata: {
+					openapi: {
+						description: "Check if the user has permission",
+						requestBody: { content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								permission: {
+									type: "object",
+									description: "The permission to check",
+									deprecated: true
+								},
+								permissions: {
+									type: "object",
+									description: "The permission to check"
+								}
+							},
+							required: ["permissions"]
+						} } } },
+						responses: { "200": {
+							description: "Success",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									error: { type: "string" },
+									success: { type: "boolean" }
+								},
+								required: ["success"]
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				if (!ctx.body?.permission && !ctx.body?.permissions) throw new APIError("BAD_REQUEST", { message: "invalid permission check. no permission(s) were passed." });
+				const session = await getSessionFromCtx(ctx);
+				if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
+				if (!session && !ctx.body.userId && !ctx.body.role) throw new APIError("BAD_REQUEST", { message: "user id or role is required" });
+				const user = session?.user || (ctx.body.role ? {
+					id: ctx.body.userId || "",
+					role: ctx.body.role
+				} : null) || await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+				if (!user) throw new APIError("BAD_REQUEST", { message: "user not found" });
+				const result = hasPermission({
+					userId: user.id,
+					role: user.role,
+					options,
+					permissions: ctx.body.permissions ?? ctx.body.permission
+				});
+				return ctx.json({
+					error: null,
+					success: result
+				});
+			})
+		},
+		$ERROR_CODES: ADMIN_ERROR_CODES,
+		schema: mergeSchema(schema, opts.schema),
+		options
+	};
+};
+
+//#endregion
+export { admin as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak2 b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak2
new file mode 100644
index 0000000..39e3b3a
--- /dev/null
+++ b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak2
@@ -0,0 +1,743 @@
+import { l as parseUserOutput, t as mergeSchema, u as getDate } from "./schema-BevzneML.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie, n as deleteSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx } from "./session-Efap-vxj.mjs";
+import { t as getEndpointResponse } from "./plugin-helper-RJJBTOba.mjs";
+import { t as hasPermission } from "./has-permission-DhpFBOUO.mjs";
+import "@better-auth/core/db";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/admin/error-codes.ts
+const ADMIN_ERROR_CODES = defineErrorCodes({
+	FAILED_TO_CREATE_USER: "Failed to create user",
+	USER_ALREADY_EXISTS: "User already exists.",
+	USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
+	YOU_CANNOT_BAN_YOURSELF: "You cannot ban yourself",
+	YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE: "You are not allowed to change users role",
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS: "You are not allowed to create users",
+	YOU_ARE_NOT_ALLOWED_TO_LIST_USERS: "You are not allowed to list users",
+	YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS: "You are not allowed to list users sessions",
+	YOU_ARE_NOT_ALLOWED_TO_BAN_USERS: "You are not allowed to ban users",
+	YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS: "You are not allowed to impersonate users",
+	YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS: "You are not allowed to revoke users sessions",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS: "You are not allowed to delete users",
+	YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD: "You are not allowed to set users password",
+	BANNED_USER: "You have been banned from this application",
+	YOU_ARE_NOT_ALLOWED_TO_GET_USER: "You are not allowed to get user",
+	NO_DATA_TO_UPDATE: "No data to update",
+	YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS: "You are not allowed to update users",
+	YOU_CANNOT_REMOVE_YOURSELF: "You cannot remove yourself",
+	YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE: "You are not allowed to set a non-existent role value"
+});
+
+//#endregion
+//#region src/plugins/admin/schema.ts
+const schema = {
+	user: { fields: {
+		role: {
+			type: "string",
+			required: false,
+			input: false
+		},
+		banned: {
+			type: "boolean",
+			defaultValue: false,
+			required: false,
+			input: false
+		},
+		banReason: {
+			type: "string",
+			required: false,
+			input: false
+		},
+		banExpires: {
+			type: "date",
+			required: false,
+			input: false
+		}
+	} },
+	session: { fields: { impersonatedBy: {
+		type: "string",
+		required: false
+	} } }
+};
+
+//#endregion
+//#region src/plugins/admin/admin.ts
+function parseRoles(roles) {
+	return Array.isArray(roles) ? roles.join(",") : roles;
+}
+const admin = (options) => {
+	const opts = {
+		defaultRole: options?.defaultRole ?? "user",
+		adminRoles: options?.adminRoles ?? ["admin"],
+		bannedUserMessage: options?.bannedUserMessage ?? "You have been banned from this application. Please contact support if you believe this is an error.",
+		...options
+	};
+	/**
+	* Ensures a valid session, if not will throw.
+	* Will also provide additional types on the user to include role types.
+	*/
+	const adminMiddleware = createAuthMiddleware(async (ctx) => {
+		const session = await getSessionFromCtx(ctx);
+		if (!session) throw new APIError("UNAUTHORIZED");
+		return { session };
+	});
+	return {
+		id: "admin",
+		init() {
+			return { options: { databaseHooks: {
+				user: { create: { async before(user) {
+					return { data: {
+						role: options?.defaultRole ?? "user",
+						...user
+					} };
+				} } },
+				session: { create: { async before(session, ctx) {
+					if (!ctx) return;
+					const user = await ctx.context.internalAdapter.findUserById(session.userId);
+					if (user.banned) {
+						if (user.banExpires && new Date(user.banExpires).getTime() < Date.now()) {
+							await ctx.context.internalAdapter.updateUser(session.userId, {
+								banned: false,
+								banReason: null,
+								banExpires: null
+							});
+							return;
+						}
+						if (ctx && (ctx.path.startsWith("/callback") || ctx.path.startsWith("/oauth2/callback"))) {
+							const redirectURI = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
+							throw ctx.redirect(`${redirectURI}?error=banned&error_description=${opts.bannedUserMessage}`);
+						}
+						throw new APIError("FORBIDDEN", {
+							message: opts.bannedUserMessage,
+							code: "BANNED_USER"
+						});
+					}
+				} } }
+			} } };
+		},
+		hooks: { after: [{
+			matcher(context) {
+				return context.path === "/list-sessions";
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const response = await getEndpointResponse(ctx);
+				if (!response) return;
+				const newJson = response.filter((session) => {
+					return !session.impersonatedBy;
+				});
+				return ctx.json(newJson);
+			})
+		}] },
+		endpoints: {
+			setRole: createAuthEndpoint("/admin/set-role", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string(),
+					role: z.union([z.string().meta({ description: "The role to set. `admin` or `user` by default" }), z.array(z.string().meta({ description: "The roles to set. `admin` or `user` by default" }))]).meta({ description: "The role to set, this can be a string or an array of strings. Eg: `admin` or `[admin, user]`" })
+				}),
+				requireHeaders: true,
+				use: [adminMiddleware],
+				metadata: {
+					openapi: {
+						operationId: "setUserRole",
+						summary: "Set the role of a user",
+						description: "Set the role of a user",
+						responses: { 200: {
+							description: "User role updated",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { user: { $ref: "#/components/schemas/User" } }
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["set-role"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });
+				const roles = opts.roles;
+				if (roles) {
+					const inputRoles = Array.isArray(ctx.body.role) ? ctx.body.role : [ctx.body.role];
+					for (const role of inputRoles) if (!roles[role]) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });
+				}
+				const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, { role: parseRoles(ctx.body.role) });
+				return ctx.json({ user: updatedUser });
+			}),
+			getUser: createAuthEndpoint("/admin/get-user", {
+				method: "GET",
+				query: z.object({ id: z.string().meta({ description: "The id of the User" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "getUser",
+					summary: "Get an existing user",
+					description: "Get an existing user",
+					responses: { 200: {
+						description: "User",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { id } = ctx.query;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["get"] }
+				})) throw ctx.error("FORBIDDEN", {
+					message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_USER,
+					code: "YOU_ARE_NOT_ALLOWED_TO_GET_USER"
+				});
+				const user = await ctx.context.internalAdapter.findUserById(id);
+				if (!user) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				return parseUserOutput(ctx.context.options, user);
+			}),
+			createUser: createAuthEndpoint("/admin/create-user", {
+				method: "POST",
+				body: z.object({
+					email: z.string().meta({ description: "The email of the user" }),
+					password: z.string().meta({ description: "The password of the user" }),
+					name: z.string().meta({ description: "The name of the user" }),
+					role: z.union([z.string().meta({ description: "The role of the user" }), z.array(z.string().meta({ description: "The roles of user" }))]).optional().meta({ description: `A string or array of strings representing the roles to apply to the new user. Eg: \"user\"` }),
+					data: z.record(z.string(), z.any()).optional().meta({ description: "Extra fields for the user. Including custom additional fields." })
+				}),
+				metadata: {
+					openapi: {
+						operationId: "createUser",
+						summary: "Create a new user",
+						description: "Create a new user",
+						responses: { 200: {
+							description: "User created",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { user: { $ref: "#/components/schemas/User" } }
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				const session = await getSessionFromCtx(ctx);
+				if (!session && (ctx.request || ctx.headers)) throw ctx.error("UNAUTHORIZED");
+				if (session) {
+					if (!hasPermission({
+						userId: session.user.id,
+						role: session.user.role,
+						options: opts,
+						permissions: { user: ["create"] }
+					})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS });
+				}
+				const email = ctx.body.email.toLowerCase();
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				if (await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
+				const user = await ctx.context.internalAdapter.createUser({
+					email,
+					name: ctx.body.name,
+					role: (ctx.body.role && parseRoles(ctx.body.role)) ?? options?.defaultRole ?? "user",
+					...ctx.body.data
+				});
+				if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
+				const hashedPassword = await ctx.context.password.hash(ctx.body.password);
+				await ctx.context.internalAdapter.linkAccount({
+					accountId: user.id,
+					providerId: "credential",
+					password: hashedPassword,
+					userId: user.id
+				});
+				return ctx.json({ user });
+			}),
+			adminUpdateUser: createAuthEndpoint("/admin/update-user", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string(),
+					data: z.record(z.any(), z.any()).meta({ description: "The user data to update" })
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "updateUser",
+					summary: "Update a user",
+					description: "Update a user's details",
+					responses: { 200: {
+						description: "User updated",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["update"] }
+				})) throw ctx.error("FORBIDDEN", {
+					message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS,
+					code: "YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS"
+				});
+				if (Object.keys(ctx.body.data).length === 0) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.NO_DATA_TO_UPDATE });
+				if (ctx.body.data?.role) ctx.body.data.role = parseRoles(ctx.body.data.role);
+				const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, ctx.body.data);
+				return ctx.json(updatedUser);
+			}),
+			listUsers: createAuthEndpoint("/admin/list-users", {
+				method: "GET",
+				use: [adminMiddleware],
+				query: z.object({
+					searchValue: z.string().optional().meta({ description: "The value to search for. Eg: \"some name\"" }),
+					searchField: z.enum(["email", "name"]).meta({ description: "The field to search in, defaults to email. Can be `email` or `name`. Eg: \"name\"" }).optional(),
+					searchOperator: z.enum([
+						"contains",
+						"starts_with",
+						"ends_with"
+					]).meta({ description: "The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. Eg: \"contains\"" }).optional(),
+					limit: z.string().meta({ description: "The number of users to return" }).or(z.number()).optional(),
+					offset: z.string().meta({ description: "The offset to start from" }).or(z.number()).optional(),
+					sortBy: z.string().meta({ description: "The field to sort by" }).optional(),
+					sortDirection: z.enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
+					filterField: z.string().meta({ description: "The field to filter by" }).optional(),
+					filterValue: z.string().meta({ description: "The value to filter by" }).or(z.number()).or(z.boolean()).optional(),
+					filterOperator: z.enum([
+						"eq",
+						"ne",
+						"lt",
+						"lte",
+						"gt",
+						"gte",
+						"contains"
+					]).meta({ description: "The operator to use for the filter" }).optional()
+				}),
+				metadata: { openapi: {
+					operationId: "listUsers",
+					summary: "List users",
+					description: "List users",
+					responses: { 200: {
+						description: "List of users",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								users: {
+									type: "array",
+									items: { $ref: "#/components/schemas/User" }
+								},
+								total: { type: "number" },
+								limit: { type: "number" },
+								offset: { type: "number" }
+							},
+							required: ["users", "total"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["list"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS });
+				const where = [];
+				if (ctx.query?.searchValue) where.push({
+					field: ctx.query.searchField || "email",
+					operator: ctx.query.searchOperator || "contains",
+					value: ctx.query.searchValue
+				});
+				if (ctx.query?.filterValue) where.push({
+					field: ctx.query.filterField || "email",
+					operator: ctx.query.filterOperator || "eq",
+					value: ctx.query.filterValue
+				});
+				try {
+					const users = await ctx.context.internalAdapter.listUsers(Number(ctx.query?.limit) || void 0, Number(ctx.query?.offset) || void 0, ctx.query?.sortBy ? {
+						field: ctx.query.sortBy,
+						direction: ctx.query.sortDirection || "asc"
+					} : void 0, where.length ? where : void 0);
+					const total = await ctx.context.internalAdapter.countTotalUsers(where.length ? where : void 0);
+					return ctx.json({
+						users,
+						total,
+						limit: Number(ctx.query?.limit) || void 0,
+						offset: Number(ctx.query?.offset) || void 0
+					});
+				} catch (e) {
+					return ctx.json({
+						users: [],
+						total: 0
+					});
+				}
+			}),
+			listUserSessions: createAuthEndpoint("/admin/list-user-sessions", {
+				method: "POST",
+				use: [adminMiddleware],
+				body: z.object({ userId: z.coerce.string() }),
+				metadata: { openapi: {
+					operationId: "listUserSessions",
+					summary: "List user sessions",
+					description: "List user sessions",
+					responses: { 200: {
+						description: "List of user sessions",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { sessions: {
+								type: "array",
+								items: { $ref: "#/components/schemas/Session" }
+							} }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["list"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS });
+				return { sessions: await ctx.context.internalAdapter.listSessions(ctx.body.userId) };
+			}),
+			unbanUser: createAuthEndpoint("/admin/unban-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "unbanUser",
+					summary: "Unban a user",
+					description: "Unban a user",
+					responses: { 200: {
+						description: "User unbanned",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["ban"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
+				const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
+					banned: false,
+					banExpires: null,
+					banReason: null,
+					updatedAt: /* @__PURE__ */ new Date()
+				});
+				return ctx.json({ user });
+			}),
+			banUser: createAuthEndpoint("/admin/ban-user", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string(),
+					banReason: z.string().meta({ description: "The reason for the ban" }).optional(),
+					banExpiresIn: z.number().meta({ description: "The number of seconds until the ban expires" }).optional()
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "banUser",
+					summary: "Ban a user",
+					description: "Ban a user",
+					responses: { 200: {
+						description: "User banned",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["ban"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
+				if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_BAN_YOURSELF });
+				const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
+					banned: true,
+					banReason: ctx.body.banReason || options?.defaultBanReason || "No reason",
+					banExpires: ctx.body.banExpiresIn ? getDate(ctx.body.banExpiresIn, "sec") : options?.defaultBanExpiresIn ? getDate(options.defaultBanExpiresIn, "sec") : void 0,
+					updatedAt: /* @__PURE__ */ new Date()
+				});
+				await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
+				return ctx.json({ user });
+			}),
+			impersonateUser: createAuthEndpoint("/admin/impersonate-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "impersonateUser",
+					summary: "Impersonate a user",
+					description: "Impersonate a user",
+					responses: { 200: {
+						description: "Impersonation session created",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								session: { $ref: "#/components/schemas/Session" },
+								user: { $ref: "#/components/schemas/User" }
+							}
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["impersonate"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS });
+				const targetUser = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+				if (!targetUser) throw new APIError("NOT_FOUND", { message: "User not found" });
+				const session = await ctx.context.internalAdapter.createSession(targetUser.id, true, {
+					impersonatedBy: ctx.context.session.user.id,
+					expiresAt: options?.impersonationSessionDuration ? getDate(options.impersonationSessionDuration, "sec") : getDate(3600, "sec")
+				}, true);
+				if (!session) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
+				const authCookies = ctx.context.authCookies;
+				deleteSessionCookie(ctx);
+				const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
+				const adminCookieProp = ctx.context.createAuthCookie("admin_session");
+				await ctx.setSignedCookie(adminCookieProp.name, `${ctx.context.session.session.token}:${dontRememberMeCookie || ""}`, ctx.context.secret, authCookies.sessionToken.options);
+				await setSessionCookie(ctx, {
+					session,
+					user: targetUser
+				}, true);
+				return ctx.json({
+					session,
+					user: targetUser
+				});
+			}),
+			stopImpersonating: createAuthEndpoint("/admin/stop-impersonating", {
+				method: "POST",
+				requireHeaders: true
+			}, async (ctx) => {
+				const session = await getSessionFromCtx(ctx);
+				if (!session) throw new APIError("UNAUTHORIZED");
+				if (!session.session.impersonatedBy) throw new APIError("BAD_REQUEST", { message: "You are not impersonating anyone" });
+				const user = await ctx.context.internalAdapter.findUserById(session.session.impersonatedBy);
+				if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find user" });
+				const adminCookieName = ctx.context.createAuthCookie("admin_session").name;
+				const adminCookie = await ctx.getSignedCookie(adminCookieName, ctx.context.secret);
+				if (!adminCookie) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
+				const [adminSessionToken, dontRememberMeCookie] = adminCookie?.split(":");
+				const adminSession = await ctx.context.internalAdapter.findSession(adminSessionToken);
+				if (!adminSession || adminSession.session.userId !== user.id) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
+				await ctx.context.internalAdapter.deleteSession(session.session.token);
+				await setSessionCookie(ctx, adminSession, !!dontRememberMeCookie);
+				return ctx.json(adminSession);
+			}),
+			revokeUserSession: createAuthEndpoint("/admin/revoke-user-session", {
+				method: "POST",
+				body: z.object({ sessionToken: z.string().meta({ description: "The session token" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "revokeUserSession",
+					summary: "Revoke a user session",
+					description: "Revoke a user session",
+					responses: { 200: {
+						description: "Session revoked",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["revoke"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
+				await ctx.context.internalAdapter.deleteSession(ctx.body.sessionToken);
+				return ctx.json({ success: true });
+			}),
+			revokeUserSessions: createAuthEndpoint("/admin/revoke-user-sessions", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "revokeUserSessions",
+					summary: "Revoke all user sessions",
+					description: "Revoke all user sessions",
+					responses: { 200: {
+						description: "Sessions revoked",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["revoke"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
+				await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
+				return ctx.json({ success: true });
+			}),
+			removeUser: createAuthEndpoint("/admin/remove-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "removeUser",
+					summary: "Remove a user",
+					description: "Delete a user and all their sessions and accounts. Cannot be undone.",
+					responses: { 200: {
+						description: "User removed",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["delete"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS });
+				if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_REMOVE_YOURSELF });
+				if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: "User not found" });
+				await ctx.context.internalAdapter.deleteUser(ctx.body.userId);
+				return ctx.json({ success: true });
+			}),
+			setUserPassword: createAuthEndpoint("/admin/set-user-password", {
+				method: "POST",
+				body: z.object({
+					newPassword: z.string().nonempty("newPassword cannot be empty").meta({ description: "The new password" }),
+					userId: z.coerce.string().nonempty("userId cannot be empty").meta({ description: "The user id" })
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "setUserPassword",
+					summary: "Set a user's password",
+					description: "Set a user's password",
+					responses: { 200: {
+						description: "Password set",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["set-password"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD });
+				const { newPassword, userId } = ctx.body;
+				const minPasswordLength = ctx.context.password.config.minPasswordLength;
+				if (newPassword.length < minPasswordLength) {
+					ctx.context.logger.error("Password is too short");
+					throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
+				}
+				const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
+				if (newPassword.length > maxPasswordLength) {
+					ctx.context.logger.error("Password is too long");
+					throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
+				}
+				const hashedPassword = await ctx.context.password.hash(newPassword);
+				await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);
+				return ctx.json({ status: true });
+			}),
+			userHasPermission: createAuthEndpoint("/admin/has-permission", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string().optional().meta({ description: `The user id. Eg: "user-id"` }),
+					role: z.string().optional().meta({ description: `The role to check permission for. Eg: "admin"` })
+				}).and(z.union([z.object({
+					permission: z.record(z.string(), z.array(z.string())),
+					permissions: z.undefined()
+				}), z.object({
+					permission: z.undefined(),
+					permissions: z.record(z.string(), z.array(z.string()))
+				})])),
+				metadata: {
+					openapi: {
+						description: "Check if the user has permission",
+						requestBody: { content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								permission: {
+									type: "object",
+									description: "The permission to check",
+									deprecated: true
+								},
+								permissions: {
+									type: "object",
+									description: "The permission to check"
+								}
+							},
+							required: ["permissions"]
+						} } } },
+						responses: { "200": {
+							description: "Success",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									error: { type: "string" },
+									success: { type: "boolean" }
+								},
+								required: ["success"]
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				if (!ctx.body?.permission && !ctx.body?.permissions) throw new APIError("BAD_REQUEST", { message: "invalid permission check. no permission(s) were passed." });
+				const session = await getSessionFromCtx(ctx);
+				if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
+				if (!session && !ctx.body.userId && !ctx.body.role) throw new APIError("BAD_REQUEST", { message: "user id or role is required" });
+				const user = session?.user || (ctx.body.role ? {
+					id: ctx.body.userId || "",
+					role: ctx.body.role
+				} : null) || await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+				if (!user) throw new APIError("BAD_REQUEST", { message: "user not found" });
+				const result = hasPermission({
+					userId: user.id,
+					role: user.role,
+					options,
+					permissions: ctx.body.permissions ?? ctx.body.permission
+				});
+				return ctx.json({
+					error: null,
+					success: result
+				});
+			})
+		},
+		$ERROR_CODES: ADMIN_ERROR_CODES,
+		schema: mergeSchema(schema, opts.schema),
+		options
+	};
+};
+
+//#endregion
+export { admin as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak3 b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak3
new file mode 100644
index 0000000..fd38cff
--- /dev/null
+++ b/node_modules/better-auth/dist/admin-CJ3jncSX.mjs.bak3
@@ -0,0 +1,743 @@
+import { l as parseUserOutput, t as mergeSchema, u as getDate } from "./schema-BevzneML.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie, n as deleteSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx } from "./session-Efap-vxj.mjs";
+import { t as getEndpointResponse } from "./plugin-helper-RJJBTOba.mjs";
+import { t as hasPermission } from "./has-permission-DhpFBOUO.mjs";
+import "@better-auth/core/db";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/admin/error-codes.ts
+const ADMIN_ERROR_CODES = defineErrorCodes({
+	FAILED_TO_CREATE_USER: "Failed to create user",
+	USER_ALREADY_EXISTS: "User already exists.",
+	USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
+	YOU_CANNOT_BAN_YOURSELF: "You cannot ban yourself",
+	YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE: "You are not allowed to change users role",
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS: "You are not allowed to create users",
+	YOU_ARE_NOT_ALLOWED_TO_LIST_USERS: "You are not allowed to list users",
+	YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS: "You are not allowed to list users sessions",
+	YOU_ARE_NOT_ALLOWED_TO_BAN_USERS: "You are not allowed to ban users",
+	YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS: "You are not allowed to impersonate users",
+	YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS: "You are not allowed to revoke users sessions",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS: "You are not allowed to delete users",
+	YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD: "You are not allowed to set users password",
+	BANNED_USER: "You have been banned from this application",
+	YOU_ARE_NOT_ALLOWED_TO_GET_USER: "You are not allowed to get user",
+	NO_DATA_TO_UPDATE: "No data to update",
+	YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS: "You are not allowed to update users",
+	YOU_CANNOT_REMOVE_YOURSELF: "You cannot remove yourself",
+	YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE: "You are not allowed to set a non-existent role value"
+});
+
+//#endregion
+//#region src/plugins/admin/schema.ts
+const schema = {
+	user: { fields: {
+		role: {
+			type: "string",
+			required: false,
+			input: false
+		},
+		banned: {
+			type: "boolean",
+			defaultValue: false,
+			required: false,
+			input: false
+		},
+		banReason: {
+			type: "string",
+			required: false,
+			input: false
+		},
+		banExpires: {
+			type: "date",
+			required: false,
+			input: false
+		}
+	} },
+	session: { fields: { impersonatedBy: {
+		type: "string",
+		required: false
+	} } }
+};
+
+//#endregion
+//#region src/plugins/admin/admin.ts
+function parseRoles(roles) {
+	return Array.isArray(roles) ? roles.join(",") : roles;
+}
+const admin = (options) => {
+	const opts = {
+		defaultRole: options?.defaultRole ?? "user",
+		adminRoles: options?.adminRoles ?? ["admin"],
+		bannedUserMessage: options?.bannedUserMessage ?? "You have been banned from this application. Please contact support if you believe this is an error.",
+		...options
+	};
+	/**
+	* Ensures a valid session, if not will throw.
+	* Will also provide additional types on the user to include role types.
+	*/
+	const adminMiddleware = createAuthMiddleware(async (ctx) => {
+		const session = await getSessionFromCtx(ctx);
+		if (!session) throw new APIError("UNAUTHORIZED");
+		return { session };
+	});
+	return {
+		id: "admin",
+		init() {
+			return { options: { databaseHooks: {
+				user: { create: { async before(user) {
+					return { data: {
+						role: options?.defaultRole ?? "user",
+						...user
+					} };
+				} } },
+				session: { create: { async before(session, ctx) {
+					if (!ctx) return;
+					const user = await ctx.context.internalAdapter.findUserById(session.userId);
+					if (user.banned) {
+						if (user.banExpires && new Date(user.banExpires).getTime() < Date.now()) {
+							await ctx.context.internalAdapter.updateUser(session.userId, {
+								banned: false,
+								banReason: null,
+								banExpires: null
+							});
+							return;
+						}
+						if (ctx && (ctx.path.startsWith("/callback") || ctx.path.startsWith("/oauth2/callback"))) {
+							const redirectURI = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
+							throw ctx.redirect(`${redirectURI}?error=banned&error_description=${opts.bannedUserMessage}`);
+						}
+						throw new APIError("FORBIDDEN", {
+							message: opts.bannedUserMessage,
+							code: "BANNED_USER"
+						});
+					}
+				} } }
+			} } };
+		},
+		hooks: { after: [{
+			matcher(context) {
+				return context.path === "/list-sessions";
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const response = await getEndpointResponse(ctx);
+				if (!response) return;
+				const newJson = response.filter((session) => {
+					return !session.impersonatedBy;
+				});
+				return ctx.json(newJson);
+			})
+		}] },
+		endpoints: {
+			setRole: createAuthEndpoint("/admin/set-role", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string(),
+					role: z.union([z.string().meta({ description: "The role to set. `admin` or `user` by default" }), z.array(z.string().meta({ description: "The roles to set. `admin` or `user` by default" }))]).meta({ description: "The role to set, this can be a string or an array of strings. Eg: `admin` or `[admin, user]`" })
+				}),
+				requireHeaders: true,
+				use: [adminMiddleware],
+				metadata: {
+					openapi: {
+						operationId: "setUserRole",
+						summary: "Set the role of a user",
+						description: "Set the role of a user",
+						responses: { 200: {
+							description: "User role updated",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { user: { $ref: "#/components/schemas/User" } }
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["set-role"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });
+				const roles = opts.roles;
+				if (roles) {
+					const inputRoles = Array.isArray(ctx.body.role) ? ctx.body.role : [ctx.body.role];
+					for (const role of inputRoles) if (!roles[role]) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });
+				}
+				const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, { role: parseRoles(ctx.body.role) });
+				return ctx.json({ user: updatedUser });
+			}),
+			getUser: createAuthEndpoint("/admin/get-user", {
+				method: "GET",
+				query: z.object({ id: z.string().meta({ description: "The id of the User" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "getUser",
+					summary: "Get an existing user",
+					description: "Get an existing user",
+					responses: { 200: {
+						description: "User",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { id } = ctx.query;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["get"] }
+				})) throw ctx.error("FORBIDDEN", {
+					message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_USER,
+					code: "YOU_ARE_NOT_ALLOWED_TO_GET_USER"
+				});
+				const user = await ctx.context.internalAdapter.findUserById(id);
+				if (!user) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				return parseUserOutput(ctx.context.options, user);
+			}),
+			createUser: createAuthEndpoint("/admin/create-user", {
+				method: "POST",
+				body: z.object({
+					email: z.string().meta({ description: "The email of the user" }),
+					password: z.string().meta({ description: "The password of the user" }),
+					name: z.string().meta({ description: "The name of the user" }),
+					role: z.union([z.string().meta({ description: "The role of the user" }), z.array(z.string().meta({ description: "The roles of user" }))]).optional().meta({ description: `A string or array of strings representing the roles to apply to the new user. Eg: \"user\"` }),
+					data: z.record(z.string(), z.any()).optional().meta({ description: "Extra fields for the user. Including custom additional fields." })
+				}),
+				metadata: {
+					openapi: {
+						operationId: "createUser",
+						summary: "Create a new user",
+						description: "Create a new user",
+						responses: { 200: {
+							description: "User created",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { user: { $ref: "#/components/schemas/User" } }
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				const session = await getSessionFromCtx(ctx);
+				if (!session && (ctx.request || ctx.headers)) throw ctx.error("UNAUTHORIZED");
+				if (session) {
+					if (!hasPermission({
+						userId: session.user.id,
+						role: session.user.role,
+						options: opts,
+						permissions: { user: ["create"] }
+					})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS });
+				}
+				const email = ctx.body.email.toLowerCase();
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				if (await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
+				const user = await ctx.context.internalAdapter.createUser({
+					email,
+					name: ctx.body.name,
+					role: (ctx.body.role && parseRoles(ctx.body.role)) ?? options?.defaultRole ?? "user",
+					...ctx.body.data
+				});
+				if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
+				const hashedPassword = await ctx.context.password.hash(ctx.body.password);
+				await ctx.context.internalAdapter.linkAccount({
+					accountId: user.id,
+					providerId: "credential",
+					password: hashedPassword,
+					userId: user.id
+				});
+				return ctx.json({ user });
+			}),
+			adminUpdateUser: createAuthEndpoint("/admin/update-user", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string(),
+					data: z.record(z.any(), z.any()).meta({ description: "The user data to update" })
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "updateUser",
+					summary: "Update a user",
+					description: "Update a user's details",
+					responses: { 200: {
+						description: "User updated",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["update"] }
+				})) throw ctx.error("FORBIDDEN", {
+					message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS,
+					code: "YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS"
+				});
+				if (Object.keys(ctx.body.data).length === 0) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.NO_DATA_TO_UPDATE });
+				if (ctx.body.data?.role) ctx.body.data.role = parseRoles(ctx.body.data.role);
+				const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, ctx.body.data);
+				return ctx.json(updatedUser);
+			}),
+			listUsers: createAuthEndpoint("/admin/list-users", {
+				method: "GET",
+				use: [adminMiddleware],
+				query: z.object({
+					searchValue: z.string().optional().meta({ description: "The value to search for. Eg: \"some name\"" }),
+					searchField: z.enum(["email", "name"]).meta({ description: "The field to search in, defaults to email. Can be `email` or `name`. Eg: \"name\"" }).optional(),
+					searchOperator: z.enum([
+						"contains",
+						"starts_with",
+						"ends_with"
+					]).meta({ description: "The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. Eg: \"contains\"" }).optional(),
+					limit: z.string().meta({ description: "The number of users to return" }).or(z.number()).optional(),
+					offset: z.string().meta({ description: "The offset to start from" }).or(z.number()).optional(),
+					sortBy: z.string().meta({ description: "The field to sort by" }).optional(),
+					sortDirection: z.enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
+					filterField: z.string().meta({ description: "The field to filter by" }).optional(),
+					filterValue: z.string().meta({ description: "The value to filter by" }).or(z.number()).or(z.boolean()).optional(),
+					filterOperator: z.enum([
+						"eq",
+						"ne",
+						"lt",
+						"lte",
+						"gt",
+						"gte",
+						"contains"
+					]).meta({ description: "The operator to use for the filter" }).optional()
+				}),
+				metadata: { openapi: {
+					operationId: "listUsers",
+					summary: "List users",
+					description: "List users",
+					responses: { 200: {
+						description: "List of users",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								users: {
+									type: "array",
+									items: { $ref: "#/components/schemas/User" }
+								},
+								total: { type: "number" },
+								limit: { type: "number" },
+								offset: { type: "number" }
+							},
+							required: ["users", "total"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["list"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS });
+				const where = [];
+				if (ctx.query?.searchValue) where.push({
+					field: ctx.query.searchField || "email",
+					operator: ctx.query.searchOperator || "contains",
+					value: ctx.query.searchValue
+				});
+				if (ctx.query?.filterValue) where.push({
+					field: ctx.query.filterField || "email",
+					operator: ctx.query.filterOperator || "eq",
+					value: ctx.query.filterValue
+				});
+				try {
+					const users = await ctx.context.internalAdapter.listUsers(Number(ctx.query?.limit) || void 0, Number(ctx.query?.offset) || void 0, ctx.query?.sortBy ? {
+						field: ctx.query.sortBy,
+						direction: ctx.query.sortDirection || "asc"
+					} : void 0, where.length ? where : void 0);
+					const total = await ctx.context.internalAdapter.countTotalUsers(where.length ? where : void 0);
+					return ctx.json({
+						users,
+						total,
+						limit: Number(ctx.query?.limit) || void 0,
+						offset: Number(ctx.query?.offset) || void 0
+					});
+				} catch (e) {
+					return ctx.json({
+						users: [],
+						total: 0
+					});
+				}
+			}),
+			listUserSessions: createAuthEndpoint("/admin/list-user-sessions", {
+				method: "POST",
+				use: [adminMiddleware],
+				body: z.object({ userId: z.coerce.string() }),
+				metadata: { openapi: {
+					operationId: "listUserSessions",
+					summary: "List user sessions",
+					description: "List user sessions",
+					responses: { 200: {
+						description: "List of user sessions",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { sessions: {
+								type: "array",
+								items: { $ref: "#/components/schemas/Session" }
+							} }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["list"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS });
+				return { sessions: await ctx.context.internalAdapter.listSessions(ctx.body.userId) };
+			}),
+			unbanUser: createAuthEndpoint("/admin/unban-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "unbanUser",
+					summary: "Unban a user",
+					description: "Unban a user",
+					responses: { 200: {
+						description: "User unbanned",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["ban"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
+				const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
+					banned: false,
+					banExpires: null,
+					banReason: null,
+					updatedAt: /* @__PURE__ */ new Date()
+				});
+				return ctx.json({ user });
+			}),
+			banUser: createAuthEndpoint("/admin/ban-user", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string(),
+					banReason: z.string().meta({ description: "The reason for the ban" }).optional(),
+					banExpiresIn: z.number().meta({ description: "The number of seconds until the ban expires" }).optional()
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "banUser",
+					summary: "Ban a user",
+					description: "Ban a user",
+					responses: { 200: {
+						description: "User banned",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { user: { $ref: "#/components/schemas/User" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["ban"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
+				if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_BAN_YOURSELF });
+				const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
+					banned: true,
+					banReason: ctx.body.banReason || options?.defaultBanReason || "No reason",
+					banExpires: ctx.body.banExpiresIn ? getDate(ctx.body.banExpiresIn, "sec") : options?.defaultBanExpiresIn ? getDate(options.defaultBanExpiresIn, "sec") : void 0,
+					updatedAt: /* @__PURE__ */ new Date()
+				});
+				await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
+				return ctx.json({ user });
+			}),
+			impersonateUser: createAuthEndpoint("/admin/impersonate-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "impersonateUser",
+					summary: "Impersonate a user",
+					description: "Impersonate a user",
+					responses: { 200: {
+						description: "Impersonation session created",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								session: { $ref: "#/components/schemas/Session" },
+								user: { $ref: "#/components/schemas/User" }
+							}
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["impersonate"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS });
+				const targetUser = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+				if (!targetUser) throw new APIError("NOT_FOUND", { message: "User not found" });
+				const session = await ctx.context.internalAdapter.createSession(targetUser.id, true, {
+					impersonatedBy: ctx.context.session.user.id,
+					expiresAt: options?.impersonationSessionDuration ? getDate(options.impersonationSessionDuration, "sec") : getDate(3600, "sec")
+				}, true);
+				if (!session) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
+				const authCookies = ctx.context.authCookies;
+				deleteSessionCookie(ctx);
+				const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
+				const adminCookieProp = ctx.context.createAuthCookie("admin_session");
+				await ctx.setSignedCookie(adminCookieProp.name, `${ctx.context.session.session.token}:${dontRememberMeCookie || ""}`, ctx.context.secret, authCookies.sessionToken.options);
+				await setSessionCookie(ctx, {
+					session,
+					user: targetUser
+				}, true);
+				return ctx.json({
+					session,
+					user: targetUser
+				});
+			}),
+			stopImpersonating: createAuthEndpoint("/admin/stop-impersonating", {
+				method: "POST",
+				requireHeaders: true
+			}, async (ctx) => {
+				const session = await getSessionFromCtx(ctx);
+				if (!session) throw new APIError("UNAUTHORIZED");
+				if (!session.session.impersonatedBy) throw new APIError("BAD_REQUEST", { message: "You are not impersonating anyone" });
+				const user = await ctx.context.internalAdapter.findUserById(session.session.impersonatedBy);
+				if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find user" });
+				const adminCookieName = ctx.context.createAuthCookie("admin_session").name;
+				const adminCookie = await ctx.getSignedCookie(adminCookieName, ctx.context.secret);
+				if (!adminCookie) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
+				const [adminSessionToken, dontRememberMeCookie] = adminCookie?.split(":");
+				const adminSession = await ctx.context.internalAdapter.findSession(adminSessionToken);
+				if (!adminSession || adminSession.session.userId !== user.id) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
+				await ctx.context.internalAdapter.deleteSession(session.session.token);
+				await setSessionCookie(ctx, adminSession, !!dontRememberMeCookie);
+				return ctx.json(adminSession);
+			}),
+			revokeUserSession: createAuthEndpoint("/admin/revoke-user-session", {
+				method: "POST",
+				body: z.object({ sessionToken: z.string().meta({ description: "The session token" }) }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "revokeUserSession",
+					summary: "Revoke a user session",
+					description: "Revoke a user session",
+					responses: { 200: {
+						description: "Session revoked",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["revoke"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
+				await ctx.context.internalAdapter.deleteSession(ctx.body.sessionToken);
+				return ctx.json({ success: true });
+			}),
+			revokeUserSessions: createAuthEndpoint("/admin/revoke-user-sessions", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "revokeUserSessions",
+					summary: "Revoke all user sessions",
+					description: "Revoke all user sessions",
+					responses: { 200: {
+						description: "Sessions revoked",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { session: ["revoke"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
+				await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
+				return ctx.json({ success: true });
+			}),
+			removeUser: createAuthEndpoint("/admin/remove-user", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string() }),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "removeUser",
+					summary: "Remove a user",
+					description: "Delete a user and all their sessions and accounts. Cannot be undone.",
+					responses: { 200: {
+						description: "User removed",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = ctx.context.session;
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: session.user.role,
+					options: opts,
+					permissions: { user: ["delete"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS });
+				if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_REMOVE_YOURSELF });
+				if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: "User not found" });
+				await ctx.context.internalAdapter.deleteUser(ctx.body.userId);
+				return ctx.json({ success: true });
+			}),
+			setUserPassword: createAuthEndpoint("/admin/set-user-password", {
+				method: "POST",
+				body: z.object({
+					newPassword: z.string().nonempty("newPassword cannot be empty").meta({ description: "The new password" }),
+					userId: z.coerce.string().nonempty("userId cannot be empty")
+				}),
+				use: [adminMiddleware],
+				metadata: { openapi: {
+					operationId: "setUserPassword",
+					summary: "Set a user's password",
+					description: "Set a user's password",
+					responses: { 200: {
+						description: "Password set",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!hasPermission({
+					userId: ctx.context.session.user.id,
+					role: ctx.context.session.user.role,
+					options: opts,
+					permissions: { user: ["set-password"] }
+				})) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD });
+				const { newPassword, userId } = ctx.body;
+				const minPasswordLength = ctx.context.password.config.minPasswordLength;
+				if (newPassword.length < minPasswordLength) {
+					ctx.context.logger.error("Password is too short");
+					throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
+				}
+				const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
+				if (newPassword.length > maxPasswordLength) {
+					ctx.context.logger.error("Password is too long");
+					throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
+				}
+				const hashedPassword = await ctx.context.password.hash(newPassword);
+				await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);
+				return ctx.json({ status: true });
+			}),
+			userHasPermission: createAuthEndpoint("/admin/has-permission", {
+				method: "POST",
+				body: z.object({
+					userId: z.coerce.string().optional().meta({ description: `The user id. Eg: "user-id"` }),
+					role: z.string().optional().meta({ description: `The role to check permission for. Eg: "admin"` })
+				}).and(z.union([z.object({
+					permission: z.record(z.string(), z.array(z.string())),
+					permissions: z.undefined()
+				}), z.object({
+					permission: z.undefined(),
+					permissions: z.record(z.string(), z.array(z.string()))
+				})])),
+				metadata: {
+					openapi: {
+						description: "Check if the user has permission",
+						requestBody: { content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								permission: {
+									type: "object",
+									description: "The permission to check",
+									deprecated: true
+								},
+								permissions: {
+									type: "object",
+									description: "The permission to check"
+								}
+							},
+							required: ["permissions"]
+						} } } },
+						responses: { "200": {
+							description: "Success",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									error: { type: "string" },
+									success: { type: "boolean" }
+								},
+								required: ["success"]
+							} } }
+						} }
+					},
+					$Infer: { body: {} }
+				}
+			}, async (ctx) => {
+				if (!ctx.body?.permission && !ctx.body?.permissions) throw new APIError("BAD_REQUEST", { message: "invalid permission check. no permission(s) were passed." });
+				const session = await getSessionFromCtx(ctx);
+				if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
+				if (!session && !ctx.body.userId && !ctx.body.role) throw new APIError("BAD_REQUEST", { message: "user id or role is required" });
+				const user = session?.user || (ctx.body.role ? {
+					id: ctx.body.userId || "",
+					role: ctx.body.role
+				} : null) || await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+				if (!user) throw new APIError("BAD_REQUEST", { message: "user not found" });
+				const result = hasPermission({
+					userId: user.id,
+					role: user.role,
+					options,
+					permissions: ctx.body.permissions ?? ctx.body.permission
+				});
+				return ctx.json({
+					error: null,
+					success: result
+				});
+			})
+		},
+		$ERROR_CODES: ADMIN_ERROR_CODES,
+		schema: mergeSchema(schema, opts.schema),
+		options
+	};
+};
+
+//#endregion
+export { admin as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/anonymous-DCfvRfoL.mjs b/node_modules/better-auth/dist/anonymous-DCfvRfoL.mjs
index fd49bf2..96581fb 100644
--- a/node_modules/better-auth/dist/anonymous-DCfvRfoL.mjs
+++ b/node_modules/better-auth/dist/anonymous-DCfvRfoL.mjs
@@ -29,7 +29,7 @@ const schema = { user: { fields: { isAnonymous: {
 async function getAnonUserEmail(options) {
 	const customEmail = await options?.generateRandomEmail?.();
 	if (customEmail) {
-		if (!z.email().safeParse(customEmail).success) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.INVALID_EMAIL_FORMAT });
+		if (!z.string().email().safeParse(customEmail).success) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.INVALID_EMAIL_FORMAT });
 		return customEmail;
 	}
 	const id = generateId();
diff --git a/node_modules/better-auth/dist/anonymous-DCfvRfoL.mjs.bak b/node_modules/better-auth/dist/anonymous-DCfvRfoL.mjs.bak
new file mode 100644
index 0000000..96581fb
--- /dev/null
+++ b/node_modules/better-auth/dist/anonymous-DCfvRfoL.mjs.bak
@@ -0,0 +1,125 @@
+import { t as generateId } from "./utils-F62c-ieM.mjs";
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie, l as parseSetCookieHeader } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx } from "./session-Efap-vxj.mjs";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/anonymous/error-codes.ts
+const ANONYMOUS_ERROR_CODES = defineErrorCodes({
+	INVALID_EMAIL_FORMAT: "Email was not generated in a valid format",
+	FAILED_TO_CREATE_USER: "Failed to create user",
+	COULD_NOT_CREATE_SESSION: "Could not create session",
+	ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY: "Anonymous users cannot sign in again anonymously"
+});
+
+//#endregion
+//#region src/plugins/anonymous/schema.ts
+const schema = { user: { fields: { isAnonymous: {
+	type: "boolean",
+	required: false,
+	input: false,
+	defaultValue: false
+} } } };
+
+//#endregion
+//#region src/plugins/anonymous/index.ts
+async function getAnonUserEmail(options) {
+	const customEmail = await options?.generateRandomEmail?.();
+	if (customEmail) {
+		if (!z.string().email().safeParse(customEmail).success) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.INVALID_EMAIL_FORMAT });
+		return customEmail;
+	}
+	const id = generateId();
+	if (options?.emailDomainName) return `temp-${id}@${options.emailDomainName}`;
+	return `temp@${id}.com`;
+}
+const anonymous = (options) => {
+	return {
+		id: "anonymous",
+		endpoints: { signInAnonymous: createAuthEndpoint("/sign-in/anonymous", {
+			method: "POST",
+			metadata: { openapi: {
+				description: "Sign in anonymously",
+				responses: { 200: {
+					description: "Sign in anonymously",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: {
+							user: { $ref: "#/components/schemas/User" },
+							session: { $ref: "#/components/schemas/Session" }
+						}
+					} } }
+				} }
+			} }
+		}, async (ctx) => {
+			if ((await getSessionFromCtx(ctx, { disableRefresh: true }))?.user.isAnonymous) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY });
+			const email = await getAnonUserEmail(options);
+			const name = await options?.generateName?.(ctx) || "Anonymous";
+			const newUser = await ctx.context.internalAdapter.createUser({
+				email,
+				emailVerified: false,
+				isAnonymous: true,
+				name,
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date()
+			});
+			if (!newUser) throw ctx.error("INTERNAL_SERVER_ERROR", { message: ANONYMOUS_ERROR_CODES.FAILED_TO_CREATE_USER });
+			const session = await ctx.context.internalAdapter.createSession(newUser.id);
+			if (!session) return ctx.json(null, {
+				status: 400,
+				body: { message: ANONYMOUS_ERROR_CODES.COULD_NOT_CREATE_SESSION }
+			});
+			await setSessionCookie(ctx, {
+				session,
+				user: newUser
+			});
+			return ctx.json({
+				token: session.token,
+				user: {
+					id: newUser.id,
+					email: newUser.email,
+					emailVerified: newUser.emailVerified,
+					name: newUser.name,
+					createdAt: newUser.createdAt,
+					updatedAt: newUser.updatedAt
+				}
+			});
+		}) },
+		hooks: { after: [{
+			matcher(ctx) {
+				return ctx.path.startsWith("/sign-in") || ctx.path.startsWith("/sign-up") || ctx.path.startsWith("/callback") || ctx.path.startsWith("/oauth2/callback") || ctx.path.startsWith("/magic-link/verify") || ctx.path.startsWith("/email-otp/verify-email") || ctx.path.startsWith("/one-tap/callback") || ctx.path.startsWith("/passkey/verify-authentication") || ctx.path.startsWith("/phone-number/verify");
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const setCookie = ctx.context.responseHeaders?.get("set-cookie");
+				/**
+				* We can consider the user is about to sign in or sign up
+				* if the response contains a session token.
+				*/
+				const sessionTokenName = ctx.context.authCookies.sessionToken.name;
+				if (!parseSetCookieHeader(setCookie || "").get(sessionTokenName)?.value.split(".")[0]) return;
+				/**
+				* Make sure the user had an anonymous session.
+				*/
+				const session = await getSessionFromCtx(ctx, { disableRefresh: true });
+				if (!session || !session.user.isAnonymous) return;
+				if (ctx.path === "/sign-in/anonymous" && !ctx.context.newSession) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY });
+				const newSession = ctx.context.newSession;
+				if (!newSession) return;
+				if (options?.onLinkAccount) await options?.onLinkAccount?.({
+					anonymousUser: session,
+					newUser: newSession,
+					ctx
+				});
+				if (!options?.disableDeleteAnonymousUser) await ctx.context.internalAdapter.deleteUser(session.user.id);
+			})
+		}] },
+		schema: mergeSchema(schema, options?.schema),
+		$ERROR_CODES: ANONYMOUS_ERROR_CODES
+	};
+};
+
+//#endregion
+export { anonymous as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/api-C0IsrmGz.mjs b/node_modules/better-auth/dist/api-C0IsrmGz.mjs
index f0b6e01..235f8ea 100644
--- a/node_modules/better-auth/dist/api-C0IsrmGz.mjs
+++ b/node_modules/better-auth/dist/api-C0IsrmGz.mjs
@@ -455,7 +455,7 @@ const linkSocialAccount = createAuthEndpoint("/link-social", {
 	method: "POST",
 	requireHeaders: true,
 	body: z.object({
-		callbackURL: z.string().meta({ description: "The URL to redirect to after the user has signed in" }).optional(),
+		callbackURL: z.string().optional(),
 		provider: SocialProviderListEnum,
 		idToken: z.object({
 			token: z.string(),
@@ -465,9 +465,9 @@ const linkSocialAccount = createAuthEndpoint("/link-social", {
 			scopes: z.array(z.string()).optional()
 		}).optional(),
 		requestSignUp: z.boolean().optional(),
-		scopes: z.array(z.string()).meta({ description: "Additional scopes to request from the provider" }).optional(),
-		errorCallbackURL: z.string().meta({ description: "The URL to redirect to if there is an error during the link process" }).optional(),
-		disableRedirect: z.boolean().meta({ description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself" }).optional(),
+		scopes: z.array(z.string()).optional(),
+		errorCallbackURL: z.string().optional(),
+		disableRedirect: z.boolean().optional(),
 		additionalData: z.record(z.string(), z.any()).optional()
 	}),
 	use: [sessionMiddleware],
@@ -602,9 +602,9 @@ const unlinkAccount = createAuthEndpoint("/unlink-account", {
 const getAccessToken = createAuthEndpoint("/get-access-token", {
 	method: "POST",
 	body: z.object({
-		providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
-		accountId: z.string().meta({ description: "The account ID associated with the refresh token" }).optional(),
-		userId: z.string().meta({ description: "The user ID associated with the account" }).optional()
+		providerId: z.string(),
+		accountId: z.string().optional(),
+		userId: z.string().optional()
 	}),
 	metadata: { openapi: {
 		description: "Get a valid access token, doing a refresh if needed",
@@ -674,9 +674,9 @@ const getAccessToken = createAuthEndpoint("/get-access-token", {
 const refreshToken = createAuthEndpoint("/refresh-token", {
 	method: "POST",
 	body: z.object({
-		providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
-		accountId: z.string().meta({ description: "The account ID associated with the refresh token" }).optional(),
-		userId: z.string().meta({ description: "The user ID associated with the account" }).optional()
+		providerId: z.string(),
+		accountId: z.string().optional(),
+		userId: z.string().optional()
 	}),
 	metadata: { openapi: {
 		description: "Refresh the access token using a refresh token",
@@ -764,7 +764,7 @@ const accountInfo = createAuthEndpoint("/account-info", {
 			} } }
 		} }
 	} },
-	body: z.object({ accountId: z.string().meta({ description: "The provider given account id for which to get the account info" }) })
+	body: z.object({ accountId: z.string() })
 }, async (ctx) => {
 	const account = await ctx.context.internalAdapter.findAccount(ctx.body.accountId);
 	if (!account || account.userId !== ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: "Account not found" });
@@ -1103,8 +1103,8 @@ const sendVerificationEmail = createAuthEndpoint("/send-verification-email", {
 	method: "POST",
 	operationId: "sendVerificationEmail",
 	body: z.object({
-		email: z.email().meta({ description: "The email to send the verification email to" }),
-		callbackURL: z.string().meta({ description: "The URL to use for email verification callback" }).optional()
+		email: z.string().email(),
+		callbackURL: z.string().optional()
 	}),
 	metadata: { openapi: {
 		operationId: "sendVerificationEmail",
@@ -1173,8 +1173,8 @@ const verifyEmail = createAuthEndpoint("/verify-email", {
 	method: "GET",
 	operationId: "verifyEmail",
 	query: z.object({
-		token: z.string().meta({ description: "The token to verify the email" }),
-		callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
+		token: z.string(),
+		callbackURL: z.string().optional()
 	}),
 	use: [originCheck((ctx) => ctx.query.callbackURL)],
 	metadata: { openapi: {
@@ -1227,7 +1227,7 @@ const verifyEmail = createAuthEndpoint("/verify-email", {
 		return redirectOnError("invalid_token");
 	}
 	const parsed = z.object({
-		email: z.email(),
+		email: z.string().email(),
 		updateTo: z.string().optional()
 	}).parse(jwt.payload);
 	const user = await ctx.context.internalAdapter.findUserByEmail(parsed.email);
@@ -1726,8 +1726,8 @@ const requestPasswordReset = createAuthEndpoint("/request-password-reset", {
 	method: "POST",
 	operationId: "forgetPassword",
 	body: z.object({
-		email: z.email().meta({ description: "The email address of the user to send a password reset email to" }),
-		redirectTo: z.string().meta({ description: "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN" }).optional()
+		email: z.string().email(),
+		redirectTo: z.string().optional()
 	}),
 	metadata: { openapi: {
 		operationId: "forgetPassword",
@@ -1779,7 +1779,7 @@ const requestPasswordReset = createAuthEndpoint("/request-password-reset", {
 const requestPasswordResetCallback = createAuthEndpoint("/reset-password/:token", {
 	method: "GET",
 	operationId: "forgetPasswordCallback",
-	query: z.object({ callbackURL: z.string().meta({ description: "The URL to redirect the user to reset their password" }) }),
+	query: z.object({ callbackURL: z.string() }),
 	use: [originCheck((ctx) => ctx.query.callbackURL)],
 	metadata: { openapi: {
 		operationId: "resetPasswordCallback",
@@ -1818,8 +1818,8 @@ const resetPassword = createAuthEndpoint("/reset-password", {
 	operationId: "resetPassword",
 	query: z.object({ token: z.string().optional() }).optional(),
 	body: z.object({
-		newPassword: z.string().meta({ description: "The new password to set" }),
-		token: z.string().meta({ description: "The token to reset the password" }).optional()
+		newPassword: z.string(),
+		token: z.string().optional()
 	}),
 	metadata: { openapi: {
 		operationId: "resetPassword",
@@ -1867,22 +1867,22 @@ const signInSocial = createAuthEndpoint("/sign-in/social", {
 	method: "POST",
 	operationId: "socialSignIn",
 	body: z.object({
-		callbackURL: z.string().meta({ description: "Callback URL to redirect to after the user has signed in" }).optional(),
+		callbackURL: z.string().optional(),
 		newUserCallbackURL: z.string().optional(),
-		errorCallbackURL: z.string().meta({ description: "Callback URL to redirect to if an error happens" }).optional(),
+		errorCallbackURL: z.string().optional(),
 		provider: SocialProviderListEnum,
-		disableRedirect: z.boolean().meta({ description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself" }).optional(),
+		disableRedirect: z.boolean().optional(),
 		idToken: z.optional(z.object({
-			token: z.string().meta({ description: "ID token from the provider" }),
-			nonce: z.string().meta({ description: "Nonce used to generate the token" }).optional(),
-			accessToken: z.string().meta({ description: "Access token from the provider" }).optional(),
-			refreshToken: z.string().meta({ description: "Refresh token from the provider" }).optional(),
-			expiresAt: z.number().meta({ description: "Expiry date of the token" }).optional()
+			token: z.string(),
+			nonce: z.string().optional(),
+			accessToken: z.string().optional(),
+			refreshToken: z.string().optional(),
+			expiresAt: z.number().optional()
 		})),
-		scopes: z.array(z.string()).meta({ description: "Array of scopes to request from the provider. This will override the default scopes passed." }).optional(),
-		requestSignUp: z.boolean().meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider" }).optional(),
-		loginHint: z.string().meta({ description: "The login hint to use for the authorization code request" }).optional(),
-		additionalData: z.record(z.string(), z.any()).optional().meta({ description: "Additional data to be passed through the OAuth flow" })
+		scopes: z.array(z.string()).optional(),
+		requestSignUp: z.boolean().optional(),
+		loginHint: z.string().optional(),
+		additionalData: z.record(z.string(), z.any()).optional()
 	}),
 	metadata: { openapi: {
 		description: "Sign in with a social provider",
@@ -1992,10 +1992,10 @@ const signInEmail = createAuthEndpoint("/sign-in/email", {
 	method: "POST",
 	operationId: "signInEmail",
 	body: z.object({
-		email: z.string().meta({ description: "Email of the user" }),
-		password: z.string().meta({ description: "Password of the user" }),
-		callbackURL: z.string().meta({ description: "Callback URL to use as a redirect for email verification" }).optional(),
-		rememberMe: z.boolean().meta({ description: "If this is false, the session will not be remembered. Default is `true`." }).default(true).optional()
+		email: z.string(),
+		password: z.string(),
+		callbackURL: z.string().optional(),
+		rememberMe: z.boolean().default(true).optional()
 	}),
 	metadata: { openapi: {
 		operationId: "signInEmail",
@@ -2037,7 +2037,7 @@ const signInEmail = createAuthEndpoint("/sign-in/email", {
 		throw new APIError("BAD_REQUEST", { message: "Email and password is not enabled" });
 	}
 	const { email, password } = ctx.body;
-	if (!z.email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+	if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
 	const user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });
 	if (!user) {
 		await ctx.context.password.hash(password);
@@ -2249,7 +2249,7 @@ const signUpEmail = () => createAuthEndpoint("/sign-up/email", {
 		if (!ctx.context.options.emailAndPassword?.enabled || ctx.context.options.emailAndPassword?.disableSignUp) throw new APIError("BAD_REQUEST", { message: "Email and password sign up is not enabled" });
 		const body = ctx.body;
 		const { name, email, password, image, callbackURL, rememberMe,...rest } = body;
-		if (!z.email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+		if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
 		const minPasswordLength = ctx.context.password.config.minPasswordLength;
 		if (password.length < minPasswordLength) {
 			ctx.context.logger.error("Password is too short");
@@ -2353,7 +2353,7 @@ const signUpEmail = () => createAuthEndpoint("/sign-up/email", {
 const updateUser = () => createAuthEndpoint("/update-user", {
 	method: "POST",
 	operationId: "updateUser",
-	body: z.record(z.string().meta({ description: "Field name must be a string" }), z.any()),
+	body: z.record(z.string(), z.any()),
 	use: [sessionMiddleware],
 	metadata: {
 		$Infer: { body: {} },
@@ -2410,9 +2410,9 @@ const changePassword = createAuthEndpoint("/change-password", {
 	method: "POST",
 	operationId: "changePassword",
 	body: z.object({
-		newPassword: z.string().meta({ description: "The new password to set" }),
-		currentPassword: z.string().meta({ description: "The current password is required" }),
-		revokeOtherSessions: z.boolean().meta({ description: "Must be a boolean value" }).optional()
+		newPassword: z.string(),
+		currentPassword: z.string(),
+		revokeOtherSessions: z.boolean().optional()
 	}),
 	use: [sensitiveSessionMiddleware],
 	metadata: { openapi: {
@@ -2526,7 +2526,7 @@ const changePassword = createAuthEndpoint("/change-password", {
 });
 const setPassword = createAuthEndpoint("/set-password", {
 	method: "POST",
-	body: z.object({ newPassword: z.string().meta({ description: "The new password to set is required" }) }),
+	body: z.object({ newPassword: z.string() }),
 	metadata: { SERVER_ONLY: true },
 	use: [sensitiveSessionMiddleware]
 }, async (ctx) => {
@@ -2559,9 +2559,9 @@ const deleteUser = createAuthEndpoint("/delete-user", {
 	method: "POST",
 	use: [sensitiveSessionMiddleware],
 	body: z.object({
-		callbackURL: z.string().meta({ description: "The callback URL to redirect to after the user is deleted" }).optional(),
-		password: z.string().meta({ description: "The password of the user is required to delete the user" }).optional(),
-		token: z.string().meta({ description: "The token to delete the user is required" }).optional()
+		callbackURL: z.string().optional(),
+		password: z.string().optional(),
+		token: z.string().optional()
 	}),
 	metadata: { openapi: {
 		operationId: "deleteUser",
@@ -2664,8 +2664,8 @@ const deleteUser = createAuthEndpoint("/delete-user", {
 const deleteUserCallback = createAuthEndpoint("/delete-user/callback", {
 	method: "GET",
 	query: z.object({
-		token: z.string().meta({ description: "The token to verify the deletion request" }),
-		callbackURL: z.string().meta({ description: "The URL to redirect to after deletion" }).optional()
+		token: z.string(),
+		callbackURL: z.string().optional()
 	}),
 	use: [originCheck((ctx) => ctx.query.callbackURL)],
 	metadata: { openapi: {
@@ -2717,8 +2717,8 @@ const deleteUserCallback = createAuthEndpoint("/delete-user/callback", {
 const changeEmail = createAuthEndpoint("/change-email", {
 	method: "POST",
 	body: z.object({
-		newEmail: z.email().meta({ description: "The new email address to set must be a valid email address" }),
-		callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
+		newEmail: z.string().email(),
+		callbackURL: z.string().optional()
 	}),
 	use: [sensitiveSessionMiddleware],
 	metadata: { openapi: {
diff --git a/node_modules/better-auth/dist/api-C0IsrmGz.mjs.bak b/node_modules/better-auth/dist/api-C0IsrmGz.mjs.bak
new file mode 100644
index 0000000..ec8db6b
--- /dev/null
+++ b/node_modules/better-auth/dist/api-C0IsrmGz.mjs.bak
@@ -0,0 +1,3165 @@
+import { i as parseState, n as HIDE_METADATA, r as generateState, t as generateId } from "./utils-F62c-ieM.mjs";
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { t as signJWT } from "./jwt-CmxZAGe2.mjs";
+import { c as parseUserInput, u as getDate } from "./schema-BevzneML.mjs";
+import { t as getIp } from "./get-request-ip-kbu825ez.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { i as getProtocol, n as getHost, r as getOrigin } from "./url-SXU3XD3W.mjs";
+import { c as setSessionCookie, n as deleteSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { c as revokeSessions, i as listSessions, l as sensitiveSessionMiddleware, n as getSession, o as revokeOtherSessions, r as getSessionFromCtx, s as revokeSession, t as freshSessionMiddleware, u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { hasRequestState, runWithEndpointContext, runWithRequestState, runWithTransaction } from "@better-auth/core/context";
+import { isDevelopment, isProduction, logger, shouldPublishLog } from "@better-auth/core/env";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { APIError, APIError as APIError$1, createRouter, toResponse } from "better-call";
+import * as z from "zod";
+import { jwtVerify } from "jose";
+import { SocialProviderListEnum } from "@better-auth/core/social-providers";
+import { createDefu } from "defu";
+import { createAuthEndpoint, createAuthEndpoint as createAuthEndpoint$1, createAuthMiddleware, createAuthMiddleware as createAuthMiddleware$1, optionsMiddleware } from "@better-auth/core/api";
+import { JWTExpired } from "jose/errors";
+
+//#region src/utils/wildcard.ts
+/**
+* Escapes a character if it has a special meaning in regular expressions
+* and returns the character as is if it doesn't
+*/
+function escapeRegExpChar(char) {
+	if (char === "-" || char === "^" || char === "$" || char === "+" || char === "." || char === "(" || char === ")" || char === "|" || char === "[" || char === "]" || char === "{" || char === "}" || char === "*" || char === "?" || char === "\\") return `\\${char}`;
+	else return char;
+}
+/**
+* Escapes all characters in a given string that have a special meaning in regular expressions
+*/
+function escapeRegExpString(str) {
+	let result = "";
+	for (let i = 0; i < str.length; i++) result += escapeRegExpChar(str[i]);
+	return result;
+}
+/**
+* Transforms one or more glob patterns into a RegExp pattern
+*/
+function transform(pattern, separator = true) {
+	if (Array.isArray(pattern)) return `(?:${pattern.map((p) => `^${transform(p, separator)}$`).join("|")})`;
+	let separatorSplitter = "";
+	let separatorMatcher = "";
+	let wildcard = ".";
+	if (separator === true) {
+		separatorSplitter = "/";
+		separatorMatcher = "[/\\\\]";
+		wildcard = "[^/\\\\]";
+	} else if (separator) {
+		separatorSplitter = separator;
+		separatorMatcher = escapeRegExpString(separatorSplitter);
+		if (separatorMatcher.length > 1) {
+			separatorMatcher = `(?:${separatorMatcher})`;
+			wildcard = `((?!${separatorMatcher}).)`;
+		} else wildcard = `[^${separatorMatcher}]`;
+	}
+	let requiredSeparator = separator ? `${separatorMatcher}+?` : "";
+	let optionalSeparator = separator ? `${separatorMatcher}*?` : "";
+	let segments = separator ? pattern.split(separatorSplitter) : [pattern];
+	let result = "";
+	for (let s = 0; s < segments.length; s++) {
+		let segment = segments[s];
+		let nextSegment = segments[s + 1];
+		let currentSeparator = "";
+		if (!segment && s > 0) continue;
+		if (separator) if (s === segments.length - 1) currentSeparator = optionalSeparator;
+		else if (nextSegment !== "**") currentSeparator = requiredSeparator;
+		else currentSeparator = "";
+		if (separator && segment === "**") {
+			if (currentSeparator) {
+				result += s === 0 ? "" : currentSeparator;
+				result += `(?:${wildcard}*?${currentSeparator})*?`;
+			}
+			continue;
+		}
+		for (let c = 0; c < segment.length; c++) {
+			let char = segment[c];
+			if (char === "\\") {
+				if (c < segment.length - 1) {
+					result += escapeRegExpChar(segment[c + 1]);
+					c++;
+				}
+			} else if (char === "?") result += wildcard;
+			else if (char === "*") result += `${wildcard}*?`;
+			else result += escapeRegExpChar(char);
+		}
+		result += currentSeparator;
+	}
+	return result;
+}
+function isMatch(regexp, sample) {
+	if (typeof sample !== "string") throw new TypeError(`Sample must be a string, but ${typeof sample} given`);
+	return regexp.test(sample);
+}
+/**
+* Compiles one or more glob patterns into a RegExp and returns an isMatch function.
+* The isMatch function takes a sample string as its only argument and returns `true`
+* if the string matches the pattern(s).
+*
+* ```js
+* wildcardMatch('src/*.js')('src/index.js') //=> true
+* ```
+*
+* ```js
+* const isMatch = wildcardMatch('*.example.com', '.')
+* isMatch('foo.example.com') //=> true
+* isMatch('foo.bar.com') //=> false
+* ```
+*/
+function wildcardMatch(pattern, options) {
+	if (typeof pattern !== "string" && !Array.isArray(pattern)) throw new TypeError(`The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`);
+	if (typeof options === "string" || typeof options === "boolean") options = { separator: options };
+	if (arguments.length === 2 && !(typeof options === "undefined" || typeof options === "object" && options !== null && !Array.isArray(options))) throw new TypeError(`The second argument must be an options object or a string/boolean separator, but ${typeof options} given`);
+	options = options || {};
+	if (options.separator === "\\") throw new Error("\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead");
+	let regexpPattern = transform(pattern, options.separator);
+	let regexp = new RegExp(`^${regexpPattern}$`, options.flags);
+	let fn = isMatch.bind(null, regexp);
+	fn.options = options;
+	fn.pattern = pattern;
+	fn.regexp = regexp;
+	return fn;
+}
+
+//#endregion
+//#region src/api/middlewares/origin-check.ts
+/**
+* A middleware to validate callbackURL and origin against
+* trustedOrigins.
+*/
+const originCheckMiddleware = createAuthMiddleware(async (ctx) => {
+	if (ctx.request?.method === "GET" || ctx.request?.method === "OPTIONS" || ctx.request?.method === "HEAD" || !ctx.request) return;
+	const headers = ctx.request?.headers;
+	const request = ctx.request;
+	const { body, query, context } = ctx;
+	/**
+	* We only allow requests with the x-auth-request header set to
+	* true or application/json content type. This is to prevent
+	* simple requests from being processed
+	*/
+	if (isSimpleRequest(headers) && !ctx.context.skipCSRFCheck) throw new APIError("FORBIDDEN", { message: "Invalid request" });
+	const originHeader = headers?.get("origin") || headers?.get("referer") || "";
+	const callbackURL = body?.callbackURL || query?.callbackURL;
+	const redirectURL = body?.redirectTo;
+	const errorCallbackURL = body?.errorCallbackURL;
+	const newUserCallbackURL = body?.newUserCallbackURL;
+	const trustedOrigins = Array.isArray(context.options.trustedOrigins) ? context.trustedOrigins : [...context.trustedOrigins, ...await context.options.trustedOrigins?.(request) || []];
+	const useCookies = headers?.has("cookie");
+	const matchesPattern = (url, pattern) => {
+		if (url.startsWith("/")) return false;
+		if (pattern.includes("*")) {
+			if (pattern.includes("://")) return wildcardMatch(pattern)(getOrigin(url) || url);
+			const host = getHost(url);
+			if (!host) return false;
+			return wildcardMatch(pattern)(host);
+		}
+		const protocol = getProtocol(url);
+		return protocol === "http:" || protocol === "https:" || !protocol ? pattern === getOrigin(url) : url.startsWith(pattern);
+	};
+	const validateURL = (url, label) => {
+		if (!url) return;
+		if (!trustedOrigins.some((origin) => matchesPattern(url, origin) || url?.startsWith("/") && label !== "origin" && /^\/(?!\/|\\|%2f|%5c)[\w\-.\+/@]*(?:\?[\w\-.\+/=&%@]*)?$/.test(url))) {
+			ctx.context.logger.error(`Invalid ${label}: ${url}`);
+			ctx.context.logger.info(`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\n`, `Current list of trustedOrigins: ${trustedOrigins}`);
+			throw new APIError("FORBIDDEN", { message: `Invalid ${label}` });
+		}
+	};
+	if (useCookies && !ctx.context.skipCSRFCheck && !ctx.context.skipOriginCheck) {
+		if (!originHeader || originHeader === "null") throw new APIError("FORBIDDEN", { message: "Missing or null Origin" });
+		validateURL(originHeader, "origin");
+	}
+	callbackURL && validateURL(callbackURL, "callbackURL");
+	redirectURL && validateURL(redirectURL, "redirectURL");
+	errorCallbackURL && validateURL(errorCallbackURL, "errorCallbackURL");
+	newUserCallbackURL && validateURL(newUserCallbackURL, "newUserCallbackURL");
+});
+const originCheck = (getValue) => createAuthMiddleware(async (ctx) => {
+	if (!ctx.request) return;
+	const { context } = ctx;
+	const callbackURL = getValue(ctx);
+	const trustedOrigins = Array.isArray(context.options.trustedOrigins) ? context.trustedOrigins : [...context.trustedOrigins, ...await context.options.trustedOrigins?.(ctx.request) || []];
+	const matchesPattern = (url, pattern) => {
+		if (url.startsWith("/")) return false;
+		if (pattern.includes("*")) {
+			if (pattern.includes("://")) return wildcardMatch(pattern)(getOrigin(url) || url);
+			const host = getHost(url);
+			if (!host) return false;
+			return wildcardMatch(pattern)(host);
+		}
+		const protocol = getProtocol(url);
+		return protocol === "http:" || protocol === "https:" || !protocol ? pattern === getOrigin(url) : url.startsWith(pattern);
+	};
+	const validateURL = (url, label) => {
+		if (!url) return;
+		if (!trustedOrigins.some((origin) => matchesPattern(url, origin) || url?.startsWith("/") && label !== "origin" && /^\/(?!\/|\\|%2f|%5c)[\w\-.\+/@]*(?:\?[\w\-.\+/=&%@]*)?$/.test(url))) {
+			ctx.context.logger.error(`Invalid ${label}: ${url}`);
+			ctx.context.logger.info(`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\n`, `Current list of trustedOrigins: ${trustedOrigins}`);
+			throw new APIError("FORBIDDEN", { message: `Invalid ${label}` });
+		}
+	};
+	const callbacks = Array.isArray(callbackURL) ? callbackURL : [callbackURL];
+	for (const url of callbacks) validateURL(url, "callbackURL");
+});
+function isSimpleRequest(headers) {
+	const SIMPLE_HEADERS = [
+		"accept",
+		"accept-language",
+		"content-language",
+		"content-type"
+	];
+	const SIMPLE_CONTENT_TYPES = [
+		"application/x-www-form-urlencoded",
+		"multipart/form-data",
+		"text/plain"
+	];
+	for (const [key, value] of headers.entries()) {
+		if (!SIMPLE_HEADERS.includes(key.toLowerCase())) return false;
+		if (key.toLowerCase() === "content-type" && !SIMPLE_CONTENT_TYPES.includes(value?.split(";")[0]?.trim()?.toLowerCase() || "")) return false;
+	}
+	return true;
+}
+
+//#endregion
+//#region src/api/rate-limiter/index.ts
+function shouldRateLimit(max, window, rateLimitData) {
+	const now = Date.now();
+	const windowInMs = window * 1e3;
+	return now - rateLimitData.lastRequest < windowInMs && rateLimitData.count >= max;
+}
+function rateLimitResponse(retryAfter) {
+	return new Response(JSON.stringify({ message: "Too many requests. Please try again later." }), {
+		status: 429,
+		statusText: "Too Many Requests",
+		headers: { "X-Retry-After": retryAfter.toString() }
+	});
+}
+function getRetryAfter(lastRequest, window) {
+	const now = Date.now();
+	const windowInMs = window * 1e3;
+	return Math.ceil((lastRequest + windowInMs - now) / 1e3);
+}
+function createDBStorage(ctx) {
+	const model = "rateLimit";
+	const db = ctx.adapter;
+	return {
+		get: async (key) => {
+			const data = (await db.findMany({
+				model,
+				where: [{
+					field: "key",
+					value: key
+				}]
+			}))[0];
+			if (typeof data?.lastRequest === "bigint") data.lastRequest = Number(data.lastRequest);
+			return data;
+		},
+		set: async (key, value, _update) => {
+			try {
+				if (_update) await db.updateMany({
+					model,
+					where: [{
+						field: "key",
+						value: key
+					}],
+					update: {
+						count: value.count,
+						lastRequest: value.lastRequest
+					}
+				});
+				else await db.create({
+					model,
+					data: {
+						key,
+						count: value.count,
+						lastRequest: value.lastRequest
+					}
+				});
+			} catch (e) {
+				ctx.logger.error("Error setting rate limit", e);
+			}
+		}
+	};
+}
+const memory = /* @__PURE__ */ new Map();
+function getRateLimitStorage(ctx, rateLimitSettings) {
+	if (ctx.options.rateLimit?.customStorage) return ctx.options.rateLimit.customStorage;
+	const storage = ctx.rateLimit.storage;
+	if (storage === "secondary-storage") return {
+		get: async (key) => {
+			const data = await ctx.options.secondaryStorage?.get(key);
+			return data ? safeJSONParse(data) : void 0;
+		},
+		set: async (key, value, _update) => {
+			const ttl = rateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;
+			await ctx.options.secondaryStorage?.set?.(key, JSON.stringify(value), ttl);
+		}
+	};
+	else if (storage === "memory") return {
+		async get(key) {
+			return memory.get(key);
+		},
+		async set(key, value, _update) {
+			memory.set(key, value);
+		}
+	};
+	return createDBStorage(ctx);
+}
+async function onRequestRateLimit(req, ctx) {
+	if (!ctx.rateLimit.enabled) return;
+	const path = new URL(req.url).pathname.replace(ctx.options.basePath || "/api/auth", "");
+	let window = ctx.rateLimit.window;
+	let max = ctx.rateLimit.max;
+	const ip = getIp(req, ctx.options);
+	if (!ip) return;
+	const key = ip + path;
+	const specialRule = getDefaultSpecialRules().find((rule) => rule.pathMatcher(path));
+	if (specialRule) {
+		window = specialRule.window;
+		max = specialRule.max;
+	}
+	for (const plugin of ctx.options.plugins || []) if (plugin.rateLimit) {
+		const matchedRule = plugin.rateLimit.find((rule) => rule.pathMatcher(path));
+		if (matchedRule) {
+			window = matchedRule.window;
+			max = matchedRule.max;
+			break;
+		}
+	}
+	if (ctx.rateLimit.customRules) {
+		const _path = Object.keys(ctx.rateLimit.customRules).find((p) => {
+			if (p.includes("*")) return wildcardMatch(p)(path);
+			return p === path;
+		});
+		if (_path) {
+			const customRule = ctx.rateLimit.customRules[_path];
+			const resolved = typeof customRule === "function" ? await customRule(req) : customRule;
+			if (resolved) {
+				window = resolved.window;
+				max = resolved.max;
+			}
+			if (resolved === false) return;
+		}
+	}
+	const storage = getRateLimitStorage(ctx, { window });
+	const data = await storage.get(key);
+	const now = Date.now();
+	if (!data) await storage.set(key, {
+		key,
+		count: 1,
+		lastRequest: now
+	});
+	else {
+		const timeSinceLastRequest = now - data.lastRequest;
+		if (shouldRateLimit(max, window, data)) return rateLimitResponse(getRetryAfter(data.lastRequest, window));
+		else if (timeSinceLastRequest > window * 1e3) await storage.set(key, {
+			...data,
+			count: 1,
+			lastRequest: now
+		}, true);
+		else await storage.set(key, {
+			...data,
+			count: data.count + 1,
+			lastRequest: now
+		}, true);
+	}
+}
+function getDefaultSpecialRules() {
+	return [{
+		pathMatcher(path) {
+			return path.startsWith("/sign-in") || path.startsWith("/sign-up") || path.startsWith("/change-password") || path.startsWith("/change-email");
+		},
+		window: 10,
+		max: 3
+	}];
+}
+
+//#endregion
+//#region src/oauth2/utils.ts
+function decryptOAuthToken(token, ctx) {
+	if (!token) return token;
+	if (ctx.options.account?.encryptOAuthTokens) return symmetricDecrypt({
+		key: ctx.secret,
+		data: token
+	});
+	return token;
+}
+function setTokenUtil(token, ctx) {
+	if (ctx.options.account?.encryptOAuthTokens && token) return symmetricEncrypt({
+		key: ctx.secret,
+		data: token
+	});
+	return token;
+}
+
+//#endregion
+//#region src/api/routes/account.ts
+const listUserAccounts = createAuthEndpoint("/list-accounts", {
+	method: "GET",
+	use: [sessionMiddleware],
+	metadata: { openapi: {
+		operationId: "listUserAccounts",
+		description: "List all accounts linked to the user",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "array",
+				items: {
+					type: "object",
+					properties: {
+						id: { type: "string" },
+						providerId: { type: "string" },
+						createdAt: {
+							type: "string",
+							format: "date-time"
+						},
+						updatedAt: {
+							type: "string",
+							format: "date-time"
+						},
+						accountId: { type: "string" },
+						userId: { type: "string" },
+						scopes: {
+							type: "array",
+							items: { type: "string" }
+						}
+					},
+					required: [
+						"id",
+						"providerId",
+						"createdAt",
+						"updatedAt",
+						"accountId",
+						"userId",
+						"scopes"
+					]
+				}
+			} } }
+		} }
+	} }
+}, async (c) => {
+	const session = c.context.session;
+	const accounts = await c.context.internalAdapter.findAccounts(session.user.id);
+	return c.json(accounts.map((a) => ({
+		id: a.id,
+		providerId: a.providerId,
+		createdAt: a.createdAt,
+		updatedAt: a.updatedAt,
+		accountId: a.accountId,
+		userId: a.userId,
+		scopes: a.scope?.split(",") || []
+	})));
+});
+const linkSocialAccount = createAuthEndpoint("/link-social", {
+	method: "POST",
+	requireHeaders: true,
+	body: z.object({
+		callbackURL: z.string().meta({ description: "The URL to redirect to after the user has signed in" }).optional(),
+		provider: SocialProviderListEnum,
+		idToken: z.object({
+			token: z.string(),
+			nonce: z.string().optional(),
+			accessToken: z.string().optional(),
+			refreshToken: z.string().optional(),
+			scopes: z.array(z.string()).optional()
+		}).optional(),
+		requestSignUp: z.boolean().optional(),
+		scopes: z.array(z.string()).meta({ description: "Additional scopes to request from the provider" }).optional(),
+		errorCallbackURL: z.string().meta({ description: "The URL to redirect to if there is an error during the link process" }).optional(),
+		disableRedirect: z.boolean().meta({ description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself" }).optional(),
+		additionalData: z.record(z.string(), z.any()).optional()
+	}),
+	use: [sessionMiddleware],
+	metadata: { openapi: {
+		description: "Link a social account to the user",
+		operationId: "linkSocialAccount",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					url: {
+						type: "string",
+						description: "The authorization URL to redirect the user to"
+					},
+					redirect: {
+						type: "boolean",
+						description: "Indicates if the user should be redirected to the authorization URL"
+					},
+					status: { type: "boolean" }
+				},
+				required: ["redirect"]
+			} } }
+		} }
+	} }
+}, async (c) => {
+	const session = c.context.session;
+	const provider = c.context.socialProviders.find((p) => p.id === c.body.provider);
+	if (!provider) {
+		c.context.logger.error("Provider not found. Make sure to add the provider in your auth config", { provider: c.body.provider });
+		throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });
+	}
+	if (c.body.idToken) {
+		if (!provider.verifyIdToken) {
+			c.context.logger.error("Provider does not support id token verification", { provider: c.body.provider });
+			throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED });
+		}
+		const { token, nonce } = c.body.idToken;
+		if (!await provider.verifyIdToken(token, nonce)) {
+			c.context.logger.error("Invalid id token", { provider: c.body.provider });
+			throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_TOKEN });
+		}
+		const linkingUserInfo = await provider.getUserInfo({
+			idToken: token,
+			accessToken: c.body.idToken.accessToken,
+			refreshToken: c.body.idToken.refreshToken
+		});
+		if (!linkingUserInfo || !linkingUserInfo?.user) {
+			c.context.logger.error("Failed to get user info", { provider: c.body.provider });
+			throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });
+		}
+		const linkingUserId = String(linkingUserInfo.user.id);
+		if (!linkingUserInfo.user.email) {
+			c.context.logger.error("User email not found", { provider: c.body.provider });
+			throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND });
+		}
+		if ((await c.context.internalAdapter.findAccounts(session.user.id)).find((a) => a.providerId === provider.id && a.accountId === linkingUserId)) return c.json({
+			url: "",
+			status: true,
+			redirect: false
+		});
+		if (!(c.context.options.account?.accountLinking?.trustedProviders)?.includes(provider.id) && !linkingUserInfo.user.emailVerified || c.context.options.account?.accountLinking?.enabled === false) throw new APIError("UNAUTHORIZED", { message: "Account not linked - linking not allowed" });
+		if (linkingUserInfo.user.email !== session.user.email && c.context.options.account?.accountLinking?.allowDifferentEmails !== true) throw new APIError("UNAUTHORIZED", { message: "Account not linked - different emails not allowed" });
+		try {
+			await c.context.internalAdapter.createAccount({
+				userId: session.user.id,
+				providerId: provider.id,
+				accountId: linkingUserId,
+				accessToken: c.body.idToken.accessToken,
+				idToken: token,
+				refreshToken: c.body.idToken.refreshToken,
+				scope: c.body.idToken.scopes?.join(",")
+			});
+		} catch (e) {
+			throw new APIError("EXPECTATION_FAILED", { message: "Account not linked - unable to create account" });
+		}
+		if (c.context.options.account?.accountLinking?.updateUserInfoOnLink === true) try {
+			await c.context.internalAdapter.updateUser(session.user.id, {
+				name: linkingUserInfo.user?.name,
+				image: linkingUserInfo.user?.image
+			});
+		} catch (e) {
+			console.warn("Could not update user - " + e.toString());
+		}
+		return c.json({
+			url: "",
+			status: true,
+			redirect: false
+		});
+	}
+	const state = await generateState(c, {
+		userId: session.user.id,
+		email: session.user.email
+	}, c.body.additionalData);
+	const url = await provider.createAuthorizationURL({
+		state: state.state,
+		codeVerifier: state.codeVerifier,
+		redirectURI: `${c.context.baseURL}/callback/${provider.id}`,
+		scopes: c.body.scopes
+	});
+	return c.json({
+		url: url.toString(),
+		redirect: !c.body.disableRedirect
+	});
+});
+const unlinkAccount = createAuthEndpoint("/unlink-account", {
+	method: "POST",
+	body: z.object({
+		providerId: z.string(),
+		accountId: z.string().optional()
+	}),
+	use: [freshSessionMiddleware],
+	metadata: { openapi: {
+		description: "Unlink an account",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { status: { type: "boolean" } }
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const { providerId, accountId } = ctx.body;
+	const accounts = await ctx.context.internalAdapter.findAccounts(ctx.context.session.user.id);
+	if (accounts.length === 1 && !ctx.context.options.account?.accountLinking?.allowUnlinkingAll) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_UNLINK_LAST_ACCOUNT });
+	const accountExist = accounts.find((account) => accountId ? account.accountId === accountId && account.providerId === providerId : account.providerId === providerId);
+	if (!accountExist) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.ACCOUNT_NOT_FOUND });
+	await ctx.context.internalAdapter.deleteAccount(accountExist.id);
+	return ctx.json({ status: true });
+});
+const getAccessToken = createAuthEndpoint("/get-access-token", {
+	method: "POST",
+	body: z.object({
+		providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
+		accountId: z.string().meta({ description: "The account ID associated with the refresh token" }).optional(),
+		userId: z.string().meta({ description: "The user ID associated with the account" }).optional()
+	}),
+	metadata: { openapi: {
+		description: "Get a valid access token, doing a refresh if needed",
+		responses: {
+			200: {
+				description: "A Valid access token",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						tokenType: { type: "string" },
+						idToken: { type: "string" },
+						accessToken: { type: "string" },
+						refreshToken: { type: "string" },
+						accessTokenExpiresAt: {
+							type: "string",
+							format: "date-time"
+						},
+						refreshTokenExpiresAt: {
+							type: "string",
+							format: "date-time"
+						}
+					}
+				} } }
+			},
+			400: { description: "Invalid refresh token or provider configuration" }
+		}
+	} }
+}, async (ctx) => {
+	const { providerId, accountId, userId } = ctx.body;
+	const req = ctx.request;
+	const session = await getSessionFromCtx(ctx);
+	if (req && !session) throw ctx.error("UNAUTHORIZED");
+	let resolvedUserId = session?.user?.id || userId;
+	if (!resolvedUserId) throw new APIError("BAD_REQUEST", { message: `Either userId or session is required` });
+	if (!ctx.context.socialProviders.find((p) => p.id === providerId)) throw new APIError("BAD_REQUEST", { message: `Provider ${providerId} is not supported.` });
+	const account = (await ctx.context.internalAdapter.findAccounts(resolvedUserId)).find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);
+	if (!account) throw new APIError("BAD_REQUEST", { message: "Account not found" });
+	const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
+	if (!provider) throw new APIError("BAD_REQUEST", { message: `Provider ${providerId} not found.` });
+	try {
+		let newTokens = null;
+		const accessTokenExpired = account.accessTokenExpiresAt && new Date(account.accessTokenExpiresAt).getTime() - Date.now() < 5e3;
+		if (account.refreshToken && accessTokenExpired && provider.refreshAccessToken) {
+			const refreshToken$1 = await decryptOAuthToken(account.refreshToken, ctx.context);
+			newTokens = await provider.refreshAccessToken(refreshToken$1);
+			await ctx.context.internalAdapter.updateAccount(account.id, {
+				accessToken: await setTokenUtil(newTokens.accessToken, ctx.context),
+				accessTokenExpiresAt: newTokens.accessTokenExpiresAt,
+				refreshToken: await setTokenUtil(newTokens.refreshToken, ctx.context),
+				refreshTokenExpiresAt: newTokens.refreshTokenExpiresAt
+			});
+		}
+		const tokens = {
+			accessToken: newTokens?.accessToken ?? await decryptOAuthToken(account.accessToken ?? "", ctx.context),
+			accessTokenExpiresAt: newTokens?.accessTokenExpiresAt ?? account.accessTokenExpiresAt ?? void 0,
+			scopes: account.scope?.split(",") ?? [],
+			idToken: newTokens?.idToken ?? account.idToken ?? void 0
+		};
+		return ctx.json(tokens);
+	} catch (error$1) {
+		throw new APIError("BAD_REQUEST", {
+			message: "Failed to get a valid access token",
+			cause: error$1
+		});
+	}
+});
+const refreshToken = createAuthEndpoint("/refresh-token", {
+	method: "POST",
+	body: z.object({
+		providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
+		accountId: z.string().meta({ description: "The account ID associated with the refresh token" }).optional(),
+		userId: z.string().meta({ description: "The user ID associated with the account" }).optional()
+	}),
+	metadata: { openapi: {
+		description: "Refresh the access token using a refresh token",
+		responses: {
+			200: {
+				description: "Access token refreshed successfully",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						tokenType: { type: "string" },
+						idToken: { type: "string" },
+						accessToken: { type: "string" },
+						refreshToken: { type: "string" },
+						accessTokenExpiresAt: {
+							type: "string",
+							format: "date-time"
+						},
+						refreshTokenExpiresAt: {
+							type: "string",
+							format: "date-time"
+						}
+					}
+				} } }
+			},
+			400: { description: "Invalid refresh token or provider configuration" }
+		}
+	} }
+}, async (ctx) => {
+	const { providerId, accountId, userId } = ctx.body;
+	const req = ctx.request;
+	const session = await getSessionFromCtx(ctx);
+	if (req && !session) throw ctx.error("UNAUTHORIZED");
+	let resolvedUserId = session?.user?.id || userId;
+	if (!resolvedUserId) throw new APIError("BAD_REQUEST", { message: `Either userId or session is required` });
+	const account = (await ctx.context.internalAdapter.findAccounts(resolvedUserId)).find((acc) => accountId ? acc.id === accountId && acc.providerId === providerId : acc.providerId === providerId);
+	if (!account) throw new APIError("BAD_REQUEST", { message: "Account not found" });
+	const provider = ctx.context.socialProviders.find((p) => p.id === providerId);
+	if (!provider) throw new APIError("BAD_REQUEST", { message: `Provider ${providerId} not found.` });
+	if (!provider.refreshAccessToken) throw new APIError("BAD_REQUEST", { message: `Provider ${providerId} does not support token refreshing.` });
+	try {
+		const tokens = await provider.refreshAccessToken(account.refreshToken);
+		await ctx.context.internalAdapter.updateAccount(account.id, {
+			accessToken: await setTokenUtil(tokens.accessToken, ctx.context),
+			refreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),
+			accessTokenExpiresAt: tokens.accessTokenExpiresAt,
+			refreshTokenExpiresAt: tokens.refreshTokenExpiresAt
+		});
+		return ctx.json(tokens);
+	} catch (error$1) {
+		throw new APIError("BAD_REQUEST", {
+			message: "Failed to refresh access token",
+			cause: error$1
+		});
+	}
+});
+const accountInfo = createAuthEndpoint("/account-info", {
+	method: "POST",
+	use: [sessionMiddleware],
+	metadata: { openapi: {
+		description: "Get the account info provided by the provider",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					user: {
+						type: "object",
+						properties: {
+							id: { type: "string" },
+							name: { type: "string" },
+							email: { type: "string" },
+							image: { type: "string" },
+							emailVerified: { type: "boolean" }
+						},
+						required: ["id", "emailVerified"]
+					},
+					data: {
+						type: "object",
+						properties: {},
+						additionalProperties: true
+					}
+				},
+				required: ["user", "data"],
+				additionalProperties: false
+			} } }
+		} }
+	} },
+	body: z.object({ accountId: z.string().meta({ description: "The provider given account id for which to get the account info" }) })
+}, async (ctx) => {
+	const account = await ctx.context.internalAdapter.findAccount(ctx.body.accountId);
+	if (!account || account.userId !== ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: "Account not found" });
+	const provider = ctx.context.socialProviders.find((p) => p.id === account.providerId);
+	if (!provider) throw new APIError("INTERNAL_SERVER_ERROR", { message: `Provider account provider is ${account.providerId} but it is not configured` });
+	const tokens = await getAccessToken({
+		...ctx,
+		body: {
+			accountId: account.id,
+			providerId: account.providerId
+		},
+		returnHeaders: false
+	});
+	if (!tokens.accessToken) throw new APIError("BAD_REQUEST", { message: "Access token not found" });
+	const info = await provider.getUserInfo({
+		...tokens,
+		accessToken: tokens.accessToken
+	});
+	return ctx.json(info);
+});
+
+//#endregion
+//#region src/oauth2/link-account.ts
+async function handleOAuthUserInfo(c, { userInfo, account, callbackURL, disableSignUp, overrideUserInfo }) {
+	const dbUser = await c.context.internalAdapter.findOAuthUser(userInfo.email.toLowerCase(), account.accountId, account.providerId).catch((e) => {
+		logger.error("Better auth was unable to query your database.\nError: ", e);
+		const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+		throw c.redirect(`${errorURL}?error=internal_server_error`);
+	});
+	let user = dbUser?.user;
+	let isRegister = !user;
+	if (dbUser) {
+		const hasBeenLinked = dbUser.accounts.find((a) => a.providerId === account.providerId && a.accountId === account.accountId);
+		if (!hasBeenLinked) {
+			if (!(c.context.options.account?.accountLinking?.trustedProviders)?.includes(account.providerId) && !userInfo.emailVerified || c.context.options.account?.accountLinking?.enabled === false) {
+				if (isDevelopment()) logger.warn(`User already exist but account isn't linked to ${account.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`);
+				return {
+					error: "account not linked",
+					data: null
+				};
+			}
+			try {
+				await c.context.internalAdapter.linkAccount({
+					providerId: account.providerId,
+					accountId: userInfo.id.toString(),
+					userId: dbUser.user.id,
+					accessToken: await setTokenUtil(account.accessToken, c.context),
+					refreshToken: await setTokenUtil(account.refreshToken, c.context),
+					idToken: account.idToken,
+					accessTokenExpiresAt: account.accessTokenExpiresAt,
+					refreshTokenExpiresAt: account.refreshTokenExpiresAt,
+					scope: account.scope
+				});
+			} catch (e) {
+				logger.error("Unable to link account", e);
+				return {
+					error: "unable to link account",
+					data: null
+				};
+			}
+			if (userInfo.emailVerified && !dbUser.user.emailVerified && userInfo.email.toLowerCase() === dbUser.user.email) await c.context.internalAdapter.updateUser(dbUser.user.id, { emailVerified: true });
+		} else {
+			if (c.context.options.account?.updateAccountOnSignIn !== false) {
+				const updateData = Object.fromEntries(Object.entries({
+					idToken: account.idToken,
+					accessToken: await setTokenUtil(account.accessToken, c.context),
+					refreshToken: await setTokenUtil(account.refreshToken, c.context),
+					accessTokenExpiresAt: account.accessTokenExpiresAt,
+					refreshTokenExpiresAt: account.refreshTokenExpiresAt,
+					scope: account.scope
+				}).filter(([_, value]) => value !== void 0));
+				if (Object.keys(updateData).length > 0) await c.context.internalAdapter.updateAccount(hasBeenLinked.id, updateData);
+			}
+			if (userInfo.emailVerified && !dbUser.user.emailVerified && userInfo.email.toLowerCase() === dbUser.user.email) await c.context.internalAdapter.updateUser(dbUser.user.id, { emailVerified: true });
+		}
+		if (overrideUserInfo) {
+			const { id: _,...restUserInfo } = userInfo;
+			user = await c.context.internalAdapter.updateUser(dbUser.user.id, {
+				...restUserInfo,
+				email: userInfo.email.toLowerCase(),
+				emailVerified: userInfo.email.toLowerCase() === dbUser.user.email ? dbUser.user.emailVerified || userInfo.emailVerified : userInfo.emailVerified
+			});
+		}
+	} else {
+		if (disableSignUp) return {
+			error: "signup disabled",
+			data: null,
+			isRegister: false
+		};
+		try {
+			const { id: _,...restUserInfo } = userInfo;
+			user = await c.context.internalAdapter.createOAuthUser({
+				...restUserInfo,
+				email: userInfo.email.toLowerCase()
+			}, {
+				accessToken: await setTokenUtil(account.accessToken, c.context),
+				refreshToken: await setTokenUtil(account.refreshToken, c.context),
+				idToken: account.idToken,
+				accessTokenExpiresAt: account.accessTokenExpiresAt,
+				refreshTokenExpiresAt: account.refreshTokenExpiresAt,
+				scope: account.scope,
+				providerId: account.providerId,
+				accountId: userInfo.id.toString()
+			}).then((res) => res?.user);
+			if (!userInfo.emailVerified && user && c.context.options.emailVerification?.sendOnSignUp) {
+				const token = await createEmailVerificationToken(c.context.secret, user.email, void 0, c.context.options.emailVerification?.expiresIn);
+				const url = `${c.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;
+				await c.context.options.emailVerification?.sendVerificationEmail?.({
+					user,
+					url,
+					token
+				}, c.request);
+			}
+		} catch (e) {
+			logger.error(e);
+			if (e instanceof APIError$1) return {
+				error: e.message,
+				data: null,
+				isRegister: false
+			};
+			return {
+				error: "unable to create user",
+				data: null,
+				isRegister: false
+			};
+		}
+	}
+	if (!user) return {
+		error: "unable to create user",
+		data: null,
+		isRegister: false
+	};
+	const session = await c.context.internalAdapter.createSession(user.id);
+	if (!session) return {
+		error: "unable to create session",
+		data: null,
+		isRegister: false
+	};
+	return {
+		data: {
+			session,
+			user
+		},
+		error: null,
+		isRegister
+	};
+}
+
+//#endregion
+//#region src/api/routes/callback.ts
+const schema = z.object({
+	code: z.string().optional(),
+	error: z.string().optional(),
+	device_id: z.string().optional(),
+	error_description: z.string().optional(),
+	state: z.string().optional(),
+	user: z.string().optional()
+});
+const callbackOAuth = createAuthEndpoint("/callback/:id", {
+	method: ["GET", "POST"],
+	operationId: "handleOAuthCallback",
+	body: schema.optional(),
+	query: schema.optional(),
+	metadata: HIDE_METADATA
+}, async (c) => {
+	let queryOrBody;
+	const defaultErrorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+	if (c.method === "POST") {
+		const postData = c.body ? schema.parse(c.body) : {};
+		const queryData = c.query ? schema.parse(c.query) : {};
+		const mergedData = schema.parse({
+			...postData,
+			...queryData
+		});
+		const params = new URLSearchParams();
+		for (const [key, value] of Object.entries(mergedData)) if (value !== void 0 && value !== null) params.set(key, String(value));
+		const redirectURL = `${c.context.baseURL}/callback/${c.params.id}?${params.toString()}`;
+		throw c.redirect(redirectURL);
+	}
+	try {
+		if (c.method === "GET") queryOrBody = schema.parse(c.query);
+		else if (c.method === "POST") queryOrBody = schema.parse(c.body);
+		else throw new Error("Unsupported method");
+	} catch (e) {
+		c.context.logger.error("INVALID_CALLBACK_REQUEST", e);
+		throw c.redirect(`${defaultErrorURL}?error=invalid_callback_request`);
+	}
+	const { code, error: error$1, state, error_description, device_id } = queryOrBody;
+	if (!state) {
+		c.context.logger.error("State not found", error$1);
+		const url = `${defaultErrorURL}${defaultErrorURL.includes("?") ? "&" : "?"}state=state_not_found`;
+		throw c.redirect(url);
+	}
+	const { codeVerifier, callbackURL, link, errorURL, newUserURL, requestSignUp } = await parseState(c);
+	function redirectOnError(error$2, description) {
+		const baseURL = errorURL ?? defaultErrorURL;
+		const params = new URLSearchParams({ error: error$2 });
+		if (description) params.set("error_description", description);
+		const url = `${baseURL}${baseURL.includes("?") ? "&" : "?"}${params.toString()}`;
+		throw c.redirect(url);
+	}
+	if (error$1) redirectOnError(error$1, error_description);
+	if (!code) {
+		c.context.logger.error("Code not found");
+		throw redirectOnError("no_code");
+	}
+	const provider = c.context.socialProviders.find((p) => p.id === c.params.id);
+	if (!provider) {
+		c.context.logger.error("Oauth provider with id", c.params.id, "not found");
+		throw redirectOnError("oauth_provider_not_found");
+	}
+	let tokens;
+	try {
+		tokens = await provider.validateAuthorizationCode({
+			code,
+			codeVerifier,
+			deviceId: device_id,
+			redirectURI: `${c.context.baseURL}/callback/${provider.id}`
+		});
+	} catch (e) {
+		c.context.logger.error("", e);
+		throw redirectOnError("invalid_code");
+	}
+	const userInfo = await provider.getUserInfo({
+		...tokens,
+		user: c.body?.user ? safeJSONParse(c.body.user) : void 0
+	}).then((res) => res?.user);
+	if (!userInfo) {
+		c.context.logger.error("Unable to get user info");
+		return redirectOnError("unable_to_get_user_info");
+	}
+	if (!callbackURL) {
+		c.context.logger.error("No callback URL found");
+		throw redirectOnError("no_callback_url");
+	}
+	if (link) {
+		if (!(c.context.options.account?.accountLinking?.trustedProviders)?.includes(provider.id) && !userInfo.emailVerified || c.context.options.account?.accountLinking?.enabled === false) {
+			c.context.logger.error("Unable to link account - untrusted provider");
+			return redirectOnError("unable_to_link_account");
+		}
+		if (userInfo.email !== link.email && c.context.options.account?.accountLinking?.allowDifferentEmails !== true) return redirectOnError("email_doesn't_match");
+		const existingAccount = await c.context.internalAdapter.findAccount(String(userInfo.id));
+		if (existingAccount) {
+			if (existingAccount.userId.toString() !== link.userId.toString()) return redirectOnError("account_already_linked_to_different_user");
+			const updateData = Object.fromEntries(Object.entries({
+				accessToken: await setTokenUtil(tokens.accessToken, c.context),
+				refreshToken: await setTokenUtil(tokens.refreshToken, c.context),
+				idToken: tokens.idToken,
+				accessTokenExpiresAt: tokens.accessTokenExpiresAt,
+				refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
+				scope: tokens.scopes?.join(",")
+			}).filter(([_, value]) => value !== void 0));
+			await c.context.internalAdapter.updateAccount(existingAccount.id, updateData);
+		} else if (!await c.context.internalAdapter.createAccount({
+			userId: link.userId,
+			providerId: provider.id,
+			accountId: String(userInfo.id),
+			...tokens,
+			accessToken: await setTokenUtil(tokens.accessToken, c.context),
+			refreshToken: await setTokenUtil(tokens.refreshToken, c.context),
+			scope: tokens.scopes?.join(",")
+		})) return redirectOnError("unable_to_link_account");
+		let toRedirectTo$1;
+		try {
+			toRedirectTo$1 = callbackURL.toString();
+		} catch {
+			toRedirectTo$1 = callbackURL;
+		}
+		throw c.redirect(toRedirectTo$1);
+	}
+	if (!userInfo.email) {
+		c.context.logger.error("Provider did not return email. This could be due to misconfiguration in the provider settings.");
+		return redirectOnError("email_not_found");
+	}
+	const result = await handleOAuthUserInfo(c, {
+		userInfo: {
+			...userInfo,
+			id: String(userInfo.id),
+			email: userInfo.email,
+			name: userInfo.name || userInfo.email
+		},
+		account: {
+			providerId: provider.id,
+			accountId: String(userInfo.id),
+			...tokens,
+			scope: tokens.scopes?.join(",")
+		},
+		callbackURL,
+		disableSignUp: provider.disableImplicitSignUp && !requestSignUp || provider.options?.disableSignUp,
+		overrideUserInfo: provider.options?.overrideUserInfoOnSignIn
+	});
+	if (result.error) {
+		c.context.logger.error(result.error.split(" ").join("_"));
+		return redirectOnError(result.error.split(" ").join("_"));
+	}
+	const { session, user } = result.data;
+	await setSessionCookie(c, {
+		session,
+		user
+	});
+	let toRedirectTo;
+	try {
+		toRedirectTo = (result.isRegister ? newUserURL || callbackURL : callbackURL).toString();
+	} catch {
+		toRedirectTo = result.isRegister ? newUserURL || callbackURL : callbackURL;
+	}
+	throw c.redirect(toRedirectTo);
+});
+
+//#endregion
+//#region src/api/routes/email-verification.ts
+async function createEmailVerificationToken(secret, email, updateTo, expiresIn = 3600) {
+	return await signJWT({
+		email: email.toLowerCase(),
+		updateTo
+	}, secret, expiresIn);
+}
+/**
+* A function to send a verification email to the user
+*/
+async function sendVerificationEmailFn(ctx, user) {
+	if (!ctx.context.options.emailVerification?.sendVerificationEmail) {
+		ctx.context.logger.error("Verification email isn't enabled.");
+		throw new APIError("BAD_REQUEST", { message: "Verification email isn't enabled" });
+	}
+	const token = await createEmailVerificationToken(ctx.context.secret, user.email, void 0, ctx.context.options.emailVerification?.expiresIn);
+	const callbackURL = ctx.body.callbackURL ? encodeURIComponent(ctx.body.callbackURL) : encodeURIComponent("/");
+	const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;
+	await ctx.context.options.emailVerification.sendVerificationEmail({
+		user,
+		url,
+		token
+	}, ctx.request);
+}
+const sendVerificationEmail = createAuthEndpoint("/send-verification-email", {
+	method: "POST",
+	operationId: "sendVerificationEmail",
+	body: z.object({
+		email: z.string().email().meta({ description: "The email to send the verification email to" }),
+		callbackURL: z.string().meta({ description: "The URL to use for email verification callback" }).optional()
+	}),
+	metadata: { openapi: {
+		operationId: "sendVerificationEmail",
+		description: "Send a verification email to the user",
+		requestBody: { content: { "application/json": { schema: {
+			type: "object",
+			properties: {
+				email: {
+					type: "string",
+					description: "The email to send the verification email to",
+					example: "user@example.com"
+				},
+				callbackURL: {
+					type: "string",
+					description: "The URL to use for email verification callback",
+					example: "https://example.com/callback",
+					nullable: true
+				}
+			},
+			required: ["email"]
+		} } } },
+		responses: {
+			"200": {
+				description: "Success",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { status: {
+						type: "boolean",
+						description: "Indicates if the email was sent successfully",
+						example: true
+					} }
+				} } }
+			},
+			"400": {
+				description: "Bad Request",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { message: {
+						type: "string",
+						description: "Error message",
+						example: "Verification email isn't enabled"
+					} }
+				} } }
+			}
+		}
+	} }
+}, async (ctx) => {
+	if (!ctx.context.options.emailVerification?.sendVerificationEmail) {
+		ctx.context.logger.error("Verification email isn't enabled.");
+		throw new APIError("BAD_REQUEST", { message: "Verification email isn't enabled" });
+	}
+	const { email } = ctx.body;
+	const session = await getSessionFromCtx(ctx);
+	if (!session) {
+		const user = await ctx.context.internalAdapter.findUserByEmail(email);
+		if (!user) return ctx.json({ status: true });
+		await sendVerificationEmailFn(ctx, user.user);
+		return ctx.json({ status: true });
+	}
+	if (session?.user.emailVerified) throw new APIError("BAD_REQUEST", { message: "You can only send a verification email to an unverified email" });
+	if (session?.user.email !== email) throw new APIError("BAD_REQUEST", { message: "You can only send a verification email to your own email" });
+	await sendVerificationEmailFn(ctx, session.user);
+	return ctx.json({ status: true });
+});
+const verifyEmail = createAuthEndpoint("/verify-email", {
+	method: "GET",
+	operationId: "verifyEmail",
+	query: z.object({
+		token: z.string().meta({ description: "The token to verify the email" }),
+		callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
+	}),
+	use: [originCheck((ctx) => ctx.query.callbackURL)],
+	metadata: { openapi: {
+		description: "Verify the email of the user",
+		parameters: [{
+			name: "token",
+			in: "query",
+			description: "The token to verify the email",
+			required: true,
+			schema: { type: "string" }
+		}, {
+			name: "callbackURL",
+			in: "query",
+			description: "The URL to redirect to after email verification",
+			required: false,
+			schema: { type: "string" }
+		}],
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					user: {
+						type: "object",
+						$ref: "#/components/schemas/User"
+					},
+					status: {
+						type: "boolean",
+						description: "Indicates if the email was verified successfully"
+					}
+				},
+				required: ["user", "status"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	function redirectOnError(error$1) {
+		if (ctx.query.callbackURL) {
+			if (ctx.query.callbackURL.includes("?")) throw ctx.redirect(`${ctx.query.callbackURL}&error=${error$1}`);
+			throw ctx.redirect(`${ctx.query.callbackURL}?error=${error$1}`);
+		}
+		throw new APIError("UNAUTHORIZED", { message: error$1 });
+	}
+	const { token } = ctx.query;
+	let jwt;
+	try {
+		jwt = await jwtVerify(token, new TextEncoder().encode(ctx.context.secret), { algorithms: ["HS256"] });
+	} catch (e) {
+		if (e instanceof JWTExpired) return redirectOnError("token_expired");
+		return redirectOnError("invalid_token");
+	}
+	const parsed = z.object({
+		email: z.string().email(),
+		updateTo: z.string().optional()
+	}).parse(jwt.payload);
+	const user = await ctx.context.internalAdapter.findUserByEmail(parsed.email);
+	if (!user) return redirectOnError("user_not_found");
+	if (parsed.updateTo) {
+		const session = await getSessionFromCtx(ctx);
+		if (!session) {
+			if (ctx.query.callbackURL) throw ctx.redirect(`${ctx.query.callbackURL}?error=unauthorized`);
+			return redirectOnError("unauthorized");
+		}
+		if (session.user.email !== parsed.email) {
+			if (ctx.query.callbackURL) throw ctx.redirect(`${ctx.query.callbackURL}?error=unauthorized`);
+			return redirectOnError("unauthorized");
+		}
+		const updatedUser$1 = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {
+			email: parsed.updateTo,
+			emailVerified: false
+		});
+		const newToken = await createEmailVerificationToken(ctx.context.secret, parsed.updateTo);
+		const updateCallbackURL = ctx.query.callbackURL ? encodeURIComponent(ctx.query.callbackURL) : encodeURIComponent("/");
+		await ctx.context.options.emailVerification?.sendVerificationEmail?.({
+			user: updatedUser$1,
+			url: `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`,
+			token: newToken
+		}, ctx.request);
+		await setSessionCookie(ctx, {
+			session: session.session,
+			user: {
+				...session.user,
+				email: parsed.updateTo,
+				emailVerified: false
+			}
+		});
+		if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);
+		return ctx.json({
+			status: true,
+			user: {
+				id: updatedUser$1.id,
+				email: updatedUser$1.email,
+				name: updatedUser$1.name,
+				image: updatedUser$1.image,
+				emailVerified: updatedUser$1.emailVerified,
+				createdAt: updatedUser$1.createdAt,
+				updatedAt: updatedUser$1.updatedAt
+			}
+		});
+	}
+	if (ctx.context.options.emailVerification?.onEmailVerification) await ctx.context.options.emailVerification.onEmailVerification(user.user, ctx.request);
+	const updatedUser = await ctx.context.internalAdapter.updateUserByEmail(parsed.email, { emailVerified: true });
+	if (ctx.context.options.emailVerification?.afterEmailVerification) await ctx.context.options.emailVerification.afterEmailVerification(updatedUser, ctx.request);
+	if (ctx.context.options.emailVerification?.autoSignInAfterVerification) {
+		const currentSession = await getSessionFromCtx(ctx);
+		if (!currentSession || currentSession.user.email !== parsed.email) {
+			const session = await ctx.context.internalAdapter.createSession(user.user.id);
+			if (!session) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to create session" });
+			await setSessionCookie(ctx, {
+				session,
+				user: {
+					...user.user,
+					emailVerified: true
+				}
+			});
+		} else await setSessionCookie(ctx, {
+			session: currentSession.session,
+			user: {
+				...currentSession.user,
+				emailVerified: true
+			}
+		});
+	}
+	if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL);
+	return ctx.json({
+		status: true,
+		user: null
+	});
+});
+
+//#endregion
+//#region src/api/routes/error.ts
+function sanitize(input) {
+	return input.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/&(?!amp;|lt;|gt;|quot;|#39;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, "&amp;");
+}
+const html = (options, code = "Unknown", description = null) => {
+	const custom = options.onAPIError?.customizeDefaultErrorPage;
+	return `<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="UTF-8" />
+    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+    <title>Error</title>
+    <style>
+      * {
+        box-sizing: border-box;
+      }
+      body {
+        font-family: ${custom?.font?.defaultFamily || "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif"};
+        background: ${custom?.colors?.background || "var(--background)"};
+        color: var(--foreground);
+        margin: 0;
+      }
+      :root,
+      :host {
+        --spacing: 0.25rem;
+        --container-md: 28rem;
+        --text-sm: ${custom?.size?.textSm || "0.875rem"};
+        --text-sm--line-height: calc(1.25 / 0.875);
+        --text-2xl: ${custom?.size?.text2xl || "1.5rem"};
+        --text-2xl--line-height: calc(2 / 1.5);
+        --text-4xl: ${custom?.size?.text4xl || "2.25rem"};
+        --text-4xl--line-height: calc(2.5 / 2.25);
+        --text-6xl: ${custom?.size?.text6xl || "3rem"};
+        --text-6xl--line-height: 1;
+        --font-weight-medium: 500;
+        --font-weight-semibold: 600;
+        --font-weight-bold: 700;
+        --default-transition-duration: 150ms;
+        --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
+        --radius: ${custom?.size?.radiusSm || "0.625rem"};
+        --default-mono-font-family: ${custom?.font?.monoFamily || "var(--font-geist-mono)"};
+        --primary: ${custom?.colors?.primary || "black"};
+        --primary-foreground: ${custom?.colors?.primaryForeground || "white"};
+        --background: ${custom?.colors?.background || "white"};
+        --foreground: ${custom?.colors?.foreground || "oklch(0.271 0 0)"};
+        --border: ${custom?.colors?.border || "oklch(0.89 0 0)"};
+        --destructive: ${custom?.colors?.destructive || "oklch(0.55 0.15 25.723)"};
+        --muted-foreground: ${custom?.colors?.mutedForeground || "oklch(0.545 0 0)"};
+        --corner-border: ${custom?.colors?.cornerBorder || "#404040"};
+      }
+
+      button, .btn {
+        cursor: pointer;
+        background: none;
+        border: none;
+        color: inherit;
+        font: inherit;
+        transition: all var(--default-transition-duration)
+          var(--default-transition-timing-function);
+      }
+      button:hover, .btn:hover {
+        opacity: 0.8;
+      }
+
+      @media (prefers-color-scheme: dark) {
+        :root,
+        :host {
+          --primary: ${custom?.colors?.primary || "white"};
+          --primary-foreground: ${custom?.colors?.primaryForeground || "black"};
+          --background: ${custom?.colors?.background || "oklch(0.15 0 0)"};
+          --foreground: ${custom?.colors?.foreground || "oklch(0.98 0 0)"};
+          --border: ${custom?.colors?.border || "oklch(0.27 0 0)"};
+          --destructive: ${custom?.colors?.destructive || "oklch(0.65 0.15 25.723)"};
+          --muted-foreground: ${custom?.colors?.mutedForeground || "oklch(0.65 0 0)"};
+          --corner-border: ${custom?.colors?.cornerBorder || "#a0a0a0"};
+        }
+      }
+      @media (max-width: 640px) {
+        :root, :host {
+          --text-6xl: 2.5rem;
+          --text-2xl: 1.25rem;
+          --text-sm: 0.8125rem;
+        }
+      }
+      @media (max-width: 480px) {
+        :root, :host {
+          --text-6xl: 2rem;
+          --text-2xl: 1.125rem;
+        }
+      }
+    </style>
+  </head>
+  <body style="width: 100vw; min-height: 100vh; overflow-x: hidden; overflow-y: auto;">
+    <div
+        style="
+            display: flex;
+            flex-direction: column;
+            align-items: center;
+            justify-content: center;
+            gap: 1.5rem;
+            position: relative;
+            width: 100%;
+            min-height: 100vh;
+            padding: 1rem;
+        "
+        >
+${custom?.disableBackgroundGrid ? "" : `
+      <div
+        style="
+          position: absolute;
+          inset: 0;
+          background-image: linear-gradient(to right, ${custom?.colors?.gridColor || "var(--border)"} 1px, transparent 1px),
+            linear-gradient(to bottom, ${custom?.colors?.gridColor || "var(--border)"} 1px, transparent 1px);
+          background-size: 40px 40px;
+          opacity: 0.6;
+          pointer-events: none;
+          width: 100vw;
+          height: 100vh;
+        "
+      ></div>
+      <div
+        style="
+          position: absolute;
+          inset: 0;
+          display: flex;
+          align-items: center;
+          justify-content: center;
+          background: ${custom?.colors?.background || "var(--background)"};
+          mask-image: radial-gradient(ellipse at center, transparent 20%, black);
+          -webkit-mask-image: radial-gradient(ellipse at center, transparent 20%, black);
+          pointer-events: none;
+        "
+      ></div>
+`}
+
+<div
+  style="
+    position: relative;
+    z-index: 10;
+    border: 2px solid var(--border);
+    background: ${custom?.colors?.cardBackground || "var(--background)"};
+    padding: 1.5rem;
+    max-width: 42rem;
+    width: 100%;
+  "
+>
+    ${custom?.disableCornerDecorations ? "" : `
+        <!-- Corner decorations -->
+        <div
+          style="
+            position: absolute;
+            top: -2px;
+            left: -2px;
+            width: 2rem;
+            height: 2rem;
+            border-top: 4px solid var(--corner-border);
+            border-left: 4px solid var(--corner-border);
+          "
+        ></div>
+        <div
+          style="
+            position: absolute;
+            top: -2px;
+            right: -2px;
+            width: 2rem;
+            height: 2rem;
+            border-top: 4px solid var(--corner-border);
+            border-right: 4px solid var(--corner-border);
+          "
+        ></div>
+  
+        <div
+          style="
+            position: absolute;
+            bottom: -2px;
+            left: -2px;
+            width: 2rem;
+            height: 2rem;
+            border-bottom: 4px solid var(--corner-border);
+            border-left: 4px solid var(--corner-border);
+          "
+        ></div>
+        <div
+          style="
+            position: absolute;
+            bottom: -2px;
+            right: -2px;
+            width: 2rem;
+            height: 2rem;
+            border-bottom: 4px solid var(--corner-border);
+            border-right: 4px solid var(--corner-border);
+          "
+        ></div>`}
+
+        <div style="text-align: center; margin-bottom: 1.5rem;">
+          <div style="margin-bottom: 1.5rem;">
+            <div
+              style="
+                display: inline-block;
+                border: 2px solid ${custom?.disableTitleBorder ? "transparent" : custom?.colors?.titleBorder || "var(--destructive)"};
+                padding: 0.375rem 1rem;
+              "
+            >
+              <h1
+                style="
+                  font-size: var(--text-6xl);
+                  font-weight: var(--font-weight-semibold);
+                  color: ${custom?.colors?.titleColor || "var(--foreground)"};
+                  letter-spacing: -0.02em;
+                  margin: 0;
+                "
+              >
+                ERROR
+              </h1>
+            </div>
+            <div
+              style="
+                height: 2px;
+                background-color: var(--border);
+                width: calc(100% + 3rem);
+                margin-left: -1.5rem;
+                margin-top: 1.5rem;
+              "
+            ></div>
+          </div>
+
+          <h2
+            style="
+              font-size: var(--text-2xl);
+              font-weight: var(--font-weight-semibold);
+              color: var(--foreground);
+              margin: 0 0 1rem;
+            "
+          >
+            Something went wrong
+          </h2>
+
+          <div
+            style="
+                display: inline-flex;
+                align-items: center;
+                gap: 0.5rem;
+                border: 2px solid var(--border);
+                background-color: var(--muted);
+                padding: 0.375rem 0.75rem;
+                margin: 0 0 1rem;
+                flex-wrap: wrap;
+                justify-content: center;
+            "
+            >
+            <span
+                style="
+                font-size: 0.75rem;
+                color: var(--muted-foreground);
+                font-weight: var(--font-weight-semibold);
+                "
+            >
+                CODE:
+            </span>
+            <span
+                style="
+                font-size: var(--text-sm);
+                font-family: var(--default-mono-font-family, monospace);
+                color: var(--foreground);
+                word-break: break-all;
+                "
+            >
+                ${sanitize(code)}
+            </span>
+            </div>
+
+          <p
+            style="
+              color: var(--muted-foreground);
+              max-width: 28rem;
+              margin: 0 auto;
+              font-size: var(--text-sm);
+              line-height: 1.5;
+              text-wrap: pretty;
+            "
+          >
+            ${!description ? `We encountered an unexpected error. Please try again or return to the home page. If you're a developer, you can find more information about the error <a href='https://better-auth.com/docs/errors/${encodeURIComponent(code)}' target='_blank' rel="noopener noreferrer" style='color: var(--foreground); text-decoration: underline;'>here</a>.` : description}
+          </p>
+        </div>
+
+        <div
+          style="
+            display: flex;
+            gap: 0.75rem;
+            margin-top: 1.5rem;
+            justify-content: center;
+            flex-wrap: wrap;
+          "
+        >
+          <a
+            href="/"
+            style="
+              text-decoration: none;
+            "
+          >
+            <div
+              style="
+                border: 2px solid var(--border);
+                background: var(--primary);
+                color: var(--primary-foreground);
+                padding: 0.5rem 1rem;
+                border-radius: 0;
+                white-space: nowrap;
+              "
+              class="btn"
+            >
+              Go Home
+            </div>
+          </a>
+          <a
+            href="https://better-auth.com/docs/errors/${encodeURIComponent(code)}?askai=${encodeURIComponent(`What does the error code ${code} mean?`)}"
+            target="_blank"
+            rel="noopener noreferrer"
+            style="
+              text-decoration: none;
+            "
+          >
+            <div
+              style="
+                border: 2px solid var(--border);
+                background: transparent;
+                color: var(--foreground);
+                padding: 0.5rem 1rem;
+                border-radius: 0;
+                white-space: nowrap;
+              "
+              class="btn"
+            >
+              Ask AI
+            </div>
+          </a>
+        </div>
+      </div>
+    </div>
+  </body>
+</html>`;
+};
+const error = createAuthEndpoint("/error", {
+	method: "GET",
+	metadata: {
+		...HIDE_METADATA,
+		openapi: {
+			description: "Displays an error page",
+			responses: { "200": {
+				description: "Success",
+				content: { "text/html": { schema: {
+					type: "string",
+					description: "The HTML content of the error page"
+				} } }
+			} }
+		}
+	}
+}, async (c) => {
+	const url = new URL(c.request?.url || "");
+	const unsanitizedCode = url.searchParams.get("error") || "UNKNOWN";
+	const unsanitizedDescription = url.searchParams.get("error_description") || null;
+	const safeCode = /^[\'A-Za-z0-9_-]+$/.test(unsanitizedCode || "") ? unsanitizedCode : "UNKNOWN";
+	const safeDescription = unsanitizedDescription ? sanitize(unsanitizedDescription) : null;
+	const queryParams = new URLSearchParams();
+	queryParams.set("error", safeCode);
+	if (unsanitizedDescription) queryParams.set("error_description", unsanitizedDescription);
+	const options = c.context.options;
+	const errorURL = options.onAPIError?.errorURL;
+	if (errorURL) return new Response(null, {
+		status: 302,
+		headers: { Location: `${errorURL}${errorURL.includes("?") ? "&" : "?"}${queryParams.toString()}` }
+	});
+	if (isProduction && !options.onAPIError?.customizeDefaultErrorPage) return new Response(null, {
+		status: 302,
+		headers: { Location: `/?${queryParams.toString()}` }
+	});
+	return new Response(html(c.context.options, safeCode, safeDescription), { headers: { "Content-Type": "text/html" } });
+});
+
+//#endregion
+//#region src/api/routes/ok.ts
+const ok = createAuthEndpoint("/ok", {
+	method: "GET",
+	metadata: {
+		...HIDE_METADATA,
+		openapi: {
+			description: "Check if the API is working",
+			responses: { "200": {
+				description: "API is working",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { ok: {
+						type: "boolean",
+						description: "Indicates if the API is working"
+					} },
+					required: ["ok"]
+				} } }
+			} }
+		}
+	}
+}, async (ctx) => {
+	return ctx.json({ ok: true });
+});
+
+//#endregion
+//#region src/api/routes/reset-password.ts
+function redirectError(ctx, callbackURL, query) {
+	const url = callbackURL ? new URL(callbackURL, ctx.baseURL) : new URL(`${ctx.baseURL}/error`);
+	if (query) Object.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));
+	return url.href;
+}
+function redirectCallback(ctx, callbackURL, query) {
+	const url = new URL(callbackURL, ctx.baseURL);
+	if (query) Object.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));
+	return url.href;
+}
+const requestPasswordReset = createAuthEndpoint("/request-password-reset", {
+	method: "POST",
+	operationId: "forgetPassword",
+	body: z.object({
+		email: z.string().email().meta({ description: "The email address of the user to send a password reset email to" }),
+		redirectTo: z.string().meta({ description: "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN" }).optional()
+	}),
+	metadata: { openapi: {
+		operationId: "forgetPassword",
+		description: "Send a password reset email to the user",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					status: { type: "boolean" },
+					message: { type: "string" }
+				}
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	if (!ctx.context.options.emailAndPassword?.sendResetPassword) {
+		ctx.context.logger.error("Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!");
+		throw new APIError("BAD_REQUEST", { message: "Reset password isn't enabled" });
+	}
+	const { email, redirectTo } = ctx.body;
+	const user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });
+	if (!user) {
+		ctx.context.logger.error("Reset Password: User not found", { email });
+		return ctx.json({
+			status: true,
+			message: "If this email exists in our system, check your email for the reset link"
+		});
+	}
+	const expiresAt = getDate(ctx.context.options.emailAndPassword.resetPasswordTokenExpiresIn || 3600 * 1, "sec");
+	const verificationToken = generateId(24);
+	await ctx.context.internalAdapter.createVerificationValue({
+		value: user.user.id,
+		identifier: `reset-password:${verificationToken}`,
+		expiresAt
+	});
+	const callbackURL = redirectTo ? encodeURIComponent(redirectTo) : "";
+	const url = `${ctx.context.baseURL}/reset-password/${verificationToken}?callbackURL=${callbackURL}`;
+	await ctx.context.options.emailAndPassword.sendResetPassword({
+		user: user.user,
+		url,
+		token: verificationToken
+	}, ctx.request);
+	return ctx.json({
+		status: true,
+		message: "If this email exists in our system, check your email for the reset link"
+	});
+});
+const requestPasswordResetCallback = createAuthEndpoint("/reset-password/:token", {
+	method: "GET",
+	operationId: "forgetPasswordCallback",
+	query: z.object({ callbackURL: z.string().meta({ description: "The URL to redirect the user to reset their password" }) }),
+	use: [originCheck((ctx) => ctx.query.callbackURL)],
+	metadata: { openapi: {
+		operationId: "resetPasswordCallback",
+		description: "Redirects the user to the callback URL with the token",
+		parameters: [{
+			name: "token",
+			in: "path",
+			required: true,
+			description: "The token to reset the password",
+			schema: { type: "string" }
+		}, {
+			name: "callbackURL",
+			in: "query",
+			required: true,
+			description: "The URL to redirect the user to reset their password",
+			schema: { type: "string" }
+		}],
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { token: { type: "string" } }
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const { token } = ctx.params;
+	const { callbackURL } = ctx.query;
+	if (!token || !callbackURL) throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: "INVALID_TOKEN" }));
+	const verification = await ctx.context.internalAdapter.findVerificationValue(`reset-password:${token}`);
+	if (!verification || verification.expiresAt < /* @__PURE__ */ new Date()) throw ctx.redirect(redirectError(ctx.context, callbackURL, { error: "INVALID_TOKEN" }));
+	throw ctx.redirect(redirectCallback(ctx.context, callbackURL, { token }));
+});
+const resetPassword = createAuthEndpoint("/reset-password", {
+	method: "POST",
+	operationId: "resetPassword",
+	query: z.object({ token: z.string().optional() }).optional(),
+	body: z.object({
+		newPassword: z.string().meta({ description: "The new password to set" }),
+		token: z.string().meta({ description: "The token to reset the password" }).optional()
+	}),
+	metadata: { openapi: {
+		operationId: "resetPassword",
+		description: "Reset the password for a user",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { status: { type: "boolean" } }
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const token = ctx.body.token || ctx.query?.token;
+	if (!token) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_TOKEN });
+	const { newPassword } = ctx.body;
+	const minLength = ctx.context.password?.config.minPasswordLength;
+	const maxLength = ctx.context.password?.config.maxPasswordLength;
+	if (newPassword.length < minLength) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
+	if (newPassword.length > maxLength) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
+	const id = `reset-password:${token}`;
+	const verification = await ctx.context.internalAdapter.findVerificationValue(id);
+	if (!verification || verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_TOKEN });
+	const userId = verification.value;
+	const hashedPassword = await ctx.context.password.hash(newPassword);
+	if (!(await ctx.context.internalAdapter.findAccounts(userId)).find((ac) => ac.providerId === "credential")) await ctx.context.internalAdapter.createAccount({
+		userId,
+		providerId: "credential",
+		password: hashedPassword,
+		accountId: userId
+	});
+	else await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);
+	await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
+	if (ctx.context.options.emailAndPassword?.onPasswordReset) {
+		const user = await ctx.context.internalAdapter.findUserById(userId);
+		if (user) await ctx.context.options.emailAndPassword.onPasswordReset({ user }, ctx.request);
+	}
+	if (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) await ctx.context.internalAdapter.deleteSessions(userId);
+	return ctx.json({ status: true });
+});
+
+//#endregion
+//#region src/api/routes/sign-in.ts
+const signInSocial = createAuthEndpoint("/sign-in/social", {
+	method: "POST",
+	operationId: "socialSignIn",
+	body: z.object({
+		callbackURL: z.string().meta({ description: "Callback URL to redirect to after the user has signed in" }).optional(),
+		newUserCallbackURL: z.string().optional(),
+		errorCallbackURL: z.string().meta({ description: "Callback URL to redirect to if an error happens" }).optional(),
+		provider: SocialProviderListEnum,
+		disableRedirect: z.boolean().meta({ description: "Disable automatic redirection to the provider. Useful for handling the redirection yourself" }).optional(),
+		idToken: z.optional(z.object({
+			token: z.string().meta({ description: "ID token from the provider" }),
+			nonce: z.string().meta({ description: "Nonce used to generate the token" }).optional(),
+			accessToken: z.string().meta({ description: "Access token from the provider" }).optional(),
+			refreshToken: z.string().meta({ description: "Refresh token from the provider" }).optional(),
+			expiresAt: z.number().meta({ description: "Expiry date of the token" }).optional()
+		})),
+		scopes: z.array(z.string()).meta({ description: "Array of scopes to request from the provider. This will override the default scopes passed." }).optional(),
+		requestSignUp: z.boolean().meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider" }).optional(),
+		loginHint: z.string().meta({ description: "The login hint to use for the authorization code request" }).optional(),
+		additionalData: z.record(z.string(), z.any()).optional().meta({ description: "Additional data to be passed through the OAuth flow" })
+	}),
+	metadata: { openapi: {
+		description: "Sign in with a social provider",
+		operationId: "socialSignIn",
+		responses: { "200": {
+			description: "Success - Returns either session details or redirect URL",
+			content: { "application/json": { schema: {
+				type: "object",
+				description: "Session response when idToken is provided",
+				properties: {
+					token: { type: "string" },
+					user: {
+						type: "object",
+						$ref: "#/components/schemas/User"
+					},
+					url: { type: "string" },
+					redirect: {
+						type: "boolean",
+						enum: [false]
+					}
+				},
+				required: [
+					"redirect",
+					"token",
+					"user"
+				]
+			} } }
+		} }
+	} }
+}, async (c) => {
+	const provider = c.context.socialProviders.find((p) => p.id === c.body.provider);
+	if (!provider) {
+		c.context.logger.error("Provider not found. Make sure to add the provider in your auth config", { provider: c.body.provider });
+		throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });
+	}
+	if (c.body.idToken) {
+		if (!provider.verifyIdToken) {
+			c.context.logger.error("Provider does not support id token verification", { provider: c.body.provider });
+			throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED });
+		}
+		const { token, nonce } = c.body.idToken;
+		if (!await provider.verifyIdToken(token, nonce)) {
+			c.context.logger.error("Invalid id token", { provider: c.body.provider });
+			throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_TOKEN });
+		}
+		const userInfo = await provider.getUserInfo({
+			idToken: token,
+			accessToken: c.body.idToken.accessToken,
+			refreshToken: c.body.idToken.refreshToken
+		});
+		if (!userInfo || !userInfo?.user) {
+			c.context.logger.error("Failed to get user info", { provider: c.body.provider });
+			throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });
+		}
+		if (!userInfo.user.email) {
+			c.context.logger.error("User email not found", { provider: c.body.provider });
+			throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND });
+		}
+		const data = await handleOAuthUserInfo(c, {
+			userInfo: {
+				...userInfo.user,
+				email: userInfo.user.email,
+				id: String(userInfo.user.id),
+				name: userInfo.user.name || "",
+				image: userInfo.user.image,
+				emailVerified: userInfo.user.emailVerified || false
+			},
+			account: {
+				providerId: provider.id,
+				accountId: String(userInfo.user.id),
+				accessToken: c.body.idToken.accessToken
+			},
+			callbackURL: c.body.callbackURL,
+			disableSignUp: provider.disableImplicitSignUp && !c.body.requestSignUp || provider.disableSignUp
+		});
+		if (data.error) throw new APIError("UNAUTHORIZED", { message: data.error });
+		await setSessionCookie(c, data.data);
+		return c.json({
+			redirect: false,
+			token: data.data.session.token,
+			url: void 0,
+			user: {
+				id: data.data.user.id,
+				email: data.data.user.email,
+				name: data.data.user.name,
+				image: data.data.user.image,
+				emailVerified: data.data.user.emailVerified,
+				createdAt: data.data.user.createdAt,
+				updatedAt: data.data.user.updatedAt
+			}
+		});
+	}
+	const { codeVerifier, state } = await generateState(c, void 0, c.body.additionalData);
+	const url = await provider.createAuthorizationURL({
+		state,
+		codeVerifier,
+		redirectURI: `${c.context.baseURL}/callback/${provider.id}`,
+		scopes: c.body.scopes,
+		loginHint: c.body.loginHint
+	});
+	return c.json({
+		url: url.toString(),
+		redirect: !c.body.disableRedirect
+	});
+});
+const signInEmail = createAuthEndpoint("/sign-in/email", {
+	method: "POST",
+	operationId: "signInEmail",
+	body: z.object({
+		email: z.string().meta({ description: "Email of the user" }),
+		password: z.string().meta({ description: "Password of the user" }),
+		callbackURL: z.string().meta({ description: "Callback URL to use as a redirect for email verification" }).optional(),
+		rememberMe: z.boolean().meta({ description: "If this is false, the session will not be remembered. Default is `true`." }).default(true).optional()
+	}),
+	metadata: { openapi: {
+		operationId: "signInEmail",
+		description: "Sign in with email and password",
+		responses: { "200": {
+			description: "Success - Returns either session details or redirect URL",
+			content: { "application/json": { schema: {
+				type: "object",
+				description: "Session response when idToken is provided",
+				properties: {
+					redirect: {
+						type: "boolean",
+						enum: [false]
+					},
+					token: {
+						type: "string",
+						description: "Session token"
+					},
+					url: {
+						type: "null",
+						nullable: true
+					},
+					user: {
+						type: "object",
+						$ref: "#/components/schemas/User"
+					}
+				},
+				required: [
+					"redirect",
+					"token",
+					"user"
+				]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	if (!ctx.context.options?.emailAndPassword?.enabled) {
+		ctx.context.logger.error("Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!");
+		throw new APIError("BAD_REQUEST", { message: "Email and password is not enabled" });
+	}
+	const { email, password } = ctx.body;
+	if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+	const user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });
+	if (!user) {
+		await ctx.context.password.hash(password);
+		ctx.context.logger.error("User not found", { email });
+		throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
+	}
+	const credentialAccount = user.accounts.find((a) => a.providerId === "credential");
+	if (!credentialAccount) {
+		ctx.context.logger.error("Credential account not found", { email });
+		throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
+	}
+	const currentPassword = credentialAccount?.password;
+	if (!currentPassword) {
+		ctx.context.logger.error("Password not found", { email });
+		throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
+	}
+	if (!await ctx.context.password.verify({
+		hash: currentPassword,
+		password
+	})) {
+		ctx.context.logger.error("Invalid password");
+		throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD });
+	}
+	if (ctx.context.options?.emailAndPassword?.requireEmailVerification && !user.user.emailVerified) {
+		if (!ctx.context.options?.emailVerification?.sendVerificationEmail) throw new APIError("FORBIDDEN", { message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED });
+		if (ctx.context.options?.emailVerification?.sendOnSignIn) {
+			const token = await createEmailVerificationToken(ctx.context.secret, user.user.email, void 0, ctx.context.options.emailVerification?.expiresIn);
+			const callbackURL = ctx.body.callbackURL ? encodeURIComponent(ctx.body.callbackURL) : encodeURIComponent("/");
+			const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;
+			await ctx.context.options.emailVerification.sendVerificationEmail({
+				user: user.user,
+				url,
+				token
+			}, ctx.request);
+		}
+		throw new APIError("FORBIDDEN", { message: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED });
+	}
+	const session = await ctx.context.internalAdapter.createSession(user.user.id, ctx.body.rememberMe === false);
+	if (!session) {
+		ctx.context.logger.error("Failed to create session");
+		throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
+	}
+	await setSessionCookie(ctx, {
+		session,
+		user: user.user
+	}, ctx.body.rememberMe === false);
+	return ctx.json({
+		redirect: !!ctx.body.callbackURL,
+		token: session.token,
+		url: ctx.body.callbackURL,
+		user: {
+			id: user.user.id,
+			email: user.user.email,
+			name: user.user.name,
+			image: user.user.image,
+			emailVerified: user.user.emailVerified,
+			createdAt: user.user.createdAt,
+			updatedAt: user.user.updatedAt
+		}
+	});
+});
+
+//#endregion
+//#region src/api/routes/sign-out.ts
+const signOut = createAuthEndpoint("/sign-out", {
+	method: "POST",
+	operationId: "signOut",
+	requireHeaders: true,
+	metadata: { openapi: {
+		operationId: "signOut",
+		description: "Sign out the current user",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { success: { type: "boolean" } }
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);
+	if (!sessionCookieToken) {
+		deleteSessionCookie(ctx);
+		throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION });
+	}
+	await ctx.context.internalAdapter.deleteSession(sessionCookieToken);
+	deleteSessionCookie(ctx);
+	return ctx.json({ success: true });
+});
+
+//#endregion
+//#region src/api/routes/sign-up.ts
+const signUpEmail = () => createAuthEndpoint("/sign-up/email", {
+	method: "POST",
+	operationId: "signUpWithEmailAndPassword",
+	body: z.record(z.string(), z.any()),
+	metadata: {
+		$Infer: { body: {} },
+		openapi: {
+			operationId: "signUpWithEmailAndPassword",
+			description: "Sign up a user using email and password",
+			requestBody: { content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					name: {
+						type: "string",
+						description: "The name of the user"
+					},
+					email: {
+						type: "string",
+						description: "The email of the user"
+					},
+					password: {
+						type: "string",
+						description: "The password of the user"
+					},
+					image: {
+						type: "string",
+						description: "The profile image URL of the user"
+					},
+					callbackURL: {
+						type: "string",
+						description: "The URL to use for email verification callback"
+					},
+					rememberMe: {
+						type: "boolean",
+						description: "If this is false, the session will not be remembered. Default is `true`."
+					}
+				},
+				required: [
+					"name",
+					"email",
+					"password"
+				]
+			} } } },
+			responses: {
+				"200": {
+					description: "Successfully created user",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: {
+							token: {
+								type: "string",
+								nullable: true,
+								description: "Authentication token for the session"
+							},
+							user: {
+								type: "object",
+								properties: {
+									id: {
+										type: "string",
+										description: "The unique identifier of the user"
+									},
+									email: {
+										type: "string",
+										format: "email",
+										description: "The email address of the user"
+									},
+									name: {
+										type: "string",
+										description: "The name of the user"
+									},
+									image: {
+										type: "string",
+										format: "uri",
+										nullable: true,
+										description: "The profile image URL of the user"
+									},
+									emailVerified: {
+										type: "boolean",
+										description: "Whether the email has been verified"
+									},
+									createdAt: {
+										type: "string",
+										format: "date-time",
+										description: "When the user was created"
+									},
+									updatedAt: {
+										type: "string",
+										format: "date-time",
+										description: "When the user was last updated"
+									}
+								},
+								required: [
+									"id",
+									"email",
+									"name",
+									"emailVerified",
+									"createdAt",
+									"updatedAt"
+								]
+							}
+						},
+						required: ["user"]
+					} } }
+				},
+				"422": {
+					description: "Unprocessable Entity. User already exists or failed to create user.",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: { message: { type: "string" } }
+					} } }
+				}
+			}
+		}
+	}
+}, async (ctx) => {
+	return runWithTransaction(ctx.context.adapter, async () => {
+		if (!ctx.context.options.emailAndPassword?.enabled || ctx.context.options.emailAndPassword?.disableSignUp) throw new APIError("BAD_REQUEST", { message: "Email and password sign up is not enabled" });
+		const body = ctx.body;
+		const { name, email, password, image, callbackURL, rememberMe,...rest } = body;
+		if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+		const minPasswordLength = ctx.context.password.config.minPasswordLength;
+		if (password.length < minPasswordLength) {
+			ctx.context.logger.error("Password is too short");
+			throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
+		}
+		const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
+		if (password.length > maxPasswordLength) {
+			ctx.context.logger.error("Password is too long");
+			throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
+		}
+		if ((await ctx.context.internalAdapter.findUserByEmail(email))?.user) {
+			ctx.context.logger.info(`Sign-up attempt for existing email: ${email}`);
+			throw new APIError("UNPROCESSABLE_ENTITY", { message: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
+		}
+		/**
+		* Hash the password
+		*
+		* This is done prior to creating the user
+		* to ensure that any plugin that
+		* may break the hashing should break
+		* before the user is created.
+		*/
+		const hash = await ctx.context.password.hash(password);
+		let createdUser;
+		try {
+			const data = parseUserInput(ctx.context.options, rest, "create");
+			createdUser = await ctx.context.internalAdapter.createUser({
+				email: email.toLowerCase(),
+				name,
+				image,
+				...data,
+				emailVerified: false
+			});
+			if (!createdUser) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });
+		} catch (e) {
+			if (isDevelopment()) ctx.context.logger.error("Failed to create user", e);
+			if (e instanceof APIError) throw e;
+			ctx.context.logger?.error("Failed to create user", e);
+			throw new APIError("UNPROCESSABLE_ENTITY", {
+				message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,
+				details: e
+			});
+		}
+		if (!createdUser) throw new APIError("UNPROCESSABLE_ENTITY", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });
+		await ctx.context.internalAdapter.linkAccount({
+			userId: createdUser.id,
+			providerId: "credential",
+			accountId: createdUser.id,
+			password: hash
+		});
+		if (ctx.context.options.emailVerification?.sendOnSignUp || ctx.context.options.emailAndPassword.requireEmailVerification) {
+			const token = await createEmailVerificationToken(ctx.context.secret, createdUser.email, void 0, ctx.context.options.emailVerification?.expiresIn);
+			const callbackURL$1 = body.callbackURL ? encodeURIComponent(body.callbackURL) : encodeURIComponent("/");
+			const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL$1}`;
+			const args = ctx.request ? [{
+				user: createdUser,
+				url,
+				token
+			}, ctx.request] : [{
+				user: createdUser,
+				url,
+				token
+			}];
+			await ctx.context.options.emailVerification?.sendVerificationEmail?.(...args);
+		}
+		if (ctx.context.options.emailAndPassword.autoSignIn === false || ctx.context.options.emailAndPassword.requireEmailVerification) return ctx.json({
+			token: null,
+			user: {
+				id: createdUser.id,
+				email: createdUser.email,
+				name: createdUser.name,
+				image: createdUser.image,
+				emailVerified: createdUser.emailVerified,
+				createdAt: createdUser.createdAt,
+				updatedAt: createdUser.updatedAt
+			}
+		});
+		const session = await ctx.context.internalAdapter.createSession(createdUser.id, rememberMe === false);
+		if (!session) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
+		await setSessionCookie(ctx, {
+			session,
+			user: createdUser
+		}, rememberMe === false);
+		return ctx.json({
+			token: session.token,
+			user: {
+				id: createdUser.id,
+				email: createdUser.email,
+				name: createdUser.name,
+				image: createdUser.image,
+				emailVerified: createdUser.emailVerified,
+				createdAt: createdUser.createdAt,
+				updatedAt: createdUser.updatedAt
+			}
+		});
+	});
+});
+
+//#endregion
+//#region src/api/routes/update-user.ts
+const updateUser = () => createAuthEndpoint("/update-user", {
+	method: "POST",
+	operationId: "updateUser",
+	body: z.record(z.string().meta({ description: "Field name must be a string" }), z.any()),
+	use: [sessionMiddleware],
+	metadata: {
+		$Infer: { body: {} },
+		openapi: {
+			operationId: "updateUser",
+			description: "Update the current user",
+			requestBody: { content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					name: {
+						type: "string",
+						description: "The name of the user"
+					},
+					image: {
+						type: "string",
+						description: "The image of the user"
+					}
+				}
+			} } } },
+			responses: { "200": {
+				description: "Success",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { user: {
+						type: "object",
+						$ref: "#/components/schemas/User"
+					} }
+				} } }
+			} }
+		}
+	}
+}, async (ctx) => {
+	const body = ctx.body;
+	if (body.email) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.EMAIL_CAN_NOT_BE_UPDATED });
+	const { name, image,...rest } = body;
+	const session = ctx.context.session;
+	const additionalFields = parseUserInput(ctx.context.options, rest, "update");
+	if (image === void 0 && name === void 0 && Object.keys(additionalFields).length === 0) throw new APIError("BAD_REQUEST", { message: "No fields to update" });
+	const user = await ctx.context.internalAdapter.updateUser(session.user.id, {
+		name,
+		image,
+		...additionalFields
+	});
+	/**
+	* Update the session cookie with the new user data
+	*/
+	await setSessionCookie(ctx, {
+		session: session.session,
+		user
+	});
+	return ctx.json({ status: true });
+});
+const changePassword = createAuthEndpoint("/change-password", {
+	method: "POST",
+	operationId: "changePassword",
+	body: z.object({
+		newPassword: z.string().meta({ description: "The new password to set" }),
+		currentPassword: z.string().meta({ description: "The current password is required" }),
+		revokeOtherSessions: z.boolean().meta({ description: "Must be a boolean value" }).optional()
+	}),
+	use: [sensitiveSessionMiddleware],
+	metadata: { openapi: {
+		operationId: "changePassword",
+		description: "Change the password of the user",
+		responses: { "200": {
+			description: "Password successfully changed",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					token: {
+						type: "string",
+						nullable: true,
+						description: "New session token if other sessions were revoked"
+					},
+					user: {
+						type: "object",
+						properties: {
+							id: {
+								type: "string",
+								description: "The unique identifier of the user"
+							},
+							email: {
+								type: "string",
+								format: "email",
+								description: "The email address of the user"
+							},
+							name: {
+								type: "string",
+								description: "The name of the user"
+							},
+							image: {
+								type: "string",
+								format: "uri",
+								nullable: true,
+								description: "The profile image URL of the user"
+							},
+							emailVerified: {
+								type: "boolean",
+								description: "Whether the email has been verified"
+							},
+							createdAt: {
+								type: "string",
+								format: "date-time",
+								description: "When the user was created"
+							},
+							updatedAt: {
+								type: "string",
+								format: "date-time",
+								description: "When the user was last updated"
+							}
+						},
+						required: [
+							"id",
+							"email",
+							"name",
+							"emailVerified",
+							"createdAt",
+							"updatedAt"
+						]
+					}
+				},
+				required: ["user"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const { newPassword, currentPassword, revokeOtherSessions: revokeOtherSessions$1 } = ctx.body;
+	const session = ctx.context.session;
+	const minPasswordLength = ctx.context.password.config.minPasswordLength;
+	if (newPassword.length < minPasswordLength) {
+		ctx.context.logger.error("Password is too short");
+		throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
+	}
+	const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
+	if (newPassword.length > maxPasswordLength) {
+		ctx.context.logger.error("Password is too long");
+		throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
+	}
+	const account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === "credential" && account$1.password);
+	if (!account || !account.password) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND });
+	const passwordHash = await ctx.context.password.hash(newPassword);
+	if (!await ctx.context.password.verify({
+		hash: account.password,
+		password: currentPassword
+	})) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
+	await ctx.context.internalAdapter.updateAccount(account.id, { password: passwordHash });
+	let token = null;
+	if (revokeOtherSessions$1) {
+		await ctx.context.internalAdapter.deleteSessions(session.user.id);
+		const newSession = await ctx.context.internalAdapter.createSession(session.user.id);
+		if (!newSession) throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION });
+		await setSessionCookie(ctx, {
+			session: newSession,
+			user: session.user
+		});
+		token = newSession.token;
+	}
+	return ctx.json({
+		token,
+		user: {
+			id: session.user.id,
+			email: session.user.email,
+			name: session.user.name,
+			image: session.user.image,
+			emailVerified: session.user.emailVerified,
+			createdAt: session.user.createdAt,
+			updatedAt: session.user.updatedAt
+		}
+	});
+});
+const setPassword = createAuthEndpoint("/set-password", {
+	method: "POST",
+	body: z.object({ newPassword: z.string().meta({ description: "The new password to set is required" }) }),
+	metadata: { SERVER_ONLY: true },
+	use: [sensitiveSessionMiddleware]
+}, async (ctx) => {
+	const { newPassword } = ctx.body;
+	const session = ctx.context.session;
+	const minPasswordLength = ctx.context.password.config.minPasswordLength;
+	if (newPassword.length < minPasswordLength) {
+		ctx.context.logger.error("Password is too short");
+		throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
+	}
+	const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
+	if (newPassword.length > maxPasswordLength) {
+		ctx.context.logger.error("Password is too long");
+		throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
+	}
+	const account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === "credential" && account$1.password);
+	const passwordHash = await ctx.context.password.hash(newPassword);
+	if (!account) {
+		await ctx.context.internalAdapter.linkAccount({
+			userId: session.user.id,
+			providerId: "credential",
+			accountId: session.user.id,
+			password: passwordHash
+		});
+		return ctx.json({ status: true });
+	}
+	throw new APIError("BAD_REQUEST", { message: "user already has a password" });
+});
+const deleteUser = createAuthEndpoint("/delete-user", {
+	method: "POST",
+	use: [sensitiveSessionMiddleware],
+	body: z.object({
+		callbackURL: z.string().meta({ description: "The callback URL to redirect to after the user is deleted" }).optional(),
+		password: z.string().meta({ description: "The password of the user is required to delete the user" }).optional(),
+		token: z.string().meta({ description: "The token to delete the user is required" }).optional()
+	}),
+	metadata: { openapi: {
+		operationId: "deleteUser",
+		description: "Delete the user",
+		requestBody: { content: { "application/json": { schema: {
+			type: "object",
+			properties: {
+				callbackURL: {
+					type: "string",
+					description: "The callback URL to redirect to after the user is deleted"
+				},
+				password: {
+					type: "string",
+					description: "The user's password. Required if session is not fresh"
+				},
+				token: {
+					type: "string",
+					description: "The deletion verification token"
+				}
+			}
+		} } } },
+		responses: { "200": {
+			description: "User deletion processed successfully",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					success: {
+						type: "boolean",
+						description: "Indicates if the operation was successful"
+					},
+					message: {
+						type: "string",
+						enum: ["User deleted", "Verification email sent"],
+						description: "Status message of the deletion process"
+					}
+				},
+				required: ["success", "message"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	if (!ctx.context.options.user?.deleteUser?.enabled) {
+		ctx.context.logger.error("Delete user is disabled. Enable it in the options");
+		throw new APIError("NOT_FOUND");
+	}
+	const session = ctx.context.session;
+	if (ctx.body.password) {
+		const account = (await ctx.context.internalAdapter.findAccounts(session.user.id)).find((account$1) => account$1.providerId === "credential" && account$1.password);
+		if (!account || !account.password) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND });
+		if (!await ctx.context.password.verify({
+			hash: account.password,
+			password: ctx.body.password
+		})) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
+	}
+	if (ctx.body.token) {
+		await deleteUserCallback({
+			...ctx,
+			query: { token: ctx.body.token }
+		});
+		return ctx.json({
+			success: true,
+			message: "User deleted"
+		});
+	}
+	if (ctx.context.options.user.deleteUser?.sendDeleteAccountVerification) {
+		const token = generateRandomString(32, "0-9", "a-z");
+		await ctx.context.internalAdapter.createVerificationValue({
+			value: session.user.id,
+			identifier: `delete-account-${token}`,
+			expiresAt: new Date(Date.now() + (ctx.context.options.user.deleteUser?.deleteTokenExpiresIn || 3600 * 24) * 1e3)
+		});
+		const url = `${ctx.context.baseURL}/delete-user/callback?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
+		await ctx.context.options.user.deleteUser.sendDeleteAccountVerification({
+			user: session.user,
+			url,
+			token
+		}, ctx.request);
+		return ctx.json({
+			success: true,
+			message: "Verification email sent"
+		});
+	}
+	if (!ctx.body.password && ctx.context.sessionConfig.freshAge !== 0) {
+		const currentAge = new Date(session.session.createdAt).getTime();
+		const freshAge = ctx.context.sessionConfig.freshAge * 1e3;
+		if (Date.now() - currentAge > freshAge * 1e3) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.SESSION_EXPIRED });
+	}
+	const beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;
+	if (beforeDelete) await beforeDelete(session.user, ctx.request);
+	await ctx.context.internalAdapter.deleteUser(session.user.id);
+	await ctx.context.internalAdapter.deleteSessions(session.user.id);
+	deleteSessionCookie(ctx);
+	const afterDelete = ctx.context.options.user.deleteUser?.afterDelete;
+	if (afterDelete) await afterDelete(session.user, ctx.request);
+	return ctx.json({
+		success: true,
+		message: "User deleted"
+	});
+});
+const deleteUserCallback = createAuthEndpoint("/delete-user/callback", {
+	method: "GET",
+	query: z.object({
+		token: z.string().meta({ description: "The token to verify the deletion request" }),
+		callbackURL: z.string().meta({ description: "The URL to redirect to after deletion" }).optional()
+	}),
+	use: [originCheck((ctx) => ctx.query.callbackURL)],
+	metadata: { openapi: {
+		description: "Callback to complete user deletion with verification token",
+		responses: { "200": {
+			description: "User successfully deleted",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					success: {
+						type: "boolean",
+						description: "Indicates if the deletion was successful"
+					},
+					message: {
+						type: "string",
+						enum: ["User deleted"],
+						description: "Confirmation message"
+					}
+				},
+				required: ["success", "message"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	if (!ctx.context.options.user?.deleteUser?.enabled) {
+		ctx.context.logger.error("Delete user is disabled. Enable it in the options");
+		throw new APIError("NOT_FOUND");
+	}
+	const session = await getSessionFromCtx(ctx);
+	if (!session) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO });
+	const token = await ctx.context.internalAdapter.findVerificationValue(`delete-account-${ctx.query.token}`);
+	if (!token || token.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.INVALID_TOKEN });
+	if (token.value !== session.user.id) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.INVALID_TOKEN });
+	const beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;
+	if (beforeDelete) await beforeDelete(session.user, ctx.request);
+	await ctx.context.internalAdapter.deleteUser(session.user.id);
+	await ctx.context.internalAdapter.deleteSessions(session.user.id);
+	await ctx.context.internalAdapter.deleteAccounts(session.user.id);
+	await ctx.context.internalAdapter.deleteVerificationValue(token.id);
+	deleteSessionCookie(ctx);
+	const afterDelete = ctx.context.options.user.deleteUser?.afterDelete;
+	if (afterDelete) await afterDelete(session.user, ctx.request);
+	if (ctx.query.callbackURL) throw ctx.redirect(ctx.query.callbackURL || "/");
+	return ctx.json({
+		success: true,
+		message: "User deleted"
+	});
+});
+const changeEmail = createAuthEndpoint("/change-email", {
+	method: "POST",
+	body: z.object({
+		newEmail: z.string().email().meta({ description: "The new email address to set must be a valid email address" }),
+		callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
+	}),
+	use: [sensitiveSessionMiddleware],
+	metadata: { openapi: {
+		operationId: "changeEmail",
+		responses: {
+			"200": {
+				description: "Email change request processed successfully",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						user: {
+							type: "object",
+							$ref: "#/components/schemas/User"
+						},
+						status: {
+							type: "boolean",
+							description: "Indicates if the request was successful"
+						},
+						message: {
+							type: "string",
+							enum: ["Email updated", "Verification email sent"],
+							description: "Status message of the email change process",
+							nullable: true
+						}
+					},
+					required: ["status"]
+				} } }
+			},
+			"422": {
+				description: "Unprocessable Entity. Email already exists",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { message: { type: "string" } }
+				} } }
+			}
+		}
+	} }
+}, async (ctx) => {
+	if (!ctx.context.options.user?.changeEmail?.enabled) {
+		ctx.context.logger.error("Change email is disabled.");
+		throw new APIError("BAD_REQUEST", { message: "Change email is disabled" });
+	}
+	const newEmail = ctx.body.newEmail.toLowerCase();
+	if (newEmail === ctx.context.session.user.email) {
+		ctx.context.logger.error("Email is the same");
+		throw new APIError("BAD_REQUEST", { message: "Email is the same" });
+	}
+	if (await ctx.context.internalAdapter.findUserByEmail(newEmail)) {
+		ctx.context.logger.error("Email already exists");
+		throw new APIError("UNPROCESSABLE_ENTITY", { message: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
+	}
+	/**
+	* If the email is not verified, we can update the email
+	*/
+	if (ctx.context.session.user.emailVerified !== true) {
+		await ctx.context.internalAdapter.updateUserByEmail(ctx.context.session.user.email, { email: newEmail });
+		await setSessionCookie(ctx, {
+			session: ctx.context.session.session,
+			user: {
+				...ctx.context.session.user,
+				email: newEmail
+			}
+		});
+		if (ctx.context.options.emailVerification?.sendVerificationEmail) {
+			const token$1 = await createEmailVerificationToken(ctx.context.secret, newEmail, void 0, ctx.context.options.emailVerification?.expiresIn);
+			const url$1 = `${ctx.context.baseURL}/verify-email?token=${token$1}&callbackURL=${ctx.body.callbackURL || "/"}`;
+			await ctx.context.options.emailVerification.sendVerificationEmail({
+				user: {
+					...ctx.context.session.user,
+					email: newEmail
+				},
+				url: url$1,
+				token: token$1
+			}, ctx.request);
+		}
+		return ctx.json({ status: true });
+	}
+	/**
+	* If the email is verified, we need to send a verification email
+	*/
+	if (!ctx.context.options.user.changeEmail.sendChangeEmailVerification) {
+		ctx.context.logger.error("Verification email isn't enabled.");
+		throw new APIError("BAD_REQUEST", { message: "Verification email isn't enabled" });
+	}
+	const token = await createEmailVerificationToken(ctx.context.secret, ctx.context.session.user.email, newEmail, ctx.context.options.emailVerification?.expiresIn);
+	const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
+	await ctx.context.options.user.changeEmail.sendChangeEmailVerification({
+		user: ctx.context.session.user,
+		newEmail,
+		url,
+		token
+	}, ctx.request);
+	return ctx.json({ status: true });
+});
+
+//#endregion
+//#region src/api/to-auth-endpoints.ts
+const defuReplaceArrays = createDefu((obj, key, value) => {
+	if (Array.isArray(obj[key]) && Array.isArray(value)) {
+		obj[key] = value;
+		return true;
+	}
+});
+function toAuthEndpoints(endpoints, ctx) {
+	const api = {};
+	for (const [key, endpoint] of Object.entries(endpoints)) {
+		api[key] = async (context) => {
+			const run = async () => {
+				const authContext = await ctx;
+				let internalContext = {
+					...context,
+					context: {
+						...authContext,
+						returned: void 0,
+						responseHeaders: void 0,
+						session: null
+					},
+					path: endpoint.path,
+					headers: context?.headers ? new Headers(context?.headers) : void 0
+				};
+				return runWithEndpointContext(internalContext, async () => {
+					const { beforeHooks, afterHooks } = getHooks(authContext);
+					const before = await runBeforeHooks(internalContext, beforeHooks);
+					/**
+					* If `before.context` is returned, it should
+					* get merged with the original context
+					*/
+					if ("context" in before && before.context && typeof before.context === "object") {
+						const { headers,...rest } = before.context;
+						/**
+						* Headers should be merged differently
+						* so the hook doesn't override the whole
+						* header
+						*/
+						if (headers) headers.forEach((value, key$1) => {
+							internalContext.headers.set(key$1, value);
+						});
+						internalContext = defuReplaceArrays(rest, internalContext);
+					} else if (before) return context?.asResponse ? toResponse(before, { headers: context?.headers }) : context?.returnHeaders ? {
+						headers: context?.headers,
+						response: before
+					} : before;
+					internalContext.asResponse = false;
+					internalContext.returnHeaders = true;
+					internalContext.returnStatus = true;
+					const result = await runWithEndpointContext(internalContext, () => endpoint(internalContext)).catch((e) => {
+						if (e instanceof APIError)
+ /**
+						* API Errors from response are caught
+						* and returned to hooks
+						*/
+						return {
+							response: e,
+							status: e.statusCode,
+							headers: e.headers ? new Headers(e.headers) : null
+						};
+						throw e;
+					});
+					if (result && result instanceof Response) return result;
+					internalContext.context.returned = result.response;
+					internalContext.context.responseHeaders = result.headers;
+					const after = await runAfterHooks(internalContext, afterHooks);
+					if (after.response) result.response = after.response;
+					if (result.response instanceof APIError && shouldPublishLog(authContext.logger.level, "debug")) result.response.stack = result.response.errorStack;
+					if (result.response instanceof APIError && !context?.asResponse) throw result.response;
+					return context?.asResponse ? toResponse(result.response, {
+						headers: result.headers,
+						status: result.status
+					}) : context?.returnHeaders ? context?.returnStatus ? {
+						headers: result.headers,
+						response: result.response,
+						status: result.status
+					} : {
+						headers: result.headers,
+						response: result.response
+					} : context?.returnStatus ? {
+						response: result.response,
+						status: result.status
+					} : result.response;
+				});
+			};
+			if (await hasRequestState()) return run();
+			else return runWithRequestState(/* @__PURE__ */ new WeakMap(), run);
+		};
+		api[key].path = endpoint.path;
+		api[key].options = endpoint.options;
+	}
+	return api;
+}
+async function runBeforeHooks(context, hooks) {
+	let modifiedContext = {};
+	for (const hook of hooks) if (hook.matcher(context)) {
+		const result = await hook.handler({
+			...context,
+			returnHeaders: false
+		}).catch((e) => {
+			if (e instanceof APIError && shouldPublishLog(context.context.logger.level, "debug")) e.stack = e.errorStack;
+			throw e;
+		});
+		if (result && typeof result === "object") {
+			if ("context" in result && typeof result.context === "object") {
+				const { headers,...rest } = result.context;
+				if (headers instanceof Headers) if (modifiedContext.headers) headers.forEach((value, key) => {
+					modifiedContext.headers?.set(key, value);
+				});
+				else modifiedContext.headers = headers;
+				modifiedContext = defuReplaceArrays(rest, modifiedContext);
+				continue;
+			}
+			return result;
+		}
+	}
+	return { context: modifiedContext };
+}
+async function runAfterHooks(context, hooks) {
+	for (const hook of hooks) if (hook.matcher(context)) {
+		const result = await hook.handler(context).catch((e) => {
+			if (e instanceof APIError) {
+				if (shouldPublishLog(context.context.logger.level, "debug")) e.stack = e.errorStack;
+				return {
+					response: e,
+					headers: e.headers ? new Headers(e.headers) : null
+				};
+			}
+			throw e;
+		});
+		if (result.headers) result.headers.forEach((value, key) => {
+			if (!context.context.responseHeaders) context.context.responseHeaders = new Headers({ [key]: value });
+			else if (key.toLowerCase() === "set-cookie") context.context.responseHeaders.append(key, value);
+			else context.context.responseHeaders.set(key, value);
+		});
+		if (result.response) context.context.returned = result.response;
+	}
+	return {
+		response: context.context.returned,
+		headers: context.context.responseHeaders
+	};
+}
+function getHooks(authContext) {
+	const plugins = authContext.options.plugins || [];
+	const beforeHooks = [];
+	const afterHooks = [];
+	if (authContext.options.hooks?.before) beforeHooks.push({
+		matcher: () => true,
+		handler: authContext.options.hooks.before
+	});
+	if (authContext.options.hooks?.after) afterHooks.push({
+		matcher: () => true,
+		handler: authContext.options.hooks.after
+	});
+	const pluginBeforeHooks = plugins.map((plugin) => {
+		if (plugin.hooks?.before) return plugin.hooks.before;
+	}).filter((plugin) => plugin !== void 0).flat();
+	const pluginAfterHooks = plugins.map((plugin) => {
+		if (plugin.hooks?.after) return plugin.hooks.after;
+	}).filter((plugin) => plugin !== void 0).flat();
+	/**
+	* Add plugin added hooks at last
+	*/
+	if (pluginBeforeHooks.length) beforeHooks.push(...pluginBeforeHooks);
+	if (pluginAfterHooks.length) afterHooks.push(...pluginAfterHooks);
+	return {
+		beforeHooks,
+		afterHooks
+	};
+}
+
+//#endregion
+//#region src/api/index.ts
+function checkEndpointConflicts(options, logger$1) {
+	const endpointRegistry = /* @__PURE__ */ new Map();
+	options.plugins?.forEach((plugin) => {
+		if (plugin.endpoints) {
+			for (const [key, endpoint] of Object.entries(plugin.endpoints)) if (endpoint && "path" in endpoint) {
+				const path = endpoint.path;
+				let methods = [];
+				if (endpoint.options && "method" in endpoint.options) {
+					if (Array.isArray(endpoint.options.method)) methods = endpoint.options.method;
+					else if (typeof endpoint.options.method === "string") methods = [endpoint.options.method];
+				}
+				if (methods.length === 0) methods = ["*"];
+				if (!endpointRegistry.has(path)) endpointRegistry.set(path, []);
+				endpointRegistry.get(path).push({
+					pluginId: plugin.id,
+					endpointKey: key,
+					methods
+				});
+			}
+		}
+	});
+	const conflicts = [];
+	for (const [path, entries] of endpointRegistry.entries()) if (entries.length > 1) {
+		const methodMap = /* @__PURE__ */ new Map();
+		let hasConflict = false;
+		for (const entry of entries) for (const method of entry.methods) {
+			if (!methodMap.has(method)) methodMap.set(method, []);
+			methodMap.get(method).push(entry.pluginId);
+			if (methodMap.get(method).length > 1) hasConflict = true;
+			if (method === "*" && entries.length > 1) hasConflict = true;
+			else if (method !== "*" && methodMap.has("*")) hasConflict = true;
+		}
+		if (hasConflict) {
+			const uniquePlugins = [...new Set(entries.map((e) => e.pluginId))];
+			const conflictingMethods = [];
+			for (const [method, plugins] of methodMap.entries()) if (plugins.length > 1 || method === "*" && entries.length > 1 || method !== "*" && methodMap.has("*")) conflictingMethods.push(method);
+			conflicts.push({
+				path,
+				plugins: uniquePlugins,
+				conflictingMethods
+			});
+		}
+	}
+	if (conflicts.length > 0) {
+		const conflictMessages = conflicts.map((conflict) => `  - "${conflict.path}" [${conflict.conflictingMethods.join(", ")}] used by plugins: ${conflict.plugins.join(", ")}`).join("\n");
+		logger$1.error(`Endpoint path conflicts detected! Multiple plugins are trying to use the same endpoint paths with conflicting HTTP methods:
+${conflictMessages}
+
+To resolve this, you can:
+	1. Use only one of the conflicting plugins
+	2. Configure the plugins to use different paths (if supported)
+	3. Ensure plugins use different HTTP methods for the same path
+`);
+	}
+}
+function getEndpoints(ctx, options) {
+	const pluginEndpoints = options.plugins?.reduce((acc, plugin) => {
+		return {
+			...acc,
+			...plugin.endpoints
+		};
+	}, {}) ?? {};
+	const middlewares = options.plugins?.map((plugin) => plugin.middlewares?.map((m) => {
+		const middleware = (async (context) => {
+			const authContext = await ctx;
+			return m.middleware({
+				...context,
+				context: {
+					...authContext,
+					...context.context
+				}
+			});
+		});
+		middleware.options = m.middleware.options;
+		return {
+			path: m.path,
+			middleware
+		};
+	})).filter((plugin) => plugin !== void 0).flat() || [];
+	return {
+		api: toAuthEndpoints({
+			signInSocial,
+			callbackOAuth,
+			getSession: getSession(),
+			signOut,
+			signUpEmail: signUpEmail(),
+			signInEmail,
+			resetPassword,
+			verifyEmail,
+			sendVerificationEmail,
+			changeEmail,
+			changePassword,
+			setPassword,
+			updateUser: updateUser(),
+			deleteUser,
+			requestPasswordReset,
+			requestPasswordResetCallback,
+			listSessions: listSessions(),
+			revokeSession,
+			revokeSessions,
+			revokeOtherSessions,
+			linkSocialAccount,
+			listUserAccounts,
+			deleteUserCallback,
+			unlinkAccount,
+			refreshToken,
+			getAccessToken,
+			accountInfo,
+			...pluginEndpoints,
+			ok,
+			error
+		}, ctx),
+		middlewares
+	};
+}
+const router = (ctx, options) => {
+	const { api, middlewares } = getEndpoints(ctx, options);
+	const basePath = new URL(ctx.baseURL).pathname;
+	return createRouter(api, {
+		routerContext: ctx,
+		openapi: { disabled: true },
+		basePath,
+		routerMiddleware: [{
+			path: "/**",
+			middleware: originCheckMiddleware
+		}, ...middlewares],
+		async onRequest(req) {
+			const disabledPaths = ctx.options.disabledPaths || [];
+			const path = new URL(req.url).pathname.replace(basePath, "");
+			if (disabledPaths.includes(path)) return new Response("Not Found", { status: 404 });
+			for (const plugin of ctx.options.plugins || []) if (plugin.onRequest) {
+				const response = await plugin.onRequest(req, ctx);
+				if (response && "response" in response) return response.response;
+				if (response && "request" in response) {
+					const rateLimitResponse$1 = await onRequestRateLimit(response.request, ctx);
+					if (rateLimitResponse$1) return rateLimitResponse$1;
+					return response.request;
+				}
+			}
+			return onRequestRateLimit(req, ctx);
+		},
+		async onResponse(res) {
+			for (const plugin of ctx.options.plugins || []) if (plugin.onResponse) {
+				const response = await plugin.onResponse(res, ctx);
+				if (response) return response.response;
+			}
+			return res;
+		},
+		onError(e) {
+			if (e instanceof APIError && e.status === "FOUND") return;
+			if (options.onAPIError?.throw) throw e;
+			if (options.onAPIError?.onError) {
+				options.onAPIError.onError(e, ctx);
+				return;
+			}
+			const optLogLevel = options.logger?.level;
+			const log = optLogLevel === "error" || optLogLevel === "warn" || optLogLevel === "debug" ? logger : void 0;
+			if (options.logger?.disabled !== true) {
+				if (e && typeof e === "object" && "message" in e && typeof e.message === "string") {
+					if (e.message.includes("no column") || e.message.includes("column") || e.message.includes("relation") || e.message.includes("table") || e.message.includes("does not exist")) {
+						ctx.logger?.error(e.message);
+						return;
+					}
+				}
+				if (e instanceof APIError) {
+					if (e.status === "INTERNAL_SERVER_ERROR") ctx.logger.error(e.status, e);
+					log?.error(e.message);
+				} else ctx.logger?.error(e && typeof e === "object" && "name" in e ? e.name : "", e);
+			}
+		}
+	});
+};
+
+//#endregion
+export { getAccessToken as A, createEmailVerificationToken as C, callbackOAuth as D, verifyEmail as E, decryptOAuthToken as F, setTokenUtil as I, isSimpleRequest as L, listUserAccounts as M, refreshToken as N, handleOAuthUserInfo as O, unlinkAccount as P, originCheck as R, error as S, sendVerificationEmailFn as T, signInSocial as _, getEndpoints as a, resetPassword as b, changeEmail as c, deleteUserCallback as d, setPassword as f, signInEmail as g, signOut as h, createAuthMiddleware$1 as i, linkSocialAccount as j, accountInfo as k, changePassword as l, signUpEmail as m, checkEndpointConflicts as n, optionsMiddleware as o, updateUser as p, createAuthEndpoint$1 as r, router as s, APIError$1 as t, deleteUser as u, requestPasswordReset as v, sendVerificationEmail as w, ok as x, requestPasswordResetCallback as y, originCheckMiddleware as z };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/api/index.mjs.bak b/node_modules/better-auth/dist/api/index.mjs.bak
new file mode 100644
index 0000000..a62919e
--- /dev/null
+++ b/node_modules/better-auth/dist/api/index.mjs.bak
@@ -0,0 +1,17 @@
+import "../dialect-BhkkSrrx.mjs";
+import "../get-model-name-nJd9iPTo.mjs";
+import "../get-migration-C1tgKlQ6.mjs";
+import "../types-BReKsBV6.mjs";
+import { a as getOAuthState } from "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import "../schema-BevzneML.mjs";
+import { t as getIp } from "../get-request-ip-kbu825ez.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import { A as getAccessToken, C as createEmailVerificationToken, D as callbackOAuth, E as verifyEmail, L as isSimpleRequest, M as listUserAccounts, N as refreshToken, P as unlinkAccount, R as originCheck, S as error, T as sendVerificationEmailFn, _ as signInSocial, a as getEndpoints, b as resetPassword, c as changeEmail, d as deleteUserCallback, f as setPassword, g as signInEmail, h as signOut, i as createAuthMiddleware, j as linkSocialAccount, k as accountInfo, l as changePassword, m as signUpEmail, n as checkEndpointConflicts, o as optionsMiddleware, p as updateUser, r as createAuthEndpoint, s as router, t as APIError, u as deleteUser, v as requestPasswordReset, w as sendVerificationEmail, x as ok, y as requestPasswordResetCallback, z as originCheckMiddleware } from "../api-C0IsrmGz.mjs";
+import "../cookies-Cl2L38B1.mjs";
+import { a as requestOnlySessionMiddleware, c as revokeSessions, i as listSessions, l as sensitiveSessionMiddleware, n as getSession, o as revokeOtherSessions, r as getSessionFromCtx, s as revokeSession, t as freshSessionMiddleware, u as sessionMiddleware } from "../session-Efap-vxj.mjs";
+
+export { APIError, accountInfo, callbackOAuth, changeEmail, changePassword, checkEndpointConflicts, createAuthEndpoint, createAuthMiddleware, createEmailVerificationToken, deleteUser, deleteUserCallback, error, freshSessionMiddleware, getAccessToken, getEndpoints, getIp, getOAuthState, getSession, getSessionFromCtx, isSimpleRequest, linkSocialAccount, listSessions, listUserAccounts, ok, optionsMiddleware, originCheck, originCheckMiddleware, refreshToken, requestOnlySessionMiddleware, requestPasswordReset, requestPasswordResetCallback, resetPassword, revokeOtherSessions, revokeSession, revokeSessions, router, sendVerificationEmail, sendVerificationEmailFn, sensitiveSessionMiddleware, sessionMiddleware, setPassword, signInEmail, signInSocial, signOut, signUpEmail, unlinkAccount, updateUser, verifyEmail };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/auth-DG0t9Q_P.mjs.bak b/node_modules/better-auth/dist/auth-DG0t9Q_P.mjs.bak
new file mode 100644
index 0000000..e1bfd79
--- /dev/null
+++ b/node_modules/better-auth/dist/auth-DG0t9Q_P.mjs.bak
@@ -0,0 +1,31 @@
+import { n as getKyselyDatabaseType } from "./dialect-BhkkSrrx.mjs";
+import { t as getMigrations, u as getAdapter } from "./get-migration-C1tgKlQ6.mjs";
+import { n as createAuthContext, t as createBetterAuth } from "./base-DtHhS6VT.mjs";
+import { BetterAuthError } from "@better-auth/core/error";
+
+//#region src/context/init.ts
+const init = async (options) => {
+	const adapter = await getAdapter(options);
+	const getDatabaseType = (database) => getKyselyDatabaseType(database) || "unknown";
+	const ctx = await createAuthContext(adapter, options, getDatabaseType);
+	ctx.runMigrations = async function() {
+		if (!options.database || "updateMany" in options.database) throw new BetterAuthError("Database is not provided or it's an adapter. Migrations are only supported with a database instance.");
+		const { runMigrations } = await getMigrations(options);
+		await runMigrations();
+	};
+	return ctx;
+};
+
+//#endregion
+//#region src/auth/auth.ts
+/**
+* Better Auth initializer for full mode (with Kysely)
+*
+* Check `minimal.ts` for minimal mode (without Kysely)
+*/
+const betterAuth = (options) => {
+	return createBetterAuth(options, init);
+};
+
+//#endregion
+export { betterAuth as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/auth/minimal.mjs.bak b/node_modules/better-auth/dist/auth/minimal.mjs.bak
new file mode 100644
index 0000000..6172b70
--- /dev/null
+++ b/node_modules/better-auth/dist/auth/minimal.mjs.bak
@@ -0,0 +1,43 @@
+import "../dialect-BhkkSrrx.mjs";
+import "../get-model-name-nJd9iPTo.mjs";
+import { d as getBaseAdapter } from "../get-migration-C1tgKlQ6.mjs";
+import "../types-BReKsBV6.mjs";
+import "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import "../schema-BevzneML.mjs";
+import "../get-request-ip-kbu825ez.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import "../api-C0IsrmGz.mjs";
+import "../cookies-Cl2L38B1.mjs";
+import "../session-Efap-vxj.mjs";
+import { n as createAuthContext, t as createBetterAuth } from "../base-DtHhS6VT.mjs";
+import "../password-DWi8yN3A.mjs";
+import { BetterAuthError } from "@better-auth/core/error";
+
+//#region src/context/init-minimal.ts
+const initMinimal = async (options) => {
+	const adapter = await getBaseAdapter(options, async () => {
+		throw new BetterAuthError("Direct database connection requires Kysely. Please use `better-auth` instead of `better-auth/minimal`, or provide an adapter (drizzleAdapter, prismaAdapter, etc.)");
+	});
+	const getDatabaseType = (_database) => "unknown";
+	const ctx = await createAuthContext(adapter, options, getDatabaseType);
+	ctx.runMigrations = async function() {
+		throw new BetterAuthError("Migrations are not supported in 'better-auth/minimal'. Please use 'better-auth' for migration support.");
+	};
+	return ctx;
+};
+
+//#endregion
+//#region src/auth/minimal.ts
+/**
+* Better Auth initializer for minimal mode (without Kysely)
+*/
+const betterAuth = (options) => {
+	return createBetterAuth(options, initMinimal);
+};
+
+//#endregion
+export { betterAuth };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/base-DtHhS6VT.mjs.bak b/node_modules/better-auth/dist/base-DtHhS6VT.mjs.bak
new file mode 100644
index 0000000..21f3186
--- /dev/null
+++ b/node_modules/better-auth/dist/base-DtHhS6VT.mjs.bak
@@ -0,0 +1,240 @@
+import { a as getAuthTables } from "./get-model-name-nJd9iPTo.mjs";
+import { a as createInternalAdapter } from "./get-migration-C1tgKlQ6.mjs";
+import { t as generateId } from "./utils-F62c-ieM.mjs";
+import { a as verifyPassword, i as hashPassword } from "./crypto-DZW3hrq1.mjs";
+import { r as getOrigin, t as getBaseURL } from "./url-SXU3XD3W.mjs";
+import { a as getEndpoints, n as checkEndpointConflicts, s as router } from "./api-C0IsrmGz.mjs";
+import { i as getCookies, t as createCookieGetter } from "./cookies-Cl2L38B1.mjs";
+import { t as checkPassword } from "./password-DWi8yN3A.mjs";
+import { runWithAdapter } from "@better-auth/core/context";
+import { createLogger, env, isProduction, isTest } from "@better-auth/core/env";
+import { BASE_ERROR_CODES, BetterAuthError } from "@better-auth/core/error";
+import { socialProviders } from "@better-auth/core/social-providers";
+import { createTelemetry } from "@better-auth/telemetry";
+import defu$1, { defu } from "defu";
+
+//#region src/utils/constants.ts
+const DEFAULT_SECRET = "better-auth-secret-123456789";
+
+//#endregion
+//#region src/utils/is-promise.ts
+function isPromise(obj) {
+	return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
+}
+
+//#endregion
+//#region src/context/helpers.ts
+async function runPluginInit(ctx) {
+	let options = ctx.options;
+	const plugins = options.plugins || [];
+	let context = ctx;
+	const dbHooks = [];
+	for (const plugin of plugins) if (plugin.init) {
+		let initPromise = plugin.init(context);
+		let result;
+		if (isPromise(initPromise)) result = await initPromise;
+		else result = initPromise;
+		if (typeof result === "object") {
+			if (result.options) {
+				const { databaseHooks,...restOpts } = result.options;
+				if (databaseHooks) dbHooks.push(databaseHooks);
+				options = defu(options, restOpts);
+			}
+			if (result.context) context = {
+				...context,
+				...result.context
+			};
+		}
+	}
+	dbHooks.push(options.databaseHooks);
+	context.internalAdapter = createInternalAdapter(context.adapter, {
+		options,
+		logger: context.logger,
+		hooks: dbHooks.filter((u) => u !== void 0),
+		generateId: context.generateId
+	});
+	context.options = options;
+	return { context };
+}
+function getInternalPlugins(options) {
+	const plugins = [];
+	if (options.advanced?.crossSubDomainCookies?.enabled) {}
+	return plugins;
+}
+function getTrustedOrigins(options) {
+	const baseURL = getBaseURL(options.baseURL, options.basePath);
+	if (!baseURL) return [];
+	const trustedOrigins = [new URL(baseURL).origin];
+	if (options.trustedOrigins && Array.isArray(options.trustedOrigins)) trustedOrigins.push(...options.trustedOrigins);
+	const envTrustedOrigins = env.BETTER_AUTH_TRUSTED_ORIGINS;
+	if (envTrustedOrigins) trustedOrigins.push(...envTrustedOrigins.split(","));
+	if (trustedOrigins.filter((x) => !x).length) throw new BetterAuthError("A provided trusted origin is invalid, make sure your trusted origins list is properly defined.");
+	return trustedOrigins;
+}
+
+//#endregion
+//#region src/context/create-context.ts
+async function createAuthContext(adapter, options, getDatabaseType) {
+	if (!options.database) options = defu$1(options, {
+		session: { cookieCache: {
+			enabled: true,
+			strategy: "jwe",
+			refreshCache: true
+		} },
+		advanced: { oauthConfig: { storeStateStrategy: "cookie" } }
+	});
+	const plugins = options.plugins || [];
+	const internalPlugins = getInternalPlugins(options);
+	const logger$1 = createLogger(options.logger);
+	const baseURL = getBaseURL(options.baseURL, options.basePath);
+	const secret = options.secret || env.BETTER_AUTH_SECRET || env.AUTH_SECRET || DEFAULT_SECRET;
+	if (secret === DEFAULT_SECRET) {
+		if (isProduction) logger$1.error("You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config.");
+	}
+	options = {
+		...options,
+		secret,
+		baseURL: baseURL ? new URL(baseURL).origin : "",
+		basePath: options.basePath || "/api/auth",
+		plugins: plugins.concat(internalPlugins)
+	};
+	checkEndpointConflicts(options, logger$1);
+	const cookies = getCookies(options);
+	const tables = getAuthTables(options);
+	const providers = Object.entries(options.socialProviders || {}).map(([key, config]) => {
+		if (config == null) return null;
+		if (config.enabled === false) return null;
+		if (!config.clientId) logger$1.warn(`Social provider ${key} is missing clientId or clientSecret`);
+		const provider = socialProviders[key](config);
+		provider.disableImplicitSignUp = config.disableImplicitSignUp;
+		return provider;
+	}).filter((x) => x !== null);
+	const generateIdFunc = ({ model, size }) => {
+		if (typeof options.advanced?.generateId === "function") return options.advanced.generateId({
+			model,
+			size
+		});
+		if (typeof options?.advanced?.database?.generateId === "function") return options.advanced.database.generateId({
+			model,
+			size
+		});
+		return generateId(size);
+	};
+	const { publish } = await createTelemetry(options, {
+		adapter: adapter.id,
+		database: typeof options.database === "function" ? "adapter" : getDatabaseType(options.database)
+	});
+	const initOrPromise = runPluginInit({
+		appName: options.appName || "Better Auth",
+		socialProviders: providers,
+		options,
+		oauthConfig: {
+			storeStateStrategy: options.advanced?.oauthConfig?.storeStateStrategy || "database",
+			skipStateCookieCheck: !!options.advanced?.oauthConfig?.skipStateCookieCheck
+		},
+		tables,
+		trustedOrigins: getTrustedOrigins(options),
+		baseURL: baseURL || "",
+		sessionConfig: {
+			updateAge: options.session?.updateAge !== void 0 ? options.session.updateAge : 1440 * 60,
+			expiresIn: options.session?.expiresIn || 3600 * 24 * 7,
+			freshAge: options.session?.freshAge === void 0 ? 3600 * 24 : options.session.freshAge,
+			cookieRefreshCache: (() => {
+				const refreshCache = options.session?.cookieCache?.refreshCache;
+				const maxAge = options.session?.cookieCache?.maxAge || 300;
+				if (refreshCache === false || refreshCache === void 0) return false;
+				if (refreshCache === true) return {
+					enabled: true,
+					updateAge: Math.floor(maxAge * .2)
+				};
+				return {
+					enabled: true,
+					updateAge: refreshCache.updateAge !== void 0 ? refreshCache.updateAge : Math.floor(maxAge * .2)
+				};
+			})()
+		},
+		secret,
+		rateLimit: {
+			...options.rateLimit,
+			enabled: options.rateLimit?.enabled ?? isProduction,
+			window: options.rateLimit?.window || 10,
+			max: options.rateLimit?.max || 100,
+			storage: options.rateLimit?.storage || (options.secondaryStorage ? "secondary-storage" : "memory")
+		},
+		authCookies: cookies,
+		logger: logger$1,
+		generateId: generateIdFunc,
+		session: null,
+		secondaryStorage: options.secondaryStorage,
+		password: {
+			hash: options.emailAndPassword?.password?.hash || hashPassword,
+			verify: options.emailAndPassword?.password?.verify || verifyPassword,
+			config: {
+				minPasswordLength: options.emailAndPassword?.minPasswordLength || 8,
+				maxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128
+			},
+			checkPassword
+		},
+		setNewSession(session) {
+			this.newSession = session;
+		},
+		newSession: null,
+		adapter,
+		internalAdapter: createInternalAdapter(adapter, {
+			options,
+			logger: logger$1,
+			hooks: options.databaseHooks ? [options.databaseHooks] : [],
+			generateId: generateIdFunc
+		}),
+		createAuthCookie: createCookieGetter(options),
+		async runMigrations() {
+			throw new BetterAuthError("runMigrations will be set by the specific init implementation");
+		},
+		publishTelemetry: publish,
+		skipCSRFCheck: !!options.advanced?.disableCSRFCheck,
+		skipOriginCheck: options.advanced?.disableOriginCheck !== void 0 ? options.advanced.disableOriginCheck : isTest() ? true : false
+	});
+	let context;
+	if (isPromise(initOrPromise)) ({context} = await initOrPromise);
+	else ({context} = initOrPromise);
+	return context;
+}
+
+//#endregion
+//#region src/auth/base.ts
+const createBetterAuth = (options, initFn) => {
+	const authContext = initFn(options);
+	const { api } = getEndpoints(authContext, options);
+	return {
+		handler: async (request) => {
+			const ctx = await authContext;
+			const basePath = ctx.options.basePath || "/api/auth";
+			if (!ctx.options.baseURL) {
+				const baseURL = getBaseURL(void 0, basePath, request);
+				if (baseURL) {
+					ctx.baseURL = baseURL;
+					ctx.options.baseURL = getOrigin(ctx.baseURL) || void 0;
+				} else throw new BetterAuthError("Could not get base URL from request. Please provide a valid base URL.");
+			}
+			ctx.trustedOrigins = [...options.trustedOrigins ? Array.isArray(options.trustedOrigins) ? options.trustedOrigins : await options.trustedOrigins(request) : [], ctx.options.baseURL];
+			const { handler } = router(ctx, options);
+			return runWithAdapter(ctx.adapter, () => handler(request));
+		},
+		api,
+		options,
+		$context: authContext,
+		$ERROR_CODES: {
+			...options.plugins?.reduce((acc, plugin) => {
+				if (plugin.$ERROR_CODES) return {
+					...acc,
+					...plugin.$ERROR_CODES
+				};
+				return acc;
+			}, {}),
+			...BASE_ERROR_CODES
+		}
+	};
+};
+
+//#endregion
+export { createAuthContext as n, createBetterAuth as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/bearer-DRqPkgUx.mjs.bak b/node_modules/better-auth/dist/bearer-DRqPkgUx.mjs.bak
new file mode 100644
index 0000000..4bd2a17
--- /dev/null
+++ b/node_modules/better-auth/dist/bearer-DRqPkgUx.mjs.bak
@@ -0,0 +1,63 @@
+import { l as parseSetCookieHeader } from "./cookies-Cl2L38B1.mjs";
+import { serializeSignedCookie } from "better-call";
+import { createAuthMiddleware } from "@better-auth/core/api";
+import { createHMAC } from "@better-auth/utils/hmac";
+
+//#region src/plugins/bearer/index.ts
+/**
+* Converts bearer token to session cookie
+*/
+const bearer = (options) => {
+	return {
+		id: "bearer",
+		hooks: {
+			before: [{
+				matcher(context) {
+					return Boolean(context.request?.headers.get("authorization") || context.headers?.get("authorization"));
+				},
+				handler: createAuthMiddleware(async (c) => {
+					const token = c.request?.headers.get("authorization")?.replace("Bearer ", "") || c.headers?.get("Authorization")?.replace("Bearer ", "");
+					if (!token) return;
+					let signedToken = "";
+					if (token.includes(".")) signedToken = token.replace("=", "");
+					else {
+						if (options?.requireSignature) return;
+						signedToken = (await serializeSignedCookie("", token, c.context.secret)).replace("=", "");
+					}
+					try {
+						const decodedToken = decodeURIComponent(signedToken);
+						if (!await createHMAC("SHA-256", "base64urlnopad").verify(c.context.secret, decodedToken.split(".")[0], decodedToken.split(".")[1])) return;
+					} catch (e) {
+						return;
+					}
+					const existingHeaders = c.request?.headers || c.headers;
+					const headers = new Headers({ ...Object.fromEntries(existingHeaders?.entries()) });
+					headers.append("cookie", `${c.context.authCookies.sessionToken.name}=${signedToken}`);
+					return { context: { headers } };
+				})
+			}],
+			after: [{
+				matcher(context) {
+					return true;
+				},
+				handler: createAuthMiddleware(async (ctx) => {
+					const setCookie = ctx.context.responseHeaders?.get("set-cookie");
+					if (!setCookie) return;
+					const parsedCookies = parseSetCookieHeader(setCookie);
+					const cookieName = ctx.context.authCookies.sessionToken.name;
+					const sessionCookie = parsedCookies.get(cookieName);
+					if (!sessionCookie || !sessionCookie.value || sessionCookie["max-age"] === 0) return;
+					const token = sessionCookie.value;
+					const exposedHeaders = ctx.context.responseHeaders?.get("access-control-expose-headers") || "";
+					const headersSet = new Set(exposedHeaders.split(",").map((header) => header.trim()).filter(Boolean));
+					headersSet.add("set-auth-token");
+					ctx.setHeader("set-auth-token", token);
+					ctx.setHeader("Access-Control-Expose-Headers", Array.from(headersSet).join(", "));
+				})
+			}]
+		}
+	};
+};
+
+//#endregion
+export { bearer as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/bun-sqlite-dialect-ZxGiPNhl.mjs.bak b/node_modules/better-auth/dist/bun-sqlite-dialect-ZxGiPNhl.mjs.bak
new file mode 100644
index 0000000..003c2ec
--- /dev/null
+++ b/node_modules/better-auth/dist/bun-sqlite-dialect-ZxGiPNhl.mjs.bak
@@ -0,0 +1,155 @@
+import { CompiledQuery, DEFAULT_MIGRATION_LOCK_TABLE, DEFAULT_MIGRATION_TABLE, DefaultQueryCompiler, Kysely, sql } from "kysely";
+
+//#region src/adapters/kysely-adapter/bun-sqlite-dialect.ts
+var BunSqliteAdapter = class {
+	get supportsCreateIfNotExists() {
+		return true;
+	}
+	get supportsTransactionalDdl() {
+		return false;
+	}
+	get supportsReturning() {
+		return true;
+	}
+	async acquireMigrationLock() {}
+	async releaseMigrationLock() {}
+	get supportsOutput() {
+		return true;
+	}
+};
+var BunSqliteDriver = class {
+	#config;
+	#connectionMutex = new ConnectionMutex();
+	#db;
+	#connection;
+	constructor(config) {
+		this.#config = { ...config };
+	}
+	async init() {
+		this.#db = this.#config.database;
+		this.#connection = new BunSqliteConnection(this.#db);
+		if (this.#config.onCreateConnection) await this.#config.onCreateConnection(this.#connection);
+	}
+	async acquireConnection() {
+		await this.#connectionMutex.lock();
+		return this.#connection;
+	}
+	async beginTransaction(connection) {
+		await connection.executeQuery(CompiledQuery.raw("begin"));
+	}
+	async commitTransaction(connection) {
+		await connection.executeQuery(CompiledQuery.raw("commit"));
+	}
+	async rollbackTransaction(connection) {
+		await connection.executeQuery(CompiledQuery.raw("rollback"));
+	}
+	async releaseConnection() {
+		this.#connectionMutex.unlock();
+	}
+	async destroy() {
+		this.#db?.close();
+	}
+};
+var BunSqliteConnection = class {
+	#db;
+	constructor(db) {
+		this.#db = db;
+	}
+	executeQuery(compiledQuery) {
+		const { sql: sql$1, parameters } = compiledQuery;
+		const stmt = this.#db.prepare(sql$1);
+		return Promise.resolve({ rows: stmt.all(parameters) });
+	}
+	async *streamQuery() {
+		throw new Error("Streaming query is not supported by SQLite driver.");
+	}
+};
+var ConnectionMutex = class {
+	#promise;
+	#resolve;
+	async lock() {
+		while (this.#promise) await this.#promise;
+		this.#promise = new Promise((resolve) => {
+			this.#resolve = resolve;
+		});
+	}
+	unlock() {
+		const resolve = this.#resolve;
+		this.#promise = void 0;
+		this.#resolve = void 0;
+		resolve?.();
+	}
+};
+var BunSqliteIntrospector = class {
+	#db;
+	constructor(db) {
+		this.#db = db;
+	}
+	async getSchemas() {
+		return [];
+	}
+	async getTables(options = { withInternalKyselyTables: false }) {
+		let query = this.#db.selectFrom("sqlite_schema").where("type", "=", "table").where("name", "not like", "sqlite_%").select("name").$castTo();
+		if (!options.withInternalKyselyTables) query = query.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
+		const tables = await query.execute();
+		return Promise.all(tables.map(({ name }) => this.#getTableMetadata(name)));
+	}
+	async getMetadata(options) {
+		return { tables: await this.getTables(options) };
+	}
+	async #getTableMetadata(table) {
+		const db = this.#db;
+		const autoIncrementCol = (await db.selectFrom("sqlite_master").where("name", "=", table).select("sql").$castTo().execute())[0]?.sql?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
+		return {
+			name: table,
+			columns: (await db.selectFrom(sql`pragma_table_info(${table})`.as("table_info")).select([
+				"name",
+				"type",
+				"notnull",
+				"dflt_value"
+			]).execute()).map((col) => ({
+				name: col.name,
+				dataType: col.type,
+				isNullable: !col.notnull,
+				isAutoIncrementing: col.name === autoIncrementCol,
+				hasDefaultValue: col.dflt_value != null
+			})),
+			isView: true
+		};
+	}
+};
+var BunSqliteQueryCompiler = class extends DefaultQueryCompiler {
+	getCurrentParameterPlaceholder() {
+		return "?";
+	}
+	getLeftIdentifierWrapper() {
+		return "\"";
+	}
+	getRightIdentifierWrapper() {
+		return "\"";
+	}
+	getAutoIncrement() {
+		return "autoincrement";
+	}
+};
+var BunSqliteDialect = class {
+	#config;
+	constructor(config) {
+		this.#config = { ...config };
+	}
+	createDriver() {
+		return new BunSqliteDriver(this.#config);
+	}
+	createQueryCompiler() {
+		return new BunSqliteQueryCompiler();
+	}
+	createAdapter() {
+		return new BunSqliteAdapter();
+	}
+	createIntrospector(db) {
+		return new BunSqliteIntrospector(db);
+	}
+};
+
+//#endregion
+export { BunSqliteAdapter, BunSqliteDialect, BunSqliteDriver, BunSqliteIntrospector, BunSqliteQueryCompiler };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/captcha-CU0p6qrj.mjs.bak b/node_modules/better-auth/dist/captcha-CU0p6qrj.mjs.bak
new file mode 100644
index 0000000..dfbf9c0
--- /dev/null
+++ b/node_modules/better-auth/dist/captcha-CU0p6qrj.mjs.bak
@@ -0,0 +1,178 @@
+import { t as getIp } from "./get-request-ip-kbu825ez.mjs";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { betterFetch } from "@better-fetch/fetch";
+
+//#region src/utils/middleware-response.ts
+const middlewareResponse = ({ message, status }) => ({ response: new Response(JSON.stringify({ message }), { status }) });
+
+//#endregion
+//#region src/plugins/captcha/constants.ts
+const defaultEndpoints = [
+	"/sign-up/email",
+	"/sign-in/email",
+	"/request-password-reset"
+];
+const Providers = {
+	CLOUDFLARE_TURNSTILE: "cloudflare-turnstile",
+	GOOGLE_RECAPTCHA: "google-recaptcha",
+	HCAPTCHA: "hcaptcha",
+	CAPTCHAFOX: "captchafox"
+};
+const siteVerifyMap = {
+	[Providers.CLOUDFLARE_TURNSTILE]: "https://challenges.cloudflare.com/turnstile/v0/siteverify",
+	[Providers.GOOGLE_RECAPTCHA]: "https://www.google.com/recaptcha/api/siteverify",
+	[Providers.HCAPTCHA]: "https://api.hcaptcha.com/siteverify",
+	[Providers.CAPTCHAFOX]: "https://api.captchafox.com/siteverify"
+};
+
+//#endregion
+//#region src/plugins/captcha/error-codes.ts
+const EXTERNAL_ERROR_CODES = defineErrorCodes({
+	VERIFICATION_FAILED: "Captcha verification failed",
+	MISSING_RESPONSE: "Missing CAPTCHA response",
+	UNKNOWN_ERROR: "Something went wrong"
+});
+const INTERNAL_ERROR_CODES = defineErrorCodes({
+	MISSING_SECRET_KEY: "Missing secret key",
+	SERVICE_UNAVAILABLE: "CAPTCHA service unavailable"
+});
+
+//#endregion
+//#region src/plugins/captcha/utils.ts
+const encodeToURLParams = (obj) => {
+	if (typeof obj !== "object" || obj === null || Array.isArray(obj)) throw new Error("Input must be a non-null object.");
+	const params = new URLSearchParams();
+	for (const [key, value] of Object.entries(obj)) if (value !== void 0 && value !== null) params.append(key, String(value));
+	return params.toString();
+};
+
+//#endregion
+//#region src/plugins/captcha/verify-handlers/captchafox.ts
+const captchaFox = async ({ siteVerifyURL, captchaResponse, secretKey, siteKey, remoteIP }) => {
+	const response = await betterFetch(siteVerifyURL, {
+		method: "POST",
+		headers: { "Content-Type": "application/x-www-form-urlencoded" },
+		body: encodeToURLParams({
+			secret: secretKey,
+			response: captchaResponse,
+			...siteKey && { sitekey: siteKey },
+			...remoteIP && { remoteIp: remoteIP }
+		})
+	});
+	if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
+	if (!response.data.success) return middlewareResponse({
+		message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
+		status: 403
+	});
+};
+
+//#endregion
+//#region src/plugins/captcha/verify-handlers/cloudflare-turnstile.ts
+const cloudflareTurnstile = async ({ siteVerifyURL, captchaResponse, secretKey, remoteIP }) => {
+	const response = await betterFetch(siteVerifyURL, {
+		method: "POST",
+		headers: { "Content-Type": "application/json" },
+		body: JSON.stringify({
+			secret: secretKey,
+			response: captchaResponse,
+			...remoteIP && { remoteip: remoteIP }
+		})
+	});
+	if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
+	if (!response.data.success) return middlewareResponse({
+		message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
+		status: 403
+	});
+};
+
+//#endregion
+//#region src/plugins/captcha/verify-handlers/google-recaptcha.ts
+const isV3 = (response) => {
+	return "score" in response && typeof response.score === "number";
+};
+const googleRecaptcha = async ({ siteVerifyURL, captchaResponse, secretKey, minScore = .5, remoteIP }) => {
+	const response = await betterFetch(siteVerifyURL, {
+		method: "POST",
+		headers: { "Content-Type": "application/x-www-form-urlencoded" },
+		body: encodeToURLParams({
+			secret: secretKey,
+			response: captchaResponse,
+			...remoteIP && { remoteip: remoteIP }
+		})
+	});
+	if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
+	if (!response.data.success || isV3(response.data) && response.data.score < minScore) return middlewareResponse({
+		message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
+		status: 403
+	});
+};
+
+//#endregion
+//#region src/plugins/captcha/verify-handlers/h-captcha.ts
+const hCaptcha = async ({ siteVerifyURL, captchaResponse, secretKey, siteKey, remoteIP }) => {
+	const response = await betterFetch(siteVerifyURL, {
+		method: "POST",
+		headers: { "Content-Type": "application/x-www-form-urlencoded" },
+		body: encodeToURLParams({
+			secret: secretKey,
+			response: captchaResponse,
+			...siteKey && { sitekey: siteKey },
+			...remoteIP && { remoteip: remoteIP }
+		})
+	});
+	if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
+	if (!response.data.success) return middlewareResponse({
+		message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
+		status: 403
+	});
+};
+
+//#endregion
+//#region src/plugins/captcha/index.ts
+const captcha = (options) => ({
+	id: "captcha",
+	onRequest: async (request, ctx) => {
+		try {
+			if (!(options.endpoints?.length ? options.endpoints : defaultEndpoints).some((endpoint) => request.url.includes(endpoint))) return void 0;
+			if (!options.secretKey) throw new Error(INTERNAL_ERROR_CODES.MISSING_SECRET_KEY);
+			const captchaResponse = request.headers.get("x-captcha-response");
+			const remoteUserIP = getIp(request, ctx.options) ?? void 0;
+			if (!captchaResponse) return middlewareResponse({
+				message: EXTERNAL_ERROR_CODES.MISSING_RESPONSE,
+				status: 400
+			});
+			const handlerParams = {
+				siteVerifyURL: options.siteVerifyURLOverride || siteVerifyMap[options.provider],
+				captchaResponse,
+				secretKey: options.secretKey,
+				remoteIP: remoteUserIP
+			};
+			if (options.provider === Providers.CLOUDFLARE_TURNSTILE) return await cloudflareTurnstile(handlerParams);
+			if (options.provider === Providers.GOOGLE_RECAPTCHA) return await googleRecaptcha({
+				...handlerParams,
+				minScore: options.minScore
+			});
+			if (options.provider === Providers.HCAPTCHA) return await hCaptcha({
+				...handlerParams,
+				siteKey: options.siteKey
+			});
+			if (options.provider === Providers.CAPTCHAFOX) return await captchaFox({
+				...handlerParams,
+				siteKey: options.siteKey
+			});
+		} catch (_error) {
+			const errorMessage = _error instanceof Error ? _error.message : void 0;
+			ctx.logger.error(errorMessage ?? "Unknown error", {
+				endpoint: request.url,
+				message: _error
+			});
+			return middlewareResponse({
+				message: EXTERNAL_ERROR_CODES.UNKNOWN_ERROR,
+				status: 500
+			});
+		}
+	}
+});
+
+//#endregion
+export { captcha as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/chunk-BK_LfMhE.mjs.bak b/node_modules/better-auth/dist/chunk-BK_LfMhE.mjs.bak
new file mode 100644
index 0000000..8dd1047
--- /dev/null
+++ b/node_modules/better-auth/dist/chunk-BK_LfMhE.mjs.bak
@@ -0,0 +1,40 @@
+import { createRequire } from "node:module";
+
+//#region rolldown:runtime
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __commonJS = (cb, mod) => function() {
+	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
+};
+var __export = (all) => {
+	let target = {};
+	for (var name in all) __defProp(target, name, {
+		get: all[name],
+		enumerable: true
+	});
+	return target;
+};
+var __copyProps = (to, from, except, desc) => {
+	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
+		key = keys[i];
+		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
+			get: ((k) => from[k]).bind(null, key),
+			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
+		});
+	}
+	return to;
+};
+var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
+	value: mod,
+	enumerable: true
+}) : target, mod));
+var __toDynamicImportESM = (isNodeMode) => (mod) => __toESM(mod.default, isNodeMode);
+var __require = /* @__PURE__ */ createRequire(import.meta.url);
+
+//#endregion
+export { __toDynamicImportESM as a, __require as i, __export as n, __toESM as o, __reExport as r, __commonJS as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client-CuoyvYUC.mjs.bak b/node_modules/better-auth/dist/client-CuoyvYUC.mjs.bak
new file mode 100644
index 0000000..881191d
--- /dev/null
+++ b/node_modules/better-auth/dist/client-CuoyvYUC.mjs.bak
@@ -0,0 +1,29 @@
+//#region src/plugins/two-factor/client.ts
+const twoFactorClient = (options) => {
+	return {
+		id: "two-factor",
+		$InferServerPlugin: {},
+		atomListeners: [{
+			matcher: (path) => path.startsWith("/two-factor/"),
+			signal: "$sessionSignal"
+		}],
+		pathMethods: {
+			"/two-factor/disable": "POST",
+			"/two-factor/enable": "POST",
+			"/two-factor/send-otp": "POST",
+			"/two-factor/generate-backup-codes": "POST"
+		},
+		fetchPlugins: [{
+			id: "two-factor",
+			name: "two-factor",
+			hooks: { async onSuccess(context) {
+				if (context.data?.twoFactorRedirect) {
+					if (options?.onTwoFactorRedirect) await options.onTwoFactorRedirect();
+				}
+			} }
+		}]
+	};
+};
+
+//#endregion
+export { twoFactorClient as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client-DQywG8SE.mjs.bak b/node_modules/better-auth/dist/client-DQywG8SE.mjs.bak
new file mode 100644
index 0000000..ba7d93a
--- /dev/null
+++ b/node_modules/better-auth/dist/client-DQywG8SE.mjs.bak
@@ -0,0 +1,30 @@
+import { t as capitalizeFirstLetter } from "./misc-CADLxPeM.mjs";
+import { n as getClientConfig, t as createDynamicPathProxy } from "./proxy-CH2wKnFj.mjs";
+
+//#region src/client/vanilla.ts
+function createAuthClient(options) {
+	const { pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, atomListeners, $store } = getClientConfig(options);
+	let resolvedHooks = {};
+	for (const [key, value] of Object.entries(pluginsAtoms)) resolvedHooks[`use${capitalizeFirstLetter(key)}`] = value;
+	return createDynamicPathProxy({
+		...pluginsActions,
+		...resolvedHooks,
+		$fetch,
+		$store
+	}, $fetch, pluginPathMethods, pluginsAtoms, atomListeners);
+}
+
+//#endregion
+//#region src/client/index.ts
+const InferPlugin = () => {
+	return {
+		id: "infer-server-plugin",
+		$InferServerPlugin: {}
+	};
+};
+function InferAuth() {
+	return {};
+}
+
+//#endregion
+export { InferPlugin as n, createAuthClient as r, InferAuth as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client-WiN43tAS.mjs.bak b/node_modules/better-auth/dist/client-WiN43tAS.mjs.bak
new file mode 100644
index 0000000..e248a34
--- /dev/null
+++ b/node_modules/better-auth/dist/client-WiN43tAS.mjs.bak
@@ -0,0 +1,17 @@
+//#region src/plugins/device-authorization/client.ts
+const deviceAuthorizationClient = () => {
+	return {
+		id: "device-authorization",
+		$InferServerPlugin: {},
+		pathMethods: {
+			"/device/code": "POST",
+			"/device/token": "POST",
+			"/device": "GET",
+			"/device/approve": "POST",
+			"/device/deny": "POST"
+		}
+	};
+};
+
+//#endregion
+export { deviceAuthorizationClient as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client/index.mjs.bak b/node_modules/better-auth/dist/client/index.mjs.bak
new file mode 100644
index 0000000..bea3c60
--- /dev/null
+++ b/node_modules/better-auth/dist/client/index.mjs.bak
@@ -0,0 +1,7 @@
+import "../misc-CADLxPeM.mjs";
+import "../url-SXU3XD3W.mjs";
+import { a as createBroadcastChannel, i as useAuthQuery, r as createSessionRefreshManager } from "../proxy-CH2wKnFj.mjs";
+import "../parser-DcrIEuXE.mjs";
+import { n as InferPlugin, r as createAuthClient, t as InferAuth } from "../client-DQywG8SE.mjs";
+
+export { InferAuth, InferPlugin, createAuthClient, createBroadcastChannel, createSessionRefreshManager, useAuthQuery };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client/lynx/index.mjs.bak b/node_modules/better-auth/dist/client/lynx/index.mjs.bak
new file mode 100644
index 0000000..ff4e985
--- /dev/null
+++ b/node_modules/better-auth/dist/client/lynx/index.mjs.bak
@@ -0,0 +1,69 @@
+import "../../url-SXU3XD3W.mjs";
+import { n as getClientConfig, t as createDynamicPathProxy } from "../../proxy-CH2wKnFj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import { listenKeys } from "nanostores";
+import { useCallback, useRef, useSyncExternalStore } from "@lynx-js/react";
+
+//#region src/client/lynx/lynx-store.ts
+/**
+* Subscribe to store changes and get store's value.
+*
+* Can be used with store builder too.
+*
+* ```js
+* import { useStore } from 'nanostores/react'
+*
+* import { router } from '../store/router'
+*
+* export const Layout = () => {
+*   let page = useStore(router)
+*   if (page.route === 'home') {
+*     return <HomePage />
+*   } else {
+*     return <Error404 />
+*   }
+* }
+* ```
+*
+* @param store Store instance.
+* @returns Store value.
+*/
+function useStore(store, options = {}) {
+	let snapshotRef = useRef(store.get());
+	const { keys, deps = [store, keys] } = options;
+	let subscribe = useCallback((onChange) => {
+		const emitChange = (value) => {
+			if (snapshotRef.current === value) return;
+			snapshotRef.current = value;
+			onChange();
+		};
+		emitChange(store.value);
+		if (keys?.length) return listenKeys(store, keys, emitChange);
+		return store.listen(emitChange);
+	}, deps);
+	let get = () => snapshotRef.current;
+	return useSyncExternalStore(subscribe, get, get);
+}
+
+//#endregion
+//#region src/client/lynx/index.ts
+function getAtomKey(str) {
+	return `use${capitalizeFirstLetter(str)}`;
+}
+function capitalizeFirstLetter(str) {
+	return str.charAt(0).toUpperCase() + str.slice(1);
+}
+function createAuthClient(options) {
+	const { pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, $store, atomListeners } = getClientConfig(options);
+	let resolvedHooks = {};
+	for (const [key, value] of Object.entries(pluginsAtoms)) resolvedHooks[getAtomKey(key)] = () => useStore(value);
+	return createDynamicPathProxy({
+		...pluginsActions,
+		...resolvedHooks,
+		$fetch,
+		$store
+	}, $fetch, pluginPathMethods, pluginsAtoms, atomListeners);
+}
+
+//#endregion
+export { capitalizeFirstLetter, createAuthClient, useStore };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client/plugins/index.mjs.bak b/node_modules/better-auth/dist/client/plugins/index.mjs.bak
new file mode 100644
index 0000000..2c07138
--- /dev/null
+++ b/node_modules/better-auth/dist/client/plugins/index.mjs.bak
@@ -0,0 +1,424 @@
+import "../../misc-CADLxPeM.mjs";
+import "../../url-SXU3XD3W.mjs";
+import { i as useAuthQuery } from "../../proxy-CH2wKnFj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import "../../client-DQywG8SE.mjs";
+import "../../access-6c2-Np4U.mjs";
+import { a as userAc, t as adminAc$1 } from "../../access-BYnrn7CR.mjs";
+import { t as hasPermission } from "../../has-permission-DhpFBOUO.mjs";
+import { t as deviceAuthorizationClient } from "../../client-WiN43tAS.mjs";
+import { a as memberAc, o as ownerAc, r as defaultRoles, t as adminAc } from "../../access-HdxSBEa0.mjs";
+import { n as hasPermissionFn } from "../../permission-CDDWgA_O.mjs";
+import { t as twoFactorClient } from "../../client-CuoyvYUC.mjs";
+import { atom } from "nanostores";
+
+//#region src/plugins/additional-fields/client.ts
+const inferAdditionalFields = (schema) => {
+	return {
+		id: "additional-fields-client",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+//#region src/plugins/admin/client.ts
+const adminClient = (options) => {
+	const roles = {
+		admin: adminAc$1,
+		user: userAc,
+		...options?.roles
+	};
+	return {
+		id: "admin-client",
+		$InferServerPlugin: {},
+		getActions: () => ({ admin: { checkRolePermission: (data) => {
+			return hasPermission({
+				role: data.role,
+				options: {
+					ac: options?.ac,
+					roles
+				},
+				permissions: data.permissions ?? data.permission
+			});
+		} } }),
+		pathMethods: {
+			"/admin/list-users": "GET",
+			"/admin/stop-impersonating": "POST"
+		}
+	};
+};
+
+//#endregion
+//#region src/plugins/anonymous/client.ts
+const anonymousClient = () => {
+	return {
+		id: "anonymous",
+		$InferServerPlugin: {},
+		pathMethods: { "/sign-in/anonymous": "POST" },
+		atomListeners: [{
+			matcher: (path) => path === "/sign-in/anonymous",
+			signal: "$sessionSignal"
+		}]
+	};
+};
+
+//#endregion
+//#region src/plugins/api-key/client.ts
+const apiKeyClient = () => {
+	return {
+		id: "api-key",
+		$InferServerPlugin: {},
+		pathMethods: {
+			"/api-key/create": "POST",
+			"/api-key/delete": "POST",
+			"/api-key/delete-all-expired-api-keys": "POST"
+		}
+	};
+};
+
+//#endregion
+//#region src/plugins/custom-session/client.ts
+const customSessionClient = () => {
+	return InferServerPlugin();
+};
+
+//#endregion
+//#region src/plugins/email-otp/client.ts
+const emailOTPClient = () => {
+	return {
+		id: "email-otp",
+		$InferServerPlugin: {},
+		atomListeners: [{
+			matcher: (path) => path === "/email-otp/verify-email" || path === "/sign-in/email-otp",
+			signal: "$sessionSignal"
+		}]
+	};
+};
+
+//#endregion
+//#region src/plugins/generic-oauth/client.ts
+const genericOAuthClient = () => {
+	return {
+		id: "generic-oauth-client",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+//#region src/plugins/jwt/client.ts
+const jwtClient = () => {
+	return {
+		id: "better-auth-client",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+//#region src/plugins/last-login-method/client.ts
+function getCookieValue(name) {
+	if (typeof document === "undefined") return null;
+	const cookie = document.cookie.split("; ").find((row) => row.startsWith(`${name}=`));
+	return cookie ? cookie.split("=")[1] : null;
+}
+/**
+* Client-side plugin to retrieve the last used login method
+*/
+const lastLoginMethodClient = (config = {}) => {
+	const cookieName = config.cookieName || "better-auth.last_used_login_method";
+	return {
+		id: "last-login-method-client",
+		getActions() {
+			return {
+				getLastUsedLoginMethod: () => {
+					return getCookieValue(cookieName);
+				},
+				clearLastUsedLoginMethod: () => {
+					if (typeof document !== "undefined") document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
+				},
+				isLastUsedLoginMethod: (method) => {
+					return getCookieValue(cookieName) === method;
+				}
+			};
+		}
+	};
+};
+
+//#endregion
+//#region src/plugins/magic-link/client.ts
+const magicLinkClient = () => {
+	return {
+		id: "magic-link",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+//#region src/plugins/multi-session/client.ts
+const multiSessionClient = () => {
+	return {
+		id: "multi-session",
+		$InferServerPlugin: {},
+		atomListeners: [{
+			matcher(path) {
+				return path === "/multi-session/set-active";
+			},
+			signal: "$sessionSignal"
+		}]
+	};
+};
+
+//#endregion
+//#region src/plugins/oidc-provider/client.ts
+const oidcClient = () => {
+	return {
+		id: "oidc-client",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+//#region src/plugins/one-tap/client.ts
+let isRequestInProgress = false;
+const oneTapClient = (options) => {
+	return {
+		id: "one-tap",
+		getActions: ($fetch, _) => ({ oneTap: async (opts, fetchOptions) => {
+			if (isRequestInProgress) {
+				console.warn("A Google One Tap request is already in progress. Please wait.");
+				return;
+			}
+			isRequestInProgress = true;
+			try {
+				if (typeof window === "undefined" || !window.document) {
+					console.warn("Google One Tap is only available in browser environments");
+					return;
+				}
+				const { autoSelect, cancelOnTapOutside, context } = opts ?? {};
+				const contextValue = context ?? options.context ?? "signin";
+				await loadGoogleScript();
+				await new Promise((resolve, reject) => {
+					let isResolved = false;
+					const baseDelay = options.promptOptions?.baseDelay ?? 1e3;
+					const maxAttempts = options.promptOptions?.maxAttempts ?? 5;
+					window.google?.accounts.id.initialize({
+						client_id: options.clientId,
+						callback: async (response) => {
+							isResolved = true;
+							try {
+								await $fetch("/one-tap/callback", {
+									method: "POST",
+									body: { idToken: response.credential },
+									...opts?.fetchOptions,
+									...fetchOptions
+								});
+								if (!opts?.fetchOptions && !fetchOptions || opts?.callbackURL) window.location.href = opts?.callbackURL ?? "/";
+								resolve();
+							} catch (error) {
+								console.error("Error during One Tap callback:", error);
+								reject(error);
+							}
+						},
+						auto_select: autoSelect,
+						cancel_on_tap_outside: cancelOnTapOutside,
+						context: contextValue,
+						...options.additionalOptions
+					});
+					const handlePrompt = (attempt) => {
+						if (isResolved) return;
+						window.google?.accounts.id.prompt((notification) => {
+							if (isResolved) return;
+							if (notification.isDismissedMoment && notification.isDismissedMoment()) if (attempt < maxAttempts) {
+								const delay = Math.pow(2, attempt) * baseDelay;
+								setTimeout(() => handlePrompt(attempt + 1), delay);
+							} else opts?.onPromptNotification?.(notification);
+							else if (notification.isSkippedMoment && notification.isSkippedMoment()) if (attempt < maxAttempts) {
+								const delay = Math.pow(2, attempt) * baseDelay;
+								setTimeout(() => handlePrompt(attempt + 1), delay);
+							} else opts?.onPromptNotification?.(notification);
+						});
+					};
+					handlePrompt(0);
+				});
+			} catch (error) {
+				console.error("Error during Google One Tap flow:", error);
+				throw error;
+			} finally {
+				isRequestInProgress = false;
+			}
+		} }),
+		getAtoms($fetch) {
+			return {};
+		}
+	};
+};
+const loadGoogleScript = () => {
+	return new Promise((resolve) => {
+		if (window.googleScriptInitialized) {
+			resolve();
+			return;
+		}
+		const script = document.createElement("script");
+		script.src = "https://accounts.google.com/gsi/client";
+		script.async = true;
+		script.defer = true;
+		script.onload = () => {
+			window.googleScriptInitialized = true;
+			resolve();
+		};
+		document.head.appendChild(script);
+	});
+};
+
+//#endregion
+//#region src/plugins/one-time-token/client.ts
+const oneTimeTokenClient = () => {
+	return {
+		id: "one-time-token",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+//#region src/plugins/organization/client.ts
+/**
+* Using the same `hasPermissionFn` function, but without the need for a `ctx` parameter or the `organizationId` parameter.
+*/
+const clientSideHasPermission = (input) => {
+	return hasPermissionFn(input, input.options.roles || defaultRoles);
+};
+const organizationClient = (options) => {
+	const $listOrg = atom(false);
+	const $activeOrgSignal = atom(false);
+	const $activeMemberSignal = atom(false);
+	const $activeMemberRoleSignal = atom(false);
+	const roles = {
+		admin: adminAc,
+		member: memberAc,
+		owner: ownerAc,
+		...options?.roles
+	};
+	return {
+		id: "organization",
+		$InferServerPlugin: {},
+		getActions: ($fetch, _$store, co) => ({
+			$Infer: {
+				ActiveOrganization: {},
+				Organization: {},
+				Invitation: {},
+				Member: {},
+				Team: {}
+			},
+			organization: { checkRolePermission: (data) => {
+				return clientSideHasPermission({
+					role: data.role,
+					options: {
+						ac: options?.ac,
+						roles
+					},
+					permissions: data.permissions ?? data.permission
+				});
+			} }
+		}),
+		getAtoms: ($fetch) => {
+			const listOrganizations = useAuthQuery($listOrg, "/organization/list", $fetch, { method: "GET" });
+			return {
+				$listOrg,
+				$activeOrgSignal,
+				$activeMemberSignal,
+				$activeMemberRoleSignal,
+				activeOrganization: useAuthQuery([$activeOrgSignal], "/organization/get-full-organization", $fetch, () => ({ method: "GET" })),
+				listOrganizations,
+				activeMember: useAuthQuery([$activeMemberSignal], "/organization/get-active-member", $fetch, { method: "GET" }),
+				activeMemberRole: useAuthQuery([$activeMemberRoleSignal], "/organization/get-active-member-role", $fetch, { method: "GET" })
+			};
+		},
+		pathMethods: {
+			"/organization/get-full-organization": "GET",
+			"/organization/list-user-teams": "GET"
+		},
+		atomListeners: [
+			{
+				matcher(path) {
+					return path === "/organization/create" || path === "/organization/delete" || path === "/organization/update";
+				},
+				signal: "$listOrg"
+			},
+			{
+				matcher(path) {
+					return path.startsWith("/organization");
+				},
+				signal: "$activeOrgSignal"
+			},
+			{
+				matcher(path) {
+					return path.startsWith("/organization/set-active");
+				},
+				signal: "$sessionSignal"
+			},
+			{
+				matcher(path) {
+					return path.includes("/organization/update-member-role");
+				},
+				signal: "$activeMemberSignal"
+			},
+			{
+				matcher(path) {
+					return path.includes("/organization/update-member-role");
+				},
+				signal: "$activeMemberRoleSignal"
+			}
+		]
+	};
+};
+const inferOrgAdditionalFields = (schema) => {
+	return {};
+};
+
+//#endregion
+//#region src/plugins/phone-number/client.ts
+const phoneNumberClient = () => {
+	return {
+		id: "phoneNumber",
+		$InferServerPlugin: {},
+		atomListeners: [{
+			matcher(path) {
+				return path === "/phone-number/update" || path === "/phone-number/verify" || path === "/sign-in/phone-number";
+			},
+			signal: "$sessionSignal"
+		}]
+	};
+};
+
+//#endregion
+//#region src/plugins/siwe/client.ts
+const siweClient = () => {
+	return {
+		id: "siwe",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+//#region src/plugins/username/client.ts
+const usernameClient = () => {
+	return {
+		id: "username",
+		$InferServerPlugin: {},
+		atomListeners: [{
+			matcher: (path) => path === "/sign-in/username",
+			signal: "$sessionSignal"
+		}]
+	};
+};
+
+//#endregion
+//#region src/client/plugins/infer-plugin.ts
+const InferServerPlugin = () => {
+	return {
+		id: "infer-server-plugin",
+		$InferServerPlugin: {}
+	};
+};
+
+//#endregion
+export { InferServerPlugin, adminClient, anonymousClient, apiKeyClient, clientSideHasPermission, customSessionClient, deviceAuthorizationClient, emailOTPClient, genericOAuthClient, inferAdditionalFields, inferOrgAdditionalFields, jwtClient, lastLoginMethodClient, magicLinkClient, multiSessionClient, oidcClient, oneTapClient, oneTimeTokenClient, organizationClient, phoneNumberClient, siweClient, twoFactorClient, usernameClient };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client/react/index.mjs.bak b/node_modules/better-auth/dist/client/react/index.mjs.bak
new file mode 100644
index 0000000..12dff38
--- /dev/null
+++ b/node_modules/better-auth/dist/client/react/index.mjs.bak
@@ -0,0 +1,69 @@
+import "../../url-SXU3XD3W.mjs";
+import { n as getClientConfig, t as createDynamicPathProxy } from "../../proxy-CH2wKnFj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import { listenKeys } from "nanostores";
+import { useCallback, useRef, useSyncExternalStore } from "react";
+
+//#region src/client/react/react-store.ts
+/**
+* Subscribe to store changes and get store's value.
+*
+* Can be used with store builder too.
+*
+* ```js
+* import { useStore } from 'nanostores/react'
+*
+* import { router } from '../store/router'
+*
+* export const Layout = () => {
+*   let page = useStore(router)
+*   if (page.route === 'home') {
+*     return <HomePage />
+*   } else {
+*     return <Error404 />
+*   }
+* }
+* ```
+*
+* @param store Store instance.
+* @returns Store value.
+*/
+function useStore(store, options = {}) {
+	let snapshotRef = useRef(store.get());
+	const { keys, deps = [store, keys] } = options;
+	let subscribe = useCallback((onChange) => {
+		const emitChange = (value) => {
+			if (snapshotRef.current === value) return;
+			snapshotRef.current = value;
+			onChange();
+		};
+		emitChange(store.value);
+		if (keys?.length) return listenKeys(store, keys, emitChange);
+		return store.listen(emitChange);
+	}, deps);
+	let get = () => snapshotRef.current;
+	return useSyncExternalStore(subscribe, get, get);
+}
+
+//#endregion
+//#region src/client/react/index.ts
+function getAtomKey(str) {
+	return `use${capitalizeFirstLetter(str)}`;
+}
+function capitalizeFirstLetter(str) {
+	return str.charAt(0).toUpperCase() + str.slice(1);
+}
+function createAuthClient(options) {
+	const { pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, $store, atomListeners } = getClientConfig(options);
+	let resolvedHooks = {};
+	for (const [key, value] of Object.entries(pluginsAtoms)) resolvedHooks[getAtomKey(key)] = () => useStore(value);
+	return createDynamicPathProxy({
+		...pluginsActions,
+		...resolvedHooks,
+		$fetch,
+		$store
+	}, $fetch, pluginPathMethods, pluginsAtoms, atomListeners);
+}
+
+//#endregion
+export { capitalizeFirstLetter, createAuthClient, useStore };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client/solid/index.mjs.bak b/node_modules/better-auth/dist/client/solid/index.mjs.bak
new file mode 100644
index 0000000..c28736e
--- /dev/null
+++ b/node_modules/better-auth/dist/client/solid/index.mjs.bak
@@ -0,0 +1,42 @@
+import { t as capitalizeFirstLetter } from "../../misc-CADLxPeM.mjs";
+import "../../url-SXU3XD3W.mjs";
+import { n as getClientConfig, t as createDynamicPathProxy } from "../../proxy-CH2wKnFj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import { onCleanup } from "solid-js";
+import { createStore, reconcile } from "solid-js/store";
+
+//#region src/client/solid/solid-store.ts
+/**
+* Subscribes to store changes and gets storeâ€™s value.
+*
+* @param store Store instance.
+* @returns Store value.
+*/
+function useStore(store) {
+	const unbindActivation = store.listen(() => {});
+	const [state, setState] = createStore({ value: store.get() });
+	const unsubscribe = store.subscribe((newValue) => {
+		setState("value", reconcile(newValue));
+	});
+	onCleanup(() => unsubscribe());
+	unbindActivation();
+	return () => state.value;
+}
+
+//#endregion
+//#region src/client/solid/index.ts
+function getAtomKey(str) {
+	return `use${capitalizeFirstLetter(str)}`;
+}
+function createAuthClient(options) {
+	const { pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, atomListeners } = getClientConfig(options);
+	let resolvedHooks = {};
+	for (const [key, value] of Object.entries(pluginsAtoms)) resolvedHooks[getAtomKey(key)] = () => useStore(value);
+	return createDynamicPathProxy({
+		...pluginsActions,
+		...resolvedHooks
+	}, $fetch, pluginPathMethods, pluginsAtoms, atomListeners);
+}
+
+//#endregion
+export { createAuthClient };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client/svelte/index.mjs.bak b/node_modules/better-auth/dist/client/svelte/index.mjs.bak
new file mode 100644
index 0000000..1d6860f
--- /dev/null
+++ b/node_modules/better-auth/dist/client/svelte/index.mjs.bak
@@ -0,0 +1,20 @@
+import { t as capitalizeFirstLetter } from "../../misc-CADLxPeM.mjs";
+import "../../url-SXU3XD3W.mjs";
+import { n as getClientConfig, t as createDynamicPathProxy } from "../../proxy-CH2wKnFj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+
+//#region src/client/svelte/index.ts
+function createAuthClient(options) {
+	const { pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, atomListeners, $store } = getClientConfig(options);
+	let resolvedHooks = {};
+	for (const [key, value] of Object.entries(pluginsAtoms)) resolvedHooks[`use${capitalizeFirstLetter(key)}`] = () => value;
+	return createDynamicPathProxy({
+		...pluginsActions,
+		...resolvedHooks,
+		$fetch,
+		$store
+	}, $fetch, pluginPathMethods, pluginsAtoms, atomListeners);
+}
+
+//#endregion
+export { createAuthClient };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/client/vue/index.mjs.bak b/node_modules/better-auth/dist/client/vue/index.mjs.bak
new file mode 100644
index 0000000..57332f8
--- /dev/null
+++ b/node_modules/better-auth/dist/client/vue/index.mjs.bak
@@ -0,0 +1,60 @@
+import { t as capitalizeFirstLetter } from "../../misc-CADLxPeM.mjs";
+import "../../url-SXU3XD3W.mjs";
+import { n as getClientConfig, t as createDynamicPathProxy } from "../../proxy-CH2wKnFj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import { getCurrentInstance, getCurrentScope, onScopeDispose, readonly, shallowRef } from "vue";
+
+//#region src/client/vue/vue-store.ts
+function registerStore(store) {
+	let instance = getCurrentInstance();
+	if (instance && instance.proxy) {
+		let vm = instance.proxy;
+		("_nanostores" in vm ? vm._nanostores : vm._nanostores = []).push(store);
+	}
+}
+function useStore(store) {
+	let state = shallowRef();
+	let unsubscribe = store.subscribe((value) => {
+		state.value = value;
+	});
+	if (getCurrentScope()) onScopeDispose(unsubscribe);
+	if (process.env.NODE_ENV !== "production") {
+		registerStore(store);
+		return readonly(state);
+	}
+	return state;
+}
+
+//#endregion
+//#region src/client/vue/index.ts
+function getAtomKey(str) {
+	return `use${capitalizeFirstLetter(str)}`;
+}
+function createAuthClient(options) {
+	const { baseURL, pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, $store, atomListeners } = getClientConfig(options, false);
+	let resolvedHooks = {};
+	for (const [key, value] of Object.entries(pluginsAtoms)) resolvedHooks[getAtomKey(key)] = () => useStore(value);
+	function useSession(useFetch) {
+		if (useFetch) {
+			const ref = useStore(pluginsAtoms.$sessionSignal);
+			return useFetch(`${baseURL}/get-session`, { ref }).then((res) => {
+				return {
+					data: res.data,
+					isPending: false,
+					error: res.error
+				};
+			});
+		}
+		return resolvedHooks.useSession();
+	}
+	return createDynamicPathProxy({
+		...pluginsActions,
+		...resolvedHooks,
+		useSession,
+		$fetch,
+		$store
+	}, $fetch, pluginPathMethods, pluginsAtoms, atomListeners);
+}
+
+//#endregion
+export { createAuthClient };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/cookies-Cl2L38B1.mjs b/node_modules/better-auth/dist/cookies-Cl2L38B1.mjs
index 8f18c7f..9f9f5cb 100644
--- a/node_modules/better-auth/dist/cookies-Cl2L38B1.mjs
+++ b/node_modules/better-auth/dist/cookies-Cl2L38B1.mjs
@@ -281,8 +281,8 @@ function getChunkedCookie(ctx, cookieName) {
 	return null;
 }
 const getSessionQuerySchema = z.optional(z.object({
-	disableCookieCache: z.coerce.boolean().meta({ description: "Disable cookie cache and fetch session from database" }).optional(),
-	disableRefresh: z.coerce.boolean().meta({ description: "Disable session refresh. Useful for checking session status, without updating the session" }).optional()
+	disableCookieCache: z.coerce.boolean().optional(),
+	disableRefresh: z.coerce.boolean().optional()
 }));
 
 //#endregion
diff --git a/node_modules/better-auth/dist/cookies-Cl2L38B1.mjs.bak b/node_modules/better-auth/dist/cookies-Cl2L38B1.mjs.bak
new file mode 100644
index 0000000..9f9f5cb
--- /dev/null
+++ b/node_modules/better-auth/dist/cookies-Cl2L38B1.mjs.bak
@@ -0,0 +1,597 @@
+import { i as verifyJWT, n as symmetricDecodeJWT, r as symmetricEncodeJWT, t as signJWT } from "./jwt-CmxZAGe2.mjs";
+import { l as parseUserOutput, u as getDate } from "./schema-BevzneML.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { t as getBaseURL } from "./url-SXU3XD3W.mjs";
+import { env, isProduction } from "@better-auth/core/env";
+import { BetterAuthError } from "@better-auth/core/error";
+import * as z from "zod";
+import { base64Url } from "@better-auth/utils/base64";
+import { binary } from "@better-auth/utils/binary";
+import { createHMAC } from "@better-auth/utils/hmac";
+
+//#region ../../node_modules/.pnpm/ms@4.0.0-nightly.202508271359/node_modules/ms/dist/index.js
+const s = 1e3;
+const m = s * 60;
+const h = m * 60;
+const d = h * 24;
+const w = d * 7;
+const y = d * 365.25;
+const mo = y / 12;
+function ms(value, options) {
+	if (typeof value === "string") return parse(value);
+	else if (typeof value === "number") return format(value, options);
+	throw new Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(value)}`);
+}
+/**
+* Parse the given string and return milliseconds.
+*
+* @param str - A string to parse to milliseconds
+* @returns The parsed value in milliseconds, or `NaN` if the string can't be
+* parsed
+*/
+function parse(str) {
+	if (typeof str !== "string" || str.length === 0 || str.length > 100) throw new Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(str)}`);
+	const match = /^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(str);
+	if (!match?.groups) return NaN;
+	const { value, unit = "ms" } = match.groups;
+	const n = parseFloat(value);
+	const matchUnit = unit.toLowerCase();
+	/* istanbul ignore next - istanbul doesn't understand, but thankfully the TypeScript the exhaustiveness check in the default case keeps us type safe here */
+	switch (matchUnit) {
+		case "years":
+		case "year":
+		case "yrs":
+		case "yr":
+		case "y": return n * y;
+		case "months":
+		case "month":
+		case "mo": return n * mo;
+		case "weeks":
+		case "week":
+		case "w": return n * w;
+		case "days":
+		case "day":
+		case "d": return n * d;
+		case "hours":
+		case "hour":
+		case "hrs":
+		case "hr":
+		case "h": return n * h;
+		case "minutes":
+		case "minute":
+		case "mins":
+		case "min":
+		case "m": return n * m;
+		case "seconds":
+		case "second":
+		case "secs":
+		case "sec":
+		case "s": return n * s;
+		case "milliseconds":
+		case "millisecond":
+		case "msecs":
+		case "msec":
+		case "ms": return n;
+		default: throw new Error(`Unknown unit "${matchUnit}" provided to ms.parse(). value=${JSON.stringify(str)}`);
+	}
+}
+/**
+* Short format for `ms`.
+*/
+function fmtShort(ms$1) {
+	const msAbs = Math.abs(ms$1);
+	if (msAbs >= y) return `${Math.round(ms$1 / y)}y`;
+	if (msAbs >= mo) return `${Math.round(ms$1 / mo)}mo`;
+	if (msAbs >= w) return `${Math.round(ms$1 / w)}w`;
+	if (msAbs >= d) return `${Math.round(ms$1 / d)}d`;
+	if (msAbs >= h) return `${Math.round(ms$1 / h)}h`;
+	if (msAbs >= m) return `${Math.round(ms$1 / m)}m`;
+	if (msAbs >= s) return `${Math.round(ms$1 / s)}s`;
+	return `${ms$1}ms`;
+}
+/**
+* Long format for `ms`.
+*/
+function fmtLong(ms$1) {
+	const msAbs = Math.abs(ms$1);
+	if (msAbs >= y) return plural(ms$1, msAbs, y, "year");
+	if (msAbs >= mo) return plural(ms$1, msAbs, mo, "month");
+	if (msAbs >= w) return plural(ms$1, msAbs, w, "week");
+	if (msAbs >= d) return plural(ms$1, msAbs, d, "day");
+	if (msAbs >= h) return plural(ms$1, msAbs, h, "hour");
+	if (msAbs >= m) return plural(ms$1, msAbs, m, "minute");
+	if (msAbs >= s) return plural(ms$1, msAbs, s, "second");
+	return `${ms$1} ms`;
+}
+/**
+* Format the given integer as a string.
+*
+* @param ms - milliseconds
+* @param options - Options for the conversion
+* @returns The formatted string
+*/
+function format(ms$1, options) {
+	if (typeof ms$1 !== "number" || !Number.isFinite(ms$1)) throw new Error("Value provided to ms.format() must be of type number.");
+	return options?.long ? fmtLong(ms$1) : fmtShort(ms$1);
+}
+/**
+* Pluralization helper.
+*/
+function plural(ms$1, msAbs, n, name) {
+	const isPlural = msAbs >= n * 1.5;
+	return `${Math.round(ms$1 / n)} ${name}${isPlural ? "s" : ""}`;
+}
+
+//#endregion
+//#region src/cookies/session-store.ts
+const ALLOWED_COOKIE_SIZE = 4096;
+const ESTIMATED_EMPTY_COOKIE_SIZE = 200;
+const CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;
+/**
+* Parse cookies from the request headers
+*/
+function parseCookiesFromContext(ctx) {
+	const cookieHeader = ctx.headers?.get("cookie");
+	if (!cookieHeader) return {};
+	const cookies = {};
+	const pairs = cookieHeader.split("; ");
+	for (const pair of pairs) {
+		const [name, ...valueParts] = pair.split("=");
+		if (name && valueParts.length > 0) cookies[name] = valueParts.join("=");
+	}
+	return cookies;
+}
+/**
+* Extract the chunk index from a cookie name
+*/
+function getChunkIndex(cookieName) {
+	const parts = cookieName.split(".");
+	const lastPart = parts[parts.length - 1];
+	const index = parseInt(lastPart || "0", 10);
+	return isNaN(index) ? 0 : index;
+}
+/**
+* Read all existing chunks from cookies
+*/
+function readExistingChunks(cookieName, ctx) {
+	const chunks = {};
+	const cookies = parseCookiesFromContext(ctx);
+	for (const [name, value] of Object.entries(cookies)) if (name.startsWith(cookieName)) chunks[name] = value;
+	return chunks;
+}
+/**
+* Get the full session data by joining all chunks
+*/
+function joinChunks(chunks) {
+	return Object.keys(chunks).sort((a, b) => {
+		return getChunkIndex(a) - getChunkIndex(b);
+	}).map((key) => chunks[key]).join("");
+}
+/**
+* Split a cookie value into chunks if needed
+*/
+function chunkCookie(cookie, chunks, logger$1) {
+	const chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);
+	if (chunkCount === 1) {
+		chunks[cookie.name] = cookie.value;
+		return [cookie];
+	}
+	const cookies = [];
+	for (let i = 0; i < chunkCount; i++) {
+		const name = `${cookie.name}.${i}`;
+		const start = i * CHUNK_SIZE;
+		const value = cookie.value.substring(start, start + CHUNK_SIZE);
+		cookies.push({
+			...cookie,
+			name,
+			value
+		});
+		chunks[name] = value;
+	}
+	logger$1.debug("CHUNKING_SESSION_COOKIE", {
+		message: `Session cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,
+		emptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,
+		valueSize: cookie.value.length,
+		chunkCount,
+		chunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE)
+	});
+	return cookies;
+}
+/**
+* Get all cookies that should be cleaned (removed)
+*/
+function getCleanCookies(chunks, cookieOptions) {
+	const cleanedChunks = {};
+	for (const name in chunks) cleanedChunks[name] = {
+		name,
+		value: "",
+		options: {
+			...cookieOptions,
+			maxAge: 0
+		}
+	};
+	return cleanedChunks;
+}
+/**
+* Create a session store for handling cookie chunking.
+* When session data exceeds 4KB, it automatically splits it into multiple cookies.
+*
+* Based on next-auth's SessionStore implementation.
+* @see https://github.com/nextauthjs/next-auth/blob/27b2519b84b8eb9cf053775dea29d577d2aa0098/packages/next-auth/src/core/lib/cookie.ts
+*/
+function createSessionStore(cookieName, cookieOptions, ctx) {
+	const chunks = readExistingChunks(cookieName, ctx);
+	const logger$1 = ctx.context.logger;
+	return {
+		getValue() {
+			return joinChunks(chunks);
+		},
+		hasChunks() {
+			return Object.keys(chunks).length > 0;
+		},
+		chunk(value, options) {
+			const cleanedChunks = getCleanCookies(chunks, cookieOptions);
+			for (const name in chunks) delete chunks[name];
+			const cookies = cleanedChunks;
+			const chunked = chunkCookie({
+				name: cookieName,
+				value,
+				options: {
+					...cookieOptions,
+					...options
+				}
+			}, chunks, logger$1);
+			for (const chunk of chunked) cookies[chunk.name] = chunk;
+			return Object.values(cookies);
+		},
+		clean() {
+			const cleanedChunks = getCleanCookies(chunks, cookieOptions);
+			for (const name in chunks) delete chunks[name];
+			return Object.values(cleanedChunks);
+		},
+		setCookies(cookies) {
+			for (const cookie of cookies) ctx.setCookie(cookie.name, cookie.value, cookie.options);
+		}
+	};
+}
+function getChunkedCookie(ctx, cookieName) {
+	const value = ctx.getCookie(cookieName);
+	if (value) return value;
+	const chunks = [];
+	const cookieHeader = ctx.headers?.get("cookie");
+	if (!cookieHeader) return null;
+	const cookies = {};
+	const pairs = cookieHeader.split("; ");
+	for (const pair of pairs) {
+		const [name, ...valueParts] = pair.split("=");
+		if (name && valueParts.length > 0) cookies[name] = valueParts.join("=");
+	}
+	for (const [name, val] of Object.entries(cookies)) if (name.startsWith(cookieName + ".")) {
+		const indexStr = name.split(".").at(-1);
+		const index = parseInt(indexStr || "0", 10);
+		if (!isNaN(index)) chunks.push({
+			index,
+			value: val
+		});
+	}
+	if (chunks.length > 0) {
+		chunks.sort((a, b) => a.index - b.index);
+		return chunks.map((c) => c.value).join("");
+	}
+	return null;
+}
+const getSessionQuerySchema = z.optional(z.object({
+	disableCookieCache: z.coerce.boolean().optional(),
+	disableRefresh: z.coerce.boolean().optional()
+}));
+
+//#endregion
+//#region src/cookies/cookie-utils.ts
+function parseSetCookieHeader(setCookie) {
+	const cookies = /* @__PURE__ */ new Map();
+	setCookie.split(", ").forEach((cookieString) => {
+		const [nameValue, ...attributes] = cookieString.split(";").map((part) => part.trim());
+		const [name, ...valueParts] = (nameValue || "").split("=");
+		const value = valueParts.join("=");
+		if (!name || value === void 0) return;
+		const attrObj = { value };
+		attributes.forEach((attribute) => {
+			const [attrName, ...attrValueParts] = attribute.split("=");
+			const attrValue = attrValueParts.join("=");
+			const normalizedAttrName = attrName.trim().toLowerCase();
+			switch (normalizedAttrName) {
+				case "max-age":
+					attrObj["max-age"] = attrValue ? parseInt(attrValue.trim(), 10) : void 0;
+					break;
+				case "expires":
+					attrObj.expires = attrValue ? new Date(attrValue.trim()) : void 0;
+					break;
+				case "domain":
+					attrObj.domain = attrValue ? attrValue.trim() : void 0;
+					break;
+				case "path":
+					attrObj.path = attrValue ? attrValue.trim() : void 0;
+					break;
+				case "secure":
+					attrObj.secure = true;
+					break;
+				case "httponly":
+					attrObj.httponly = true;
+					break;
+				case "samesite":
+					attrObj.samesite = attrValue ? attrValue.trim().toLowerCase() : void 0;
+					break;
+				default:
+					attrObj[normalizedAttrName] = attrValue ? attrValue.trim() : true;
+					break;
+			}
+		});
+		cookies.set(name, attrObj);
+	});
+	return cookies;
+}
+function setCookieToHeader(headers) {
+	return (context) => {
+		const setCookieHeader = context.response.headers.get("set-cookie");
+		if (!setCookieHeader) return;
+		const cookieMap = /* @__PURE__ */ new Map();
+		(headers.get("cookie") || "").split(";").forEach((cookie) => {
+			const [name, ...rest] = cookie.trim().split("=");
+			if (name && rest.length > 0) cookieMap.set(name, rest.join("="));
+		});
+		setCookieHeader.split(",").forEach((header) => {
+			parseSetCookieHeader(header).forEach((value, name) => {
+				cookieMap.set(name, value.value);
+			});
+		});
+		const updatedCookies = Array.from(cookieMap.entries()).map(([name, value]) => `${name}=${value}`).join("; ");
+		headers.set("cookie", updatedCookies);
+	};
+}
+
+//#endregion
+//#region src/cookies/index.ts
+function createCookieGetter(options) {
+	const secureCookiePrefix = (options.advanced?.useSecureCookies !== void 0 ? options.advanced?.useSecureCookies : options.baseURL !== void 0 ? options.baseURL.startsWith("https://") ? true : false : isProduction) ? "__Secure-" : "";
+	const crossSubdomainEnabled = !!options.advanced?.crossSubDomainCookies?.enabled;
+	const domain = crossSubdomainEnabled ? options.advanced?.crossSubDomainCookies?.domain || (options.baseURL ? new URL(options.baseURL).hostname : void 0) : void 0;
+	if (crossSubdomainEnabled && !domain) throw new BetterAuthError("baseURL is required when crossSubdomainCookies are enabled");
+	function createCookie(cookieName, overrideAttributes = {}) {
+		const prefix = options.advanced?.cookiePrefix || "better-auth";
+		const name = options.advanced?.cookies?.[cookieName]?.name || `${prefix}.${cookieName}`;
+		const attributes = options.advanced?.cookies?.[cookieName]?.attributes;
+		return {
+			name: `${secureCookiePrefix}${name}`,
+			attributes: {
+				secure: !!secureCookiePrefix,
+				sameSite: "lax",
+				path: "/",
+				httpOnly: true,
+				...crossSubdomainEnabled ? { domain } : {},
+				...options.advanced?.defaultCookieAttributes,
+				...overrideAttributes,
+				...attributes
+			}
+		};
+	}
+	return createCookie;
+}
+function getCookies(options) {
+	const createCookie = createCookieGetter(options);
+	const sessionToken = createCookie("session_token", { maxAge: options.session?.expiresIn || ms("7d") / 1e3 });
+	const sessionData = createCookie("session_data", { maxAge: options.session?.cookieCache?.maxAge || 300 });
+	const dontRememberToken = createCookie("dont_remember");
+	return {
+		sessionToken: {
+			name: sessionToken.name,
+			options: sessionToken.attributes
+		},
+		sessionData: {
+			name: sessionData.name,
+			options: sessionData.attributes
+		},
+		dontRememberToken: {
+			name: dontRememberToken.name,
+			options: dontRememberToken.attributes
+		}
+	};
+}
+async function setCookieCache(ctx, session, dontRememberMe) {
+	if (ctx.context.options.session?.cookieCache?.enabled) {
+		const filteredSession = Object.entries(session.session).reduce((acc, [key, value]) => {
+			const fieldConfig = ctx.context.options.session?.additionalFields?.[key];
+			if (!fieldConfig || fieldConfig.returned !== false) acc[key] = value;
+			return acc;
+		}, {});
+		const filteredUser = parseUserOutput(ctx.context.options, session.user);
+		const versionConfig = ctx.context.options.session?.cookieCache?.version;
+		let version = "1";
+		if (versionConfig) {
+			if (typeof versionConfig === "string") version = versionConfig;
+			else if (typeof versionConfig === "function") {
+				const result = versionConfig(session.session, session.user);
+				version = result instanceof Promise ? await result : result;
+			}
+		}
+		const sessionData = {
+			session: filteredSession,
+			user: filteredUser,
+			updatedAt: Date.now(),
+			version
+		};
+		const options = {
+			...ctx.context.authCookies.sessionData.options,
+			maxAge: dontRememberMe ? void 0 : ctx.context.authCookies.sessionData.options.maxAge
+		};
+		const expiresAtDate = getDate(options.maxAge || 60, "sec").getTime();
+		const strategy = ctx.context.options.session?.cookieCache?.strategy || "compact";
+		let data;
+		if (strategy === "jwe") data = await symmetricEncodeJWT(sessionData, ctx.context.secret, "better-auth-session", options.maxAge || 300);
+		else if (strategy === "jwt") data = await signJWT(sessionData, ctx.context.secret, options.maxAge || 300);
+		else data = base64Url.encode(JSON.stringify({
+			session: sessionData,
+			expiresAt: expiresAtDate,
+			signature: await createHMAC("SHA-256", "base64urlnopad").sign(ctx.context.secret, JSON.stringify({
+				...sessionData,
+				expiresAt: expiresAtDate
+			}))
+		}), { padding: false });
+		if (data.length > 4093) {
+			const sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, options, ctx);
+			const cookies = sessionStore.chunk(data, options);
+			sessionStore.setCookies(cookies);
+		} else {
+			const sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, options, ctx);
+			if (sessionStore.hasChunks()) {
+				const cleanCookies = sessionStore.clean();
+				sessionStore.setCookies(cleanCookies);
+			}
+			ctx.setCookie(ctx.context.authCookies.sessionData.name, data, options);
+		}
+	}
+}
+async function setSessionCookie(ctx, session, dontRememberMe, overrides) {
+	const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
+	dontRememberMe = dontRememberMe !== void 0 ? dontRememberMe : !!dontRememberMeCookie;
+	const options = ctx.context.authCookies.sessionToken.options;
+	const maxAge = dontRememberMe ? void 0 : ctx.context.sessionConfig.expiresIn;
+	await ctx.setSignedCookie(ctx.context.authCookies.sessionToken.name, session.session.token, ctx.context.secret, {
+		...options,
+		maxAge,
+		...overrides
+	});
+	if (dontRememberMe) await ctx.setSignedCookie(ctx.context.authCookies.dontRememberToken.name, "true", ctx.context.secret, ctx.context.authCookies.dontRememberToken.options);
+	await setCookieCache(ctx, session, dontRememberMe);
+	ctx.context.setNewSession(session);
+	/**
+	* If secondary storage is enabled, store the session data in the secondary storage
+	* This is useful if the session got updated and we want to update the session data in the
+	* secondary storage
+	*/
+	if (ctx.context.options.secondaryStorage) await ctx.context.secondaryStorage?.set(session.session.token, JSON.stringify({
+		user: session.user,
+		session: session.session
+	}), Math.floor((new Date(session.session.expiresAt).getTime() - Date.now()) / 1e3));
+}
+function deleteSessionCookie(ctx, skipDontRememberMe) {
+	ctx.setCookie(ctx.context.authCookies.sessionToken.name, "", {
+		...ctx.context.authCookies.sessionToken.options,
+		maxAge: 0
+	});
+	const sessionStore = createSessionStore(ctx.context.authCookies.sessionData.name, ctx.context.authCookies.sessionData.options, ctx);
+	const cleanCookies = sessionStore.clean();
+	sessionStore.setCookies(cleanCookies);
+	if (!skipDontRememberMe) ctx.setCookie(ctx.context.authCookies.dontRememberToken.name, "", {
+		...ctx.context.authCookies.dontRememberToken.options,
+		maxAge: 0
+	});
+}
+function parseCookies(cookieHeader) {
+	const cookies = cookieHeader.split("; ");
+	const cookieMap = /* @__PURE__ */ new Map();
+	cookies.forEach((cookie) => {
+		const [name, value] = cookie.split("=");
+		cookieMap.set(name, value);
+	});
+	return cookieMap;
+}
+const getSessionCookie = (request, config) => {
+	if (config?.cookiePrefix) if (config.cookieName) config.cookiePrefix = `${config.cookiePrefix}-`;
+	else config.cookiePrefix = `${config.cookiePrefix}.`;
+	const headers = "headers" in request ? request.headers : request;
+	const req = request instanceof Request ? request : void 0;
+	getBaseURL(req?.url, config?.path, req);
+	const cookies = headers.get("cookie");
+	if (!cookies) return null;
+	const { cookieName = "session_token", cookiePrefix = "better-auth." } = config || {};
+	const name = `${cookiePrefix}${cookieName}`;
+	const secureCookieName = `__Secure-${name}`;
+	const parsedCookie = parseCookies(cookies);
+	const sessionToken = parsedCookie.get(name) || parsedCookie.get(secureCookieName);
+	if (sessionToken) return sessionToken;
+	return null;
+};
+const getCookieCache = async (request, config) => {
+	const cookies = (request instanceof Headers ? request : request.headers).get("cookie");
+	if (!cookies) return null;
+	const { cookieName = "session_data", cookiePrefix = "better-auth" } = config || {};
+	const name = config?.isSecure !== void 0 ? config.isSecure ? `__Secure-${cookiePrefix}.${cookieName}` : `${cookiePrefix}.${cookieName}` : isProduction ? `__Secure-${cookiePrefix}.${cookieName}` : `${cookiePrefix}.${cookieName}`;
+	const parsedCookie = parseCookies(cookies);
+	let sessionData = parsedCookie.get(name);
+	if (!sessionData) {
+		const chunks = [];
+		for (const [cookieName$1, value] of parsedCookie.entries()) if (cookieName$1.startsWith(name + ".")) {
+			const parts = cookieName$1.split(".");
+			const indexStr = parts[parts.length - 1];
+			const index = parseInt(indexStr || "0", 10);
+			if (!isNaN(index)) chunks.push({
+				index,
+				value
+			});
+		}
+		if (chunks.length > 0) {
+			chunks.sort((a, b) => a.index - b.index);
+			sessionData = chunks.map((c) => c.value).join("");
+		}
+	}
+	if (sessionData) {
+		const secret = config?.secret || env.BETTER_AUTH_SECRET;
+		if (!secret) throw new BetterAuthError("getCookieCache requires a secret to be provided. Either pass it as an option or set the BETTER_AUTH_SECRET environment variable");
+		const strategy = config?.strategy || "compact";
+		if (strategy === "jwe") {
+			const payload = await symmetricDecodeJWT(sessionData, secret, "better-auth-session");
+			if (payload && payload.session && payload.user) {
+				if (config?.version) {
+					const cookieVersion = payload.version || "1";
+					let expectedVersion = "1";
+					if (typeof config.version === "string") expectedVersion = config.version;
+					else if (typeof config.version === "function") {
+						const result = config.version(payload.session, payload.user);
+						expectedVersion = result instanceof Promise ? await result : result;
+					}
+					if (cookieVersion !== expectedVersion) return null;
+				}
+				return payload;
+			}
+			return null;
+		} else if (strategy === "jwt") {
+			const payload = await verifyJWT(sessionData, secret);
+			if (payload && payload.session && payload.user) {
+				if (config?.version) {
+					const cookieVersion = payload.version || "1";
+					let expectedVersion = "1";
+					if (typeof config.version === "string") expectedVersion = config.version;
+					else if (typeof config.version === "function") {
+						const result = config.version(payload.session, payload.user);
+						expectedVersion = result instanceof Promise ? await result : result;
+					}
+					if (cookieVersion !== expectedVersion) return null;
+				}
+				return payload;
+			}
+			return null;
+		} else {
+			const sessionDataPayload = safeJSONParse(binary.decode(base64Url.decode(sessionData)));
+			if (!sessionDataPayload) return null;
+			if (!await createHMAC("SHA-256", "base64urlnopad").verify(secret, JSON.stringify({
+				...sessionDataPayload.session,
+				expiresAt: sessionDataPayload.expiresAt
+			}), sessionDataPayload.signature)) return null;
+			if (config?.version && sessionDataPayload.session) {
+				const cookieVersion = sessionDataPayload.session.version || "1";
+				let expectedVersion = "1";
+				if (typeof config.version === "string") expectedVersion = config.version;
+				else if (typeof config.version === "function") {
+					const result = config.version(sessionDataPayload.session.session, sessionDataPayload.session.user);
+					expectedVersion = result instanceof Promise ? await result : result;
+				}
+				if (cookieVersion !== expectedVersion) return null;
+			}
+			return sessionDataPayload.session;
+		}
+	}
+	return null;
+};
+
+//#endregion
+export { getSessionCookie as a, setSessionCookie as c, createSessionStore as d, getChunkedCookie as f, getCookies as i, parseSetCookieHeader as l, ms as m, deleteSessionCookie as n, parseCookies as o, getSessionQuerySchema as p, getCookieCache as r, setCookieCache as s, createCookieGetter as t, setCookieToHeader as u };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/cookies/index.mjs.bak b/node_modules/better-auth/dist/cookies/index.mjs.bak
new file mode 100644
index 0000000..09701b8
--- /dev/null
+++ b/node_modules/better-auth/dist/cookies/index.mjs.bak
@@ -0,0 +1,7 @@
+import "../jwt-CmxZAGe2.mjs";
+import "../schema-BevzneML.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import { a as getSessionCookie, c as setSessionCookie, d as createSessionStore, f as getChunkedCookie, i as getCookies, l as parseSetCookieHeader, n as deleteSessionCookie, o as parseCookies, r as getCookieCache, s as setCookieCache, t as createCookieGetter, u as setCookieToHeader } from "../cookies-Cl2L38B1.mjs";
+
+export { createCookieGetter, createSessionStore, deleteSessionCookie, getChunkedCookie, getCookieCache, getCookies, getSessionCookie, parseCookies, parseSetCookieHeader, setCookieCache, setCookieToHeader, setSessionCookie };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/crypto-DZW3hrq1.mjs.bak b/node_modules/better-auth/dist/crypto-DZW3hrq1.mjs.bak
new file mode 100644
index 0000000..ef27153
--- /dev/null
+++ b/node_modules/better-auth/dist/crypto-DZW3hrq1.mjs.bak
@@ -0,0 +1,70 @@
+import { BetterAuthError } from "@better-auth/core/error";
+import { createHash } from "@better-auth/utils/hash";
+import { xchacha20poly1305 } from "@noble/ciphers/chacha.js";
+import { bytesToHex, hexToBytes, managedNonce, utf8ToBytes } from "@noble/ciphers/utils.js";
+import { hex } from "@better-auth/utils/hex";
+import { scryptAsync } from "@noble/hashes/scrypt.js";
+import { hexToBytes as hexToBytes$1 } from "@noble/hashes/utils.js";
+import { createRandomStringGenerator } from "@better-auth/utils/random";
+
+//#region src/crypto/buffer.ts
+/**
+* Compare two buffers in constant time.
+*/
+function constantTimeEqual(a, b) {
+	const aBuffer = new Uint8Array(a);
+	const bBuffer = new Uint8Array(b);
+	let c = aBuffer.length ^ bBuffer.length;
+	const length = Math.max(aBuffer.length, bBuffer.length);
+	for (let i = 0; i < length; i++) c |= (i < aBuffer.length ? aBuffer[i] : 0) ^ (i < bBuffer.length ? bBuffer[i] : 0);
+	return c === 0;
+}
+
+//#endregion
+//#region src/crypto/password.ts
+const config = {
+	N: 16384,
+	r: 16,
+	p: 1,
+	dkLen: 64
+};
+async function generateKey(password, salt) {
+	return await scryptAsync(password.normalize("NFKC"), salt, {
+		N: config.N,
+		p: config.p,
+		r: config.r,
+		dkLen: config.dkLen,
+		maxmem: 128 * config.N * config.r * 2
+	});
+}
+const hashPassword = async (password) => {
+	const salt = hex.encode(crypto.getRandomValues(new Uint8Array(16)));
+	const key = await generateKey(password, salt);
+	return `${salt}:${hex.encode(key)}`;
+};
+const verifyPassword = async ({ hash, password }) => {
+	const [salt, key] = hash.split(":");
+	if (!salt || !key) throw new BetterAuthError("Invalid password hash");
+	return constantTimeEqual(await generateKey(password, salt), hexToBytes$1(key));
+};
+
+//#endregion
+//#region src/crypto/random.ts
+const generateRandomString = createRandomStringGenerator("a-z", "0-9", "A-Z", "-_");
+
+//#endregion
+//#region src/crypto/index.ts
+const symmetricEncrypt = async ({ key, data }) => {
+	const keyAsBytes = await createHash("SHA-256").digest(key);
+	const dataAsBytes = utf8ToBytes(data);
+	return bytesToHex(managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes)).encrypt(dataAsBytes));
+};
+const symmetricDecrypt = async ({ key, data }) => {
+	const keyAsBytes = await createHash("SHA-256").digest(key);
+	const dataAsBytes = hexToBytes(data);
+	const chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));
+	return new TextDecoder().decode(chacha.decrypt(dataAsBytes));
+};
+
+//#endregion
+export { verifyPassword as a, hashPassword as i, symmetricEncrypt as n, constantTimeEqual as o, generateRandomString as r, symmetricDecrypt as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/crypto/index.mjs.bak b/node_modules/better-auth/dist/crypto/index.mjs.bak
new file mode 100644
index 0000000..2413f09
--- /dev/null
+++ b/node_modules/better-auth/dist/crypto/index.mjs.bak
@@ -0,0 +1,4 @@
+import { a as verifyPassword, i as hashPassword, n as symmetricEncrypt, o as constantTimeEqual, r as generateRandomString, t as symmetricDecrypt } from "../crypto-DZW3hrq1.mjs";
+import { i as verifyJWT, n as symmetricDecodeJWT, r as symmetricEncodeJWT, t as signJWT } from "../jwt-CmxZAGe2.mjs";
+
+export { constantTimeEqual, generateRandomString, hashPassword, signJWT, symmetricDecodeJWT, symmetricDecrypt, symmetricEncodeJWT, symmetricEncrypt, verifyJWT, verifyPassword };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/custom-session-BDpuPRbk.mjs b/node_modules/better-auth/dist/custom-session-BDpuPRbk.mjs
index 6970ed1..b388c4c 100644
--- a/node_modules/better-auth/dist/custom-session-BDpuPRbk.mjs
+++ b/node_modules/better-auth/dist/custom-session-BDpuPRbk.mjs
@@ -5,8 +5,8 @@ import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api"
 
 //#region src/plugins/custom-session/index.ts
 const getSessionQuerySchema = z.optional(z.object({
-	disableCookieCache: z.boolean().meta({ description: "Disable cookie cache and fetch session from database" }).or(z.string().transform((v) => v === "true")).optional(),
-	disableRefresh: z.boolean().meta({ description: "Disable session refresh. Useful for checking session status, without updating the session" }).optional()
+	disableCookieCache: z.boolean().or(z.string().transform((v) => v === "true")).optional(),
+	disableRefresh: z.boolean().optional()
 }));
 const customSession = (fn, options, pluginOptions) => {
 	return {
diff --git a/node_modules/better-auth/dist/custom-session-BDpuPRbk.mjs.bak b/node_modules/better-auth/dist/custom-session-BDpuPRbk.mjs.bak
new file mode 100644
index 0000000..6970ed1
--- /dev/null
+++ b/node_modules/better-auth/dist/custom-session-BDpuPRbk.mjs.bak
@@ -0,0 +1,67 @@
+import { n as getSession } from "./session-Efap-vxj.mjs";
+import { t as getEndpointResponse } from "./plugin-helper-RJJBTOba.mjs";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/custom-session/index.ts
+const getSessionQuerySchema = z.optional(z.object({
+	disableCookieCache: z.boolean().meta({ description: "Disable cookie cache and fetch session from database" }).or(z.string().transform((v) => v === "true")).optional(),
+	disableRefresh: z.boolean().meta({ description: "Disable session refresh. Useful for checking session status, without updating the session" }).optional()
+}));
+const customSession = (fn, options, pluginOptions) => {
+	return {
+		id: "custom-session",
+		hooks: { after: [{
+			matcher: (ctx) => ctx.path === "/multi-session/list-device-sessions" && (pluginOptions?.shouldMutateListDeviceSessionsEndpoint ?? false),
+			handler: createAuthMiddleware(async (ctx) => {
+				const response = await getEndpointResponse(ctx);
+				if (!response) return;
+				const newResponse = await Promise.all(response.map(async (v) => await fn(v, ctx)));
+				return ctx.json(newResponse);
+			})
+		}] },
+		endpoints: { getSession: createAuthEndpoint("/get-session", {
+			method: "GET",
+			query: getSessionQuerySchema,
+			metadata: {
+				CUSTOM_SESSION: true,
+				openapi: {
+					description: "Get custom session data",
+					responses: { "200": {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "array",
+							nullable: true,
+							items: { $ref: "#/components/schemas/Session" }
+						} } }
+					} }
+				}
+			},
+			requireHeaders: true
+		}, async (ctx) => {
+			const session = await getSession()({
+				...ctx,
+				asResponse: false,
+				headers: ctx.headers,
+				returnHeaders: true
+			}).catch((e) => {
+				return null;
+			});
+			if (!session?.response) return ctx.json(null);
+			const fnResult = await fn(session.response, ctx);
+			const setCookie = session.headers.get("set-cookie");
+			if (setCookie) {
+				ctx.setHeader("set-cookie", setCookie);
+				session.headers.delete("set-cookie");
+			}
+			session.headers.forEach((value, key) => {
+				ctx.setHeader(key, value);
+			});
+			return ctx.json(fnResult);
+		}) },
+		$Infer: { Session: {} }
+	};
+};
+
+//#endregion
+export { customSession as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/db/index.mjs.bak b/node_modules/better-auth/dist/db/index.mjs.bak
new file mode 100644
index 0000000..d8ff6fc
--- /dev/null
+++ b/node_modules/better-auth/dist/db/index.mjs.bak
@@ -0,0 +1,15 @@
+import "../dialect-BhkkSrrx.mjs";
+import { a as getAuthTables } from "../get-model-name-nJd9iPTo.mjs";
+import { a as createInternalAdapter, c as convertToDB, d as getBaseAdapter, i as toZodSchema, l as createFieldAttribute, n as matchType, o as getWithHooks, r as getSchema, s as convertFromDB, t as getMigrations, u as getAdapter } from "../get-migration-C1tgKlQ6.mjs";
+import "../types-BReKsBV6.mjs";
+import "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import { a as parseInputData, c as parseUserInput, i as parseAdditionalUserInput, l as parseUserOutput, n as parseAccountInput, o as parseSessionInput, r as parseAccountOutput, s as parseSessionOutput, t as mergeSchema } from "../schema-BevzneML.mjs";
+import "../get-request-ip-kbu825ez.mjs";
+import "../json-BS-nL3f-.mjs";
+
+export * from "@better-auth/core/db"
+
+export { convertFromDB, convertToDB, createFieldAttribute, createInternalAdapter, getAdapter, getAuthTables, getBaseAdapter, getMigrations, getSchema, getWithHooks, matchType, mergeSchema, parseAccountInput, parseAccountOutput, parseAdditionalUserInput, parseInputData, parseSessionInput, parseSessionOutput, parseUserInput, parseUserOutput, toZodSchema };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/device-authorization-CIxU2CCU.mjs b/node_modules/better-auth/dist/device-authorization-CIxU2CCU.mjs
index 6de48a7..d89fc81 100644
--- a/node_modules/better-auth/dist/device-authorization-CIxU2CCU.mjs
+++ b/node_modules/better-auth/dist/device-authorization-CIxU2CCU.mjs
@@ -125,12 +125,12 @@ const deviceAuthorization = (options = {}) => {
 			deviceCode: createAuthEndpoint("/device/code", {
 				method: "POST",
 				body: z.object({
-					client_id: z.string().meta({ description: "The client ID of the application" }),
-					scope: z.string().meta({ description: "Space-separated list of scopes" }).optional()
+					client_id: z.string(),
+					scope: z.string().optional()
 				}),
 				error: z.object({
-					error: z.enum(["invalid_request", "invalid_client"]).meta({ description: "Error code" }),
-					error_description: z.string().meta({ description: "Detailed error description" })
+					error: z.enum(["invalid_request", "invalid_client"]),
+					error_description: z.string()
 				}),
 				metadata: { openapi: {
 					description: `Request a device and user code
@@ -224,9 +224,9 @@ Follow [rfc8628#section-3.2](https://datatracker.ietf.org/doc/html/rfc8628#secti
 			deviceToken: createAuthEndpoint("/device/token", {
 				method: "POST",
 				body: z.object({
-					grant_type: z.literal("urn:ietf:params:oauth:grant-type:device_code").meta({ description: "The grant type for device flow" }),
-					device_code: z.string().meta({ description: "The device verification code" }),
-					client_id: z.string().meta({ description: "The client ID of the application" })
+					grant_type: z.literal("urn:ietf:params:oauth:grant-type:device_code"),
+					device_code: z.string(),
+					client_id: z.string()
 				}),
 				error: z.object({
 					error: z.enum([
@@ -236,8 +236,8 @@ Follow [rfc8628#section-3.2](https://datatracker.ietf.org/doc/html/rfc8628#secti
 						"access_denied",
 						"invalid_request",
 						"invalid_grant"
-					]).meta({ description: "Error code" }),
-					error_description: z.string().meta({ description: "Detailed error description" })
+					]),
+					error_description: z.string()
 				}),
 				metadata: { openapi: {
 					description: `Exchange device code for access token
@@ -386,10 +386,10 @@ Follow [rfc8628#section-3.4](https://datatracker.ietf.org/doc/html/rfc8628#secti
 			}),
 			deviceVerify: createAuthEndpoint("/device", {
 				method: "GET",
-				query: z.object({ user_code: z.string().meta({ description: "The user code to verify" }) }),
+				query: z.object({ user_code: z.string() }),
 				error: z.object({
-					error: z.enum(["invalid_request"]).meta({ description: "Error code" }),
-					error_description: z.string().meta({ description: "Detailed error description" })
+					error: z.enum(["invalid_request"]),
+					error_description: z.string()
 				}),
 				metadata: { openapi: {
 					description: "Display device verification page",
@@ -440,14 +440,14 @@ Follow [rfc8628#section-3.4](https://datatracker.ietf.org/doc/html/rfc8628#secti
 			}),
 			deviceApprove: createAuthEndpoint("/device/approve", {
 				method: "POST",
-				body: z.object({ userCode: z.string().meta({ description: "The user code to approve" }) }),
+				body: z.object({ userCode: z.string() }),
 				error: z.object({
 					error: z.enum([
 						"invalid_request",
 						"expired_token",
 						"device_code_already_processed"
-					]).meta({ description: "Error code" }),
-					error_description: z.string().meta({ description: "Detailed error description" })
+					]),
+					error_description: z.string()
 				}),
 				requireHeaders: true,
 				metadata: { openapi: {
@@ -501,10 +501,10 @@ Follow [rfc8628#section-3.4](https://datatracker.ietf.org/doc/html/rfc8628#secti
 			}),
 			deviceDeny: createAuthEndpoint("/device/deny", {
 				method: "POST",
-				body: z.object({ userCode: z.string().meta({ description: "The user code to deny" }) }),
+				body: z.object({ userCode: z.string() }),
 				error: z.object({
-					error: z.enum(["invalid_request", "expired_token"]).meta({ description: "Error code" }),
-					error_description: z.string().meta({ description: "Detailed error description" })
+					error: z.enum(["invalid_request", "expired_token"]),
+					error_description: z.string()
 				}),
 				metadata: { openapi: {
 					description: "Deny device authorization",
diff --git a/node_modules/better-auth/dist/device-authorization-CIxU2CCU.mjs.bak b/node_modules/better-auth/dist/device-authorization-CIxU2CCU.mjs.bak
new file mode 100644
index 0000000..6de48a7
--- /dev/null
+++ b/node_modules/better-auth/dist/device-authorization-CIxU2CCU.mjs.bak
@@ -0,0 +1,557 @@
+import { r as generateRandomString } from "./crypto-DZW3hrq1.mjs";
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { m as ms } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx } from "./session-Efap-vxj.mjs";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createAuthEndpoint } from "@better-auth/core/api";
+
+//#region src/plugins/device-authorization/schema.ts
+const schema = { deviceCode: { fields: {
+	deviceCode: {
+		type: "string",
+		required: true
+	},
+	userCode: {
+		type: "string",
+		required: true
+	},
+	userId: {
+		type: "string",
+		required: false
+	},
+	expiresAt: {
+		type: "date",
+		required: true
+	},
+	status: {
+		type: "string",
+		required: true
+	},
+	lastPolledAt: {
+		type: "date",
+		required: false
+	},
+	pollingInterval: {
+		type: "number",
+		required: false
+	},
+	clientId: {
+		type: "string",
+		required: false
+	},
+	scope: {
+		type: "string",
+		required: false
+	}
+} } };
+const deviceCode = z.object({
+	id: z.string(),
+	deviceCode: z.string(),
+	userCode: z.string(),
+	userId: z.string().optional(),
+	expiresAt: z.date(),
+	status: z.string(),
+	lastPolledAt: z.date().optional(),
+	pollingInterval: z.number().optional(),
+	clientId: z.string().optional(),
+	scope: z.string().optional()
+});
+
+//#endregion
+//#region src/plugins/device-authorization/index.ts
+const msStringValueSchema = z.custom((val) => {
+	try {
+		ms(val);
+	} catch (e) {
+		return false;
+	}
+	return true;
+}, { message: "Invalid time string format. Use formats like '30m', '5s', '1h', etc." });
+const $deviceAuthorizationOptionsSchema = z.object({
+	expiresIn: msStringValueSchema.default("30m").describe("Time in seconds until the device code expires. Use formats like '30m', '5s', '1h', etc."),
+	interval: msStringValueSchema.default("5s").describe("Time in seconds between polling attempts. Use formats like '30m', '5s', '1h', etc."),
+	deviceCodeLength: z.number().int().positive().default(40).describe("Length of the device code to be generated. Default is 40 characters."),
+	userCodeLength: z.number().int().positive().default(8).describe("Length of the user code to be generated. Default is 8 characters."),
+	generateDeviceCode: z.custom((val) => typeof val === "function", { message: "generateDeviceCode must be a function that returns a string or a promise that resolves to a string." }).optional().describe("Function to generate a device code. If not provided, a default random string generator will be used."),
+	generateUserCode: z.custom((val) => typeof val === "function", { message: "generateUserCode must be a function that returns a string or a promise that resolves to a string." }).optional().describe("Function to generate a user code. If not provided, a default random string generator will be used."),
+	validateClient: z.custom((val) => typeof val === "function", { message: "validateClient must be a function that returns a boolean or a promise that resolves to a boolean." }).optional().describe("Function to validate the client ID. If not provided, no validation will be performed."),
+	onDeviceAuthRequest: z.custom((val) => typeof val === "function", { message: "onDeviceAuthRequest must be a function that returns void or a promise that resolves to void." }).optional().describe("Function to handle device authorization requests. If not provided, no additional actions will be taken."),
+	schema: z.custom(() => true)
+});
+const DEVICE_AUTHORIZATION_ERROR_CODES = defineErrorCodes({
+	INVALID_DEVICE_CODE: "Invalid device code",
+	EXPIRED_DEVICE_CODE: "Device code has expired",
+	EXPIRED_USER_CODE: "User code has expired",
+	AUTHORIZATION_PENDING: "Authorization pending",
+	ACCESS_DENIED: "Access denied",
+	INVALID_USER_CODE: "Invalid user code",
+	DEVICE_CODE_ALREADY_PROCESSED: "Device code already processed",
+	POLLING_TOO_FREQUENTLY: "Polling too frequently",
+	USER_NOT_FOUND: "User not found",
+	FAILED_TO_CREATE_SESSION: "Failed to create session",
+	INVALID_DEVICE_CODE_STATUS: "Invalid device code status",
+	AUTHENTICATION_REQUIRED: "Authentication required"
+});
+const defaultCharset = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
+/**
+* @internal
+*/
+const defaultGenerateDeviceCode = (length) => {
+	return generateRandomString(length, "a-z", "A-Z", "0-9");
+};
+/**
+* @internal
+*/
+const defaultGenerateUserCode = (length) => {
+	const chars = new Uint8Array(length);
+	return Array.from(crypto.getRandomValues(chars)).map((byte) => defaultCharset[byte % 32]).join("");
+};
+const deviceAuthorization = (options = {}) => {
+	const opts = $deviceAuthorizationOptionsSchema.parse(options);
+	const generateDeviceCode = async () => {
+		if (opts.generateDeviceCode) return opts.generateDeviceCode();
+		return defaultGenerateDeviceCode(opts.deviceCodeLength);
+	};
+	const generateUserCode = async () => {
+		if (opts.generateUserCode) return opts.generateUserCode();
+		return defaultGenerateUserCode(opts.userCodeLength);
+	};
+	return {
+		id: "device-authorization",
+		schema: mergeSchema(schema, options?.schema),
+		endpoints: {
+			deviceCode: createAuthEndpoint("/device/code", {
+				method: "POST",
+				body: z.object({
+					client_id: z.string().meta({ description: "The client ID of the application" }),
+					scope: z.string().meta({ description: "Space-separated list of scopes" }).optional()
+				}),
+				error: z.object({
+					error: z.enum(["invalid_request", "invalid_client"]).meta({ description: "Error code" }),
+					error_description: z.string().meta({ description: "Detailed error description" })
+				}),
+				metadata: { openapi: {
+					description: `Request a device and user code
+
+Follow [rfc8628#section-3.2](https://datatracker.ietf.org/doc/html/rfc8628#section-3.2)`,
+					responses: {
+						200: {
+							description: "Success",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									device_code: {
+										type: "string",
+										description: "The device verification code"
+									},
+									user_code: {
+										type: "string",
+										description: "The user code to display"
+									},
+									verification_uri: {
+										type: "string",
+										description: "The URL for user verification"
+									},
+									verification_uri_complete: {
+										type: "string",
+										description: "The complete URL with user code"
+									},
+									expires_in: {
+										type: "number",
+										description: "Lifetime in seconds of the device code"
+									},
+									interval: {
+										type: "number",
+										description: "Minimum polling interval in seconds"
+									}
+								}
+							} } }
+						},
+						400: {
+							description: "Error response",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									error: {
+										type: "string",
+										enum: ["invalid_request", "invalid_client"]
+									},
+									error_description: { type: "string" }
+								}
+							} } }
+						}
+					}
+				} }
+			}, async (ctx) => {
+				if (opts.validateClient) {
+					if (!await opts.validateClient(ctx.body.client_id)) throw new APIError("BAD_REQUEST", {
+						error: "invalid_client",
+						error_description: "Invalid client ID"
+					});
+				}
+				if (opts.onDeviceAuthRequest) await opts.onDeviceAuthRequest(ctx.body.client_id, ctx.body.scope);
+				const deviceCode$1 = await generateDeviceCode();
+				const userCode = await generateUserCode();
+				const expiresIn = ms(opts.expiresIn);
+				const expiresAt = new Date(Date.now() + expiresIn);
+				await ctx.context.adapter.create({
+					model: "deviceCode",
+					data: {
+						deviceCode: deviceCode$1,
+						userCode,
+						expiresAt,
+						status: "pending",
+						pollingInterval: ms(opts.interval),
+						clientId: ctx.body.client_id,
+						scope: ctx.body.scope
+					}
+				});
+				const baseURL = new URL(ctx.context.baseURL);
+				const verification_uri = new URL("/device", baseURL);
+				const verification_uri_complete = new URL(verification_uri);
+				verification_uri_complete.searchParams.set("user_code", encodeURIComponent(userCode));
+				return ctx.json({
+					device_code: deviceCode$1,
+					user_code: userCode,
+					verification_uri: verification_uri.toString(),
+					verification_uri_complete: verification_uri_complete.toString(),
+					expires_in: Math.floor(expiresIn / 1e3),
+					interval: Math.floor(ms(opts.interval) / 1e3)
+				}, { headers: { "Cache-Control": "no-store" } });
+			}),
+			deviceToken: createAuthEndpoint("/device/token", {
+				method: "POST",
+				body: z.object({
+					grant_type: z.literal("urn:ietf:params:oauth:grant-type:device_code").meta({ description: "The grant type for device flow" }),
+					device_code: z.string().meta({ description: "The device verification code" }),
+					client_id: z.string().meta({ description: "The client ID of the application" })
+				}),
+				error: z.object({
+					error: z.enum([
+						"authorization_pending",
+						"slow_down",
+						"expired_token",
+						"access_denied",
+						"invalid_request",
+						"invalid_grant"
+					]).meta({ description: "Error code" }),
+					error_description: z.string().meta({ description: "Detailed error description" })
+				}),
+				metadata: { openapi: {
+					description: `Exchange device code for access token
+
+Follow [rfc8628#section-3.4](https://datatracker.ietf.org/doc/html/rfc8628#section-3.4)`,
+					responses: {
+						200: {
+							description: "Success",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									session: { $ref: "#/components/schemas/Session" },
+									user: { $ref: "#/components/schemas/User" }
+								}
+							} } }
+						},
+						400: {
+							description: "Error response",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									error: {
+										type: "string",
+										enum: [
+											"authorization_pending",
+											"slow_down",
+											"expired_token",
+											"access_denied",
+											"invalid_request",
+											"invalid_grant"
+										]
+									},
+									error_description: { type: "string" }
+								}
+							} } }
+						}
+					}
+				} }
+			}, async (ctx) => {
+				const { device_code, client_id } = ctx.body;
+				if (opts.validateClient) {
+					if (!await opts.validateClient(client_id)) throw new APIError("BAD_REQUEST", {
+						error: "invalid_grant",
+						error_description: "Invalid client ID"
+					});
+				}
+				const deviceCodeRecord = await ctx.context.adapter.findOne({
+					model: "deviceCode",
+					where: [{
+						field: "deviceCode",
+						value: device_code
+					}]
+				});
+				if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
+					error: "invalid_grant",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_DEVICE_CODE
+				});
+				if (deviceCodeRecord.clientId && deviceCodeRecord.clientId !== client_id) throw new APIError("BAD_REQUEST", {
+					error: "invalid_grant",
+					error_description: "Client ID mismatch"
+				});
+				if (deviceCodeRecord.lastPolledAt && deviceCodeRecord.pollingInterval) {
+					if (Date.now() - new Date(deviceCodeRecord.lastPolledAt).getTime() < deviceCodeRecord.pollingInterval) throw new APIError("BAD_REQUEST", {
+						error: "slow_down",
+						error_description: DEVICE_AUTHORIZATION_ERROR_CODES.POLLING_TOO_FREQUENTLY
+					});
+				}
+				await ctx.context.adapter.update({
+					model: "deviceCode",
+					where: [{
+						field: "id",
+						value: deviceCodeRecord.id
+					}],
+					update: { lastPolledAt: /* @__PURE__ */ new Date() }
+				});
+				if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) {
+					await ctx.context.adapter.delete({
+						model: "deviceCode",
+						where: [{
+							field: "id",
+							value: deviceCodeRecord.id
+						}]
+					});
+					throw new APIError("BAD_REQUEST", {
+						error: "expired_token",
+						error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_DEVICE_CODE
+					});
+				}
+				if (deviceCodeRecord.status === "pending") throw new APIError("BAD_REQUEST", {
+					error: "authorization_pending",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHORIZATION_PENDING
+				});
+				if (deviceCodeRecord.status === "denied") {
+					await ctx.context.adapter.delete({
+						model: "deviceCode",
+						where: [{
+							field: "id",
+							value: deviceCodeRecord.id
+						}]
+					});
+					throw new APIError("BAD_REQUEST", {
+						error: "access_denied",
+						error_description: DEVICE_AUTHORIZATION_ERROR_CODES.ACCESS_DENIED
+					});
+				}
+				if (deviceCodeRecord.status === "approved" && deviceCodeRecord.userId) {
+					await ctx.context.adapter.delete({
+						model: "deviceCode",
+						where: [{
+							field: "id",
+							value: deviceCodeRecord.id
+						}]
+					});
+					const user = await ctx.context.internalAdapter.findUserById(deviceCodeRecord.userId);
+					if (!user) throw new APIError("INTERNAL_SERVER_ERROR", {
+						error: "server_error",
+						error_description: DEVICE_AUTHORIZATION_ERROR_CODES.USER_NOT_FOUND
+					});
+					const session = await ctx.context.internalAdapter.createSession(user.id);
+					if (!session) throw new APIError("INTERNAL_SERVER_ERROR", {
+						error: "server_error",
+						error_description: DEVICE_AUTHORIZATION_ERROR_CODES.FAILED_TO_CREATE_SESSION
+					});
+					ctx.context.setNewSession({
+						session,
+						user
+					});
+					if (ctx.context.options.secondaryStorage) await ctx.context.secondaryStorage?.set(session.token, JSON.stringify({
+						user,
+						session
+					}), Math.floor((new Date(session.expiresAt).getTime() - Date.now()) / 1e3));
+					return ctx.json({
+						access_token: session.token,
+						token_type: "Bearer",
+						expires_in: Math.floor((new Date(session.expiresAt).getTime() - Date.now()) / 1e3),
+						scope: deviceCodeRecord.scope || ""
+					}, { headers: {
+						"Cache-Control": "no-store",
+						Pragma: "no-cache"
+					} });
+				}
+				throw new APIError("INTERNAL_SERVER_ERROR", {
+					error: "server_error",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_DEVICE_CODE_STATUS
+				});
+			}),
+			deviceVerify: createAuthEndpoint("/device", {
+				method: "GET",
+				query: z.object({ user_code: z.string().meta({ description: "The user code to verify" }) }),
+				error: z.object({
+					error: z.enum(["invalid_request"]).meta({ description: "Error code" }),
+					error_description: z.string().meta({ description: "Detailed error description" })
+				}),
+				metadata: { openapi: {
+					description: "Display device verification page",
+					responses: { 200: {
+						description: "Verification page HTML",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								user_code: {
+									type: "string",
+									description: "The user code to verify"
+								},
+								status: {
+									type: "string",
+									enum: [
+										"pending",
+										"approved",
+										"denied"
+									],
+									description: "Current status of the device authorization"
+								}
+							}
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { user_code } = ctx.query;
+				const cleanUserCode = user_code.replace(/-/g, "");
+				const deviceCodeRecord = await ctx.context.adapter.findOne({
+					model: "deviceCode",
+					where: [{
+						field: "userCode",
+						value: cleanUserCode
+					}]
+				});
+				if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
+					error: "invalid_request",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
+				});
+				if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", {
+					error: "expired_token",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
+				});
+				return ctx.json({
+					user_code,
+					status: deviceCodeRecord.status
+				});
+			}),
+			deviceApprove: createAuthEndpoint("/device/approve", {
+				method: "POST",
+				body: z.object({ userCode: z.string().meta({ description: "The user code to approve" }) }),
+				error: z.object({
+					error: z.enum([
+						"invalid_request",
+						"expired_token",
+						"device_code_already_processed"
+					]).meta({ description: "Error code" }),
+					error_description: z.string().meta({ description: "Detailed error description" })
+				}),
+				requireHeaders: true,
+				metadata: { openapi: {
+					description: "Approve device authorization",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const session = await getSessionFromCtx(ctx);
+				if (!session) throw new APIError("UNAUTHORIZED", {
+					error: "unauthorized",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHENTICATION_REQUIRED
+				});
+				const { userCode } = ctx.body;
+				const deviceCodeRecord = await ctx.context.adapter.findOne({
+					model: "deviceCode",
+					where: [{
+						field: "userCode",
+						value: userCode
+					}]
+				});
+				if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
+					error: "invalid_request",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
+				});
+				if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", {
+					error: "expired_token",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
+				});
+				if (deviceCodeRecord.status !== "pending") throw new APIError("BAD_REQUEST", {
+					error: "invalid_request",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED
+				});
+				await ctx.context.adapter.update({
+					model: "deviceCode",
+					where: [{
+						field: "id",
+						value: deviceCodeRecord.id
+					}],
+					update: {
+						status: "approved",
+						userId: session.user.id
+					}
+				});
+				return ctx.json({ success: true });
+			}),
+			deviceDeny: createAuthEndpoint("/device/deny", {
+				method: "POST",
+				body: z.object({ userCode: z.string().meta({ description: "The user code to deny" }) }),
+				error: z.object({
+					error: z.enum(["invalid_request", "expired_token"]).meta({ description: "Error code" }),
+					error_description: z.string().meta({ description: "Detailed error description" })
+				}),
+				metadata: { openapi: {
+					description: "Deny device authorization",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { userCode } = ctx.body;
+				const cleanUserCode = userCode.replace(/-/g, "");
+				const deviceCodeRecord = await ctx.context.adapter.findOne({
+					model: "deviceCode",
+					where: [{
+						field: "userCode",
+						value: cleanUserCode
+					}]
+				});
+				if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
+					error: "invalid_request",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
+				});
+				if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", {
+					error: "expired_token",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
+				});
+				if (deviceCodeRecord.status !== "pending") throw new APIError("BAD_REQUEST", {
+					error: "invalid_request",
+					error_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED
+				});
+				await ctx.context.adapter.update({
+					model: "deviceCode",
+					where: [{
+						field: "id",
+						value: deviceCodeRecord.id
+					}],
+					update: { status: "denied" }
+				});
+				return ctx.json({ success: true });
+			})
+		},
+		$ERROR_CODES: DEVICE_AUTHORIZATION_ERROR_CODES
+	};
+};
+
+//#endregion
+export { deviceAuthorization as n, $deviceAuthorizationOptionsSchema as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/dialect-BhkkSrrx.mjs.bak b/node_modules/better-auth/dist/dialect-BhkkSrrx.mjs.bak
new file mode 100644
index 0000000..7f5eff1
--- /dev/null
+++ b/node_modules/better-auth/dist/dialect-BhkkSrrx.mjs.bak
@@ -0,0 +1,72 @@
+import { Kysely, MssqlDialect, MysqlDialect, PostgresDialect, SqliteDialect } from "kysely";
+
+//#region src/adapters/kysely-adapter/dialect.ts
+function getKyselyDatabaseType(db) {
+	if (!db) return null;
+	if ("dialect" in db) return getKyselyDatabaseType(db.dialect);
+	if ("createDriver" in db) {
+		if (db instanceof SqliteDialect) return "sqlite";
+		if (db instanceof MysqlDialect) return "mysql";
+		if (db instanceof PostgresDialect) return "postgres";
+		if (db instanceof MssqlDialect) return "mssql";
+	}
+	if ("aggregate" in db) return "sqlite";
+	if ("getConnection" in db) return "mysql";
+	if ("connect" in db) return "postgres";
+	if ("fileControl" in db) return "sqlite";
+	if ("open" in db && "close" in db && "prepare" in db) return "sqlite";
+	return null;
+}
+const createKyselyAdapter = async (config) => {
+	const db = config.database;
+	if (!db) return {
+		kysely: null,
+		databaseType: null,
+		transaction: void 0
+	};
+	if ("db" in db) return {
+		kysely: db.db,
+		databaseType: db.type,
+		transaction: db.transaction
+	};
+	if ("dialect" in db) return {
+		kysely: new Kysely({ dialect: db.dialect }),
+		databaseType: db.type,
+		transaction: db.transaction
+	};
+	let dialect = void 0;
+	const databaseType = getKyselyDatabaseType(db);
+	if ("createDriver" in db) dialect = db;
+	if ("aggregate" in db && !("createSession" in db)) dialect = new SqliteDialect({ database: db });
+	if ("getConnection" in db) dialect = new MysqlDialect(db);
+	if ("connect" in db) dialect = new PostgresDialect({ pool: db });
+	if ("fileControl" in db) {
+		const { BunSqliteDialect } = await import("./bun-sqlite-dialect-ZxGiPNhl.mjs");
+		dialect = new BunSqliteDialect({ database: db });
+	}
+	if ("createSession" in db && typeof window === "undefined") {
+		let DatabaseSync = void 0;
+		try {
+			let nodeSqlite = "node:sqlite";
+			({DatabaseSync} = await import(
+				/* @vite-ignore */
+				/* webpackIgnore: true */
+				nodeSqlite
+));
+		} catch (error) {
+			if (error !== null && typeof error === "object" && "code" in error && error.code !== "ERR_UNKNOWN_BUILTIN_MODULE") throw error;
+		}
+		if (DatabaseSync && db instanceof DatabaseSync) {
+			const { NodeSqliteDialect } = await import("./node-sqlite-dialect-GK1cTZHJ.mjs");
+			dialect = new NodeSqliteDialect({ database: db });
+		}
+	}
+	return {
+		kysely: dialect ? new Kysely({ dialect }) : null,
+		databaseType,
+		transaction: void 0
+	};
+};
+
+//#endregion
+export { getKyselyDatabaseType as n, createKyselyAdapter as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/email-otp-C08WNTNC.mjs b/node_modules/better-auth/dist/email-otp-C08WNTNC.mjs
index 827422c..d3454c2 100644
--- a/node_modules/better-auth/dist/email-otp-C08WNTNC.mjs
+++ b/node_modules/better-auth/dist/email-otp-C08WNTNC.mjs
@@ -65,8 +65,8 @@ const emailOTP = (options) => {
 	const endpoints = { sendVerificationOTP: createAuthEndpoint("/email-otp/send-verification-otp", {
 		method: "POST",
 		body: z.object({
-			email: z.string({}).meta({ description: "Email address to send the OTP" }),
-			type: z.enum(types).meta({ description: "Type of the OTP" })
+			email: z.string({}),
+			type: z.enum(types)
 		}),
 		metadata: { openapi: {
 			operationId: "sendEmailVerificationOTP",
@@ -85,7 +85,7 @@ const emailOTP = (options) => {
 			throw new APIError("BAD_REQUEST", { message: "send email verification is not implemented" });
 		}
 		const email = ctx.body.email.toLowerCase();
-		if (!z.email().safeParse(email).success) throw ctx.error("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+		if (!z.string().email().safeParse(email).success) throw ctx.error("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
 		if (opts.disableSignUp) {
 			if (!await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
 		} else if (ctx.body.type === "forget-password") {
@@ -136,11 +136,8 @@ const emailOTP = (options) => {
 			createVerificationOTP: createAuthEndpoint("/email-otp/create-verification-otp", {
 				method: "POST",
 				body: z.object({
-					email: z.string({}).meta({ description: "Email address to send the OTP" }),
-					type: z.enum(types).meta({
-						required: true,
-						description: "Type of the OTP"
-					})
+					email: z.string({}),
+					type: z.enum(types)
 				}),
 				metadata: {
 					SERVER_ONLY: true,
@@ -170,11 +167,8 @@ const emailOTP = (options) => {
 			getVerificationOTP: createAuthEndpoint("/email-otp/get-verification-otp", {
 				method: "GET",
 				query: z.object({
-					email: z.string({}).meta({ description: "Email address the OTP was sent to" }),
-					type: z.enum(types).meta({
-						required: true,
-						description: "Type of the OTP"
-					})
+					email: z.string({}),
+					type: z.enum(types)
 				}),
 				metadata: {
 					SERVER_ONLY: true,
@@ -212,15 +206,9 @@ const emailOTP = (options) => {
 			checkVerificationOTP: createAuthEndpoint("/email-otp/check-verification-otp", {
 				method: "POST",
 				body: z.object({
-					email: z.string().meta({ description: "Email address the OTP was sent to" }),
-					type: z.enum(types).meta({
-						required: true,
-						description: "Type of the OTP"
-					}),
-					otp: z.string().meta({
-						required: true,
-						description: "OTP to verify"
-					})
+					email: z.string(),
+					type: z.enum(types),
+					otp: z.string()
 				}),
 				metadata: { openapi: {
 					operationId: "verifyEmailWithOTP",
@@ -235,7 +223,7 @@ const emailOTP = (options) => {
 				} }
 			}, async (ctx) => {
 				const email = ctx.body.email.toLowerCase();
-				if (!z.email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
 				if (!await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
 				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`${ctx.body.type}-otp-${email}`);
 				if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
@@ -258,11 +246,8 @@ const emailOTP = (options) => {
 			verifyEmailOTP: createAuthEndpoint("/email-otp/verify-email", {
 				method: "POST",
 				body: z.object({
-					email: z.string({}).meta({ description: "Email address to verify" }),
-					otp: z.string().meta({
-						required: true,
-						description: "OTP to verify"
-					})
+					email: z.string({}),
+					otp: z.string()
 				}),
 				metadata: { openapi: {
 					description: "Verify email with OTP",
@@ -293,7 +278,7 @@ const emailOTP = (options) => {
 				} }
 			}, async (ctx) => {
 				const email = ctx.body.email.toLowerCase();
-				if (!z.email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
 				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`email-verification-otp-${email}`);
 				if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
 				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.OTP_EXPIRED });
@@ -363,11 +348,8 @@ const emailOTP = (options) => {
 			signInEmailOTP: createAuthEndpoint("/sign-in/email-otp", {
 				method: "POST",
 				body: z.object({
-					email: z.string({}).meta({ description: "Email address to sign in" }),
-					otp: z.string().meta({
-						required: true,
-						description: "OTP sent to the email"
-					})
+					email: z.string({}),
+					otp: z.string()
 				}),
 				metadata: { openapi: {
 					operationId: "signInWithEmailOTP",
@@ -450,7 +432,7 @@ const emailOTP = (options) => {
 			}),
 			forgetPasswordEmailOTP: createAuthEndpoint("/forget-password/email-otp", {
 				method: "POST",
-				body: z.object({ email: z.string().meta({ description: "Email address to send the OTP" }) }),
+				body: z.object({ email: z.string() }),
 				metadata: { openapi: {
 					operationId: "forgetPasswordWithEmailOTP",
 					description: "Forget password with email and OTP",
@@ -488,9 +470,9 @@ const emailOTP = (options) => {
 			resetPasswordEmailOTP: createAuthEndpoint("/email-otp/reset-password", {
 				method: "POST",
 				body: z.object({
-					email: z.string().meta({ description: "Email address to reset the password" }),
-					otp: z.string().meta({ description: "OTP sent to the email" }),
-					password: z.string().meta({ description: "New password" })
+					email: z.string(),
+					otp: z.string(),
+					password: z.string()
 				}),
 				metadata: { openapi: {
 					operationId: "resetPasswordWithEmailOTP",
diff --git a/node_modules/better-auth/dist/email-otp-C08WNTNC.mjs.bak b/node_modules/better-auth/dist/email-otp-C08WNTNC.mjs.bak
new file mode 100644
index 0000000..65ce946
--- /dev/null
+++ b/node_modules/better-auth/dist/email-otp-C08WNTNC.mjs.bak
@@ -0,0 +1,600 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { u as getDate } from "./schema-BevzneML.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie, s as setCookieCache } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx } from "./session-Efap-vxj.mjs";
+import { t as getEndpointResponse } from "./plugin-helper-RJJBTOba.mjs";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import * as z from "zod";
+import { createHash } from "@better-auth/utils/hash";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+import { base64Url } from "@better-auth/utils/base64";
+
+//#region src/plugins/email-otp/utils.ts
+const defaultKeyHasher = async (otp) => {
+	const hash = await createHash("SHA-256").digest(new TextEncoder().encode(otp));
+	return base64Url.encode(new Uint8Array(hash), { padding: false });
+};
+function splitAtLastColon(input) {
+	const idx = input.lastIndexOf(":");
+	if (idx === -1) return [input, ""];
+	return [input.slice(0, idx), input.slice(idx + 1)];
+}
+
+//#endregion
+//#region src/plugins/email-otp/index.ts
+const types = [
+	"email-verification",
+	"sign-in",
+	"forget-password"
+];
+const defaultOTPGenerator = (options) => generateRandomString(options.otpLength ?? 6, "0-9");
+const ERROR_CODES = defineErrorCodes({
+	OTP_EXPIRED: "OTP expired",
+	INVALID_OTP: "Invalid OTP",
+	TOO_MANY_ATTEMPTS: "Too many attempts"
+});
+const emailOTP = (options) => {
+	const opts = {
+		expiresIn: 300,
+		generateOTP: () => defaultOTPGenerator(options),
+		storeOTP: "plain",
+		...options
+	};
+	async function storeOTP(ctx, otp) {
+		if (opts.storeOTP === "encrypted") return await symmetricEncrypt({
+			key: ctx.context.secret,
+			data: otp
+		});
+		if (opts.storeOTP === "hashed") return await defaultKeyHasher(otp);
+		if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return await opts.storeOTP.hash(otp);
+		if (typeof opts.storeOTP === "object" && "encrypt" in opts.storeOTP) return await opts.storeOTP.encrypt(otp);
+		return otp;
+	}
+	async function verifyStoredOTP(ctx, storedOtp, otp) {
+		if (opts.storeOTP === "encrypted") return await symmetricDecrypt({
+			key: ctx.context.secret,
+			data: storedOtp
+		}) === otp;
+		if (opts.storeOTP === "hashed") return await defaultKeyHasher(otp) === storedOtp;
+		if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return await opts.storeOTP.hash(otp) === storedOtp;
+		if (typeof opts.storeOTP === "object" && "decrypt" in opts.storeOTP) return await opts.storeOTP.decrypt(storedOtp) === otp;
+		return otp === storedOtp;
+	}
+	const endpoints = { sendVerificationOTP: createAuthEndpoint("/email-otp/send-verification-otp", {
+		method: "POST",
+		body: z.object({
+			email: z.string({}).meta({ description: "Email address to send the OTP" }),
+			type: z.enum(types).meta({ description: "Type of the OTP" })
+		}),
+		metadata: { openapi: {
+			operationId: "sendEmailVerificationOTP",
+			description: "Send a verification OTP to an email",
+			responses: { 200: {
+				description: "Success",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { success: { type: "boolean" } }
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		if (!options?.sendVerificationOTP) {
+			ctx.context.logger.error("send email verification is not implemented");
+			throw new APIError("BAD_REQUEST", { message: "send email verification is not implemented" });
+		}
+		const email = ctx.body.email.toLowerCase();
+		if (!z.string().email().safeParse(email).success) throw ctx.error("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+		if (opts.disableSignUp) {
+			if (!await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+		} else if (ctx.body.type === "forget-password") {
+			if (!await ctx.context.internalAdapter.findUserByEmail(email)) return ctx.json({ success: true });
+		}
+		let otp = opts.generateOTP({
+			email,
+			type: ctx.body.type
+		}, ctx) || defaultOTPGenerator(opts);
+		let storedOTP = await storeOTP(ctx, otp);
+		await ctx.context.internalAdapter.createVerificationValue({
+			value: `${storedOTP}:0`,
+			identifier: `${ctx.body.type}-otp-${email}`,
+			expiresAt: getDate(opts.expiresIn, "sec")
+		}).catch(async (error) => {
+			await ctx.context.internalAdapter.deleteVerificationByIdentifier(`${ctx.body.type}-otp-${email}`);
+			await ctx.context.internalAdapter.createVerificationValue({
+				value: `${storedOTP}:0`,
+				identifier: `${ctx.body.type}-otp-${email}`,
+				expiresAt: getDate(opts.expiresIn, "sec")
+			});
+		});
+		await options.sendVerificationOTP({
+			email,
+			otp,
+			type: ctx.body.type
+		}, ctx);
+		return ctx.json({ success: true });
+	}) };
+	return {
+		id: "email-otp",
+		init(ctx) {
+			if (!opts.overrideDefaultEmailVerification) return;
+			return { options: { emailVerification: { async sendVerificationEmail(data, request) {
+				await endpoints.sendVerificationOTP({
+					context: ctx,
+					request,
+					body: {
+						email: data.user.email,
+						type: "email-verification"
+					},
+					ctx
+				});
+			} } } };
+		},
+		endpoints: {
+			...endpoints,
+			createVerificationOTP: createAuthEndpoint("/email-otp/create-verification-otp", {
+				method: "POST",
+				body: z.object({
+					email: z.string({}).meta({ description: "Email address to send the OTP" }),
+					type: z.enum(types).meta({
+						required: true,
+						description: "Type of the OTP"
+					})
+				}),
+				metadata: {
+					SERVER_ONLY: true,
+					openapi: {
+						operationId: "createEmailVerificationOTP",
+						description: "Create a verification OTP for an email",
+						responses: { 200: {
+							description: "Success",
+							content: { "application/json": { schema: { type: "string" } } }
+						} }
+					}
+				}
+			}, async (ctx) => {
+				const email = ctx.body.email;
+				const otp = opts.generateOTP({
+					email,
+					type: ctx.body.type
+				}, ctx) || defaultOTPGenerator(opts);
+				let storedOTP = await storeOTP(ctx, otp);
+				await ctx.context.internalAdapter.createVerificationValue({
+					value: `${storedOTP}:0`,
+					identifier: `${ctx.body.type}-otp-${email}`,
+					expiresAt: getDate(opts.expiresIn, "sec")
+				});
+				return otp;
+			}),
+			getVerificationOTP: createAuthEndpoint("/email-otp/get-verification-otp", {
+				method: "GET",
+				query: z.object({
+					email: z.string({}).meta({ description: "Email address the OTP was sent to" }),
+					type: z.enum(types).meta({
+						required: true,
+						description: "Type of the OTP"
+					})
+				}),
+				metadata: {
+					SERVER_ONLY: true,
+					openapi: {
+						operationId: "getEmailVerificationOTP",
+						description: "Get a verification OTP for an email",
+						responses: { "200": {
+							description: "OTP retrieved successfully or not found/expired",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { otp: {
+									type: "string",
+									nullable: true,
+									description: "The stored OTP, or null if not found or expired"
+								} },
+								required: ["otp"]
+							} } }
+						} }
+					}
+				}
+			}, async (ctx) => {
+				const email = ctx.query.email;
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`${ctx.query.type}-otp-${email}`);
+				if (!verificationValue || verificationValue.expiresAt < /* @__PURE__ */ new Date()) return ctx.json({ otp: null });
+				if (opts.storeOTP === "hashed" || typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) throw new APIError("BAD_REQUEST", { message: "OTP is hashed, cannot return the plain text OTP" });
+				let [storedOtp, _attempts] = splitAtLastColon(verificationValue.value);
+				let otp = storedOtp;
+				if (opts.storeOTP === "encrypted") otp = await symmetricDecrypt({
+					key: ctx.context.secret,
+					data: storedOtp
+				});
+				if (typeof opts.storeOTP === "object" && "decrypt" in opts.storeOTP) otp = await opts.storeOTP.decrypt(storedOtp);
+				return ctx.json({ otp });
+			}),
+			checkVerificationOTP: createAuthEndpoint("/email-otp/check-verification-otp", {
+				method: "POST",
+				body: z.object({
+					email: z.string().meta({ description: "Email address the OTP was sent to" }),
+					type: z.enum(types).meta({
+						required: true,
+						description: "Type of the OTP"
+					}),
+					otp: z.string().meta({
+						required: true,
+						description: "OTP to verify"
+					})
+				}),
+				metadata: { openapi: {
+					operationId: "verifyEmailWithOTP",
+					description: "Verify an email with an OTP",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const email = ctx.body.email.toLowerCase();
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				if (!await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`${ctx.body.type}-otp-${email}`);
+				if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+					throw new APIError("BAD_REQUEST", { message: ERROR_CODES.OTP_EXPIRED });
+				}
+				const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
+				const allowedAttempts = options?.allowedAttempts || 3;
+				if (attempts && parseInt(attempts) >= allowedAttempts) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+					throw new APIError("FORBIDDEN", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });
+				}
+				if (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {
+					await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
+					throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				}
+				return ctx.json({ success: true });
+			}),
+			verifyEmailOTP: createAuthEndpoint("/email-otp/verify-email", {
+				method: "POST",
+				body: z.object({
+					email: z.string({}).meta({ description: "Email address to verify" }),
+					otp: z.string().meta({
+						required: true,
+						description: "OTP to verify"
+					})
+				}),
+				metadata: { openapi: {
+					description: "Verify email with OTP",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								status: {
+									type: "boolean",
+									description: "Indicates if the verification was successful",
+									enum: [true]
+								},
+								token: {
+									type: "string",
+									nullable: true,
+									description: "Session token if autoSignInAfterVerification is enabled, otherwise null"
+								},
+								user: { $ref: "#/components/schemas/User" }
+							},
+							required: [
+								"status",
+								"token",
+								"user"
+							]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const email = ctx.body.email.toLowerCase();
+				if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`email-verification-otp-${email}`);
+				if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.OTP_EXPIRED });
+				const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
+				const allowedAttempts = options?.allowedAttempts || 3;
+				if (attempts && parseInt(attempts) >= allowedAttempts) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+					throw new APIError("FORBIDDEN", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });
+				}
+				if (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {
+					await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
+					throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				}
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				const user = await ctx.context.internalAdapter.findUserByEmail(email);
+				if (!user) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				const updatedUser = await ctx.context.internalAdapter.updateUser(user.user.id, {
+					email,
+					emailVerified: true
+				});
+				await ctx.context.options.emailVerification?.onEmailVerification?.(updatedUser, ctx.request);
+				if (ctx.context.options.emailVerification?.autoSignInAfterVerification) {
+					const session = await ctx.context.internalAdapter.createSession(updatedUser.id);
+					await setSessionCookie(ctx, {
+						session,
+						user: updatedUser
+					});
+					return ctx.json({
+						status: true,
+						token: session.token,
+						user: {
+							id: updatedUser.id,
+							email: updatedUser.email,
+							emailVerified: updatedUser.emailVerified,
+							name: updatedUser.name,
+							image: updatedUser.image,
+							createdAt: updatedUser.createdAt,
+							updatedAt: updatedUser.updatedAt
+						}
+					});
+				}
+				const currentSession = await getSessionFromCtx(ctx);
+				if (currentSession && updatedUser.emailVerified) {
+					const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
+					await setCookieCache(ctx, {
+						session: currentSession.session,
+						user: {
+							...currentSession.user,
+							emailVerified: true
+						}
+					}, !!dontRememberMeCookie);
+				}
+				return ctx.json({
+					status: true,
+					token: null,
+					user: {
+						id: updatedUser.id,
+						email: updatedUser.email,
+						emailVerified: updatedUser.emailVerified,
+						name: updatedUser.name,
+						image: updatedUser.image,
+						createdAt: updatedUser.createdAt,
+						updatedAt: updatedUser.updatedAt
+					}
+				});
+			}),
+			signInEmailOTP: createAuthEndpoint("/sign-in/email-otp", {
+				method: "POST",
+				body: z.object({
+					email: z.string({}).meta({ description: "Email address to sign in" }),
+					otp: z.string().meta({
+						required: true,
+						description: "OTP sent to the email"
+					})
+				}),
+				metadata: { openapi: {
+					operationId: "signInWithEmailOTP",
+					description: "Sign in with email and OTP",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								token: {
+									type: "string",
+									description: "Session token for the authenticated session"
+								},
+								user: { $ref: "#/components/schemas/User" }
+							},
+							required: ["token", "user"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const email = ctx.body.email;
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`sign-in-otp-${email}`);
+				if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.OTP_EXPIRED });
+				const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
+				const allowedAttempts = options?.allowedAttempts || 3;
+				if (attempts && parseInt(attempts) >= allowedAttempts) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+					throw new APIError("FORBIDDEN", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });
+				}
+				if (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {
+					await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
+					throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				}
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				const user = await ctx.context.internalAdapter.findUserByEmail(email);
+				if (!user) {
+					if (opts.disableSignUp) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+					const newUser = await ctx.context.internalAdapter.createUser({
+						email,
+						emailVerified: true,
+						name: ""
+					});
+					const session$1 = await ctx.context.internalAdapter.createSession(newUser.id);
+					await setSessionCookie(ctx, {
+						session: session$1,
+						user: newUser
+					});
+					return ctx.json({
+						token: session$1.token,
+						user: {
+							id: newUser.id,
+							email: newUser.email,
+							emailVerified: newUser.emailVerified,
+							name: newUser.name,
+							image: newUser.image,
+							createdAt: newUser.createdAt,
+							updatedAt: newUser.updatedAt
+						}
+					});
+				}
+				if (!user.user.emailVerified) await ctx.context.internalAdapter.updateUser(user.user.id, { emailVerified: true });
+				const session = await ctx.context.internalAdapter.createSession(user.user.id);
+				await setSessionCookie(ctx, {
+					session,
+					user: user.user
+				});
+				return ctx.json({
+					token: session.token,
+					user: {
+						id: user.user.id,
+						email: user.user.email,
+						emailVerified: user.user.emailVerified,
+						name: user.user.name,
+						image: user.user.image,
+						createdAt: user.user.createdAt,
+						updatedAt: user.user.updatedAt
+					}
+				});
+			}),
+			forgetPasswordEmailOTP: createAuthEndpoint("/forget-password/email-otp", {
+				method: "POST",
+				body: z.object({ email: z.string().meta({ description: "Email address to send the OTP" }) }),
+				metadata: { openapi: {
+					operationId: "forgetPasswordWithEmailOTP",
+					description: "Forget password with email and OTP",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { success: {
+								type: "boolean",
+								description: "Indicates if the OTP was sent successfully"
+							} }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const email = ctx.body.email;
+				if (!await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				const otp = opts.generateOTP({
+					email,
+					type: "forget-password"
+				}, ctx) || defaultOTPGenerator(opts);
+				let storedOTP = await storeOTP(ctx, otp);
+				await ctx.context.internalAdapter.createVerificationValue({
+					value: `${storedOTP}:0`,
+					identifier: `forget-password-otp-${email}`,
+					expiresAt: getDate(opts.expiresIn, "sec")
+				});
+				await options.sendVerificationOTP({
+					email,
+					otp,
+					type: "forget-password"
+				}, ctx);
+				return ctx.json({ success: true });
+			}),
+			resetPasswordEmailOTP: createAuthEndpoint("/email-otp/reset-password", {
+				method: "POST",
+				body: z.object({
+					email: z.string().meta({ description: "Email address to reset the password" }),
+					otp: z.string().meta({ description: "OTP sent to the email" }),
+					password: z.string().meta({ description: "New password" })
+				}),
+				metadata: { openapi: {
+					operationId: "resetPasswordWithEmailOTP",
+					description: "Reset password with email and OTP",
+					responses: { 200: {
+						description: "Success",
+						contnt: { "application/json": { schema: {
+							type: "object",
+							properties: { success: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const email = ctx.body.email;
+				const user = await ctx.context.internalAdapter.findUserByEmail(email, { includeAccounts: true });
+				if (!user) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`forget-password-otp-${email}`);
+				if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+					throw new APIError("BAD_REQUEST", { message: ERROR_CODES.OTP_EXPIRED });
+				}
+				const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
+				const allowedAttempts = options?.allowedAttempts || 3;
+				if (attempts && parseInt(attempts) >= allowedAttempts) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+					throw new APIError("FORBIDDEN", { message: ERROR_CODES.TOO_MANY_ATTEMPTS });
+				}
+				if (!await verifyStoredOTP(ctx, otpValue, ctx.body.otp)) {
+					await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
+					throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OTP });
+				}
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				const passwordHash = await ctx.context.password.hash(ctx.body.password);
+				if (!user.accounts.find((account) => account.providerId === "credential")) await ctx.context.internalAdapter.createAccount({
+					userId: user.user.id,
+					providerId: "credential",
+					accountId: user.user.id,
+					password: passwordHash
+				});
+				else await ctx.context.internalAdapter.updatePassword(user.user.id, passwordHash);
+				if (ctx.context.options.emailAndPassword?.onPasswordReset) await ctx.context.options.emailAndPassword.onPasswordReset({ user: user.user }, ctx.request);
+				if (!user.user.emailVerified) await ctx.context.internalAdapter.updateUser(user.user.id, { emailVerified: true });
+				return ctx.json({ success: true });
+			})
+		},
+		hooks: { after: [{
+			matcher(context) {
+				return !!(context.path?.startsWith("/sign-up") && opts.sendVerificationOnSignUp && !opts.overrideDefaultEmailVerification);
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const email = (await getEndpointResponse(ctx))?.user.email;
+				if (email) {
+					const otp = opts.generateOTP({
+						email,
+						type: ctx.body.type
+					}, ctx) || defaultOTPGenerator(opts);
+					let storedOTP = await storeOTP(ctx, otp);
+					await ctx.context.internalAdapter.createVerificationValue({
+						value: `${storedOTP}:0`,
+						identifier: `email-verification-otp-${email}`,
+						expiresAt: getDate(opts.expiresIn, "sec")
+					});
+					await options.sendVerificationOTP({
+						email,
+						otp,
+						type: "email-verification"
+					}, ctx);
+				}
+			})
+		}] },
+		$ERROR_CODES: ERROR_CODES,
+		rateLimit: [
+			{
+				pathMatcher(path) {
+					return path === "/email-otp/send-verification-otp";
+				},
+				window: 60,
+				max: 3
+			},
+			{
+				pathMatcher(path) {
+					return path === "/email-otp/check-verification-otp";
+				},
+				window: 60,
+				max: 3
+			},
+			{
+				pathMatcher(path) {
+					return path === "/email-otp/verify-email";
+				},
+				window: 60,
+				max: 3
+			},
+			{
+				pathMatcher(path) {
+					return path === "/sign-in/email-otp";
+				},
+				window: 60,
+				max: 3
+			}
+		]
+	};
+};
+
+//#endregion
+export { emailOTP as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/esm-DVsZ1UYe.mjs.bak b/node_modules/better-auth/dist/esm-DVsZ1UYe.mjs.bak
new file mode 100644
index 0000000..69160a4
--- /dev/null
+++ b/node_modules/better-auth/dist/esm-DVsZ1UYe.mjs.bak
@@ -0,0 +1,4090 @@
+import { i as __require, o as __toESM, t as __commonJS } from "./chunk-BK_LfMhE.mjs";
+
+//#region ../../node_modules/.pnpm/postgres-array@2.0.0/node_modules/postgres-array/index.js
+var require_postgres_array = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postgres-array@2.0.0/node_modules/postgres-array/index.js": ((exports) => {
+	exports.parse = function(source, transform$1) {
+		return new ArrayParser(source, transform$1).parse();
+	};
+	var ArrayParser = class ArrayParser {
+		constructor(source, transform$1) {
+			this.source = source;
+			this.transform = transform$1 || identity;
+			this.position = 0;
+			this.entries = [];
+			this.recorded = [];
+			this.dimension = 0;
+		}
+		isEof() {
+			return this.position >= this.source.length;
+		}
+		nextCharacter() {
+			var character = this.source[this.position++];
+			if (character === "\\") return {
+				value: this.source[this.position++],
+				escaped: true
+			};
+			return {
+				value: character,
+				escaped: false
+			};
+		}
+		record(character) {
+			this.recorded.push(character);
+		}
+		newEntry(includeEmpty) {
+			var entry;
+			if (this.recorded.length > 0 || includeEmpty) {
+				entry = this.recorded.join("");
+				if (entry === "NULL" && !includeEmpty) entry = null;
+				if (entry !== null) entry = this.transform(entry);
+				this.entries.push(entry);
+				this.recorded = [];
+			}
+		}
+		consumeDimensions() {
+			if (this.source[0] === "[") {
+				while (!this.isEof()) if (this.nextCharacter().value === "=") break;
+			}
+		}
+		parse(nested) {
+			var character, parser, quote;
+			this.consumeDimensions();
+			while (!this.isEof()) {
+				character = this.nextCharacter();
+				if (character.value === "{" && !quote) {
+					this.dimension++;
+					if (this.dimension > 1) {
+						parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
+						this.entries.push(parser.parse(true));
+						this.position += parser.position - 2;
+					}
+				} else if (character.value === "}" && !quote) {
+					this.dimension--;
+					if (!this.dimension) {
+						this.newEntry();
+						if (nested) return this.entries;
+					}
+				} else if (character.value === "\"" && !character.escaped) {
+					if (quote) this.newEntry(true);
+					quote = !quote;
+				} else if (character.value === "," && !quote) this.newEntry();
+				else this.record(character.value);
+			}
+			if (this.dimension !== 0) throw new Error("array dimension not balanced");
+			return this.entries;
+		}
+	};
+	function identity(value) {
+		return value;
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/arrayParser.js
+var require_arrayParser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/arrayParser.js": ((exports, module) => {
+	var array$1 = require_postgres_array();
+	module.exports = { create: function(source, transform$1) {
+		return { parse: function() {
+			return array$1.parse(source, transform$1);
+		} };
+	} };
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/postgres-date@1.0.7/node_modules/postgres-date/index.js
+var require_postgres_date = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postgres-date@1.0.7/node_modules/postgres-date/index.js": ((exports, module) => {
+	var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
+	var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
+	var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
+	var INFINITY = /^-?infinity$/;
+	module.exports = function parseDate$2(isoDate) {
+		if (INFINITY.test(isoDate)) return Number(isoDate.replace("i", "I"));
+		var matches = DATE_TIME.exec(isoDate);
+		if (!matches) return getDate(isoDate) || null;
+		var isBC = !!matches[8];
+		var year = parseInt(matches[1], 10);
+		if (isBC) year = bcYearToNegativeYear(year);
+		var month = parseInt(matches[2], 10) - 1;
+		var day = matches[3];
+		var hour = parseInt(matches[4], 10);
+		var minute = parseInt(matches[5], 10);
+		var second = parseInt(matches[6], 10);
+		var ms = matches[7];
+		ms = ms ? 1e3 * parseFloat(ms) : 0;
+		var date;
+		var offset = timeZoneOffset(isoDate);
+		if (offset != null) {
+			date = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
+			if (is0To99(year)) date.setUTCFullYear(year);
+			if (offset !== 0) date.setTime(date.getTime() - offset);
+		} else {
+			date = new Date(year, month, day, hour, minute, second, ms);
+			if (is0To99(year)) date.setFullYear(year);
+		}
+		return date;
+	};
+	function getDate(isoDate) {
+		var matches = DATE.exec(isoDate);
+		if (!matches) return;
+		var year = parseInt(matches[1], 10);
+		if (!!matches[4]) year = bcYearToNegativeYear(year);
+		var month = parseInt(matches[2], 10) - 1;
+		var day = matches[3];
+		var date = new Date(year, month, day);
+		if (is0To99(year)) date.setFullYear(year);
+		return date;
+	}
+	function timeZoneOffset(isoDate) {
+		if (isoDate.endsWith("+00")) return 0;
+		var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
+		if (!zone) return;
+		var type = zone[1];
+		if (type === "Z") return 0;
+		var sign = type === "-" ? -1 : 1;
+		return (parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10)) * sign * 1e3;
+	}
+	function bcYearToNegativeYear(year) {
+		return -(year - 1);
+	}
+	function is0To99(num) {
+		return num >= 0 && num < 100;
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/mutable.js
+var require_mutable = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/mutable.js": ((exports, module) => {
+	module.exports = extend$1;
+	var hasOwnProperty = Object.prototype.hasOwnProperty;
+	function extend$1(target) {
+		for (var i = 1; i < arguments.length; i++) {
+			var source = arguments[i];
+			for (var key in source) if (hasOwnProperty.call(source, key)) target[key] = source[key];
+		}
+		return target;
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/postgres-interval@1.2.0/node_modules/postgres-interval/index.js
+var require_postgres_interval = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postgres-interval@1.2.0/node_modules/postgres-interval/index.js": ((exports, module) => {
+	var extend = require_mutable();
+	module.exports = PostgresInterval;
+	function PostgresInterval(raw) {
+		if (!(this instanceof PostgresInterval)) return new PostgresInterval(raw);
+		extend(this, parse$5(raw));
+	}
+	var properties = [
+		"seconds",
+		"minutes",
+		"hours",
+		"days",
+		"months",
+		"years"
+	];
+	PostgresInterval.prototype.toPostgres = function() {
+		var filtered = properties.filter(this.hasOwnProperty, this);
+		if (this.milliseconds && filtered.indexOf("seconds") < 0) filtered.push("seconds");
+		if (filtered.length === 0) return "0";
+		return filtered.map(function(property) {
+			var value = this[property] || 0;
+			if (property === "seconds" && this.milliseconds) value = (value + this.milliseconds / 1e3).toFixed(6).replace(/\.?0+$/, "");
+			return value + " " + property;
+		}, this).join(" ");
+	};
+	var propertiesISOEquivalent = {
+		years: "Y",
+		months: "M",
+		days: "D",
+		hours: "H",
+		minutes: "M",
+		seconds: "S"
+	};
+	var dateProperties = [
+		"years",
+		"months",
+		"days"
+	];
+	var timeProperties = [
+		"hours",
+		"minutes",
+		"seconds"
+	];
+	PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
+		var datePart = dateProperties.map(buildProperty, this).join("");
+		var timePart = timeProperties.map(buildProperty, this).join("");
+		return "P" + datePart + "T" + timePart;
+		function buildProperty(property) {
+			var value = this[property] || 0;
+			if (property === "seconds" && this.milliseconds) value = (value + this.milliseconds / 1e3).toFixed(6).replace(/0+$/, "");
+			return value + propertiesISOEquivalent[property];
+		}
+	};
+	var NUMBER = "([+-]?\\d+)";
+	var YEAR = NUMBER + "\\s+years?";
+	var MONTH = NUMBER + "\\s+mons?";
+	var DAY = NUMBER + "\\s+days?";
+	var INTERVAL = new RegExp([
+		YEAR,
+		MONTH,
+		DAY,
+		"([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?"
+	].map(function(regexString) {
+		return "(" + regexString + ")?";
+	}).join("\\s*"));
+	var positions = {
+		years: 2,
+		months: 4,
+		days: 6,
+		hours: 9,
+		minutes: 10,
+		seconds: 11,
+		milliseconds: 12
+	};
+	var negatives = [
+		"hours",
+		"minutes",
+		"seconds",
+		"milliseconds"
+	];
+	function parseMilliseconds(fraction) {
+		var microseconds = fraction + "000000".slice(fraction.length);
+		return parseInt(microseconds, 10) / 1e3;
+	}
+	function parse$5(interval) {
+		if (!interval) return {};
+		var matches = INTERVAL.exec(interval);
+		var isNegative = matches[8] === "-";
+		return Object.keys(positions).reduce(function(parsed, property) {
+			var value = matches[positions[property]];
+			if (!value) return parsed;
+			value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
+			if (!value) return parsed;
+			if (isNegative && ~negatives.indexOf(property)) value *= -1;
+			parsed[property] = value;
+			return parsed;
+		}, {});
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/postgres-bytea@1.0.0/node_modules/postgres-bytea/index.js
+var require_postgres_bytea = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postgres-bytea@1.0.0/node_modules/postgres-bytea/index.js": ((exports, module) => {
+	module.exports = function parseBytea(input) {
+		if (/^\\x/.test(input)) return new Buffer(input.substr(2), "hex");
+		var output = "";
+		var i = 0;
+		while (i < input.length) if (input[i] !== "\\") {
+			output += input[i];
+			++i;
+		} else if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
+			output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
+			i += 4;
+		} else {
+			var backslashes = 1;
+			while (i + backslashes < input.length && input[i + backslashes] === "\\") backslashes++;
+			for (var k = 0; k < Math.floor(backslashes / 2); ++k) output += "\\";
+			i += Math.floor(backslashes / 2) * 2;
+		}
+		return new Buffer(output, "binary");
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/textParsers.js
+var require_textParsers = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/textParsers.js": ((exports, module) => {
+	var array = require_postgres_array();
+	var arrayParser$1 = require_arrayParser();
+	var parseDate$1 = require_postgres_date();
+	var parseInterval = require_postgres_interval();
+	var parseByteA = require_postgres_bytea();
+	function allowNull(fn) {
+		return function nullAllowed(value) {
+			if (value === null) return value;
+			return fn(value);
+		};
+	}
+	function parseBool$1(value) {
+		if (value === null) return value;
+		return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
+	}
+	function parseBoolArray(value) {
+		if (!value) return null;
+		return array.parse(value, parseBool$1);
+	}
+	function parseBaseTenInt(string) {
+		return parseInt(string, 10);
+	}
+	function parseIntegerArray(value) {
+		if (!value) return null;
+		return array.parse(value, allowNull(parseBaseTenInt));
+	}
+	function parseBigIntegerArray$1(value) {
+		if (!value) return null;
+		return array.parse(value, allowNull(function(entry) {
+			return parseBigInteger$1(entry).trim();
+		}));
+	}
+	var parsePointArray = function(value) {
+		if (!value) return null;
+		return arrayParser$1.create(value, function(entry) {
+			if (entry !== null) entry = parsePoint(entry);
+			return entry;
+		}).parse();
+	};
+	var parseFloatArray = function(value) {
+		if (!value) return null;
+		return arrayParser$1.create(value, function(entry) {
+			if (entry !== null) entry = parseFloat(entry);
+			return entry;
+		}).parse();
+	};
+	var parseStringArray = function(value) {
+		if (!value) return null;
+		return arrayParser$1.create(value).parse();
+	};
+	var parseDateArray = function(value) {
+		if (!value) return null;
+		return arrayParser$1.create(value, function(entry) {
+			if (entry !== null) entry = parseDate$1(entry);
+			return entry;
+		}).parse();
+	};
+	var parseIntervalArray = function(value) {
+		if (!value) return null;
+		return arrayParser$1.create(value, function(entry) {
+			if (entry !== null) entry = parseInterval(entry);
+			return entry;
+		}).parse();
+	};
+	var parseByteAArray = function(value) {
+		if (!value) return null;
+		return array.parse(value, allowNull(parseByteA));
+	};
+	var parseInteger = function(value) {
+		return parseInt(value, 10);
+	};
+	var parseBigInteger$1 = function(value) {
+		var valStr = String(value);
+		if (/^\d+$/.test(valStr)) return valStr;
+		return value;
+	};
+	var parseJsonArray = function(value) {
+		if (!value) return null;
+		return array.parse(value, allowNull(JSON.parse));
+	};
+	var parsePoint = function(value) {
+		if (value[0] !== "(") return null;
+		value = value.substring(1, value.length - 1).split(",");
+		return {
+			x: parseFloat(value[0]),
+			y: parseFloat(value[1])
+		};
+	};
+	var parseCircle = function(value) {
+		if (value[0] !== "<" && value[1] !== "(") return null;
+		var point = "(";
+		var radius = "";
+		var pointParsed = false;
+		for (var i = 2; i < value.length - 1; i++) {
+			if (!pointParsed) point += value[i];
+			if (value[i] === ")") {
+				pointParsed = true;
+				continue;
+			} else if (!pointParsed) continue;
+			if (value[i] === ",") continue;
+			radius += value[i];
+		}
+		var result = parsePoint(point);
+		result.radius = parseFloat(radius);
+		return result;
+	};
+	var init$1 = function(register) {
+		register(20, parseBigInteger$1);
+		register(21, parseInteger);
+		register(23, parseInteger);
+		register(26, parseInteger);
+		register(700, parseFloat);
+		register(701, parseFloat);
+		register(16, parseBool$1);
+		register(1082, parseDate$1);
+		register(1114, parseDate$1);
+		register(1184, parseDate$1);
+		register(600, parsePoint);
+		register(651, parseStringArray);
+		register(718, parseCircle);
+		register(1e3, parseBoolArray);
+		register(1001, parseByteAArray);
+		register(1005, parseIntegerArray);
+		register(1007, parseIntegerArray);
+		register(1028, parseIntegerArray);
+		register(1016, parseBigIntegerArray$1);
+		register(1017, parsePointArray);
+		register(1021, parseFloatArray);
+		register(1022, parseFloatArray);
+		register(1231, parseFloatArray);
+		register(1014, parseStringArray);
+		register(1015, parseStringArray);
+		register(1008, parseStringArray);
+		register(1009, parseStringArray);
+		register(1040, parseStringArray);
+		register(1041, parseStringArray);
+		register(1115, parseDateArray);
+		register(1182, parseDateArray);
+		register(1185, parseDateArray);
+		register(1186, parseInterval);
+		register(1187, parseIntervalArray);
+		register(17, parseByteA);
+		register(114, JSON.parse.bind(JSON));
+		register(3802, JSON.parse.bind(JSON));
+		register(199, parseJsonArray);
+		register(3807, parseJsonArray);
+		register(3907, parseStringArray);
+		register(2951, parseStringArray);
+		register(791, parseStringArray);
+		register(1183, parseStringArray);
+		register(1270, parseStringArray);
+	};
+	module.exports = { init: init$1 };
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-int8@1.0.1/node_modules/pg-int8/index.js
+var require_pg_int8 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-int8@1.0.1/node_modules/pg-int8/index.js": ((exports, module) => {
+	var BASE = 1e6;
+	function readInt8(buffer) {
+		var high = buffer.readInt32BE(0);
+		var low = buffer.readUInt32BE(4);
+		var sign = "";
+		if (high < 0) {
+			high = ~high + (low === 0);
+			low = ~low + 1 >>> 0;
+			sign = "-";
+		}
+		var result = "";
+		var carry;
+		var t;
+		var digits;
+		var pad;
+		var l;
+		var i;
+		carry = high % BASE;
+		high = high / BASE >>> 0;
+		t = 4294967296 * carry + low;
+		low = t / BASE >>> 0;
+		digits = "" + (t - BASE * low);
+		if (low === 0 && high === 0) return sign + digits + result;
+		pad = "";
+		l = 6 - digits.length;
+		for (i = 0; i < l; i++) pad += "0";
+		result = pad + digits + result;
+		carry = high % BASE;
+		high = high / BASE >>> 0;
+		t = 4294967296 * carry + low;
+		low = t / BASE >>> 0;
+		digits = "" + (t - BASE * low);
+		if (low === 0 && high === 0) return sign + digits + result;
+		pad = "";
+		l = 6 - digits.length;
+		for (i = 0; i < l; i++) pad += "0";
+		result = pad + digits + result;
+		carry = high % BASE;
+		high = high / BASE >>> 0;
+		t = 4294967296 * carry + low;
+		low = t / BASE >>> 0;
+		digits = "" + (t - BASE * low);
+		if (low === 0 && high === 0) return sign + digits + result;
+		pad = "";
+		l = 6 - digits.length;
+		for (i = 0; i < l; i++) pad += "0";
+		result = pad + digits + result;
+		carry = high % BASE;
+		t = 4294967296 * carry + low;
+		digits = "" + t % BASE;
+		return sign + digits + result;
+	}
+	module.exports = readInt8;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/binaryParsers.js
+var require_binaryParsers = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/binaryParsers.js": ((exports, module) => {
+	var parseInt64 = require_pg_int8();
+	var parseBits = function(data, bits, offset, invert, callback) {
+		offset = offset || 0;
+		invert = invert || false;
+		callback = callback || function(lastValue, newValue, bits$1) {
+			return lastValue * Math.pow(2, bits$1) + newValue;
+		};
+		var offsetBytes = offset >> 3;
+		var inv = function(value) {
+			if (invert) return ~value & 255;
+			return value;
+		};
+		var mask = 255;
+		var firstBits = 8 - offset % 8;
+		if (bits < firstBits) {
+			mask = 255 << 8 - bits & 255;
+			firstBits = bits;
+		}
+		if (offset) mask = mask >> offset % 8;
+		var result = 0;
+		if (offset % 8 + bits >= 8) result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
+		var bytes = bits + offset >> 3;
+		for (var i = offsetBytes + 1; i < bytes; i++) result = callback(result, inv(data[i]), 8);
+		var lastBits = (bits + offset) % 8;
+		if (lastBits > 0) result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
+		return result;
+	};
+	var parseFloatFromBits = function(data, precisionBits, exponentBits) {
+		var bias = Math.pow(2, exponentBits - 1) - 1;
+		var sign = parseBits(data, 1);
+		var exponent = parseBits(data, exponentBits, 1);
+		if (exponent === 0) return 0;
+		var precisionBitsCounter = 1;
+		var parsePrecisionBits = function(lastValue, newValue, bits) {
+			if (lastValue === 0) lastValue = 1;
+			for (var i = 1; i <= bits; i++) {
+				precisionBitsCounter /= 2;
+				if ((newValue & 1 << bits - i) > 0) lastValue += precisionBitsCounter;
+			}
+			return lastValue;
+		};
+		var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
+		if (exponent == Math.pow(2, exponentBits + 1) - 1) {
+			if (mantissa === 0) return sign === 0 ? Infinity : -Infinity;
+			return NaN;
+		}
+		return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
+	};
+	var parseInt16 = function(value) {
+		if (parseBits(value, 1) == 1) return -1 * (parseBits(value, 15, 1, true) + 1);
+		return parseBits(value, 15, 1);
+	};
+	var parseInt32 = function(value) {
+		if (parseBits(value, 1) == 1) return -1 * (parseBits(value, 31, 1, true) + 1);
+		return parseBits(value, 31, 1);
+	};
+	var parseFloat32 = function(value) {
+		return parseFloatFromBits(value, 23, 8);
+	};
+	var parseFloat64 = function(value) {
+		return parseFloatFromBits(value, 52, 11);
+	};
+	var parseNumeric = function(value) {
+		var sign = parseBits(value, 16, 32);
+		if (sign == 49152) return NaN;
+		var weight = Math.pow(1e4, parseBits(value, 16, 16));
+		var result = 0;
+		var ndigits = parseBits(value, 16);
+		for (var i = 0; i < ndigits; i++) {
+			result += parseBits(value, 16, 64 + 16 * i) * weight;
+			weight /= 1e4;
+		}
+		var scale = Math.pow(10, parseBits(value, 16, 48));
+		return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
+	};
+	var parseDate = function(isUTC, value) {
+		var sign = parseBits(value, 1);
+		var rawValue = parseBits(value, 63, 1);
+		var result = /* @__PURE__ */ new Date((sign === 0 ? 1 : -1) * rawValue / 1e3 + 9466848e5);
+		if (!isUTC) result.setTime(result.getTime() + result.getTimezoneOffset() * 6e4);
+		result.usec = rawValue % 1e3;
+		result.getMicroSeconds = function() {
+			return this.usec;
+		};
+		result.setMicroSeconds = function(value$1) {
+			this.usec = value$1;
+		};
+		result.getUTCMicroSeconds = function() {
+			return this.usec;
+		};
+		return result;
+	};
+	var parseArray = function(value) {
+		var dim = parseBits(value, 32);
+		parseBits(value, 32, 32);
+		var elementType = parseBits(value, 32, 64);
+		var offset = 96;
+		var dims = [];
+		for (var i = 0; i < dim; i++) {
+			dims[i] = parseBits(value, 32, offset);
+			offset += 32;
+			offset += 32;
+		}
+		var parseElement = function(elementType$1) {
+			var length = parseBits(value, 32, offset);
+			offset += 32;
+			if (length == 4294967295) return null;
+			var result;
+			if (elementType$1 == 23 || elementType$1 == 20) {
+				result = parseBits(value, length * 8, offset);
+				offset += length * 8;
+				return result;
+			} else if (elementType$1 == 25) {
+				result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
+				return result;
+			} else console.log("ERROR: ElementType not implemented: " + elementType$1);
+		};
+		var parse$6 = function(dimension, elementType$1) {
+			var array$2 = [];
+			var i$1;
+			if (dimension.length > 1) {
+				var count = dimension.shift();
+				for (i$1 = 0; i$1 < count; i$1++) array$2[i$1] = parse$6(dimension, elementType$1);
+				dimension.unshift(count);
+			} else for (i$1 = 0; i$1 < dimension[0]; i$1++) array$2[i$1] = parseElement(elementType$1);
+			return array$2;
+		};
+		return parse$6(dims, elementType);
+	};
+	var parseText = function(value) {
+		return value.toString("utf8");
+	};
+	var parseBool = function(value) {
+		if (value === null) return null;
+		return parseBits(value, 8) > 0;
+	};
+	var init = function(register) {
+		register(20, parseInt64);
+		register(21, parseInt16);
+		register(23, parseInt32);
+		register(26, parseInt32);
+		register(1700, parseNumeric);
+		register(700, parseFloat32);
+		register(701, parseFloat64);
+		register(16, parseBool);
+		register(1114, parseDate.bind(null, false));
+		register(1184, parseDate.bind(null, true));
+		register(1e3, parseArray);
+		register(1007, parseArray);
+		register(1016, parseArray);
+		register(1008, parseArray);
+		register(1009, parseArray);
+		register(25, parseText);
+	};
+	module.exports = { init };
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/builtins.js
+var require_builtins = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/lib/builtins.js": ((exports, module) => {
+	/**
+	* Following query was used to generate this file:
+	
+	SELECT json_object_agg(UPPER(PT.typname), PT.oid::int4 ORDER BY pt.oid)
+	FROM pg_type PT
+	WHERE typnamespace = (SELECT pgn.oid FROM pg_namespace pgn WHERE nspname = 'pg_catalog') -- Take only builting Postgres types with stable OID (extension types are not guaranted to be stable)
+	AND typtype = 'b' -- Only basic types
+	AND typelem = 0 -- Ignore aliases
+	AND typisdefined -- Ignore undefined types
+	*/
+	module.exports = {
+		BOOL: 16,
+		BYTEA: 17,
+		CHAR: 18,
+		INT8: 20,
+		INT2: 21,
+		INT4: 23,
+		REGPROC: 24,
+		TEXT: 25,
+		OID: 26,
+		TID: 27,
+		XID: 28,
+		CID: 29,
+		JSON: 114,
+		XML: 142,
+		PG_NODE_TREE: 194,
+		SMGR: 210,
+		PATH: 602,
+		POLYGON: 604,
+		CIDR: 650,
+		FLOAT4: 700,
+		FLOAT8: 701,
+		ABSTIME: 702,
+		RELTIME: 703,
+		TINTERVAL: 704,
+		CIRCLE: 718,
+		MACADDR8: 774,
+		MONEY: 790,
+		MACADDR: 829,
+		INET: 869,
+		ACLITEM: 1033,
+		BPCHAR: 1042,
+		VARCHAR: 1043,
+		DATE: 1082,
+		TIME: 1083,
+		TIMESTAMP: 1114,
+		TIMESTAMPTZ: 1184,
+		INTERVAL: 1186,
+		TIMETZ: 1266,
+		BIT: 1560,
+		VARBIT: 1562,
+		NUMERIC: 1700,
+		REFCURSOR: 1790,
+		REGPROCEDURE: 2202,
+		REGOPER: 2203,
+		REGOPERATOR: 2204,
+		REGCLASS: 2205,
+		REGTYPE: 2206,
+		UUID: 2950,
+		TXID_SNAPSHOT: 2970,
+		PG_LSN: 3220,
+		PG_NDISTINCT: 3361,
+		PG_DEPENDENCIES: 3402,
+		TSVECTOR: 3614,
+		TSQUERY: 3615,
+		GTSVECTOR: 3642,
+		REGCONFIG: 3734,
+		REGDICTIONARY: 3769,
+		JSONB: 3802,
+		REGNAMESPACE: 4089,
+		REGROLE: 4096
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js
+var require_pg_types = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js": ((exports) => {
+	var textParsers = require_textParsers();
+	var binaryParsers = require_binaryParsers();
+	var arrayParser = require_arrayParser();
+	var builtinTypes = require_builtins();
+	exports.getTypeParser = getTypeParser;
+	exports.setTypeParser = setTypeParser;
+	exports.arrayParser = arrayParser;
+	exports.builtins = builtinTypes;
+	var typeParsers = {
+		text: {},
+		binary: {}
+	};
+	function noParse(val$1) {
+		return String(val$1);
+	}
+	function getTypeParser(oid, format) {
+		format = format || "text";
+		if (!typeParsers[format]) return noParse;
+		return typeParsers[format][oid] || noParse;
+	}
+	function setTypeParser(oid, format, parseFn) {
+		if (typeof format == "function") {
+			parseFn = format;
+			format = "text";
+		}
+		typeParsers[format][oid] = parseFn;
+	}
+	textParsers.init(function(oid, converter) {
+		typeParsers.text[oid] = converter;
+	});
+	binaryParsers.init(function(oid, converter) {
+		typeParsers.binary[oid] = converter;
+	});
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js
+var require_defaults = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js": ((exports, module) => {
+	module.exports = {
+		host: "localhost",
+		user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
+		database: void 0,
+		password: null,
+		connectionString: void 0,
+		port: 5432,
+		rows: 0,
+		binary: false,
+		max: 10,
+		idleTimeoutMillis: 3e4,
+		client_encoding: "",
+		ssl: false,
+		application_name: void 0,
+		fallback_application_name: void 0,
+		options: void 0,
+		parseInputDatesAsUTC: false,
+		statement_timeout: false,
+		lock_timeout: false,
+		idle_in_transaction_session_timeout: false,
+		query_timeout: false,
+		connect_timeout: 0,
+		keepalives: 1,
+		keepalives_idle: 0
+	};
+	const pgTypes = require_pg_types();
+	const parseBigInteger = pgTypes.getTypeParser(20, "text");
+	const parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
+	module.exports.__defineSetter__("parseInt8", function(val$1) {
+		pgTypes.setTypeParser(20, "text", val$1 ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
+		pgTypes.setTypeParser(1016, "text", val$1 ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
+	});
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js
+var require_utils$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js": ((exports, module) => {
+	const defaults$4 = require_defaults();
+	const util$3 = __require("util");
+	const { isDate } = util$3.types || util$3;
+	function escapeElement(elementRepresentation) {
+		return "\"" + elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"";
+	}
+	function arrayString(val$1) {
+		let result = "{";
+		for (let i = 0; i < val$1.length; i++) {
+			if (i > 0) result = result + ",";
+			if (val$1[i] === null || typeof val$1[i] === "undefined") result = result + "NULL";
+			else if (Array.isArray(val$1[i])) result = result + arrayString(val$1[i]);
+			else if (ArrayBuffer.isView(val$1[i])) {
+				let item = val$1[i];
+				if (!(item instanceof Buffer)) {
+					const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
+					if (buf.length === item.byteLength) item = buf;
+					else item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
+				}
+				result += "\\\\x" + item.toString("hex");
+			} else result += escapeElement(prepareValue(val$1[i]));
+		}
+		result = result + "}";
+		return result;
+	}
+	const prepareValue = function(val$1, seen) {
+		if (val$1 == null) return null;
+		if (typeof val$1 === "object") {
+			if (val$1 instanceof Buffer) return val$1;
+			if (ArrayBuffer.isView(val$1)) {
+				const buf = Buffer.from(val$1.buffer, val$1.byteOffset, val$1.byteLength);
+				if (buf.length === val$1.byteLength) return buf;
+				return buf.slice(val$1.byteOffset, val$1.byteOffset + val$1.byteLength);
+			}
+			if (isDate(val$1)) if (defaults$4.parseInputDatesAsUTC) return dateToStringUTC(val$1);
+			else return dateToString(val$1);
+			if (Array.isArray(val$1)) return arrayString(val$1);
+			return prepareObject(val$1, seen);
+		}
+		return val$1.toString();
+	};
+	function prepareObject(val$1, seen) {
+		if (val$1 && typeof val$1.toPostgres === "function") {
+			seen = seen || [];
+			if (seen.indexOf(val$1) !== -1) throw new Error("circular reference detected while preparing \"" + val$1 + "\" for query");
+			seen.push(val$1);
+			return prepareValue(val$1.toPostgres(prepareValue), seen);
+		}
+		return JSON.stringify(val$1);
+	}
+	function dateToString(date) {
+		let offset = -date.getTimezoneOffset();
+		let year = date.getFullYear();
+		const isBCYear = year < 1;
+		if (isBCYear) year = Math.abs(year) + 1;
+		let ret = String(year).padStart(4, "0") + "-" + String(date.getMonth() + 1).padStart(2, "0") + "-" + String(date.getDate()).padStart(2, "0") + "T" + String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0") + "." + String(date.getMilliseconds()).padStart(3, "0");
+		if (offset < 0) {
+			ret += "-";
+			offset *= -1;
+		} else ret += "+";
+		ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
+		if (isBCYear) ret += " BC";
+		return ret;
+	}
+	function dateToStringUTC(date) {
+		let year = date.getUTCFullYear();
+		const isBCYear = year < 1;
+		if (isBCYear) year = Math.abs(year) + 1;
+		let ret = String(year).padStart(4, "0") + "-" + String(date.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date.getUTCDate()).padStart(2, "0") + "T" + String(date.getUTCHours()).padStart(2, "0") + ":" + String(date.getUTCMinutes()).padStart(2, "0") + ":" + String(date.getUTCSeconds()).padStart(2, "0") + "." + String(date.getUTCMilliseconds()).padStart(3, "0");
+		ret += "+00:00";
+		if (isBCYear) ret += " BC";
+		return ret;
+	}
+	function normalizeQueryConfig(config, values, callback) {
+		config = typeof config === "string" ? { text: config } : config;
+		if (values) if (typeof values === "function") config.callback = values;
+		else config.values = values;
+		if (callback) config.callback = callback;
+		return config;
+	}
+	const escapeIdentifier$2 = function(str) {
+		return "\"" + str.replace(/"/g, "\"\"") + "\"";
+	};
+	const escapeLiteral$2 = function(str) {
+		let hasBackslash = false;
+		let escaped = "'";
+		if (str == null) return "''";
+		if (typeof str !== "string") return "''";
+		for (let i = 0; i < str.length; i++) {
+			const c = str[i];
+			if (c === "'") escaped += c + c;
+			else if (c === "\\") {
+				escaped += c + c;
+				hasBackslash = true;
+			} else escaped += c;
+		}
+		escaped += "'";
+		if (hasBackslash === true) escaped = " E" + escaped;
+		return escaped;
+	};
+	module.exports = {
+		prepareValue: function prepareValueWrapper(value) {
+			return prepareValue(value);
+		},
+		normalizeQueryConfig,
+		escapeIdentifier: escapeIdentifier$2,
+		escapeLiteral: escapeLiteral$2
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-legacy.js
+var require_utils_legacy = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-legacy.js": ((exports, module) => {
+	const nodeCrypto$1 = __require("crypto");
+	function md5$1(string) {
+		return nodeCrypto$1.createHash("md5").update(string, "utf-8").digest("hex");
+	}
+	function postgresMd5PasswordHash$1(user, password$1, salt) {
+		const inner = md5$1(password$1 + user);
+		return "md5" + md5$1(Buffer.concat([Buffer.from(inner), salt]));
+	}
+	function sha256$1(text) {
+		return nodeCrypto$1.createHash("sha256").update(text).digest();
+	}
+	function hashByName$1(hashName, text) {
+		hashName = hashName.replace(/(\D)-/, "$1");
+		return nodeCrypto$1.createHash(hashName).update(text).digest();
+	}
+	function hmacSha256$1(key, msg) {
+		return nodeCrypto$1.createHmac("sha256", key).update(msg).digest();
+	}
+	async function deriveKey$1(password$1, salt, iterations) {
+		return nodeCrypto$1.pbkdf2Sync(password$1, salt, iterations, 32, "sha256");
+	}
+	module.exports = {
+		postgresMd5PasswordHash: postgresMd5PasswordHash$1,
+		randomBytes: nodeCrypto$1.randomBytes,
+		deriveKey: deriveKey$1,
+		sha256: sha256$1,
+		hashByName: hashByName$1,
+		hmacSha256: hmacSha256$1,
+		md5: md5$1
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-webcrypto.js
+var require_utils_webcrypto = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-webcrypto.js": ((exports, module) => {
+	const nodeCrypto = __require("crypto");
+	module.exports = {
+		postgresMd5PasswordHash,
+		randomBytes,
+		deriveKey,
+		sha256,
+		hashByName,
+		hmacSha256,
+		md5
+	};
+	/**
+	* The Web Crypto API - grabbed from the Node.js library or the global
+	* @type Crypto
+	*/
+	const webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
+	/**
+	* The SubtleCrypto API for low level crypto operations.
+	* @type SubtleCrypto
+	*/
+	const subtleCrypto = webCrypto.subtle;
+	const textEncoder = new TextEncoder();
+	/**
+	*
+	* @param {*} length
+	* @returns
+	*/
+	function randomBytes(length) {
+		return webCrypto.getRandomValues(Buffer.alloc(length));
+	}
+	async function md5(string) {
+		try {
+			return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
+		} catch (e) {
+			const data = typeof string === "string" ? textEncoder.encode(string) : string;
+			const hash = await subtleCrypto.digest("MD5", data);
+			return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
+		}
+	}
+	async function postgresMd5PasswordHash(user, password$1, salt) {
+		const inner = await md5(password$1 + user);
+		return "md5" + await md5(Buffer.concat([Buffer.from(inner), salt]));
+	}
+	/**
+	* Create a SHA-256 digest of the given data
+	* @param {Buffer} data
+	*/
+	async function sha256(text) {
+		return await subtleCrypto.digest("SHA-256", text);
+	}
+	async function hashByName(hashName, text) {
+		return await subtleCrypto.digest(hashName, text);
+	}
+	/**
+	* Sign the message with the given key
+	* @param {ArrayBuffer} keyBuffer
+	* @param {string} msg
+	*/
+	async function hmacSha256(keyBuffer, msg) {
+		const key = await subtleCrypto.importKey("raw", keyBuffer, {
+			name: "HMAC",
+			hash: "SHA-256"
+		}, false, ["sign"]);
+		return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
+	}
+	/**
+	* Derive a key from the password and salt
+	* @param {string} password
+	* @param {Uint8Array} salt
+	* @param {number} iterations
+	*/
+	async function deriveKey(password$1, salt, iterations) {
+		const key = await subtleCrypto.importKey("raw", textEncoder.encode(password$1), "PBKDF2", false, ["deriveBits"]);
+		const params = {
+			name: "PBKDF2",
+			hash: "SHA-256",
+			salt,
+			iterations
+		};
+		return await subtleCrypto.deriveBits(params, key, 256, ["deriveBits"]);
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils.js
+var require_utils = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils.js": ((exports, module) => {
+	if (parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15) module.exports = require_utils_legacy();
+	else module.exports = require_utils_webcrypto();
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/cert-signatures.js
+var require_cert_signatures = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/cert-signatures.js": ((exports, module) => {
+	function x509Error(msg, cert) {
+		return /* @__PURE__ */ new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
+	}
+	function readASN1Length(data, index) {
+		let length = data[index++];
+		if (length < 128) return {
+			length,
+			index
+		};
+		const lengthBytes = length & 127;
+		if (lengthBytes > 4) throw x509Error("bad length", data);
+		length = 0;
+		for (let i = 0; i < lengthBytes; i++) length = length << 8 | data[index++];
+		return {
+			length,
+			index
+		};
+	}
+	function readASN1OID(data, index) {
+		if (data[index++] !== 6) throw x509Error("non-OID data", data);
+		const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
+		index = indexAfterOIDLength;
+		const lastIndex = index + OIDLength;
+		const byte1 = data[index++];
+		let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
+		while (index < lastIndex) {
+			let value = 0;
+			while (index < lastIndex) {
+				const nextByte = data[index++];
+				value = value << 7 | nextByte & 127;
+				if (nextByte < 128) break;
+			}
+			oid += "." + value;
+		}
+		return {
+			oid,
+			index
+		};
+	}
+	function expectASN1Seq(data, index) {
+		if (data[index++] !== 48) throw x509Error("non-sequence data", data);
+		return readASN1Length(data, index);
+	}
+	function signatureAlgorithmHashFromCertificate$1(data, index) {
+		if (index === void 0) index = 0;
+		index = expectASN1Seq(data, index).index;
+		const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
+		index = indexAfterCertInfoLength + certInfoLength;
+		index = expectASN1Seq(data, index).index;
+		const { oid, index: indexAfterOID } = readASN1OID(data, index);
+		switch (oid) {
+			case "1.2.840.113549.1.1.4": return "MD5";
+			case "1.2.840.113549.1.1.5": return "SHA-1";
+			case "1.2.840.113549.1.1.11": return "SHA-256";
+			case "1.2.840.113549.1.1.12": return "SHA-384";
+			case "1.2.840.113549.1.1.13": return "SHA-512";
+			case "1.2.840.113549.1.1.14": return "SHA-224";
+			case "1.2.840.113549.1.1.15": return "SHA512-224";
+			case "1.2.840.113549.1.1.16": return "SHA512-256";
+			case "1.2.840.10045.4.1": return "SHA-1";
+			case "1.2.840.10045.4.3.1": return "SHA-224";
+			case "1.2.840.10045.4.3.2": return "SHA-256";
+			case "1.2.840.10045.4.3.3": return "SHA-384";
+			case "1.2.840.10045.4.3.4": return "SHA-512";
+			case "1.2.840.113549.1.1.10": {
+				index = indexAfterOID;
+				index = expectASN1Seq(data, index).index;
+				if (data[index++] !== 160) throw x509Error("non-tag data", data);
+				index = readASN1Length(data, index).index;
+				index = expectASN1Seq(data, index).index;
+				const { oid: hashOID } = readASN1OID(data, index);
+				switch (hashOID) {
+					case "1.2.840.113549.2.5": return "MD5";
+					case "1.3.14.3.2.26": return "SHA-1";
+					case "2.16.840.1.101.3.4.2.1": return "SHA-256";
+					case "2.16.840.1.101.3.4.2.2": return "SHA-384";
+					case "2.16.840.1.101.3.4.2.3": return "SHA-512";
+				}
+				throw x509Error("unknown hash OID " + hashOID, data);
+			}
+			case "1.3.101.110":
+			case "1.3.101.112": return "SHA-512";
+			case "1.3.101.111":
+			case "1.3.101.113": throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
+		}
+		throw x509Error("unknown OID " + oid, data);
+	}
+	module.exports = { signatureAlgorithmHashFromCertificate: signatureAlgorithmHashFromCertificate$1 };
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/sasl.js
+var require_sasl = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/sasl.js": ((exports, module) => {
+	const crypto$1 = require_utils();
+	const { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
+	function startSession(mechanisms, stream) {
+		const candidates = ["SCRAM-SHA-256"];
+		if (stream) candidates.unshift("SCRAM-SHA-256-PLUS");
+		const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
+		if (!mechanism) throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
+		if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
+		const clientNonce = crypto$1.randomBytes(18).toString("base64");
+		return {
+			mechanism,
+			clientNonce,
+			response: (mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n") + ",,n=*,r=" + clientNonce,
+			message: "SASLInitialResponse"
+		};
+	}
+	async function continueSession(session, password$1, serverData, stream) {
+		if (session.message !== "SASLInitialResponse") throw new Error("SASL: Last message was not SASLInitialResponse");
+		if (typeof password$1 !== "string") throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
+		if (password$1 === "") throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
+		if (typeof serverData !== "string") throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
+		const sv = parseServerFirstMessage(serverData);
+		if (!sv.nonce.startsWith(session.clientNonce)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
+		else if (sv.nonce.length === session.clientNonce.length) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
+		const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
+		const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
+		let channelBinding = stream ? "eSws" : "biws";
+		if (session.mechanism === "SCRAM-SHA-256-PLUS") {
+			const peerCert = stream.getPeerCertificate().raw;
+			let hashName = signatureAlgorithmHashFromCertificate(peerCert);
+			if (hashName === "MD5" || hashName === "SHA-1") hashName = "SHA-256";
+			const certHash = await crypto$1.hashByName(hashName, peerCert);
+			channelBinding = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]).toString("base64");
+		}
+		const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
+		const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
+		const saltBytes = Buffer.from(sv.salt, "base64");
+		const saltedPassword = await crypto$1.deriveKey(password$1, saltBytes, sv.iteration);
+		const clientKey = await crypto$1.hmacSha256(saltedPassword, "Client Key");
+		const storedKey = await crypto$1.sha256(clientKey);
+		const clientSignature = await crypto$1.hmacSha256(storedKey, authMessage);
+		const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
+		const serverKey = await crypto$1.hmacSha256(saltedPassword, "Server Key");
+		const serverSignatureBytes = await crypto$1.hmacSha256(serverKey, authMessage);
+		session.message = "SASLResponse";
+		session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
+		session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
+	}
+	function finalizeSession(session, serverData) {
+		if (session.message !== "SASLResponse") throw new Error("SASL: Last message was not SASLResponse");
+		if (typeof serverData !== "string") throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
+		const { serverSignature } = parseServerFinalMessage(serverData);
+		if (serverSignature !== session.serverSignature) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
+	}
+	/**
+	* printable       = %x21-2B / %x2D-7E
+	*                   ;; Printable ASCII except ",".
+	*                   ;; Note that any "printable" is also
+	*                   ;; a valid "value".
+	*/
+	function isPrintableChars(text) {
+		if (typeof text !== "string") throw new TypeError("SASL: text must be a string");
+		return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
+	}
+	/**
+	* base64-char     = ALPHA / DIGIT / "/" / "+"
+	*
+	* base64-4        = 4base64-char
+	*
+	* base64-3        = 3base64-char "="
+	*
+	* base64-2        = 2base64-char "=="
+	*
+	* base64          = *base64-4 [base64-3 / base64-2]
+	*/
+	function isBase64(text) {
+		return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
+	}
+	function parseAttributePairs(text) {
+		if (typeof text !== "string") throw new TypeError("SASL: attribute pairs text must be a string");
+		return new Map(text.split(",").map((attrValue) => {
+			if (!/^.=/.test(attrValue)) throw new Error("SASL: Invalid attribute pair entry");
+			return [attrValue[0], attrValue.substring(2)];
+		}));
+	}
+	function parseServerFirstMessage(data) {
+		const attrPairs = parseAttributePairs(data);
+		const nonce = attrPairs.get("r");
+		if (!nonce) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
+		else if (!isPrintableChars(nonce)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
+		const salt = attrPairs.get("s");
+		if (!salt) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
+		else if (!isBase64(salt)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
+		const iterationText = attrPairs.get("i");
+		if (!iterationText) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
+		else if (!/^[1-9][0-9]*$/.test(iterationText)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
+		return {
+			nonce,
+			salt,
+			iteration: parseInt(iterationText, 10)
+		};
+	}
+	function parseServerFinalMessage(serverData) {
+		const serverSignature = parseAttributePairs(serverData).get("v");
+		if (!serverSignature) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
+		else if (!isBase64(serverSignature)) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
+		return { serverSignature };
+	}
+	function xorBuffers(a, b) {
+		if (!Buffer.isBuffer(a)) throw new TypeError("first argument must be a Buffer");
+		if (!Buffer.isBuffer(b)) throw new TypeError("second argument must be a Buffer");
+		if (a.length !== b.length) throw new Error("Buffer lengths must match");
+		if (a.length === 0) throw new Error("Buffers cannot be empty");
+		return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
+	}
+	module.exports = {
+		startSession,
+		continueSession,
+		finalizeSession
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js
+var require_type_overrides = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js": ((exports, module) => {
+	const types$2 = require_pg_types();
+	function TypeOverrides$4(userTypes) {
+		this._types = userTypes || types$2;
+		this.text = {};
+		this.binary = {};
+	}
+	TypeOverrides$4.prototype.getOverrides = function(format) {
+		switch (format) {
+			case "text": return this.text;
+			case "binary": return this.binary;
+			default: return {};
+		}
+	};
+	TypeOverrides$4.prototype.setTypeParser = function(oid, format, parseFn) {
+		if (typeof format === "function") {
+			parseFn = format;
+			format = "text";
+		}
+		this.getOverrides(format)[oid] = parseFn;
+	};
+	TypeOverrides$4.prototype.getTypeParser = function(oid, format) {
+		format = format || "text";
+		return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
+	};
+	module.exports = TypeOverrides$4;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-connection-string@2.9.1/node_modules/pg-connection-string/index.js
+var require_pg_connection_string = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-connection-string@2.9.1/node_modules/pg-connection-string/index.js": ((exports, module) => {
+	function parse$4(str, options = {}) {
+		if (str.charAt(0) === "/") {
+			const config$1 = str.split(" ");
+			return {
+				host: config$1[0],
+				database: config$1[1]
+			};
+		}
+		const config = {};
+		let result;
+		let dummyHost = false;
+		if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
+		try {
+			try {
+				result = new URL(str, "postgres://base");
+			} catch (e) {
+				result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
+				dummyHost = true;
+			}
+		} catch (err) {
+			err.input && (err.input = "*****REDACTED*****");
+		}
+		for (const entry of result.searchParams.entries()) config[entry[0]] = entry[1];
+		config.user = config.user || decodeURIComponent(result.username);
+		config.password = config.password || decodeURIComponent(result.password);
+		if (result.protocol == "socket:") {
+			config.host = decodeURI(result.pathname);
+			config.database = result.searchParams.get("db");
+			config.client_encoding = result.searchParams.get("encoding");
+			return config;
+		}
+		const hostname = dummyHost ? "" : result.hostname;
+		if (!config.host) config.host = decodeURIComponent(hostname);
+		else if (hostname && /^%2f/i.test(hostname)) result.pathname = hostname + result.pathname;
+		if (!config.port) config.port = result.port;
+		const pathname = result.pathname.slice(1) || null;
+		config.database = pathname ? decodeURI(pathname) : null;
+		if (config.ssl === "true" || config.ssl === "1") config.ssl = true;
+		if (config.ssl === "0") config.ssl = false;
+		if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) config.ssl = {};
+		const fs$1 = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
+		if (config.sslcert) config.ssl.cert = fs$1.readFileSync(config.sslcert).toString();
+		if (config.sslkey) config.ssl.key = fs$1.readFileSync(config.sslkey).toString();
+		if (config.sslrootcert) config.ssl.ca = fs$1.readFileSync(config.sslrootcert).toString();
+		if (options.useLibpqCompat && config.uselibpqcompat) throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
+		if (config.uselibpqcompat === "true" || options.useLibpqCompat) switch (config.sslmode) {
+			case "disable":
+				config.ssl = false;
+				break;
+			case "prefer":
+				config.ssl.rejectUnauthorized = false;
+				break;
+			case "require":
+				if (config.sslrootcert) config.ssl.checkServerIdentity = function() {};
+				else config.ssl.rejectUnauthorized = false;
+				break;
+			case "verify-ca":
+				if (!config.ssl.ca) throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
+				config.ssl.checkServerIdentity = function() {};
+				break;
+			case "verify-full": break;
+		}
+		else switch (config.sslmode) {
+			case "disable":
+				config.ssl = false;
+				break;
+			case "prefer":
+			case "require":
+			case "verify-ca":
+			case "verify-full": break;
+			case "no-verify":
+				config.ssl.rejectUnauthorized = false;
+				break;
+		}
+		return config;
+	}
+	function toConnectionOptions(sslConfig) {
+		return Object.entries(sslConfig).reduce((c, [key, value]) => {
+			if (value !== void 0 && value !== null) c[key] = value;
+			return c;
+		}, {});
+	}
+	function toClientConfig(config) {
+		return Object.entries(config).reduce((c, [key, value]) => {
+			if (key === "ssl") {
+				const sslConfig = value;
+				if (typeof sslConfig === "boolean") c[key] = sslConfig;
+				if (typeof sslConfig === "object") c[key] = toConnectionOptions(sslConfig);
+			} else if (value !== void 0 && value !== null) if (key === "port") {
+				if (value !== "") {
+					const v = parseInt(value, 10);
+					if (isNaN(v)) throw new Error(`Invalid ${key}: ${value}`);
+					c[key] = v;
+				}
+			} else c[key] = value;
+			return c;
+		}, {});
+	}
+	function parseIntoClientConfig(str) {
+		return toClientConfig(parse$4(str));
+	}
+	module.exports = parse$4;
+	parse$4.parse = parse$4;
+	parse$4.toClientConfig = toClientConfig;
+	parse$4.parseIntoClientConfig = parseIntoClientConfig;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection-parameters.js
+var require_connection_parameters = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection-parameters.js": ((exports, module) => {
+	const dns = __require("dns");
+	const defaults$3 = require_defaults();
+	const parse$3 = require_pg_connection_string().parse;
+	const val = function(key, config, envVar) {
+		if (envVar === void 0) envVar = process.env["PG" + key.toUpperCase()];
+		else if (envVar === false) {} else envVar = process.env[envVar];
+		return config[key] || envVar || defaults$3[key];
+	};
+	const readSSLConfigFromEnvironment = function() {
+		switch (process.env.PGSSLMODE) {
+			case "disable": return false;
+			case "prefer":
+			case "require":
+			case "verify-ca":
+			case "verify-full": return true;
+			case "no-verify": return { rejectUnauthorized: false };
+		}
+		return defaults$3.ssl;
+	};
+	const quoteParamValue = function(value) {
+		return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
+	};
+	const add = function(params, config, paramName) {
+		const value = config[paramName];
+		if (value !== void 0 && value !== null) params.push(paramName + "=" + quoteParamValue(value));
+	};
+	var ConnectionParameters$2 = class {
+		constructor(config) {
+			config = typeof config === "string" ? parse$3(config) : config || {};
+			if (config.connectionString) config = Object.assign({}, config, parse$3(config.connectionString));
+			this.user = val("user", config);
+			this.database = val("database", config);
+			if (this.database === void 0) this.database = this.user;
+			this.port = parseInt(val("port", config), 10);
+			this.host = val("host", config);
+			Object.defineProperty(this, "password", {
+				configurable: true,
+				enumerable: false,
+				writable: true,
+				value: val("password", config)
+			});
+			this.binary = val("binary", config);
+			this.options = val("options", config);
+			this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
+			if (typeof this.ssl === "string") {
+				if (this.ssl === "true") this.ssl = true;
+			}
+			if (this.ssl === "no-verify") this.ssl = { rejectUnauthorized: false };
+			if (this.ssl && this.ssl.key) Object.defineProperty(this.ssl, "key", { enumerable: false });
+			this.client_encoding = val("client_encoding", config);
+			this.replication = val("replication", config);
+			this.isDomainSocket = !(this.host || "").indexOf("/");
+			this.application_name = val("application_name", config, "PGAPPNAME");
+			this.fallback_application_name = val("fallback_application_name", config, false);
+			this.statement_timeout = val("statement_timeout", config, false);
+			this.lock_timeout = val("lock_timeout", config, false);
+			this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
+			this.query_timeout = val("query_timeout", config, false);
+			if (config.connectionTimeoutMillis === void 0) this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
+			else this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1e3);
+			if (config.keepAlive === false) this.keepalives = 0;
+			else if (config.keepAlive === true) this.keepalives = 1;
+			if (typeof config.keepAliveInitialDelayMillis === "number") this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1e3);
+		}
+		getLibpqConnectionString(cb) {
+			const params = [];
+			add(params, this, "user");
+			add(params, this, "password");
+			add(params, this, "port");
+			add(params, this, "application_name");
+			add(params, this, "fallback_application_name");
+			add(params, this, "connect_timeout");
+			add(params, this, "options");
+			const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
+			add(params, ssl, "sslmode");
+			add(params, ssl, "sslca");
+			add(params, ssl, "sslkey");
+			add(params, ssl, "sslcert");
+			add(params, ssl, "sslrootcert");
+			if (this.database) params.push("dbname=" + quoteParamValue(this.database));
+			if (this.replication) params.push("replication=" + quoteParamValue(this.replication));
+			if (this.host) params.push("host=" + quoteParamValue(this.host));
+			if (this.isDomainSocket) return cb(null, params.join(" "));
+			if (this.client_encoding) params.push("client_encoding=" + quoteParamValue(this.client_encoding));
+			dns.lookup(this.host, function(err, address) {
+				if (err) return cb(err, null);
+				params.push("hostaddr=" + quoteParamValue(address));
+				return cb(null, params.join(" "));
+			});
+		}
+	};
+	module.exports = ConnectionParameters$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/result.js
+var require_result = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/result.js": ((exports, module) => {
+	const types$1 = require_pg_types();
+	const matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
+	var Result$3 = class {
+		constructor(rowMode, types$3) {
+			this.command = null;
+			this.rowCount = null;
+			this.oid = null;
+			this.rows = [];
+			this.fields = [];
+			this._parsers = void 0;
+			this._types = types$3;
+			this.RowCtor = null;
+			this.rowAsArray = rowMode === "array";
+			if (this.rowAsArray) this.parseRow = this._parseRowAsArray;
+			this._prebuiltEmptyResultObject = null;
+		}
+		addCommandComplete(msg) {
+			let match;
+			if (msg.text) match = matchRegexp.exec(msg.text);
+			else match = matchRegexp.exec(msg.command);
+			if (match) {
+				this.command = match[1];
+				if (match[3]) {
+					this.oid = parseInt(match[2], 10);
+					this.rowCount = parseInt(match[3], 10);
+				} else if (match[2]) this.rowCount = parseInt(match[2], 10);
+			}
+		}
+		_parseRowAsArray(rowData) {
+			const row = new Array(rowData.length);
+			for (let i = 0, len = rowData.length; i < len; i++) {
+				const rawValue = rowData[i];
+				if (rawValue !== null) row[i] = this._parsers[i](rawValue);
+				else row[i] = null;
+			}
+			return row;
+		}
+		parseRow(rowData) {
+			const row = { ...this._prebuiltEmptyResultObject };
+			for (let i = 0, len = rowData.length; i < len; i++) {
+				const rawValue = rowData[i];
+				const field = this.fields[i].name;
+				if (rawValue !== null) {
+					const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
+					row[field] = this._parsers[i](v);
+				} else row[field] = null;
+			}
+			return row;
+		}
+		addRow(row) {
+			this.rows.push(row);
+		}
+		addFields(fieldDescriptions) {
+			this.fields = fieldDescriptions;
+			if (this.fields.length) this._parsers = new Array(fieldDescriptions.length);
+			const row = {};
+			for (let i = 0; i < fieldDescriptions.length; i++) {
+				const desc = fieldDescriptions[i];
+				row[desc.name] = null;
+				if (this._types) this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
+				else this._parsers[i] = types$1.getTypeParser(desc.dataTypeID, desc.format || "text");
+			}
+			this._prebuiltEmptyResultObject = { ...row };
+		}
+	};
+	module.exports = Result$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/query.js
+var require_query$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/query.js": ((exports, module) => {
+	const { EventEmitter: EventEmitter$5 } = __require("events");
+	const Result$2 = require_result();
+	const utils$3 = require_utils$1();
+	var Query$2 = class extends EventEmitter$5 {
+		constructor(config, values, callback) {
+			super();
+			config = utils$3.normalizeQueryConfig(config, values, callback);
+			this.text = config.text;
+			this.values = config.values;
+			this.rows = config.rows;
+			this.types = config.types;
+			this.name = config.name;
+			this.queryMode = config.queryMode;
+			this.binary = config.binary;
+			this.portal = config.portal || "";
+			this.callback = config.callback;
+			this._rowMode = config.rowMode;
+			if (process.domain && config.callback) this.callback = process.domain.bind(config.callback);
+			this._result = new Result$2(this._rowMode, this.types);
+			this._results = this._result;
+			this._canceledDueToError = false;
+		}
+		requiresPreparation() {
+			if (this.queryMode === "extended") return true;
+			if (this.name) return true;
+			if (this.rows) return true;
+			if (!this.text) return false;
+			if (!this.values) return false;
+			return this.values.length > 0;
+		}
+		_checkForMultirow() {
+			if (this._result.command) {
+				if (!Array.isArray(this._results)) this._results = [this._result];
+				this._result = new Result$2(this._rowMode, this._result._types);
+				this._results.push(this._result);
+			}
+		}
+		handleRowDescription(msg) {
+			this._checkForMultirow();
+			this._result.addFields(msg.fields);
+			this._accumulateRows = this.callback || !this.listeners("row").length;
+		}
+		handleDataRow(msg) {
+			let row;
+			if (this._canceledDueToError) return;
+			try {
+				row = this._result.parseRow(msg.fields);
+			} catch (err) {
+				this._canceledDueToError = err;
+				return;
+			}
+			this.emit("row", row, this._result);
+			if (this._accumulateRows) this._result.addRow(row);
+		}
+		handleCommandComplete(msg, connection) {
+			this._checkForMultirow();
+			this._result.addCommandComplete(msg);
+			if (this.rows) connection.sync();
+		}
+		handleEmptyQuery(connection) {
+			if (this.rows) connection.sync();
+		}
+		handleError(err, connection) {
+			if (this._canceledDueToError) {
+				err = this._canceledDueToError;
+				this._canceledDueToError = false;
+			}
+			if (this.callback) return this.callback(err);
+			this.emit("error", err);
+		}
+		handleReadyForQuery(con) {
+			if (this._canceledDueToError) return this.handleError(this._canceledDueToError, con);
+			if (this.callback) try {
+				this.callback(null, this._results);
+			} catch (err) {
+				process.nextTick(() => {
+					throw err;
+				});
+			}
+			this.emit("end", this._results);
+		}
+		submit(connection) {
+			if (typeof this.text !== "string" && typeof this.name !== "string") return /* @__PURE__ */ new Error("A query must have either text or a name. Supplying neither is unsupported.");
+			const previous = connection.parsedStatements[this.name];
+			if (this.text && previous && this.text !== previous) return /* @__PURE__ */ new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
+			if (this.values && !Array.isArray(this.values)) return /* @__PURE__ */ new Error("Query values must be an array");
+			if (this.requiresPreparation()) {
+				connection.stream.cork && connection.stream.cork();
+				try {
+					this.prepare(connection);
+				} finally {
+					connection.stream.uncork && connection.stream.uncork();
+				}
+			} else connection.query(this.text);
+			return null;
+		}
+		hasBeenParsed(connection) {
+			return this.name && connection.parsedStatements[this.name];
+		}
+		handlePortalSuspended(connection) {
+			this._getRows(connection, this.rows);
+		}
+		_getRows(connection, rows) {
+			connection.execute({
+				portal: this.portal,
+				rows
+			});
+			if (!rows) connection.sync();
+			else connection.flush();
+		}
+		prepare(connection) {
+			if (!this.hasBeenParsed(connection)) connection.parse({
+				text: this.text,
+				name: this.name,
+				types: this.types
+			});
+			try {
+				connection.bind({
+					portal: this.portal,
+					statement: this.name,
+					values: this.values,
+					binary: this.binary,
+					valueMapper: utils$3.prepareValue
+				});
+			} catch (err) {
+				this.handleError(err, connection);
+				return;
+			}
+			connection.describe({
+				type: "P",
+				name: this.portal || ""
+			});
+			this._getRows(connection, this.rows);
+		}
+		handleCopyInResponse(connection) {
+			connection.sendCopyFail("No source stream defined");
+		}
+		handleCopyData(msg, connection) {}
+	};
+	module.exports = Query$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/messages.js
+var require_messages = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/messages.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = void 0;
+	exports.parseComplete = {
+		name: "parseComplete",
+		length: 5
+	};
+	exports.bindComplete = {
+		name: "bindComplete",
+		length: 5
+	};
+	exports.closeComplete = {
+		name: "closeComplete",
+		length: 5
+	};
+	exports.noData = {
+		name: "noData",
+		length: 5
+	};
+	exports.portalSuspended = {
+		name: "portalSuspended",
+		length: 5
+	};
+	exports.replicationStart = {
+		name: "replicationStart",
+		length: 4
+	};
+	exports.emptyQuery = {
+		name: "emptyQuery",
+		length: 4
+	};
+	exports.copyDone = {
+		name: "copyDone",
+		length: 4
+	};
+	var DatabaseError$2 = class extends Error {
+		constructor(message, length, name) {
+			super(message);
+			this.length = length;
+			this.name = name;
+		}
+	};
+	exports.DatabaseError = DatabaseError$2;
+	var CopyDataMessage = class {
+		constructor(length, chunk) {
+			this.length = length;
+			this.chunk = chunk;
+			this.name = "copyData";
+		}
+	};
+	exports.CopyDataMessage = CopyDataMessage;
+	var CopyResponse = class {
+		constructor(length, name, binary, columnCount) {
+			this.length = length;
+			this.name = name;
+			this.binary = binary;
+			this.columnTypes = new Array(columnCount);
+		}
+	};
+	exports.CopyResponse = CopyResponse;
+	var Field = class {
+		constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
+			this.name = name;
+			this.tableID = tableID;
+			this.columnID = columnID;
+			this.dataTypeID = dataTypeID;
+			this.dataTypeSize = dataTypeSize;
+			this.dataTypeModifier = dataTypeModifier;
+			this.format = format;
+		}
+	};
+	exports.Field = Field;
+	var RowDescriptionMessage = class {
+		constructor(length, fieldCount) {
+			this.length = length;
+			this.fieldCount = fieldCount;
+			this.name = "rowDescription";
+			this.fields = new Array(this.fieldCount);
+		}
+	};
+	exports.RowDescriptionMessage = RowDescriptionMessage;
+	var ParameterDescriptionMessage = class {
+		constructor(length, parameterCount) {
+			this.length = length;
+			this.parameterCount = parameterCount;
+			this.name = "parameterDescription";
+			this.dataTypeIDs = new Array(this.parameterCount);
+		}
+	};
+	exports.ParameterDescriptionMessage = ParameterDescriptionMessage;
+	var ParameterStatusMessage = class {
+		constructor(length, parameterName, parameterValue) {
+			this.length = length;
+			this.parameterName = parameterName;
+			this.parameterValue = parameterValue;
+			this.name = "parameterStatus";
+		}
+	};
+	exports.ParameterStatusMessage = ParameterStatusMessage;
+	var AuthenticationMD5Password = class {
+		constructor(length, salt) {
+			this.length = length;
+			this.salt = salt;
+			this.name = "authenticationMD5Password";
+		}
+	};
+	exports.AuthenticationMD5Password = AuthenticationMD5Password;
+	var BackendKeyDataMessage = class {
+		constructor(length, processID, secretKey) {
+			this.length = length;
+			this.processID = processID;
+			this.secretKey = secretKey;
+			this.name = "backendKeyData";
+		}
+	};
+	exports.BackendKeyDataMessage = BackendKeyDataMessage;
+	var NotificationResponseMessage = class {
+		constructor(length, processId, channel, payload) {
+			this.length = length;
+			this.processId = processId;
+			this.channel = channel;
+			this.payload = payload;
+			this.name = "notification";
+		}
+	};
+	exports.NotificationResponseMessage = NotificationResponseMessage;
+	var ReadyForQueryMessage = class {
+		constructor(length, status) {
+			this.length = length;
+			this.status = status;
+			this.name = "readyForQuery";
+		}
+	};
+	exports.ReadyForQueryMessage = ReadyForQueryMessage;
+	var CommandCompleteMessage = class {
+		constructor(length, text) {
+			this.length = length;
+			this.text = text;
+			this.name = "commandComplete";
+		}
+	};
+	exports.CommandCompleteMessage = CommandCompleteMessage;
+	var DataRowMessage = class {
+		constructor(length, fields) {
+			this.length = length;
+			this.fields = fields;
+			this.name = "dataRow";
+			this.fieldCount = fields.length;
+		}
+	};
+	exports.DataRowMessage = DataRowMessage;
+	var NoticeMessage = class {
+		constructor(length, message) {
+			this.length = length;
+			this.message = message;
+			this.name = "notice";
+		}
+	};
+	exports.NoticeMessage = NoticeMessage;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/buffer-writer.js
+var require_buffer_writer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/buffer-writer.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.Writer = void 0;
+	var Writer = class {
+		constructor(size = 256) {
+			this.size = size;
+			this.offset = 5;
+			this.headerPosition = 0;
+			this.buffer = Buffer.allocUnsafe(size);
+		}
+		ensure(size) {
+			if (this.buffer.length - this.offset < size) {
+				const oldBuffer = this.buffer;
+				const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
+				this.buffer = Buffer.allocUnsafe(newSize);
+				oldBuffer.copy(this.buffer);
+			}
+		}
+		addInt32(num) {
+			this.ensure(4);
+			this.buffer[this.offset++] = num >>> 24 & 255;
+			this.buffer[this.offset++] = num >>> 16 & 255;
+			this.buffer[this.offset++] = num >>> 8 & 255;
+			this.buffer[this.offset++] = num >>> 0 & 255;
+			return this;
+		}
+		addInt16(num) {
+			this.ensure(2);
+			this.buffer[this.offset++] = num >>> 8 & 255;
+			this.buffer[this.offset++] = num >>> 0 & 255;
+			return this;
+		}
+		addCString(string) {
+			if (!string) this.ensure(1);
+			else {
+				const len = Buffer.byteLength(string);
+				this.ensure(len + 1);
+				this.buffer.write(string, this.offset, "utf-8");
+				this.offset += len;
+			}
+			this.buffer[this.offset++] = 0;
+			return this;
+		}
+		addString(string = "") {
+			const len = Buffer.byteLength(string);
+			this.ensure(len);
+			this.buffer.write(string, this.offset);
+			this.offset += len;
+			return this;
+		}
+		add(otherBuffer) {
+			this.ensure(otherBuffer.length);
+			otherBuffer.copy(this.buffer, this.offset);
+			this.offset += otherBuffer.length;
+			return this;
+		}
+		join(code) {
+			if (code) {
+				this.buffer[this.headerPosition] = code;
+				const length = this.offset - (this.headerPosition + 1);
+				this.buffer.writeInt32BE(length, this.headerPosition + 1);
+			}
+			return this.buffer.slice(code ? 0 : 5, this.offset);
+		}
+		flush(code) {
+			const result = this.join(code);
+			this.offset = 5;
+			this.headerPosition = 0;
+			this.buffer = Buffer.allocUnsafe(this.size);
+			return result;
+		}
+	};
+	exports.Writer = Writer;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/serializer.js
+var require_serializer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/serializer.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.serialize = void 0;
+	const buffer_writer_1 = require_buffer_writer();
+	const writer = new buffer_writer_1.Writer();
+	const startup = (opts) => {
+		writer.addInt16(3).addInt16(0);
+		for (const key of Object.keys(opts)) writer.addCString(key).addCString(opts[key]);
+		writer.addCString("client_encoding").addCString("UTF8");
+		const bodyBuffer = writer.addCString("").flush();
+		const length = bodyBuffer.length + 4;
+		return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
+	};
+	const requestSsl = () => {
+		const response = Buffer.allocUnsafe(8);
+		response.writeInt32BE(8, 0);
+		response.writeInt32BE(80877103, 4);
+		return response;
+	};
+	const password = (password$1) => {
+		return writer.addCString(password$1).flush(112);
+	};
+	const sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
+		writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
+		return writer.flush(112);
+	};
+	const sendSCRAMClientFinalMessage = function(additionalData) {
+		return writer.addString(additionalData).flush(112);
+	};
+	const query = (text) => {
+		return writer.addCString(text).flush(81);
+	};
+	const emptyArray = [];
+	const parse$2 = (query$1) => {
+		const name = query$1.name || "";
+		if (name.length > 63) {
+			console.error("Warning! Postgres only supports 63 characters for query names.");
+			console.error("You supplied %s (%s)", name, name.length);
+			console.error("This can cause conflicts and silent errors executing queries");
+		}
+		const types$3 = query$1.types || emptyArray;
+		const len = types$3.length;
+		const buffer = writer.addCString(name).addCString(query$1.text).addInt16(len);
+		for (let i = 0; i < len; i++) buffer.addInt32(types$3[i]);
+		return writer.flush(80);
+	};
+	const paramWriter = new buffer_writer_1.Writer();
+	const writeValues = function(values, valueMapper) {
+		for (let i = 0; i < values.length; i++) {
+			const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
+			if (mappedVal == null) {
+				writer.addInt16(0);
+				paramWriter.addInt32(-1);
+			} else if (mappedVal instanceof Buffer) {
+				writer.addInt16(1);
+				paramWriter.addInt32(mappedVal.length);
+				paramWriter.add(mappedVal);
+			} else {
+				writer.addInt16(0);
+				paramWriter.addInt32(Buffer.byteLength(mappedVal));
+				paramWriter.addString(mappedVal);
+			}
+		}
+	};
+	const bind = (config = {}) => {
+		const portal = config.portal || "";
+		const statement = config.statement || "";
+		const binary = config.binary || false;
+		const values = config.values || emptyArray;
+		const len = values.length;
+		writer.addCString(portal).addCString(statement);
+		writer.addInt16(len);
+		writeValues(values, config.valueMapper);
+		writer.addInt16(len);
+		writer.add(paramWriter.flush());
+		writer.addInt16(1);
+		writer.addInt16(binary ? 1 : 0);
+		return writer.flush(66);
+	};
+	const emptyExecute = Buffer.from([
+		69,
+		0,
+		0,
+		0,
+		9,
+		0,
+		0,
+		0,
+		0,
+		0
+	]);
+	const execute = (config) => {
+		if (!config || !config.portal && !config.rows) return emptyExecute;
+		const portal = config.portal || "";
+		const rows = config.rows || 0;
+		const portalLength = Buffer.byteLength(portal);
+		const len = 4 + portalLength + 1 + 4;
+		const buff = Buffer.allocUnsafe(1 + len);
+		buff[0] = 69;
+		buff.writeInt32BE(len, 1);
+		buff.write(portal, 5, "utf-8");
+		buff[portalLength + 5] = 0;
+		buff.writeUInt32BE(rows, buff.length - 4);
+		return buff;
+	};
+	const cancel = (processID, secretKey) => {
+		const buffer = Buffer.allocUnsafe(16);
+		buffer.writeInt32BE(16, 0);
+		buffer.writeInt16BE(1234, 4);
+		buffer.writeInt16BE(5678, 6);
+		buffer.writeInt32BE(processID, 8);
+		buffer.writeInt32BE(secretKey, 12);
+		return buffer;
+	};
+	const cstringMessage = (code, string) => {
+		const len = 4 + Buffer.byteLength(string) + 1;
+		const buffer = Buffer.allocUnsafe(1 + len);
+		buffer[0] = code;
+		buffer.writeInt32BE(len, 1);
+		buffer.write(string, 5, "utf-8");
+		buffer[len] = 0;
+		return buffer;
+	};
+	const emptyDescribePortal = writer.addCString("P").flush(68);
+	const emptyDescribeStatement = writer.addCString("S").flush(68);
+	const describe = (msg) => {
+		return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
+	};
+	const close = (msg) => {
+		return cstringMessage(67, `${msg.type}${msg.name || ""}`);
+	};
+	const copyData = (chunk) => {
+		return writer.add(chunk).flush(100);
+	};
+	const copyFail = (message) => {
+		return cstringMessage(102, message);
+	};
+	const codeOnlyBuffer = (code) => Buffer.from([
+		code,
+		0,
+		0,
+		0,
+		4
+	]);
+	const flushBuffer$1 = codeOnlyBuffer(72);
+	const syncBuffer$1 = codeOnlyBuffer(83);
+	const endBuffer$1 = codeOnlyBuffer(88);
+	const copyDoneBuffer = codeOnlyBuffer(99);
+	const serialize$1 = {
+		startup,
+		password,
+		requestSsl,
+		sendSASLInitialResponseMessage,
+		sendSCRAMClientFinalMessage,
+		query,
+		parse: parse$2,
+		bind,
+		execute,
+		describe,
+		close,
+		flush: () => flushBuffer$1,
+		sync: () => syncBuffer$1,
+		end: () => endBuffer$1,
+		copyData,
+		copyDone: () => copyDoneBuffer,
+		copyFail,
+		cancel
+	};
+	exports.serialize = serialize$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/buffer-reader.js
+var require_buffer_reader = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/buffer-reader.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.BufferReader = void 0;
+	const emptyBuffer$1 = Buffer.allocUnsafe(0);
+	var BufferReader = class {
+		constructor(offset = 0) {
+			this.offset = offset;
+			this.buffer = emptyBuffer$1;
+			this.encoding = "utf-8";
+		}
+		setBuffer(offset, buffer) {
+			this.offset = offset;
+			this.buffer = buffer;
+		}
+		int16() {
+			const result = this.buffer.readInt16BE(this.offset);
+			this.offset += 2;
+			return result;
+		}
+		byte() {
+			const result = this.buffer[this.offset];
+			this.offset++;
+			return result;
+		}
+		int32() {
+			const result = this.buffer.readInt32BE(this.offset);
+			this.offset += 4;
+			return result;
+		}
+		uint32() {
+			const result = this.buffer.readUInt32BE(this.offset);
+			this.offset += 4;
+			return result;
+		}
+		string(length) {
+			const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
+			this.offset += length;
+			return result;
+		}
+		cstring() {
+			const start = this.offset;
+			let end = start;
+			while (this.buffer[end++] !== 0);
+			this.offset = end;
+			return this.buffer.toString(this.encoding, start, end - 1);
+		}
+		bytes(length) {
+			const result = this.buffer.slice(this.offset, this.offset + length);
+			this.offset += length;
+			return result;
+		}
+	};
+	exports.BufferReader = BufferReader;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/parser.js
+var require_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/parser.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.Parser = void 0;
+	const messages_1$1 = require_messages();
+	const buffer_reader_1 = require_buffer_reader();
+	const CODE_LENGTH = 1;
+	const HEADER_LENGTH = CODE_LENGTH + 4;
+	const emptyBuffer = Buffer.allocUnsafe(0);
+	var Parser = class {
+		constructor(opts) {
+			this.buffer = emptyBuffer;
+			this.bufferLength = 0;
+			this.bufferOffset = 0;
+			this.reader = new buffer_reader_1.BufferReader();
+			if ((opts === null || opts === void 0 ? void 0 : opts.mode) === "binary") throw new Error("Binary mode not supported yet");
+			this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || "text";
+		}
+		parse(buffer, callback) {
+			this.mergeBuffer(buffer);
+			const bufferFullLength = this.bufferOffset + this.bufferLength;
+			let offset = this.bufferOffset;
+			while (offset + HEADER_LENGTH <= bufferFullLength) {
+				const code = this.buffer[offset];
+				const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
+				const fullMessageLength = CODE_LENGTH + length;
+				if (fullMessageLength + offset <= bufferFullLength) {
+					callback(this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer));
+					offset += fullMessageLength;
+				} else break;
+			}
+			if (offset === bufferFullLength) {
+				this.buffer = emptyBuffer;
+				this.bufferLength = 0;
+				this.bufferOffset = 0;
+			} else {
+				this.bufferLength = bufferFullLength - offset;
+				this.bufferOffset = offset;
+			}
+		}
+		mergeBuffer(buffer) {
+			if (this.bufferLength > 0) {
+				const newLength = this.bufferLength + buffer.byteLength;
+				if (newLength + this.bufferOffset > this.buffer.byteLength) {
+					let newBuffer;
+					if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) newBuffer = this.buffer;
+					else {
+						let newBufferLength = this.buffer.byteLength * 2;
+						while (newLength >= newBufferLength) newBufferLength *= 2;
+						newBuffer = Buffer.allocUnsafe(newBufferLength);
+					}
+					this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
+					this.buffer = newBuffer;
+					this.bufferOffset = 0;
+				}
+				buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
+				this.bufferLength = newLength;
+			} else {
+				this.buffer = buffer;
+				this.bufferOffset = 0;
+				this.bufferLength = buffer.byteLength;
+			}
+		}
+		handlePacket(offset, code, length, bytes) {
+			switch (code) {
+				case 50: return messages_1$1.bindComplete;
+				case 49: return messages_1$1.parseComplete;
+				case 51: return messages_1$1.closeComplete;
+				case 110: return messages_1$1.noData;
+				case 115: return messages_1$1.portalSuspended;
+				case 99: return messages_1$1.copyDone;
+				case 87: return messages_1$1.replicationStart;
+				case 73: return messages_1$1.emptyQuery;
+				case 68: return this.parseDataRowMessage(offset, length, bytes);
+				case 67: return this.parseCommandCompleteMessage(offset, length, bytes);
+				case 90: return this.parseReadyForQueryMessage(offset, length, bytes);
+				case 65: return this.parseNotificationMessage(offset, length, bytes);
+				case 82: return this.parseAuthenticationResponse(offset, length, bytes);
+				case 83: return this.parseParameterStatusMessage(offset, length, bytes);
+				case 75: return this.parseBackendKeyData(offset, length, bytes);
+				case 69: return this.parseErrorMessage(offset, length, bytes, "error");
+				case 78: return this.parseErrorMessage(offset, length, bytes, "notice");
+				case 84: return this.parseRowDescriptionMessage(offset, length, bytes);
+				case 116: return this.parseParameterDescriptionMessage(offset, length, bytes);
+				case 71: return this.parseCopyInMessage(offset, length, bytes);
+				case 72: return this.parseCopyOutMessage(offset, length, bytes);
+				case 100: return this.parseCopyData(offset, length, bytes);
+				default: return new messages_1$1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
+			}
+		}
+		parseReadyForQueryMessage(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const status = this.reader.string(1);
+			return new messages_1$1.ReadyForQueryMessage(length, status);
+		}
+		parseCommandCompleteMessage(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const text = this.reader.cstring();
+			return new messages_1$1.CommandCompleteMessage(length, text);
+		}
+		parseCopyData(offset, length, bytes) {
+			const chunk = bytes.slice(offset, offset + (length - 4));
+			return new messages_1$1.CopyDataMessage(length, chunk);
+		}
+		parseCopyInMessage(offset, length, bytes) {
+			return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
+		}
+		parseCopyOutMessage(offset, length, bytes) {
+			return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
+		}
+		parseCopyMessage(offset, length, bytes, messageName) {
+			this.reader.setBuffer(offset, bytes);
+			const isBinary = this.reader.byte() !== 0;
+			const columnCount = this.reader.int16();
+			const message = new messages_1$1.CopyResponse(length, messageName, isBinary, columnCount);
+			for (let i = 0; i < columnCount; i++) message.columnTypes[i] = this.reader.int16();
+			return message;
+		}
+		parseNotificationMessage(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const processId = this.reader.int32();
+			const channel = this.reader.cstring();
+			const payload = this.reader.cstring();
+			return new messages_1$1.NotificationResponseMessage(length, processId, channel, payload);
+		}
+		parseRowDescriptionMessage(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const fieldCount = this.reader.int16();
+			const message = new messages_1$1.RowDescriptionMessage(length, fieldCount);
+			for (let i = 0; i < fieldCount; i++) message.fields[i] = this.parseField();
+			return message;
+		}
+		parseField() {
+			const name = this.reader.cstring();
+			const tableID = this.reader.uint32();
+			const columnID = this.reader.int16();
+			const dataTypeID = this.reader.uint32();
+			const dataTypeSize = this.reader.int16();
+			const dataTypeModifier = this.reader.int32();
+			const mode = this.reader.int16() === 0 ? "text" : "binary";
+			return new messages_1$1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
+		}
+		parseParameterDescriptionMessage(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const parameterCount = this.reader.int16();
+			const message = new messages_1$1.ParameterDescriptionMessage(length, parameterCount);
+			for (let i = 0; i < parameterCount; i++) message.dataTypeIDs[i] = this.reader.int32();
+			return message;
+		}
+		parseDataRowMessage(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const fieldCount = this.reader.int16();
+			const fields = new Array(fieldCount);
+			for (let i = 0; i < fieldCount; i++) {
+				const len = this.reader.int32();
+				fields[i] = len === -1 ? null : this.reader.string(len);
+			}
+			return new messages_1$1.DataRowMessage(length, fields);
+		}
+		parseParameterStatusMessage(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const name = this.reader.cstring();
+			const value = this.reader.cstring();
+			return new messages_1$1.ParameterStatusMessage(length, name, value);
+		}
+		parseBackendKeyData(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const processID = this.reader.int32();
+			const secretKey = this.reader.int32();
+			return new messages_1$1.BackendKeyDataMessage(length, processID, secretKey);
+		}
+		parseAuthenticationResponse(offset, length, bytes) {
+			this.reader.setBuffer(offset, bytes);
+			const code = this.reader.int32();
+			const message = {
+				name: "authenticationOk",
+				length
+			};
+			switch (code) {
+				case 0: break;
+				case 3:
+					if (message.length === 8) message.name = "authenticationCleartextPassword";
+					break;
+				case 5:
+					if (message.length === 12) {
+						message.name = "authenticationMD5Password";
+						const salt = this.reader.bytes(4);
+						return new messages_1$1.AuthenticationMD5Password(length, salt);
+					}
+					break;
+				case 10:
+					{
+						message.name = "authenticationSASL";
+						message.mechanisms = [];
+						let mechanism;
+						do {
+							mechanism = this.reader.cstring();
+							if (mechanism) message.mechanisms.push(mechanism);
+						} while (mechanism);
+					}
+					break;
+				case 11:
+					message.name = "authenticationSASLContinue";
+					message.data = this.reader.string(length - 8);
+					break;
+				case 12:
+					message.name = "authenticationSASLFinal";
+					message.data = this.reader.string(length - 8);
+					break;
+				default: throw new Error("Unknown authenticationOk message type " + code);
+			}
+			return message;
+		}
+		parseErrorMessage(offset, length, bytes, name) {
+			this.reader.setBuffer(offset, bytes);
+			const fields = {};
+			let fieldType = this.reader.string(1);
+			while (fieldType !== "\0") {
+				fields[fieldType] = this.reader.cstring();
+				fieldType = this.reader.string(1);
+			}
+			const messageValue = fields.M;
+			const message = name === "notice" ? new messages_1$1.NoticeMessage(length, messageValue) : new messages_1$1.DatabaseError(messageValue, length, name);
+			message.severity = fields.S;
+			message.code = fields.C;
+			message.detail = fields.D;
+			message.hint = fields.H;
+			message.position = fields.P;
+			message.internalPosition = fields.p;
+			message.internalQuery = fields.q;
+			message.where = fields.W;
+			message.schema = fields.s;
+			message.table = fields.t;
+			message.column = fields.c;
+			message.dataType = fields.d;
+			message.constraint = fields.n;
+			message.file = fields.F;
+			message.line = fields.L;
+			message.routine = fields.R;
+			return message;
+		}
+	};
+	exports.Parser = Parser;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/index.js
+var require_dist = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/index.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.DatabaseError = exports.serialize = exports.parse = void 0;
+	const messages_1 = require_messages();
+	Object.defineProperty(exports, "DatabaseError", {
+		enumerable: true,
+		get: function() {
+			return messages_1.DatabaseError;
+		}
+	});
+	const serializer_1 = require_serializer();
+	Object.defineProperty(exports, "serialize", {
+		enumerable: true,
+		get: function() {
+			return serializer_1.serialize;
+		}
+	});
+	const parser_1 = require_parser();
+	function parse$1(stream, callback) {
+		const parser = new parser_1.Parser();
+		stream.on("data", (buffer) => parser.parse(buffer, callback));
+		return new Promise((resolve) => stream.on("end", () => resolve()));
+	}
+	exports.parse = parse$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-cloudflare@1.2.7/node_modules/pg-cloudflare/dist/empty.js
+var require_empty = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-cloudflare@1.2.7/node_modules/pg-cloudflare/dist/empty.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.default = {};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/stream.js
+var require_stream = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/stream.js": ((exports, module) => {
+	const { getStream: getStream$1, getSecureStream: getSecureStream$1 } = getStreamFuncs();
+	module.exports = {
+		getStream: getStream$1,
+		getSecureStream: getSecureStream$1
+	};
+	/**
+	* The stream functions that work in Node.js
+	*/
+	function getNodejsStreamFuncs() {
+		function getStream$2(ssl) {
+			return new (__require("net")).Socket();
+		}
+		function getSecureStream$2(options) {
+			return __require("tls").connect(options);
+		}
+		return {
+			getStream: getStream$2,
+			getSecureStream: getSecureStream$2
+		};
+	}
+	/**
+	* The stream functions that work in Cloudflare Workers
+	*/
+	function getCloudflareStreamFuncs() {
+		function getStream$2(ssl) {
+			const { CloudflareSocket } = require_empty();
+			return new CloudflareSocket(ssl);
+		}
+		function getSecureStream$2(options) {
+			options.socket.startTls(options);
+			return options.socket;
+		}
+		return {
+			getStream: getStream$2,
+			getSecureStream: getSecureStream$2
+		};
+	}
+	/**
+	* Are we running in a Cloudflare Worker?
+	*
+	* @returns true if the code is currently running inside a Cloudflare Worker.
+	*/
+	function isCloudflareRuntime() {
+		if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") return navigator.userAgent === "Cloudflare-Workers";
+		if (typeof Response === "function") {
+			const resp = new Response(null, { cf: { thing: true } });
+			if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) return true;
+		}
+		return false;
+	}
+	function getStreamFuncs() {
+		if (isCloudflareRuntime()) return getCloudflareStreamFuncs();
+		return getNodejsStreamFuncs();
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection.js
+var require_connection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection.js": ((exports, module) => {
+	const EventEmitter$4 = __require("events").EventEmitter;
+	const { parse, serialize } = require_dist();
+	const { getStream, getSecureStream } = require_stream();
+	const flushBuffer = serialize.flush();
+	const syncBuffer = serialize.sync();
+	const endBuffer = serialize.end();
+	var Connection$3 = class extends EventEmitter$4 {
+		constructor(config) {
+			super();
+			config = config || {};
+			this.stream = config.stream || getStream(config.ssl);
+			if (typeof this.stream === "function") this.stream = this.stream(config);
+			this._keepAlive = config.keepAlive;
+			this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
+			this.lastBuffer = false;
+			this.parsedStatements = {};
+			this.ssl = config.ssl || false;
+			this._ending = false;
+			this._emitMessage = false;
+			const self = this;
+			this.on("newListener", function(eventName) {
+				if (eventName === "message") self._emitMessage = true;
+			});
+		}
+		connect(port, host) {
+			const self = this;
+			this._connecting = true;
+			this.stream.setNoDelay(true);
+			this.stream.connect(port, host);
+			this.stream.once("connect", function() {
+				if (self._keepAlive) self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);
+				self.emit("connect");
+			});
+			const reportStreamError = function(error) {
+				if (self._ending && (error.code === "ECONNRESET" || error.code === "EPIPE")) return;
+				self.emit("error", error);
+			};
+			this.stream.on("error", reportStreamError);
+			this.stream.on("close", function() {
+				self.emit("end");
+			});
+			if (!this.ssl) return this.attachListeners(this.stream);
+			this.stream.once("data", function(buffer) {
+				switch (buffer.toString("utf8")) {
+					case "S": break;
+					case "N":
+						self.stream.end();
+						return self.emit("error", /* @__PURE__ */ new Error("The server does not support SSL connections"));
+					default:
+						self.stream.end();
+						return self.emit("error", /* @__PURE__ */ new Error("There was an error establishing an SSL connection"));
+				}
+				const options = { socket: self.stream };
+				if (self.ssl !== true) {
+					Object.assign(options, self.ssl);
+					if ("key" in self.ssl) options.key = self.ssl.key;
+				}
+				const net = __require("net");
+				if (net.isIP && net.isIP(host) === 0) options.servername = host;
+				try {
+					self.stream = getSecureStream(options);
+				} catch (err) {
+					return self.emit("error", err);
+				}
+				self.attachListeners(self.stream);
+				self.stream.on("error", reportStreamError);
+				self.emit("sslconnect");
+			});
+		}
+		attachListeners(stream) {
+			parse(stream, (msg) => {
+				const eventName = msg.name === "error" ? "errorMessage" : msg.name;
+				if (this._emitMessage) this.emit("message", msg);
+				this.emit(eventName, msg);
+			});
+		}
+		requestSsl() {
+			this.stream.write(serialize.requestSsl());
+		}
+		startup(config) {
+			this.stream.write(serialize.startup(config));
+		}
+		cancel(processID, secretKey) {
+			this._send(serialize.cancel(processID, secretKey));
+		}
+		password(password$1) {
+			this._send(serialize.password(password$1));
+		}
+		sendSASLInitialResponseMessage(mechanism, initialResponse) {
+			this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
+		}
+		sendSCRAMClientFinalMessage(additionalData) {
+			this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
+		}
+		_send(buffer) {
+			if (!this.stream.writable) return false;
+			return this.stream.write(buffer);
+		}
+		query(text) {
+			this._send(serialize.query(text));
+		}
+		parse(query$1) {
+			this._send(serialize.parse(query$1));
+		}
+		bind(config) {
+			this._send(serialize.bind(config));
+		}
+		execute(config) {
+			this._send(serialize.execute(config));
+		}
+		flush() {
+			if (this.stream.writable) this.stream.write(flushBuffer);
+		}
+		sync() {
+			this._ending = true;
+			this._send(syncBuffer);
+		}
+		ref() {
+			this.stream.ref();
+		}
+		unref() {
+			this.stream.unref();
+		}
+		end() {
+			this._ending = true;
+			if (!this._connecting || !this.stream.writable) {
+				this.stream.end();
+				return;
+			}
+			return this.stream.write(endBuffer, () => {
+				this.stream.end();
+			});
+		}
+		close(msg) {
+			this._send(serialize.close(msg));
+		}
+		describe(msg) {
+			this._send(serialize.describe(msg));
+		}
+		sendCopyFromChunk(chunk) {
+			this._send(serialize.copyData(chunk));
+		}
+		endCopyFrom() {
+			this._send(serialize.copyDone());
+		}
+		sendCopyFail(msg) {
+			this._send(serialize.copyFail(msg));
+		}
+	};
+	module.exports = Connection$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/split2@4.2.0/node_modules/split2/index.js
+var require_split2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/split2@4.2.0/node_modules/split2/index.js": ((exports, module) => {
+	const { Transform } = __require("stream");
+	const { StringDecoder } = __require("string_decoder");
+	const kLast = Symbol("last");
+	const kDecoder = Symbol("decoder");
+	function transform(chunk, enc, cb) {
+		let list;
+		if (this.overflow) {
+			list = this[kDecoder].write(chunk).split(this.matcher);
+			if (list.length === 1) return cb();
+			list.shift();
+			this.overflow = false;
+		} else {
+			this[kLast] += this[kDecoder].write(chunk);
+			list = this[kLast].split(this.matcher);
+		}
+		this[kLast] = list.pop();
+		for (let i = 0; i < list.length; i++) try {
+			push(this, this.mapper(list[i]));
+		} catch (error) {
+			return cb(error);
+		}
+		this.overflow = this[kLast].length > this.maxLength;
+		if (this.overflow && !this.skipOverflow) {
+			cb(/* @__PURE__ */ new Error("maximum buffer reached"));
+			return;
+		}
+		cb();
+	}
+	function flush(cb) {
+		this[kLast] += this[kDecoder].end();
+		if (this[kLast]) try {
+			push(this, this.mapper(this[kLast]));
+		} catch (error) {
+			return cb(error);
+		}
+		cb();
+	}
+	function push(self, val$1) {
+		if (val$1 !== void 0) self.push(val$1);
+	}
+	function noop(incoming) {
+		return incoming;
+	}
+	function split$1(matcher$1, mapper, options) {
+		matcher$1 = matcher$1 || /\r?\n/;
+		mapper = mapper || noop;
+		options = options || {};
+		switch (arguments.length) {
+			case 1:
+				if (typeof matcher$1 === "function") {
+					mapper = matcher$1;
+					matcher$1 = /\r?\n/;
+				} else if (typeof matcher$1 === "object" && !(matcher$1 instanceof RegExp) && !matcher$1[Symbol.split]) {
+					options = matcher$1;
+					matcher$1 = /\r?\n/;
+				}
+				break;
+			case 2: if (typeof matcher$1 === "function") {
+				options = mapper;
+				mapper = matcher$1;
+				matcher$1 = /\r?\n/;
+			} else if (typeof mapper === "object") {
+				options = mapper;
+				mapper = noop;
+			}
+		}
+		options = Object.assign({}, options);
+		options.autoDestroy = true;
+		options.transform = transform;
+		options.flush = flush;
+		options.readableObjectMode = true;
+		const stream = new Transform(options);
+		stream[kLast] = "";
+		stream[kDecoder] = new StringDecoder("utf8");
+		stream.matcher = matcher$1;
+		stream.mapper = mapper;
+		stream.maxLength = options.maxLength;
+		stream.skipOverflow = options.skipOverflow || false;
+		stream.overflow = false;
+		stream._destroy = function(err, cb) {
+			this._writableState.errorEmitted = false;
+			cb(err);
+		};
+		return stream;
+	}
+	module.exports = split$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/helper.js
+var require_helper = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/helper.js": ((exports, module) => {
+	var path = __require("path"), Stream = __require("stream").Stream, split = require_split2(), util$2 = __require("util"), defaultPort = 5432, isWin = process.platform === "win32", warnStream = process.stderr;
+	var S_IRWXG = 56, S_IRWXO = 7, S_IFMT = 61440, S_IFREG = 32768;
+	function isRegFile(mode) {
+		return (mode & S_IFMT) == S_IFREG;
+	}
+	var fieldNames = [
+		"host",
+		"port",
+		"database",
+		"user",
+		"password"
+	];
+	var nrOfFields = fieldNames.length;
+	var passKey = fieldNames[nrOfFields - 1];
+	function warn() {
+		if (warnStream instanceof Stream && true === warnStream.writable) {
+			var args = Array.prototype.slice.call(arguments).concat("\n");
+			warnStream.write(util$2.format.apply(util$2, args));
+		}
+	}
+	Object.defineProperty(module.exports, "isWin", {
+		get: function() {
+			return isWin;
+		},
+		set: function(val$1) {
+			isWin = val$1;
+		}
+	});
+	module.exports.warnTo = function(stream) {
+		var old = warnStream;
+		warnStream = stream;
+		return old;
+	};
+	module.exports.getFileName = function(rawEnv) {
+		var env = rawEnv || process.env;
+		return env.PGPASSFILE || (isWin ? path.join(env.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env.HOME || "./", ".pgpass"));
+	};
+	module.exports.usePgPass = function(stats, fname) {
+		if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) return false;
+		if (isWin) return true;
+		fname = fname || "<unkn>";
+		if (!isRegFile(stats.mode)) {
+			warn("WARNING: password file \"%s\" is not a plain file", fname);
+			return false;
+		}
+		if (stats.mode & (S_IRWXG | S_IRWXO)) {
+			warn("WARNING: password file \"%s\" has group or world access; permissions should be u=rw (0600) or less", fname);
+			return false;
+		}
+		return true;
+	};
+	var matcher = module.exports.match = function(connInfo, entry) {
+		return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
+			if (idx == 1) {
+				if (Number(connInfo[field] || defaultPort) === Number(entry[field])) return prev && true;
+			}
+			return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
+		}, true);
+	};
+	module.exports.getPassword = function(connInfo, stream, cb) {
+		var pass;
+		var lineStream = stream.pipe(split());
+		function onLine(line) {
+			var entry = parseLine(line);
+			if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
+				pass = entry[passKey];
+				lineStream.end();
+			}
+		}
+		var onEnd = function() {
+			stream.destroy();
+			cb(pass);
+		};
+		var onErr = function(err) {
+			stream.destroy();
+			warn("WARNING: error on reading file: %s", err);
+			cb(void 0);
+		};
+		stream.on("error", onErr);
+		lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
+	};
+	var parseLine = module.exports.parseLine = function(line) {
+		if (line.length < 11 || line.match(/^\s+#/)) return null;
+		var curChar = "";
+		var prevChar = "";
+		var fieldIdx = 0;
+		var startIdx = 0;
+		var obj = {};
+		var isLastField = false;
+		var addToObj = function(idx, i0, i1) {
+			var field = line.substring(i0, i1);
+			if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) field = field.replace(/\\([:\\])/g, "$1");
+			obj[fieldNames[idx]] = field;
+		};
+		for (var i = 0; i < line.length - 1; i += 1) {
+			curChar = line.charAt(i + 1);
+			prevChar = line.charAt(i);
+			isLastField = fieldIdx == nrOfFields - 1;
+			if (isLastField) {
+				addToObj(fieldIdx, startIdx);
+				break;
+			}
+			if (i >= 0 && curChar == ":" && prevChar !== "\\") {
+				addToObj(fieldIdx, startIdx, i + 1);
+				startIdx = i + 2;
+				fieldIdx += 1;
+			}
+		}
+		obj = Object.keys(obj).length === nrOfFields ? obj : null;
+		return obj;
+	};
+	var isValidEntry = module.exports.isValidEntry = function(entry) {
+		var rules = {
+			0: function(x) {
+				return x.length > 0;
+			},
+			1: function(x) {
+				if (x === "*") return true;
+				x = Number(x);
+				return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
+			},
+			2: function(x) {
+				return x.length > 0;
+			},
+			3: function(x) {
+				return x.length > 0;
+			},
+			4: function(x) {
+				return x.length > 0;
+			}
+		};
+		for (var idx = 0; idx < fieldNames.length; idx += 1) {
+			var rule = rules[idx];
+			if (!rule(entry[fieldNames[idx]] || "")) return false;
+		}
+		return true;
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/index.js
+var require_lib$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/index.js": ((exports, module) => {
+	__require("path");
+	var fs = __require("fs"), helper = require_helper();
+	module.exports = function(connInfo, cb) {
+		var file = helper.getFileName();
+		fs.stat(file, function(err, stat) {
+			if (err || !helper.usePgPass(stat, file)) return cb(void 0);
+			var st = fs.createReadStream(file);
+			helper.getPassword(connInfo, st, cb);
+		});
+	};
+	module.exports.warnTo = helper.warnTo;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/client.js
+var require_client$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/client.js": ((exports, module) => {
+	const EventEmitter$3 = __require("events").EventEmitter;
+	const utils$2 = require_utils$1();
+	const sasl = require_sasl();
+	const TypeOverrides$3 = require_type_overrides();
+	const ConnectionParameters$1 = require_connection_parameters();
+	const Query$1 = require_query$1();
+	const defaults$2 = require_defaults();
+	const Connection$2 = require_connection();
+	const crypto = require_utils();
+	var Client$3 = class extends EventEmitter$3 {
+		constructor(config) {
+			super();
+			this.connectionParameters = new ConnectionParameters$1(config);
+			this.user = this.connectionParameters.user;
+			this.database = this.connectionParameters.database;
+			this.port = this.connectionParameters.port;
+			this.host = this.connectionParameters.host;
+			Object.defineProperty(this, "password", {
+				configurable: true,
+				enumerable: false,
+				writable: true,
+				value: this.connectionParameters.password
+			});
+			this.replication = this.connectionParameters.replication;
+			const c = config || {};
+			this._Promise = c.Promise || global.Promise;
+			this._types = new TypeOverrides$3(c.types);
+			this._ending = false;
+			this._ended = false;
+			this._connecting = false;
+			this._connected = false;
+			this._connectionError = false;
+			this._queryable = true;
+			this.enableChannelBinding = Boolean(c.enableChannelBinding);
+			this.connection = c.connection || new Connection$2({
+				stream: c.stream,
+				ssl: this.connectionParameters.ssl,
+				keepAlive: c.keepAlive || false,
+				keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
+				encoding: this.connectionParameters.client_encoding || "utf8"
+			});
+			this.queryQueue = [];
+			this.binary = c.binary || defaults$2.binary;
+			this.processID = null;
+			this.secretKey = null;
+			this.ssl = this.connectionParameters.ssl || false;
+			if (this.ssl && this.ssl.key) Object.defineProperty(this.ssl, "key", { enumerable: false });
+			this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
+		}
+		_errorAllQueries(err) {
+			const enqueueError = (query$1) => {
+				process.nextTick(() => {
+					query$1.handleError(err, this.connection);
+				});
+			};
+			if (this.activeQuery) {
+				enqueueError(this.activeQuery);
+				this.activeQuery = null;
+			}
+			this.queryQueue.forEach(enqueueError);
+			this.queryQueue.length = 0;
+		}
+		_connect(callback) {
+			const self = this;
+			const con = this.connection;
+			this._connectionCallback = callback;
+			if (this._connecting || this._connected) {
+				const err = /* @__PURE__ */ new Error("Client has already been connected. You cannot reuse a client.");
+				process.nextTick(() => {
+					callback(err);
+				});
+				return;
+			}
+			this._connecting = true;
+			if (this._connectionTimeoutMillis > 0) {
+				this.connectionTimeoutHandle = setTimeout(() => {
+					con._ending = true;
+					con.stream.destroy(/* @__PURE__ */ new Error("timeout expired"));
+				}, this._connectionTimeoutMillis);
+				if (this.connectionTimeoutHandle.unref) this.connectionTimeoutHandle.unref();
+			}
+			if (this.host && this.host.indexOf("/") === 0) con.connect(this.host + "/.s.PGSQL." + this.port);
+			else con.connect(this.port, this.host);
+			con.on("connect", function() {
+				if (self.ssl) con.requestSsl();
+				else con.startup(self.getStartupConf());
+			});
+			con.on("sslconnect", function() {
+				con.startup(self.getStartupConf());
+			});
+			this._attachListeners(con);
+			con.once("end", () => {
+				const error = this._ending ? /* @__PURE__ */ new Error("Connection terminated") : /* @__PURE__ */ new Error("Connection terminated unexpectedly");
+				clearTimeout(this.connectionTimeoutHandle);
+				this._errorAllQueries(error);
+				this._ended = true;
+				if (!this._ending) {
+					if (this._connecting && !this._connectionError) if (this._connectionCallback) this._connectionCallback(error);
+					else this._handleErrorEvent(error);
+					else if (!this._connectionError) this._handleErrorEvent(error);
+				}
+				process.nextTick(() => {
+					this.emit("end");
+				});
+			});
+		}
+		connect(callback) {
+			if (callback) {
+				this._connect(callback);
+				return;
+			}
+			return new this._Promise((resolve, reject) => {
+				this._connect((error) => {
+					if (error) reject(error);
+					else resolve();
+				});
+			});
+		}
+		_attachListeners(con) {
+			con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
+			con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
+			con.on("authenticationSASL", this._handleAuthSASL.bind(this));
+			con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
+			con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
+			con.on("backendKeyData", this._handleBackendKeyData.bind(this));
+			con.on("error", this._handleErrorEvent.bind(this));
+			con.on("errorMessage", this._handleErrorMessage.bind(this));
+			con.on("readyForQuery", this._handleReadyForQuery.bind(this));
+			con.on("notice", this._handleNotice.bind(this));
+			con.on("rowDescription", this._handleRowDescription.bind(this));
+			con.on("dataRow", this._handleDataRow.bind(this));
+			con.on("portalSuspended", this._handlePortalSuspended.bind(this));
+			con.on("emptyQuery", this._handleEmptyQuery.bind(this));
+			con.on("commandComplete", this._handleCommandComplete.bind(this));
+			con.on("parseComplete", this._handleParseComplete.bind(this));
+			con.on("copyInResponse", this._handleCopyInResponse.bind(this));
+			con.on("copyData", this._handleCopyData.bind(this));
+			con.on("notification", this._handleNotification.bind(this));
+		}
+		_checkPgPass(cb) {
+			const con = this.connection;
+			if (typeof this.password === "function") this._Promise.resolve().then(() => this.password()).then((pass) => {
+				if (pass !== void 0) {
+					if (typeof pass !== "string") {
+						con.emit("error", /* @__PURE__ */ new TypeError("Password must be a string"));
+						return;
+					}
+					this.connectionParameters.password = this.password = pass;
+				} else this.connectionParameters.password = this.password = null;
+				cb();
+			}).catch((err) => {
+				con.emit("error", err);
+			});
+			else if (this.password !== null) cb();
+			else try {
+				require_lib$1()(this.connectionParameters, (pass) => {
+					if (void 0 !== pass) this.connectionParameters.password = this.password = pass;
+					cb();
+				});
+			} catch (e) {
+				this.emit("error", e);
+			}
+		}
+		_handleAuthCleartextPassword(msg) {
+			this._checkPgPass(() => {
+				this.connection.password(this.password);
+			});
+		}
+		_handleAuthMD5Password(msg) {
+			this._checkPgPass(async () => {
+				try {
+					const hashedPassword = await crypto.postgresMd5PasswordHash(this.user, this.password, msg.salt);
+					this.connection.password(hashedPassword);
+				} catch (e) {
+					this.emit("error", e);
+				}
+			});
+		}
+		_handleAuthSASL(msg) {
+			this._checkPgPass(() => {
+				try {
+					this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
+					this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
+				} catch (err) {
+					this.connection.emit("error", err);
+				}
+			});
+		}
+		async _handleAuthSASLContinue(msg) {
+			try {
+				await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
+				this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
+			} catch (err) {
+				this.connection.emit("error", err);
+			}
+		}
+		_handleAuthSASLFinal(msg) {
+			try {
+				sasl.finalizeSession(this.saslSession, msg.data);
+				this.saslSession = null;
+			} catch (err) {
+				this.connection.emit("error", err);
+			}
+		}
+		_handleBackendKeyData(msg) {
+			this.processID = msg.processID;
+			this.secretKey = msg.secretKey;
+		}
+		_handleReadyForQuery(msg) {
+			if (this._connecting) {
+				this._connecting = false;
+				this._connected = true;
+				clearTimeout(this.connectionTimeoutHandle);
+				if (this._connectionCallback) {
+					this._connectionCallback(null, this);
+					this._connectionCallback = null;
+				}
+				this.emit("connect");
+			}
+			const { activeQuery } = this;
+			this.activeQuery = null;
+			this.readyForQuery = true;
+			if (activeQuery) activeQuery.handleReadyForQuery(this.connection);
+			this._pulseQueryQueue();
+		}
+		_handleErrorWhileConnecting(err) {
+			if (this._connectionError) return;
+			this._connectionError = true;
+			clearTimeout(this.connectionTimeoutHandle);
+			if (this._connectionCallback) return this._connectionCallback(err);
+			this.emit("error", err);
+		}
+		_handleErrorEvent(err) {
+			if (this._connecting) return this._handleErrorWhileConnecting(err);
+			this._queryable = false;
+			this._errorAllQueries(err);
+			this.emit("error", err);
+		}
+		_handleErrorMessage(msg) {
+			if (this._connecting) return this._handleErrorWhileConnecting(msg);
+			const activeQuery = this.activeQuery;
+			if (!activeQuery) {
+				this._handleErrorEvent(msg);
+				return;
+			}
+			this.activeQuery = null;
+			activeQuery.handleError(msg, this.connection);
+		}
+		_handleRowDescription(msg) {
+			this.activeQuery.handleRowDescription(msg);
+		}
+		_handleDataRow(msg) {
+			this.activeQuery.handleDataRow(msg);
+		}
+		_handlePortalSuspended(msg) {
+			this.activeQuery.handlePortalSuspended(this.connection);
+		}
+		_handleEmptyQuery(msg) {
+			this.activeQuery.handleEmptyQuery(this.connection);
+		}
+		_handleCommandComplete(msg) {
+			if (this.activeQuery == null) {
+				const error = /* @__PURE__ */ new Error("Received unexpected commandComplete message from backend.");
+				this._handleErrorEvent(error);
+				return;
+			}
+			this.activeQuery.handleCommandComplete(msg, this.connection);
+		}
+		_handleParseComplete() {
+			if (this.activeQuery == null) {
+				const error = /* @__PURE__ */ new Error("Received unexpected parseComplete message from backend.");
+				this._handleErrorEvent(error);
+				return;
+			}
+			if (this.activeQuery.name) this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
+		}
+		_handleCopyInResponse(msg) {
+			this.activeQuery.handleCopyInResponse(this.connection);
+		}
+		_handleCopyData(msg) {
+			this.activeQuery.handleCopyData(msg, this.connection);
+		}
+		_handleNotification(msg) {
+			this.emit("notification", msg);
+		}
+		_handleNotice(msg) {
+			this.emit("notice", msg);
+		}
+		getStartupConf() {
+			const params = this.connectionParameters;
+			const data = {
+				user: params.user,
+				database: params.database
+			};
+			const appName = params.application_name || params.fallback_application_name;
+			if (appName) data.application_name = appName;
+			if (params.replication) data.replication = "" + params.replication;
+			if (params.statement_timeout) data.statement_timeout = String(parseInt(params.statement_timeout, 10));
+			if (params.lock_timeout) data.lock_timeout = String(parseInt(params.lock_timeout, 10));
+			if (params.idle_in_transaction_session_timeout) data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
+			if (params.options) data.options = params.options;
+			return data;
+		}
+		cancel(client, query$1) {
+			if (client.activeQuery === query$1) {
+				const con = this.connection;
+				if (this.host && this.host.indexOf("/") === 0) con.connect(this.host + "/.s.PGSQL." + this.port);
+				else con.connect(this.port, this.host);
+				con.on("connect", function() {
+					con.cancel(client.processID, client.secretKey);
+				});
+			} else if (client.queryQueue.indexOf(query$1) !== -1) client.queryQueue.splice(client.queryQueue.indexOf(query$1), 1);
+		}
+		setTypeParser(oid, format, parseFn) {
+			return this._types.setTypeParser(oid, format, parseFn);
+		}
+		getTypeParser(oid, format) {
+			return this._types.getTypeParser(oid, format);
+		}
+		escapeIdentifier(str) {
+			return utils$2.escapeIdentifier(str);
+		}
+		escapeLiteral(str) {
+			return utils$2.escapeLiteral(str);
+		}
+		_pulseQueryQueue() {
+			if (this.readyForQuery === true) {
+				this.activeQuery = this.queryQueue.shift();
+				if (this.activeQuery) {
+					this.readyForQuery = false;
+					this.hasExecuted = true;
+					const queryError = this.activeQuery.submit(this.connection);
+					if (queryError) process.nextTick(() => {
+						this.activeQuery.handleError(queryError, this.connection);
+						this.readyForQuery = true;
+						this._pulseQueryQueue();
+					});
+				} else if (this.hasExecuted) {
+					this.activeQuery = null;
+					this.emit("drain");
+				}
+			}
+		}
+		query(config, values, callback) {
+			let query$1;
+			let result;
+			let readTimeout;
+			let readTimeoutTimer;
+			let queryCallback;
+			if (config === null || config === void 0) throw new TypeError("Client was passed a null or undefined query");
+			else if (typeof config.submit === "function") {
+				readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
+				result = query$1 = config;
+				if (typeof values === "function") query$1.callback = query$1.callback || values;
+			} else {
+				readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
+				query$1 = new Query$1(config, values, callback);
+				if (!query$1.callback) result = new this._Promise((resolve, reject) => {
+					query$1.callback = (err, res) => err ? reject(err) : resolve(res);
+				}).catch((err) => {
+					Error.captureStackTrace(err);
+					throw err;
+				});
+			}
+			if (readTimeout) {
+				queryCallback = query$1.callback;
+				readTimeoutTimer = setTimeout(() => {
+					const error = /* @__PURE__ */ new Error("Query read timeout");
+					process.nextTick(() => {
+						query$1.handleError(error, this.connection);
+					});
+					queryCallback(error);
+					query$1.callback = () => {};
+					const index = this.queryQueue.indexOf(query$1);
+					if (index > -1) this.queryQueue.splice(index, 1);
+					this._pulseQueryQueue();
+				}, readTimeout);
+				query$1.callback = (err, res) => {
+					clearTimeout(readTimeoutTimer);
+					queryCallback(err, res);
+				};
+			}
+			if (this.binary && !query$1.binary) query$1.binary = true;
+			if (query$1._result && !query$1._result._types) query$1._result._types = this._types;
+			if (!this._queryable) {
+				process.nextTick(() => {
+					query$1.handleError(/* @__PURE__ */ new Error("Client has encountered a connection error and is not queryable"), this.connection);
+				});
+				return result;
+			}
+			if (this._ending) {
+				process.nextTick(() => {
+					query$1.handleError(/* @__PURE__ */ new Error("Client was closed and is not queryable"), this.connection);
+				});
+				return result;
+			}
+			this.queryQueue.push(query$1);
+			this._pulseQueryQueue();
+			return result;
+		}
+		ref() {
+			this.connection.ref();
+		}
+		unref() {
+			this.connection.unref();
+		}
+		end(cb) {
+			this._ending = true;
+			if (!this.connection._connecting || this._ended) if (cb) cb();
+			else return this._Promise.resolve();
+			if (this.activeQuery || !this._queryable) this.connection.stream.destroy();
+			else this.connection.end();
+			if (cb) this.connection.once("end", cb);
+			else return new this._Promise((resolve) => {
+				this.connection.once("end", resolve);
+			});
+		}
+	};
+	Client$3.Query = Query$1;
+	module.exports = Client$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg-pool@3.10.1_pg@8.16.3/node_modules/pg-pool/index.js
+var require_pg_pool = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg-pool@3.10.1_pg@8.16.3/node_modules/pg-pool/index.js": ((exports, module) => {
+	const EventEmitter$2 = __require("events").EventEmitter;
+	const NOOP = function() {};
+	const removeWhere = (list, predicate) => {
+		const i = list.findIndex(predicate);
+		return i === -1 ? void 0 : list.splice(i, 1)[0];
+	};
+	var IdleItem = class {
+		constructor(client, idleListener, timeoutId) {
+			this.client = client;
+			this.idleListener = idleListener;
+			this.timeoutId = timeoutId;
+		}
+	};
+	var PendingItem = class {
+		constructor(callback) {
+			this.callback = callback;
+		}
+	};
+	function throwOnDoubleRelease() {
+		throw new Error("Release called on client which has already been released to the pool.");
+	}
+	function promisify(Promise$1, callback) {
+		if (callback) return {
+			callback,
+			result: void 0
+		};
+		let rej;
+		let res;
+		const cb = function(err, client) {
+			err ? rej(err) : res(client);
+		};
+		return {
+			callback: cb,
+			result: new Promise$1(function(resolve, reject) {
+				res = resolve;
+				rej = reject;
+			}).catch((err) => {
+				Error.captureStackTrace(err);
+				throw err;
+			})
+		};
+	}
+	function makeIdleListener(pool, client) {
+		return function idleListener(err) {
+			err.client = client;
+			client.removeListener("error", idleListener);
+			client.on("error", () => {
+				pool.log("additional client error after disconnection due to error", err);
+			});
+			pool._remove(client);
+			pool.emit("error", err, client);
+		};
+	}
+	var Pool$2 = class extends EventEmitter$2 {
+		constructor(options, Client$4) {
+			super();
+			this.options = Object.assign({}, options);
+			if (options != null && "password" in options) Object.defineProperty(this.options, "password", {
+				configurable: true,
+				enumerable: false,
+				writable: true,
+				value: options.password
+			});
+			if (options != null && options.ssl && options.ssl.key) Object.defineProperty(this.options.ssl, "key", { enumerable: false });
+			this.options.max = this.options.max || this.options.poolSize || 10;
+			this.options.min = this.options.min || 0;
+			this.options.maxUses = this.options.maxUses || Infinity;
+			this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
+			this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
+			this.log = this.options.log || function() {};
+			this.Client = this.options.Client || Client$4 || require_lib().Client;
+			this.Promise = this.options.Promise || global.Promise;
+			if (typeof this.options.idleTimeoutMillis === "undefined") this.options.idleTimeoutMillis = 1e4;
+			this._clients = [];
+			this._idle = [];
+			this._expired = /* @__PURE__ */ new WeakSet();
+			this._pendingQueue = [];
+			this._endCallback = void 0;
+			this.ending = false;
+			this.ended = false;
+		}
+		_isFull() {
+			return this._clients.length >= this.options.max;
+		}
+		_isAboveMin() {
+			return this._clients.length > this.options.min;
+		}
+		_pulseQueue() {
+			this.log("pulse queue");
+			if (this.ended) {
+				this.log("pulse queue ended");
+				return;
+			}
+			if (this.ending) {
+				this.log("pulse queue on ending");
+				if (this._idle.length) this._idle.slice().map((item) => {
+					this._remove(item.client);
+				});
+				if (!this._clients.length) {
+					this.ended = true;
+					this._endCallback();
+				}
+				return;
+			}
+			if (!this._pendingQueue.length) {
+				this.log("no queued requests");
+				return;
+			}
+			if (!this._idle.length && this._isFull()) return;
+			const pendingItem = this._pendingQueue.shift();
+			if (this._idle.length) {
+				const idleItem = this._idle.pop();
+				clearTimeout(idleItem.timeoutId);
+				const client = idleItem.client;
+				client.ref && client.ref();
+				const idleListener = idleItem.idleListener;
+				return this._acquireClient(client, pendingItem, idleListener, false);
+			}
+			if (!this._isFull()) return this.newClient(pendingItem);
+			throw new Error("unexpected condition");
+		}
+		_remove(client, callback) {
+			const removed = removeWhere(this._idle, (item) => item.client === client);
+			if (removed !== void 0) clearTimeout(removed.timeoutId);
+			this._clients = this._clients.filter((c) => c !== client);
+			const context = this;
+			client.end(() => {
+				context.emit("remove", client);
+				if (typeof callback === "function") callback();
+			});
+		}
+		connect(cb) {
+			if (this.ending) {
+				const err = /* @__PURE__ */ new Error("Cannot use a pool after calling end on the pool");
+				return cb ? cb(err) : this.Promise.reject(err);
+			}
+			const response = promisify(this.Promise, cb);
+			const result = response.result;
+			if (this._isFull() || this._idle.length) {
+				if (this._idle.length) process.nextTick(() => this._pulseQueue());
+				if (!this.options.connectionTimeoutMillis) {
+					this._pendingQueue.push(new PendingItem(response.callback));
+					return result;
+				}
+				const queueCallback = (err, res, done) => {
+					clearTimeout(tid);
+					response.callback(err, res, done);
+				};
+				const pendingItem = new PendingItem(queueCallback);
+				const tid = setTimeout(() => {
+					removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
+					pendingItem.timedOut = true;
+					response.callback(/* @__PURE__ */ new Error("timeout exceeded when trying to connect"));
+				}, this.options.connectionTimeoutMillis);
+				if (tid.unref) tid.unref();
+				this._pendingQueue.push(pendingItem);
+				return result;
+			}
+			this.newClient(new PendingItem(response.callback));
+			return result;
+		}
+		newClient(pendingItem) {
+			const client = new this.Client(this.options);
+			this._clients.push(client);
+			const idleListener = makeIdleListener(this, client);
+			this.log("checking client timeout");
+			let tid;
+			let timeoutHit = false;
+			if (this.options.connectionTimeoutMillis) tid = setTimeout(() => {
+				this.log("ending client due to timeout");
+				timeoutHit = true;
+				client.connection ? client.connection.stream.destroy() : client.end();
+			}, this.options.connectionTimeoutMillis);
+			this.log("connecting new client");
+			client.connect((err) => {
+				if (tid) clearTimeout(tid);
+				client.on("error", idleListener);
+				if (err) {
+					this.log("client failed to connect", err);
+					this._clients = this._clients.filter((c) => c !== client);
+					if (timeoutHit) err = new Error("Connection terminated due to connection timeout", { cause: err });
+					this._pulseQueue();
+					if (!pendingItem.timedOut) pendingItem.callback(err, void 0, NOOP);
+				} else {
+					this.log("new client connected");
+					if (this.options.maxLifetimeSeconds !== 0) {
+						const maxLifetimeTimeout = setTimeout(() => {
+							this.log("ending client due to expired lifetime");
+							this._expired.add(client);
+							if (this._idle.findIndex((idleItem) => idleItem.client === client) !== -1) this._acquireClient(client, new PendingItem((err$1, client$1, clientRelease) => clientRelease()), idleListener, false);
+						}, this.options.maxLifetimeSeconds * 1e3);
+						maxLifetimeTimeout.unref();
+						client.once("end", () => clearTimeout(maxLifetimeTimeout));
+					}
+					return this._acquireClient(client, pendingItem, idleListener, true);
+				}
+			});
+		}
+		_acquireClient(client, pendingItem, idleListener, isNew) {
+			if (isNew) this.emit("connect", client);
+			this.emit("acquire", client);
+			client.release = this._releaseOnce(client, idleListener);
+			client.removeListener("error", idleListener);
+			if (!pendingItem.timedOut) if (isNew && this.options.verify) this.options.verify(client, (err) => {
+				if (err) {
+					client.release(err);
+					return pendingItem.callback(err, void 0, NOOP);
+				}
+				pendingItem.callback(void 0, client, client.release);
+			});
+			else pendingItem.callback(void 0, client, client.release);
+			else if (isNew && this.options.verify) this.options.verify(client, client.release);
+			else client.release();
+		}
+		_releaseOnce(client, idleListener) {
+			let released = false;
+			return (err) => {
+				if (released) throwOnDoubleRelease();
+				released = true;
+				this._release(client, idleListener, err);
+			};
+		}
+		_release(client, idleListener, err) {
+			client.on("error", idleListener);
+			client._poolUseCount = (client._poolUseCount || 0) + 1;
+			this.emit("release", err, client);
+			if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
+				if (client._poolUseCount >= this.options.maxUses) this.log("remove expended client");
+				return this._remove(client, this._pulseQueue.bind(this));
+			}
+			if (this._expired.has(client)) {
+				this.log("remove expired client");
+				this._expired.delete(client);
+				return this._remove(client, this._pulseQueue.bind(this));
+			}
+			let tid;
+			if (this.options.idleTimeoutMillis && this._isAboveMin()) {
+				tid = setTimeout(() => {
+					this.log("remove idle client");
+					this._remove(client, this._pulseQueue.bind(this));
+				}, this.options.idleTimeoutMillis);
+				if (this.options.allowExitOnIdle) tid.unref();
+			}
+			if (this.options.allowExitOnIdle) client.unref();
+			this._idle.push(new IdleItem(client, idleListener, tid));
+			this._pulseQueue();
+		}
+		query(text, values, cb) {
+			if (typeof text === "function") {
+				const response$1 = promisify(this.Promise, text);
+				setImmediate(function() {
+					return response$1.callback(/* @__PURE__ */ new Error("Passing a function as the first parameter to pool.query is not supported"));
+				});
+				return response$1.result;
+			}
+			if (typeof values === "function") {
+				cb = values;
+				values = void 0;
+			}
+			const response = promisify(this.Promise, cb);
+			cb = response.callback;
+			this.connect((err, client) => {
+				if (err) return cb(err);
+				let clientReleased = false;
+				const onError = (err$1) => {
+					if (clientReleased) return;
+					clientReleased = true;
+					client.release(err$1);
+					cb(err$1);
+				};
+				client.once("error", onError);
+				this.log("dispatching query");
+				try {
+					client.query(text, values, (err$1, res) => {
+						this.log("query dispatched");
+						client.removeListener("error", onError);
+						if (clientReleased) return;
+						clientReleased = true;
+						client.release(err$1);
+						if (err$1) return cb(err$1);
+						return cb(void 0, res);
+					});
+				} catch (err$1) {
+					client.release(err$1);
+					return cb(err$1);
+				}
+			});
+			return response.result;
+		}
+		end(cb) {
+			this.log("ending");
+			if (this.ending) {
+				const err = /* @__PURE__ */ new Error("Called end on pool more than once");
+				return cb ? cb(err) : this.Promise.reject(err);
+			}
+			this.ending = true;
+			const promised = promisify(this.Promise, cb);
+			this._endCallback = promised.callback;
+			this._pulseQueue();
+			return promised.result;
+		}
+		get waitingCount() {
+			return this._pendingQueue.length;
+		}
+		get idleCount() {
+			return this._idle.length;
+		}
+		get expiredCount() {
+			return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
+		}
+		get totalCount() {
+			return this._clients.length;
+		}
+	};
+	module.exports = Pool$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/query.js
+var require_query = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/query.js": ((exports, module) => {
+	const EventEmitter$1 = __require("events").EventEmitter;
+	const util$1 = __require("util");
+	const utils$1 = require_utils$1();
+	const NativeQuery$1 = module.exports = function(config, values, callback) {
+		EventEmitter$1.call(this);
+		config = utils$1.normalizeQueryConfig(config, values, callback);
+		this.text = config.text;
+		this.values = config.values;
+		this.name = config.name;
+		this.queryMode = config.queryMode;
+		this.callback = config.callback;
+		this.state = "new";
+		this._arrayMode = config.rowMode === "array";
+		this._emitRowEvents = false;
+		this.on("newListener", function(event) {
+			if (event === "row") this._emitRowEvents = true;
+		}.bind(this));
+	};
+	util$1.inherits(NativeQuery$1, EventEmitter$1);
+	const errorFieldMap = {
+		sqlState: "code",
+		statementPosition: "position",
+		messagePrimary: "message",
+		context: "where",
+		schemaName: "schema",
+		tableName: "table",
+		columnName: "column",
+		dataTypeName: "dataType",
+		constraintName: "constraint",
+		sourceFile: "file",
+		sourceLine: "line",
+		sourceFunction: "routine"
+	};
+	NativeQuery$1.prototype.handleError = function(err) {
+		const fields = this.native.pq.resultErrorFields();
+		if (fields) for (const key in fields) {
+			const normalizedFieldName = errorFieldMap[key] || key;
+			err[normalizedFieldName] = fields[key];
+		}
+		if (this.callback) this.callback(err);
+		else this.emit("error", err);
+		this.state = "error";
+	};
+	NativeQuery$1.prototype.then = function(onSuccess, onFailure) {
+		return this._getPromise().then(onSuccess, onFailure);
+	};
+	NativeQuery$1.prototype.catch = function(callback) {
+		return this._getPromise().catch(callback);
+	};
+	NativeQuery$1.prototype._getPromise = function() {
+		if (this._promise) return this._promise;
+		this._promise = new Promise(function(resolve, reject) {
+			this._once("end", resolve);
+			this._once("error", reject);
+		}.bind(this));
+		return this._promise;
+	};
+	NativeQuery$1.prototype.submit = function(client) {
+		this.state = "running";
+		const self = this;
+		this.native = client.native;
+		client.native.arrayMode = this._arrayMode;
+		let after = function(err, rows, results) {
+			client.native.arrayMode = false;
+			setImmediate(function() {
+				self.emit("_done");
+			});
+			if (err) return self.handleError(err);
+			if (self._emitRowEvents) if (results.length > 1) rows.forEach((rowOfRows, i) => {
+				rowOfRows.forEach((row) => {
+					self.emit("row", row, results[i]);
+				});
+			});
+			else rows.forEach(function(row) {
+				self.emit("row", row, results);
+			});
+			self.state = "end";
+			self.emit("end", results);
+			if (self.callback) self.callback(null, results);
+		};
+		if (process.domain) after = process.domain.bind(after);
+		if (this.name) {
+			if (this.name.length > 63) {
+				console.error("Warning! Postgres only supports 63 characters for query names.");
+				console.error("You supplied %s (%s)", this.name, this.name.length);
+				console.error("This can cause conflicts and silent errors executing queries");
+			}
+			const values = (this.values || []).map(utils$1.prepareValue);
+			if (client.namedQueries[this.name]) {
+				if (this.text && client.namedQueries[this.name] !== this.text) {
+					const err = /* @__PURE__ */ new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
+					return after(err);
+				}
+				return client.native.execute(this.name, values, after);
+			}
+			return client.native.prepare(this.name, this.text, values.length, function(err) {
+				if (err) return after(err);
+				client.namedQueries[self.name] = self.text;
+				return self.native.execute(self.name, values, after);
+			});
+		} else if (this.values) {
+			if (!Array.isArray(this.values)) return after(/* @__PURE__ */ new Error("Query values must be an array"));
+			const vals = this.values.map(utils$1.prepareValue);
+			client.native.query(this.text, vals, after);
+		} else if (this.queryMode === "extended") client.native.query(this.text, [], after);
+		else client.native.query(this.text, after);
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/client.js
+var require_client = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/client.js": ((exports, module) => {
+	var Native;
+	try {
+		Native = __require("pg-native");
+	} catch (e) {
+		throw e;
+	}
+	const TypeOverrides$2 = require_type_overrides();
+	const EventEmitter = __require("events").EventEmitter;
+	const util = __require("util");
+	const ConnectionParameters = require_connection_parameters();
+	const NativeQuery = require_query();
+	const Client$2 = module.exports = function(config) {
+		EventEmitter.call(this);
+		config = config || {};
+		this._Promise = config.Promise || global.Promise;
+		this._types = new TypeOverrides$2(config.types);
+		this.native = new Native({ types: this._types });
+		this._queryQueue = [];
+		this._ending = false;
+		this._connecting = false;
+		this._connected = false;
+		this._queryable = true;
+		const cp = this.connectionParameters = new ConnectionParameters(config);
+		if (config.nativeConnectionString) cp.nativeConnectionString = config.nativeConnectionString;
+		this.user = cp.user;
+		Object.defineProperty(this, "password", {
+			configurable: true,
+			enumerable: false,
+			writable: true,
+			value: cp.password
+		});
+		this.database = cp.database;
+		this.host = cp.host;
+		this.port = cp.port;
+		this.namedQueries = {};
+	};
+	Client$2.Query = NativeQuery;
+	util.inherits(Client$2, EventEmitter);
+	Client$2.prototype._errorAllQueries = function(err) {
+		const enqueueError = (query$1) => {
+			process.nextTick(() => {
+				query$1.native = this.native;
+				query$1.handleError(err);
+			});
+		};
+		if (this._hasActiveQuery()) {
+			enqueueError(this._activeQuery);
+			this._activeQuery = null;
+		}
+		this._queryQueue.forEach(enqueueError);
+		this._queryQueue.length = 0;
+	};
+	Client$2.prototype._connect = function(cb) {
+		const self = this;
+		if (this._connecting) {
+			process.nextTick(() => cb(/* @__PURE__ */ new Error("Client has already been connected. You cannot reuse a client.")));
+			return;
+		}
+		this._connecting = true;
+		this.connectionParameters.getLibpqConnectionString(function(err, conString) {
+			if (self.connectionParameters.nativeConnectionString) conString = self.connectionParameters.nativeConnectionString;
+			if (err) return cb(err);
+			self.native.connect(conString, function(err$1) {
+				if (err$1) {
+					self.native.end();
+					return cb(err$1);
+				}
+				self._connected = true;
+				self.native.on("error", function(err$2) {
+					self._queryable = false;
+					self._errorAllQueries(err$2);
+					self.emit("error", err$2);
+				});
+				self.native.on("notification", function(msg) {
+					self.emit("notification", {
+						channel: msg.relname,
+						payload: msg.extra
+					});
+				});
+				self.emit("connect");
+				self._pulseQueryQueue(true);
+				cb();
+			});
+		});
+	};
+	Client$2.prototype.connect = function(callback) {
+		if (callback) {
+			this._connect(callback);
+			return;
+		}
+		return new this._Promise((resolve, reject) => {
+			this._connect((error) => {
+				if (error) reject(error);
+				else resolve();
+			});
+		});
+	};
+	Client$2.prototype.query = function(config, values, callback) {
+		let query$1;
+		let result;
+		let readTimeout;
+		let readTimeoutTimer;
+		let queryCallback;
+		if (config === null || config === void 0) throw new TypeError("Client was passed a null or undefined query");
+		else if (typeof config.submit === "function") {
+			readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
+			result = query$1 = config;
+			if (typeof values === "function") config.callback = values;
+		} else {
+			readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
+			query$1 = new NativeQuery(config, values, callback);
+			if (!query$1.callback) {
+				let resolveOut, rejectOut;
+				result = new this._Promise((resolve, reject) => {
+					resolveOut = resolve;
+					rejectOut = reject;
+				}).catch((err) => {
+					Error.captureStackTrace(err);
+					throw err;
+				});
+				query$1.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
+			}
+		}
+		if (readTimeout) {
+			queryCallback = query$1.callback;
+			readTimeoutTimer = setTimeout(() => {
+				const error = /* @__PURE__ */ new Error("Query read timeout");
+				process.nextTick(() => {
+					query$1.handleError(error, this.connection);
+				});
+				queryCallback(error);
+				query$1.callback = () => {};
+				const index = this._queryQueue.indexOf(query$1);
+				if (index > -1) this._queryQueue.splice(index, 1);
+				this._pulseQueryQueue();
+			}, readTimeout);
+			query$1.callback = (err, res) => {
+				clearTimeout(readTimeoutTimer);
+				queryCallback(err, res);
+			};
+		}
+		if (!this._queryable) {
+			query$1.native = this.native;
+			process.nextTick(() => {
+				query$1.handleError(/* @__PURE__ */ new Error("Client has encountered a connection error and is not queryable"));
+			});
+			return result;
+		}
+		if (this._ending) {
+			query$1.native = this.native;
+			process.nextTick(() => {
+				query$1.handleError(/* @__PURE__ */ new Error("Client was closed and is not queryable"));
+			});
+			return result;
+		}
+		this._queryQueue.push(query$1);
+		this._pulseQueryQueue();
+		return result;
+	};
+	Client$2.prototype.end = function(cb) {
+		const self = this;
+		this._ending = true;
+		if (!this._connected) this.once("connect", this.end.bind(this, cb));
+		let result;
+		if (!cb) result = new this._Promise(function(resolve, reject) {
+			cb = (err) => err ? reject(err) : resolve();
+		});
+		this.native.end(function() {
+			self._errorAllQueries(/* @__PURE__ */ new Error("Connection terminated"));
+			process.nextTick(() => {
+				self.emit("end");
+				if (cb) cb();
+			});
+		});
+		return result;
+	};
+	Client$2.prototype._hasActiveQuery = function() {
+		return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
+	};
+	Client$2.prototype._pulseQueryQueue = function(initialConnection) {
+		if (!this._connected) return;
+		if (this._hasActiveQuery()) return;
+		const query$1 = this._queryQueue.shift();
+		if (!query$1) {
+			if (!initialConnection) this.emit("drain");
+			return;
+		}
+		this._activeQuery = query$1;
+		query$1.submit(this);
+		const self = this;
+		query$1.once("_done", function() {
+			self._pulseQueryQueue();
+		});
+	};
+	Client$2.prototype.cancel = function(query$1) {
+		if (this._activeQuery === query$1) this.native.cancel(function() {});
+		else if (this._queryQueue.indexOf(query$1) !== -1) this._queryQueue.splice(this._queryQueue.indexOf(query$1), 1);
+	};
+	Client$2.prototype.ref = function() {};
+	Client$2.prototype.unref = function() {};
+	Client$2.prototype.setTypeParser = function(oid, format, parseFn) {
+		return this._types.setTypeParser(oid, format, parseFn);
+	};
+	Client$2.prototype.getTypeParser = function(oid, format) {
+		return this._types.getTypeParser(oid, format);
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/index.js
+var require_native = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/index.js": ((exports, module) => {
+	module.exports = require_client();
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/index.js
+var require_lib = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/index.js": ((exports, module) => {
+	const Client$1 = require_client$1();
+	const defaults$1 = require_defaults();
+	const Connection$1 = require_connection();
+	const Result$1 = require_result();
+	const utils = require_utils$1();
+	const Pool$1 = require_pg_pool();
+	const TypeOverrides$1 = require_type_overrides();
+	const { DatabaseError: DatabaseError$1 } = require_dist();
+	const { escapeIdentifier: escapeIdentifier$1, escapeLiteral: escapeLiteral$1 } = require_utils$1();
+	const poolFactory = (Client$4) => {
+		return class BoundPool extends Pool$1 {
+			constructor(options) {
+				super(options, Client$4);
+			}
+		};
+	};
+	const PG = function(clientConstructor) {
+		this.defaults = defaults$1;
+		this.Client = clientConstructor;
+		this.Query = this.Client.Query;
+		this.Pool = poolFactory(this.Client);
+		this._pools = [];
+		this.Connection = Connection$1;
+		this.types = require_pg_types();
+		this.DatabaseError = DatabaseError$1;
+		this.TypeOverrides = TypeOverrides$1;
+		this.escapeIdentifier = escapeIdentifier$1;
+		this.escapeLiteral = escapeLiteral$1;
+		this.Result = Result$1;
+		this.utils = utils;
+	};
+	if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") module.exports = new PG(require_native());
+	else {
+		module.exports = new PG(Client$1);
+		Object.defineProperty(module.exports, "native", {
+			configurable: true,
+			enumerable: false,
+			get() {
+				let native = null;
+				try {
+					native = new PG(require_native());
+				} catch (err) {
+					if (err.code !== "MODULE_NOT_FOUND") throw err;
+				}
+				Object.defineProperty(module.exports, "native", { value: native });
+				return native;
+			}
+		});
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/esm/index.mjs
+var import_lib = /* @__PURE__ */ __toESM(require_lib(), 1);
+const Client = import_lib.default.Client;
+const Pool = import_lib.default.Pool;
+const Connection = import_lib.default.Connection;
+const types = import_lib.default.types;
+const Query = import_lib.default.Query;
+const DatabaseError = import_lib.default.DatabaseError;
+const escapeIdentifier = import_lib.default.escapeIdentifier;
+const escapeLiteral = import_lib.default.escapeLiteral;
+const Result = import_lib.default.Result;
+const TypeOverrides = import_lib.default.TypeOverrides;
+const defaults = import_lib.default.defaults;
+
+//#endregion
+export { Pool };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/generic-oauth-BI8Iz1pK.mjs b/node_modules/better-auth/dist/generic-oauth-BI8Iz1pK.mjs
index 1fc3655..1bf4536 100644
--- a/node_modules/better-auth/dist/generic-oauth-BI8Iz1pK.mjs
+++ b/node_modules/better-auth/dist/generic-oauth-BI8Iz1pK.mjs
@@ -137,13 +137,13 @@ const genericOAuth = (options) => {
 			signInWithOAuth2: createAuthEndpoint("/sign-in/oauth2", {
 				method: "POST",
 				body: z.object({
-					providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
-					callbackURL: z.string().meta({ description: "The URL to redirect to after sign in" }).optional(),
-					errorCallbackURL: z.string().meta({ description: "The URL to redirect to if an error occurs" }).optional(),
-					newUserCallbackURL: z.string().meta({ description: "The URL to redirect to after login if the user is new. Eg: \"/welcome\"" }).optional(),
-					disableRedirect: z.boolean().meta({ description: "Disable redirect" }).optional(),
-					scopes: z.array(z.string()).meta({ description: "Scopes to be passed to the provider authorization request." }).optional(),
-					requestSignUp: z.boolean().meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. Eg: false" }).optional(),
+					providerId: z.string(),
+					callbackURL: z.string().optional(),
+					errorCallbackURL: z.string().optional(),
+					newUserCallbackURL: z.string().optional(),
+					disableRedirect: z.boolean().optional(),
+					scopes: z.array(z.string()).optional(),
+					requestSignUp: z.boolean().optional(),
 					additionalData: z.record(z.string(), z.any()).optional()
 				}),
 				metadata: { openapi: {
@@ -213,10 +213,10 @@ const genericOAuth = (options) => {
 			oAuth2Callback: createAuthEndpoint("/oauth2/callback/:providerId", {
 				method: "GET",
 				query: z.object({
-					code: z.string().meta({ description: "The OAuth2 code" }).optional(),
-					error: z.string().meta({ description: "The error message, if any" }).optional(),
-					error_description: z.string().meta({ description: "The error description, if any" }).optional(),
-					state: z.string().meta({ description: "The state parameter from the OAuth2 request" }).optional()
+					code: z.string().optional(),
+					error: z.string().optional(),
+					error_description: z.string().optional(),
+					state: z.string().optional()
 				}),
 				metadata: {
 					client: false,
@@ -367,8 +367,8 @@ const genericOAuth = (options) => {
 				body: z.object({
 					providerId: z.string(),
 					callbackURL: z.string(),
-					scopes: z.array(z.string()).meta({ description: "Additional scopes to request when linking the account" }).optional(),
-					errorCallbackURL: z.string().meta({ description: "The URL to redirect to if there is an error during the link process" }).optional()
+					scopes: z.array(z.string()).optional(),
+					errorCallbackURL: z.string().optional()
 				}),
 				use: [sessionMiddleware],
 				metadata: { openapi: {
diff --git a/node_modules/better-auth/dist/generic-oauth-BI8Iz1pK.mjs.bak b/node_modules/better-auth/dist/generic-oauth-BI8Iz1pK.mjs.bak
new file mode 100644
index 0000000..1fc3655
--- /dev/null
+++ b/node_modules/better-auth/dist/generic-oauth-BI8Iz1pK.mjs.bak
@@ -0,0 +1,446 @@
+import { i as parseState, r as generateState } from "./utils-F62c-ieM.mjs";
+import { O as handleOAuthUserInfo } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { createAuthorizationURL, refreshAccessToken, validateAuthorizationCode } from "@better-auth/core/oauth2";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { decodeJwt } from "jose";
+import { createAuthEndpoint } from "@better-auth/core/api";
+import { betterFetch } from "@better-fetch/fetch";
+
+//#region src/plugins/generic-oauth/index.ts
+async function getUserInfo(tokens, finalUserInfoUrl) {
+	if (tokens.idToken) {
+		const decoded = decodeJwt(tokens.idToken);
+		if (decoded) {
+			if (decoded.sub && decoded.email) return {
+				id: decoded.sub,
+				emailVerified: decoded.email_verified,
+				image: decoded.picture,
+				...decoded
+			};
+		}
+	}
+	if (!finalUserInfoUrl) return null;
+	const userInfo = await betterFetch(finalUserInfoUrl, {
+		method: "GET",
+		headers: { Authorization: `Bearer ${tokens.accessToken}` }
+	});
+	return {
+		id: userInfo.data?.sub,
+		emailVerified: userInfo.data?.email_verified ?? false,
+		email: userInfo.data?.email,
+		image: userInfo.data?.picture,
+		name: userInfo.data?.name,
+		...userInfo.data
+	};
+}
+const ERROR_CODES = defineErrorCodes({ INVALID_OAUTH_CONFIGURATION: "Invalid OAuth configuration" });
+/**
+* A generic OAuth plugin that can be used to add OAuth support to any provider
+*/
+const genericOAuth = (options) => {
+	return {
+		id: "generic-oauth",
+		init: (ctx) => {
+			return { context: { socialProviders: options.config.map((c) => {
+				let finalUserInfoUrl = c.userInfoUrl;
+				return {
+					id: c.providerId,
+					name: c.providerId,
+					createAuthorizationURL(data) {
+						return createAuthorizationURL({
+							id: c.providerId,
+							options: {
+								clientId: c.clientId,
+								clientSecret: c.clientSecret,
+								redirectURI: c.redirectURI
+							},
+							authorizationEndpoint: c.authorizationUrl,
+							state: data.state,
+							codeVerifier: c.pkce ? data.codeVerifier : void 0,
+							scopes: c.scopes || [],
+							redirectURI: `${ctx.baseURL}/oauth2/callback/${c.providerId}`
+						});
+					},
+					async validateAuthorizationCode(data) {
+						let finalTokenUrl = c.tokenUrl;
+						if (c.discoveryUrl) {
+							const discovery = await betterFetch(c.discoveryUrl, {
+								method: "GET",
+								headers: c.discoveryHeaders
+							});
+							if (discovery.data) {
+								finalTokenUrl = discovery.data.token_endpoint;
+								finalUserInfoUrl = discovery.data.userinfo_endpoint;
+							}
+						}
+						if (!finalTokenUrl) throw new APIError("BAD_REQUEST", { message: "Invalid OAuth configuration. Token URL not found." });
+						return validateAuthorizationCode({
+							headers: c.authorizationHeaders,
+							code: data.code,
+							codeVerifier: data.codeVerifier,
+							redirectURI: data.redirectURI,
+							options: {
+								clientId: c.clientId,
+								clientSecret: c.clientSecret,
+								redirectURI: c.redirectURI
+							},
+							tokenEndpoint: finalTokenUrl,
+							authentication: c.authentication
+						});
+					},
+					async refreshAccessToken(refreshToken) {
+						let finalTokenUrl = c.tokenUrl;
+						if (c.discoveryUrl) {
+							const discovery = await betterFetch(c.discoveryUrl, {
+								method: "GET",
+								headers: c.discoveryHeaders
+							});
+							if (discovery.data) finalTokenUrl = discovery.data.token_endpoint;
+						}
+						if (!finalTokenUrl) throw new APIError("BAD_REQUEST", { message: "Invalid OAuth configuration. Token URL not found." });
+						return refreshAccessToken({
+							refreshToken,
+							options: {
+								clientId: c.clientId,
+								clientSecret: c.clientSecret
+							},
+							authentication: c.authentication,
+							tokenEndpoint: finalTokenUrl
+						});
+					},
+					async getUserInfo(tokens) {
+						const userInfo = c.getUserInfo ? await c.getUserInfo(tokens) : await getUserInfo(tokens, finalUserInfoUrl);
+						if (!userInfo) return null;
+						const userMap = await c.mapProfileToUser?.(userInfo);
+						return {
+							user: {
+								id: userInfo?.id,
+								email: userInfo?.email,
+								emailVerified: userInfo?.emailVerified,
+								image: userInfo?.image,
+								name: userInfo?.name,
+								...userMap
+							},
+							data: userInfo
+						};
+					},
+					options: { overrideUserInfoOnSignIn: c.overrideUserInfo }
+				};
+			}).concat(ctx.socialProviders) } };
+		},
+		endpoints: {
+			signInWithOAuth2: createAuthEndpoint("/sign-in/oauth2", {
+				method: "POST",
+				body: z.object({
+					providerId: z.string().meta({ description: "The provider ID for the OAuth provider" }),
+					callbackURL: z.string().meta({ description: "The URL to redirect to after sign in" }).optional(),
+					errorCallbackURL: z.string().meta({ description: "The URL to redirect to if an error occurs" }).optional(),
+					newUserCallbackURL: z.string().meta({ description: "The URL to redirect to after login if the user is new. Eg: \"/welcome\"" }).optional(),
+					disableRedirect: z.boolean().meta({ description: "Disable redirect" }).optional(),
+					scopes: z.array(z.string()).meta({ description: "Scopes to be passed to the provider authorization request." }).optional(),
+					requestSignUp: z.boolean().meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. Eg: false" }).optional(),
+					additionalData: z.record(z.string(), z.any()).optional()
+				}),
+				metadata: { openapi: {
+					description: "Sign in with OAuth2",
+					responses: { 200: {
+						description: "Sign in with OAuth2",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								url: { type: "string" },
+								redirect: { type: "boolean" }
+							}
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { providerId } = ctx.body;
+				const config = options.config.find((c) => c.providerId === providerId);
+				if (!config) throw new APIError("BAD_REQUEST", { message: `No config found for provider ${providerId}` });
+				const { discoveryUrl, authorizationUrl, tokenUrl, clientId, clientSecret, scopes, redirectURI, responseType, pkce, prompt, accessType, authorizationUrlParams, responseMode, authentication } = config;
+				let finalAuthUrl = authorizationUrl;
+				let finalTokenUrl = tokenUrl;
+				if (discoveryUrl) {
+					const discovery = await betterFetch(discoveryUrl, {
+						method: "GET",
+						headers: config.discoveryHeaders,
+						onError(context) {
+							ctx.context.logger.error(context.error.message, context.error, { discoveryUrl });
+						}
+					});
+					if (discovery.data) {
+						finalAuthUrl = discovery.data.authorization_endpoint;
+						finalTokenUrl = discovery.data.token_endpoint;
+					}
+				}
+				if (!finalAuthUrl || !finalTokenUrl) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OAUTH_CONFIGURATION });
+				if (authorizationUrlParams) {
+					const withAdditionalParams = new URL(finalAuthUrl);
+					for (const [paramName, paramValue] of Object.entries(authorizationUrlParams)) withAdditionalParams.searchParams.set(paramName, paramValue);
+					finalAuthUrl = withAdditionalParams.toString();
+				}
+				const additionalParams = typeof authorizationUrlParams === "function" ? authorizationUrlParams(ctx) : authorizationUrlParams;
+				const { state, codeVerifier } = await generateState(ctx, void 0, ctx.body.additionalData);
+				const authUrl = await createAuthorizationURL({
+					id: providerId,
+					options: {
+						clientId,
+						clientSecret,
+						redirectURI
+					},
+					authorizationEndpoint: finalAuthUrl,
+					state,
+					codeVerifier: pkce ? codeVerifier : void 0,
+					scopes: ctx.body.scopes ? [...ctx.body.scopes, ...scopes || []] : scopes || [],
+					redirectURI: `${ctx.context.baseURL}/oauth2/callback/${providerId}`,
+					prompt,
+					accessType,
+					responseType,
+					responseMode,
+					additionalParams
+				});
+				return ctx.json({
+					url: authUrl.toString(),
+					redirect: !ctx.body.disableRedirect
+				});
+			}),
+			oAuth2Callback: createAuthEndpoint("/oauth2/callback/:providerId", {
+				method: "GET",
+				query: z.object({
+					code: z.string().meta({ description: "The OAuth2 code" }).optional(),
+					error: z.string().meta({ description: "The error message, if any" }).optional(),
+					error_description: z.string().meta({ description: "The error description, if any" }).optional(),
+					state: z.string().meta({ description: "The state parameter from the OAuth2 request" }).optional()
+				}),
+				metadata: {
+					client: false,
+					openapi: {
+						description: "OAuth2 callback",
+						responses: { 200: {
+							description: "OAuth2 callback",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { url: { type: "string" } }
+							} } }
+						} }
+					}
+				}
+			}, async (ctx) => {
+				const defaultErrorURL = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
+				if (ctx.query.error || !ctx.query.code) throw ctx.redirect(`${defaultErrorURL}?error=${ctx.query.error || "oAuth_code_missing"}&error_description=${ctx.query.error_description}`);
+				const provider = options.config.find((p) => p.providerId === ctx.params.providerId);
+				if (!provider) throw new APIError("BAD_REQUEST", { message: `No config found for provider ${ctx.params.providerId}` });
+				let tokens = void 0;
+				const { callbackURL, codeVerifier, errorURL, requestSignUp, newUserURL, link } = await parseState(ctx);
+				const code = ctx.query.code;
+				function redirectOnError(error) {
+					const defaultErrorURL$1 = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
+					let url = errorURL || defaultErrorURL$1;
+					if (url.includes("?")) url = `${url}&error=${error}`;
+					else url = `${url}?error=${error}`;
+					throw ctx.redirect(url);
+				}
+				let finalTokenUrl = provider.tokenUrl;
+				let finalUserInfoUrl = provider.userInfoUrl;
+				if (provider.discoveryUrl) {
+					const discovery = await betterFetch(provider.discoveryUrl, {
+						method: "GET",
+						headers: provider.discoveryHeaders
+					});
+					if (discovery.data) {
+						finalTokenUrl = discovery.data.token_endpoint;
+						finalUserInfoUrl = discovery.data.userinfo_endpoint;
+					}
+				}
+				try {
+					if (!finalTokenUrl) throw new APIError("BAD_REQUEST", { message: "Invalid OAuth configuration." });
+					const additionalParams = typeof provider.tokenUrlParams === "function" ? provider.tokenUrlParams(ctx) : provider.tokenUrlParams;
+					tokens = await validateAuthorizationCode({
+						headers: provider.authorizationHeaders,
+						code,
+						codeVerifier: provider.pkce ? codeVerifier : void 0,
+						redirectURI: `${ctx.context.baseURL}/oauth2/callback/${provider.providerId}`,
+						options: {
+							clientId: provider.clientId,
+							clientSecret: provider.clientSecret,
+							redirectURI: provider.redirectURI
+						},
+						tokenEndpoint: finalTokenUrl,
+						authentication: provider.authentication,
+						additionalParams
+					});
+				} catch (e) {
+					ctx.context.logger.error(e && typeof e === "object" && "name" in e ? e.name : "", e);
+					throw redirectOnError("oauth_code_verification_failed");
+				}
+				if (!tokens) throw new APIError("BAD_REQUEST", { message: "Invalid OAuth configuration." });
+				const userInfo = await (async function handleUserInfo() {
+					const userInfo$1 = provider.getUserInfo ? await provider.getUserInfo(tokens) : await getUserInfo(tokens, finalUserInfoUrl);
+					if (!userInfo$1) throw redirectOnError("user_info_is_missing");
+					const mapUser = provider.mapProfileToUser ? await provider.mapProfileToUser(userInfo$1) : userInfo$1;
+					const email = mapUser.email ? mapUser.email.toLowerCase() : userInfo$1.email?.toLowerCase();
+					if (!email) {
+						ctx.context.logger.error("Unable to get user info", userInfo$1);
+						throw redirectOnError("email_is_missing");
+					}
+					const id = mapUser.id ? String(mapUser.id) : String(userInfo$1.id);
+					const name = mapUser.name ? mapUser.name : userInfo$1.name;
+					if (!name) {
+						ctx.context.logger.error("Unable to get user info", userInfo$1);
+						throw redirectOnError("name_is_missing");
+					}
+					return {
+						...userInfo$1,
+						...mapUser,
+						email,
+						id,
+						name
+					};
+				})();
+				if (link) {
+					if (ctx.context.options.account?.accountLinking?.allowDifferentEmails !== true && link.email !== userInfo.email) return redirectOnError("email_doesn't_match");
+					const existingAccount = await ctx.context.internalAdapter.findAccountByProviderId(String(userInfo.id), provider.providerId);
+					if (existingAccount) {
+						if (existingAccount.userId !== link.userId) return redirectOnError("account_already_linked_to_different_user");
+						const updateData = Object.fromEntries(Object.entries({
+							accessToken: tokens.accessToken,
+							idToken: tokens.idToken,
+							refreshToken: tokens.refreshToken,
+							accessTokenExpiresAt: tokens.accessTokenExpiresAt,
+							refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
+							scope: tokens.scopes?.join(",")
+						}).filter(([_, value]) => value !== void 0));
+						await ctx.context.internalAdapter.updateAccount(existingAccount.id, updateData);
+					} else if (!await ctx.context.internalAdapter.createAccount({
+						userId: link.userId,
+						providerId: provider.providerId,
+						accountId: userInfo.id,
+						accessToken: tokens.accessToken,
+						accessTokenExpiresAt: tokens.accessTokenExpiresAt,
+						refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
+						scope: tokens.scopes?.join(","),
+						refreshToken: tokens.refreshToken,
+						idToken: tokens.idToken
+					})) return redirectOnError("unable_to_link_account");
+					let toRedirectTo$1;
+					try {
+						toRedirectTo$1 = callbackURL.toString();
+					} catch {
+						toRedirectTo$1 = callbackURL;
+					}
+					throw ctx.redirect(toRedirectTo$1);
+				}
+				const result = await handleOAuthUserInfo(ctx, {
+					userInfo,
+					account: {
+						providerId: provider.providerId,
+						accountId: userInfo.id,
+						...tokens,
+						scope: tokens.scopes?.join(",")
+					},
+					callbackURL,
+					disableSignUp: provider.disableImplicitSignUp && !requestSignUp || provider.disableSignUp,
+					overrideUserInfo: provider.overrideUserInfo
+				});
+				if (result.error) return redirectOnError(result.error.split(" ").join("_"));
+				const { session, user } = result.data;
+				await setSessionCookie(ctx, {
+					session,
+					user
+				});
+				let toRedirectTo;
+				try {
+					toRedirectTo = (result.isRegister ? newUserURL || callbackURL : callbackURL).toString();
+				} catch {
+					toRedirectTo = result.isRegister ? newUserURL || callbackURL : callbackURL;
+				}
+				throw ctx.redirect(toRedirectTo);
+			}),
+			oAuth2LinkAccount: createAuthEndpoint("/oauth2/link", {
+				method: "POST",
+				body: z.object({
+					providerId: z.string(),
+					callbackURL: z.string(),
+					scopes: z.array(z.string()).meta({ description: "Additional scopes to request when linking the account" }).optional(),
+					errorCallbackURL: z.string().meta({ description: "The URL to redirect to if there is an error during the link process" }).optional()
+				}),
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Link an OAuth2 account to the current user session",
+					responses: { "200": {
+						description: "Authorization URL generated successfully for linking an OAuth2 account",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								url: {
+									type: "string",
+									format: "uri",
+									description: "The authorization URL to redirect the user to for linking the OAuth2 account"
+								},
+								redirect: {
+									type: "boolean",
+									description: "Indicates that the client should redirect to the provided URL",
+									enum: [true]
+								}
+							},
+							required: ["url", "redirect"]
+						} } }
+					} }
+				} }
+			}, async (c) => {
+				const session = c.context.session;
+				const provider = options.config.find((p) => p.providerId === c.body.providerId);
+				if (!provider) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });
+				const { providerId, clientId, clientSecret, redirectURI, authorizationUrl, discoveryUrl, pkce, scopes, prompt, accessType, authorizationUrlParams } = provider;
+				let finalAuthUrl = authorizationUrl;
+				if (!finalAuthUrl) {
+					if (!discoveryUrl) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OAUTH_CONFIGURATION });
+					const discovery = await betterFetch(discoveryUrl, {
+						method: "GET",
+						headers: provider.discoveryHeaders,
+						onError(context) {
+							c.context.logger.error(context.error.message, context.error, { discoveryUrl });
+						}
+					});
+					if (discovery.data) finalAuthUrl = discovery.data.authorization_endpoint;
+				}
+				if (!finalAuthUrl) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_OAUTH_CONFIGURATION });
+				const state = await generateState(c, {
+					userId: session.user.id,
+					email: session.user.email
+				}, void 0);
+				const additionalParams = typeof authorizationUrlParams === "function" ? authorizationUrlParams(c) : authorizationUrlParams;
+				const url = await createAuthorizationURL({
+					id: providerId,
+					options: {
+						clientId,
+						clientSecret,
+						redirectURI: redirectURI || `${c.context.baseURL}/oauth2/callback/${providerId}`
+					},
+					authorizationEndpoint: finalAuthUrl,
+					state: state.state,
+					codeVerifier: pkce ? state.codeVerifier : void 0,
+					scopes: c.body.scopes || scopes || [],
+					redirectURI: redirectURI || `${c.context.baseURL}/oauth2/callback/${providerId}`,
+					prompt,
+					accessType,
+					additionalParams
+				});
+				return c.json({
+					url: url.toString(),
+					redirect: true
+				});
+			})
+		},
+		$ERROR_CODES: ERROR_CODES
+	};
+};
+
+//#endregion
+export { genericOAuth as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs b/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs
index ec5d695..09661fa 100644
--- a/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs
+++ b/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs
@@ -804,12 +804,15 @@ function toZodSchema({ fields, isClientSide }) {
 	const zodFields = Object.keys(fields).reduce((acc, key) => {
 		const field = fields[key];
 		if (!field) return acc;
-		if (isClientSide && field.input === false) return acc;
-		let schema;
-		if (field.type === "json") schema = z.json ? z.json() : z.any();
+		if (isClientSide && field.input === false) return acc;		let schema;
+		if (field.type === "json") schema = z.any();
 		else if (field.type === "string[]" || field.type === "number[]") schema = z.array(field.type === "string[]" ? z.string() : z.number());
 		else if (Array.isArray(field.type)) schema = z.any();
-		else schema = z[field.type]();
+		else {
+			// Explicitly exclude "json" to prevent webpack from resolving z.json
+			const zodType = field.type === "json" ? "any" : field.type;
+			schema = zodType === "any" ? z.any() : z[zodType]();
+		}
 		if (field?.required === false) schema = schema.optional();
 		if (field?.returned === false) return acc;
 		return {
diff --git a/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs.bak b/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs.bak
new file mode 100644
index 0000000..09661fa
--- /dev/null
+++ b/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs.bak
@@ -0,0 +1,1177 @@
+import { t as createKyselyAdapter } from "./dialect-BhkkSrrx.mjs";
+import { a as getAuthTables, n as initGetFieldName, t as initGetModelName } from "./get-model-name-nJd9iPTo.mjs";
+import { t as generateId } from "./utils-F62c-ieM.mjs";
+import { l as parseUserOutput, s as parseSessionOutput, u as getDate } from "./schema-BevzneML.mjs";
+import { t as getIp } from "./get-request-ip-kbu825ez.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { getCurrentAdapter, getCurrentAuthContext, runWithTransaction } from "@better-auth/core/context";
+import { createLogger, logger } from "@better-auth/core/env";
+import { BetterAuthError } from "@better-auth/core/error";
+import { sql } from "kysely";
+import * as z from "zod";
+
+//#region src/db/adapter-base.ts
+async function getBaseAdapter(options, handleDirectDatabase) {
+	let adapter;
+	if (!options.database) {
+		const tables = getAuthTables(options);
+		const memoryDB = Object.keys(tables).reduce((acc, key) => {
+			acc[key] = [];
+			return acc;
+		}, {});
+		const { memoryAdapter } = await import("./adapters/memory-adapter/index.mjs");
+		adapter = memoryAdapter(memoryDB)(options);
+	} else if (typeof options.database === "function") adapter = options.database(options);
+	else adapter = await handleDirectDatabase(options);
+	if (!adapter.transaction) {
+		logger.warn("Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.");
+		adapter.transaction = async (cb) => {
+			return cb(adapter);
+		};
+	}
+	return adapter;
+}
+
+//#endregion
+//#region src/db/adapter-kysely.ts
+async function getAdapter(options) {
+	return getBaseAdapter(options, async (opts) => {
+		const { createKyselyAdapter: createKyselyAdapter$1 } = await import("./adapters/kysely-adapter/index.mjs");
+		const { kysely, databaseType, transaction } = await createKyselyAdapter$1(opts);
+		if (!kysely) throw new BetterAuthError("Failed to initialize database adapter");
+		const { kyselyAdapter } = await import("./adapters/kysely-adapter/index.mjs");
+		return kyselyAdapter(kysely, {
+			type: databaseType || "sqlite",
+			debugLogs: opts.database && "debugLogs" in opts.database ? opts.database.debugLogs : false,
+			transaction
+		})(opts);
+	});
+}
+
+//#endregion
+//#region src/db/field.ts
+const createFieldAttribute = (type, config) => {
+	return {
+		type,
+		...config
+	};
+};
+
+//#endregion
+//#region src/db/field-converter.ts
+function convertToDB(fields, values) {
+	let result = values.id ? { id: values.id } : {};
+	for (const key in fields) {
+		const field = fields[key];
+		const value = values[key];
+		if (value === void 0) continue;
+		result[field.fieldName || key] = value;
+	}
+	return result;
+}
+function convertFromDB(fields, values) {
+	if (!values) return null;
+	let result = { id: values.id };
+	for (const [key, value] of Object.entries(fields)) result[key] = values[value.fieldName || key];
+	return result;
+}
+
+//#endregion
+//#region src/db/with-hooks.ts
+function getWithHooks(adapter, ctx) {
+	const hooks = ctx.hooks;
+	async function createWithHooks(data, model, customCreateFn) {
+		const context = await getCurrentAuthContext();
+		let actualData = data;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.create?.before;
+			if (toRun) {
+				const result = await toRun(actualData, context);
+				if (result === false) return null;
+				if (typeof result === "object" && "data" in result) actualData = {
+					...actualData,
+					...result.data
+				};
+			}
+		}
+		const customCreated = customCreateFn ? await customCreateFn.fn(actualData) : null;
+		const created = !customCreateFn || customCreateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).create({
+			model,
+			data: actualData,
+			forceAllowId: true
+		}) : customCreated;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.create?.after;
+			if (toRun) await toRun(created, context);
+		}
+		return created;
+	}
+	async function updateWithHooks(data, where, model, customUpdateFn) {
+		const context = await getCurrentAuthContext();
+		let actualData = data;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.before;
+			if (toRun) {
+				const result = await toRun(data, context);
+				if (result === false) return null;
+				if (typeof result === "object" && "data" in result) actualData = {
+					...actualData,
+					...result.data
+				};
+			}
+		}
+		const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
+		const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).update({
+			model,
+			update: actualData,
+			where
+		}) : customUpdated;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.after;
+			if (toRun) await toRun(updated, context);
+		}
+		return updated;
+	}
+	async function updateManyWithHooks(data, where, model, customUpdateFn) {
+		const context = await getCurrentAuthContext();
+		let actualData = data;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.before;
+			if (toRun) {
+				const result = await toRun(data, context);
+				if (result === false) return null;
+				if (typeof result === "object" && "data" in result) actualData = {
+					...actualData,
+					...result.data
+				};
+			}
+		}
+		const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
+		const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).updateMany({
+			model,
+			update: actualData,
+			where
+		}) : customUpdated;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.after;
+			if (toRun) await toRun(updated, context);
+		}
+		return updated;
+	}
+	async function deleteWithHooks(where, model, customDeleteFn) {
+		const context = await getCurrentAuthContext();
+		let entityToDelete = null;
+		try {
+			entityToDelete = (await (await getCurrentAdapter(adapter)).findMany({
+				model,
+				where,
+				limit: 1
+			}))[0] || null;
+		} catch (error) {}
+		if (entityToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.before;
+			if (toRun) {
+				if (await toRun(entityToDelete, context) === false) return null;
+			}
+		}
+		const customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;
+		const deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).delete({
+			model,
+			where
+		}) : customDeleted;
+		if (entityToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.after;
+			if (toRun) await toRun(entityToDelete, context);
+		}
+		return deleted;
+	}
+	async function deleteManyWithHooks(where, model, customDeleteFn) {
+		const context = await getCurrentAuthContext();
+		let entitiesToDelete = [];
+		try {
+			entitiesToDelete = await (await getCurrentAdapter(adapter)).findMany({
+				model,
+				where
+			});
+		} catch (error) {}
+		for (const entity of entitiesToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.before;
+			if (toRun) {
+				if (await toRun(entity, context) === false) return null;
+			}
+		}
+		const customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;
+		const deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).deleteMany({
+			model,
+			where
+		}) : customDeleted;
+		for (const entity of entitiesToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.after;
+			if (toRun) await toRun(entity, context);
+		}
+		return deleted;
+	}
+	return {
+		createWithHooks,
+		updateWithHooks,
+		updateManyWithHooks,
+		deleteWithHooks,
+		deleteManyWithHooks
+	};
+}
+
+//#endregion
+//#region src/db/internal-adapter.ts
+const createInternalAdapter = (adapter, ctx) => {
+	const logger$1 = ctx.logger;
+	const options = ctx.options;
+	const secondaryStorage = options.secondaryStorage;
+	const sessionExpiration = options.session?.expiresIn || 3600 * 24 * 7;
+	const { createWithHooks, updateWithHooks, updateManyWithHooks, deleteWithHooks, deleteManyWithHooks } = getWithHooks(adapter, ctx);
+	async function refreshUserSessions(user) {
+		if (!secondaryStorage) return;
+		const listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);
+		if (!listRaw) return;
+		const now = Date.now();
+		const validSessions = (safeJSONParse(listRaw) || []).filter((s) => s.expiresAt > now);
+		await Promise.all(validSessions.map(async ({ token }) => {
+			const cached = await secondaryStorage.get(token);
+			if (!cached) return;
+			const parsed = safeJSONParse(cached);
+			if (!parsed) return;
+			const sessionTTL = Math.max(Math.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1e3, 0);
+			await secondaryStorage.set(token, JSON.stringify({
+				session: parsed.session,
+				user
+			}), Math.floor(sessionTTL));
+		}));
+	}
+	return {
+		createOAuthUser: async (user, account) => {
+			return runWithTransaction(adapter, async () => {
+				const createdUser = await createWithHooks({
+					createdAt: /* @__PURE__ */ new Date(),
+					updatedAt: /* @__PURE__ */ new Date(),
+					...user
+				}, "user", void 0);
+				return {
+					user: createdUser,
+					account: await createWithHooks({
+						...account,
+						userId: createdUser.id,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}, "account", void 0)
+				};
+			});
+		},
+		createUser: async (user) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...user,
+				email: user.email?.toLowerCase()
+			}, "user", void 0);
+		},
+		createAccount: async (account) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...account
+			}, "account", void 0);
+		},
+		listSessions: async (userId) => {
+			if (secondaryStorage) {
+				const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
+				if (!currentList) return [];
+				const list = safeJSONParse(currentList) || [];
+				const now = Date.now();
+				const validSessions = list.filter((s) => s.expiresAt > now);
+				const sessions = [];
+				for (const session of validSessions) {
+					const sessionStringified = await secondaryStorage.get(session.token);
+					if (sessionStringified) {
+						const s = safeJSONParse(sessionStringified);
+						if (!s) return [];
+						const parsedSession = parseSessionOutput(ctx.options, {
+							...s.session,
+							expiresAt: new Date(s.session.expiresAt)
+						});
+						sessions.push(parsedSession);
+					}
+				}
+				return sessions;
+			}
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "session",
+				where: [{
+					field: "userId",
+					value: userId
+				}]
+			});
+		},
+		listUsers: async (limit, offset, sortBy, where) => {
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "user",
+				limit,
+				offset,
+				sortBy,
+				where
+			});
+		},
+		countTotalUsers: async (where) => {
+			const total = await (await getCurrentAdapter(adapter)).count({
+				model: "user",
+				where
+			});
+			if (typeof total === "string") return parseInt(total);
+			return total;
+		},
+		deleteUser: async (userId) => {
+			if (secondaryStorage) await secondaryStorage.delete(`active-sessions-${userId}`);
+			if (!secondaryStorage || options.session?.storeSessionInDatabase) await deleteManyWithHooks([{
+				field: "userId",
+				value: userId
+			}], "session", void 0);
+			await deleteManyWithHooks([{
+				field: "userId",
+				value: userId
+			}], "account", void 0);
+			await deleteWithHooks([{
+				field: "id",
+				value: userId
+			}], "user", void 0);
+		},
+		createSession: async (userId, dontRememberMe, override, overrideAll) => {
+			const ctx$1 = await getCurrentAuthContext();
+			const headers = ctx$1.headers || ctx$1.request?.headers;
+			const { id: _,...rest } = override || {};
+			const data = {
+				ipAddress: ctx$1.request || ctx$1.headers ? getIp(ctx$1.request || ctx$1.headers, ctx$1.context.options) || "" : "",
+				userAgent: headers?.get("user-agent") || "",
+				...rest,
+				expiresAt: dontRememberMe ? getDate(3600 * 24, "sec") : getDate(sessionExpiration, "sec"),
+				userId,
+				token: generateId(32),
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...overrideAll ? rest : {}
+			};
+			return await createWithHooks(data, "session", secondaryStorage ? {
+				fn: async (sessionData) => {
+					/**
+					* store the session token for the user
+					* so we can retrieve it later for listing sessions
+					*/
+					const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
+					let list = [];
+					const now = Date.now();
+					if (currentList) {
+						list = safeJSONParse(currentList) || [];
+						list = list.filter((session) => session.expiresAt > now);
+					}
+					const sorted = list.sort((a, b) => a.expiresAt - b.expiresAt);
+					let furthestSessionExp = sorted.at(-1)?.expiresAt;
+					sorted.push({
+						token: data.token,
+						expiresAt: data.expiresAt.getTime()
+					});
+					if (!furthestSessionExp || furthestSessionExp < data.expiresAt.getTime()) furthestSessionExp = data.expiresAt.getTime();
+					const furthestSessionTTL = Math.max(Math.floor((furthestSessionExp - now) / 1e3), 0);
+					if (furthestSessionTTL > 0) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(sorted), furthestSessionTTL);
+					const user = await adapter.findOne({
+						model: "user",
+						where: [{
+							field: "id",
+							value: userId
+						}]
+					});
+					const sessionTTL = Math.max(Math.floor((data.expiresAt.getTime() - now) / 1e3), 0);
+					if (sessionTTL > 0) await secondaryStorage.set(data.token, JSON.stringify({
+						session: sessionData,
+						user
+					}), sessionTTL);
+					return sessionData;
+				},
+				executeMainFn: options.session?.storeSessionInDatabase
+			} : void 0);
+		},
+		findSession: async (token) => {
+			if (secondaryStorage) {
+				const sessionStringified = await secondaryStorage.get(token);
+				if (!sessionStringified && !options.session?.storeSessionInDatabase) return null;
+				if (sessionStringified) {
+					const s = safeJSONParse(sessionStringified);
+					if (!s) return null;
+					return {
+						session: parseSessionOutput(ctx.options, {
+							...s.session,
+							expiresAt: new Date(s.session.expiresAt),
+							createdAt: new Date(s.session.createdAt),
+							updatedAt: new Date(s.session.updatedAt)
+						}),
+						user: parseUserOutput(ctx.options, {
+							...s.user,
+							createdAt: new Date(s.user.createdAt),
+							updatedAt: new Date(s.user.updatedAt)
+						})
+					};
+				}
+			}
+			const session = await (await getCurrentAdapter(adapter)).findOne({
+				model: "session",
+				where: [{
+					value: token,
+					field: "token"
+				}]
+			});
+			if (!session) return null;
+			const user = await (await getCurrentAdapter(adapter)).findOne({
+				model: "user",
+				where: [{
+					value: session.userId,
+					field: "id"
+				}]
+			});
+			if (!user) return null;
+			return {
+				session: parseSessionOutput(ctx.options, session),
+				user: parseUserOutput(ctx.options, user)
+			};
+		},
+		findSessions: async (sessionTokens) => {
+			if (secondaryStorage) {
+				const sessions$1 = [];
+				for (const sessionToken of sessionTokens) {
+					const sessionStringified = await secondaryStorage.get(sessionToken);
+					if (sessionStringified) {
+						const s = safeJSONParse(sessionStringified);
+						if (!s) return [];
+						const session = {
+							session: {
+								...s.session,
+								expiresAt: new Date(s.session.expiresAt)
+							},
+							user: {
+								...s.user,
+								createdAt: new Date(s.user.createdAt),
+								updatedAt: new Date(s.user.updatedAt)
+							}
+						};
+						sessions$1.push(session);
+					}
+				}
+				return sessions$1;
+			}
+			const sessions = await (await getCurrentAdapter(adapter)).findMany({
+				model: "session",
+				where: [{
+					field: "token",
+					value: sessionTokens,
+					operator: "in"
+				}]
+			});
+			const userIds = sessions.map((session) => {
+				return session.userId;
+			});
+			if (!userIds.length) return [];
+			const users = await (await getCurrentAdapter(adapter)).findMany({
+				model: "user",
+				where: [{
+					field: "id",
+					value: userIds,
+					operator: "in"
+				}]
+			});
+			return sessions.map((session) => {
+				const user = users.find((u) => u.id === session.userId);
+				if (!user) return null;
+				return {
+					session,
+					user
+				};
+			});
+		},
+		updateSession: async (sessionToken, session) => {
+			return await updateWithHooks(session, [{
+				field: "token",
+				value: sessionToken
+			}], "session", secondaryStorage ? {
+				async fn(data) {
+					const currentSession = await secondaryStorage.get(sessionToken);
+					let updatedSession = null;
+					if (currentSession) {
+						const parsedSession = safeJSONParse(currentSession);
+						if (!parsedSession) return null;
+						updatedSession = {
+							...parsedSession.session,
+							...data
+						};
+						return updatedSession;
+					} else return null;
+				},
+				executeMainFn: options.session?.storeSessionInDatabase
+			} : void 0);
+		},
+		deleteSession: async (token) => {
+			if (secondaryStorage) {
+				const data = await secondaryStorage.get(token);
+				if (data) {
+					const { session } = safeJSONParse(data) ?? {};
+					if (!session) {
+						logger$1.error("Session not found in secondary storage");
+						return;
+					}
+					const userId = session.userId;
+					const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
+					if (currentList) {
+						let list = safeJSONParse(currentList) || [];
+						const now = Date.now();
+						const filtered = list.filter((session$1) => session$1.expiresAt > now && session$1.token !== token);
+						const furthestSessionExp = filtered.sort((a, b) => a.expiresAt - b.expiresAt).at(-1)?.expiresAt;
+						if (filtered.length > 0 && furthestSessionExp && furthestSessionExp > Date.now()) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(filtered), Math.floor((furthestSessionExp - now) / 1e3));
+						else await secondaryStorage.delete(`active-sessions-${userId}`);
+					} else logger$1.error("Active sessions list not found in secondary storage");
+				}
+				await secondaryStorage.delete(token);
+				if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;
+			}
+			await (await getCurrentAdapter(adapter)).delete({
+				model: "session",
+				where: [{
+					field: "token",
+					value: token
+				}]
+			});
+		},
+		deleteAccounts: async (userId) => {
+			await deleteManyWithHooks([{
+				field: "userId",
+				value: userId
+			}], "account", void 0);
+		},
+		deleteAccount: async (accountId) => {
+			await deleteWithHooks([{
+				field: "id",
+				value: accountId
+			}], "account", void 0);
+		},
+		deleteSessions: async (userIdOrSessionTokens) => {
+			if (secondaryStorage) {
+				if (typeof userIdOrSessionTokens === "string") {
+					const activeSession = await secondaryStorage.get(`active-sessions-${userIdOrSessionTokens}`);
+					const sessions = activeSession ? safeJSONParse(activeSession) : [];
+					if (!sessions) return;
+					for (const session of sessions) await secondaryStorage.delete(session.token);
+				} else for (const sessionToken of userIdOrSessionTokens) if (await secondaryStorage.get(sessionToken)) await secondaryStorage.delete(sessionToken);
+				if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;
+			}
+			await deleteManyWithHooks([{
+				field: Array.isArray(userIdOrSessionTokens) ? "token" : "userId",
+				value: userIdOrSessionTokens,
+				operator: Array.isArray(userIdOrSessionTokens) ? "in" : void 0
+			}], "session", void 0);
+		},
+		findOAuthUser: async (email, accountId, providerId) => {
+			const account = await (await getCurrentAdapter(adapter)).findMany({
+				model: "account",
+				where: [{
+					value: accountId,
+					field: "accountId"
+				}]
+			}).then((accounts) => {
+				return accounts.find((a) => a.providerId === providerId);
+			});
+			if (account) {
+				const user = await (await getCurrentAdapter(adapter)).findOne({
+					model: "user",
+					where: [{
+						value: account.userId,
+						field: "id"
+					}]
+				});
+				if (user) return {
+					user,
+					accounts: [account]
+				};
+				else {
+					const user$1 = await (await getCurrentAdapter(adapter)).findOne({
+						model: "user",
+						where: [{
+							value: email.toLowerCase(),
+							field: "email"
+						}]
+					});
+					if (user$1) return {
+						user: user$1,
+						accounts: [account]
+					};
+					return null;
+				}
+			} else {
+				const user = await (await getCurrentAdapter(adapter)).findOne({
+					model: "user",
+					where: [{
+						value: email.toLowerCase(),
+						field: "email"
+					}]
+				});
+				if (user) return {
+					user,
+					accounts: await (await getCurrentAdapter(adapter)).findMany({
+						model: "account",
+						where: [{
+							value: user.id,
+							field: "userId"
+						}]
+					}) || []
+				};
+				else return null;
+			}
+		},
+		findUserByEmail: async (email, options$1) => {
+			const user = await (await getCurrentAdapter(adapter)).findOne({
+				model: "user",
+				where: [{
+					value: email.toLowerCase(),
+					field: "email"
+				}]
+			});
+			if (!user) return null;
+			if (options$1?.includeAccounts) return {
+				user,
+				accounts: await (await getCurrentAdapter(adapter)).findMany({
+					model: "account",
+					where: [{
+						value: user.id,
+						field: "userId"
+					}]
+				})
+			};
+			return {
+				user,
+				accounts: []
+			};
+		},
+		findUserById: async (userId) => {
+			return await (await getCurrentAdapter(adapter)).findOne({
+				model: "user",
+				where: [{
+					field: "id",
+					value: userId
+				}]
+			});
+		},
+		linkAccount: async (account) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...account
+			}, "account", void 0);
+		},
+		updateUser: async (userId, data) => {
+			const user = await updateWithHooks(data, [{
+				field: "id",
+				value: userId
+			}], "user", void 0);
+			await refreshUserSessions(user);
+			await refreshUserSessions(user);
+			return user;
+		},
+		updateUserByEmail: async (email, data) => {
+			const user = await updateWithHooks(data, [{
+				field: "email",
+				value: email.toLowerCase()
+			}], "user", void 0);
+			await refreshUserSessions(user);
+			await refreshUserSessions(user);
+			return user;
+		},
+		updatePassword: async (userId, password) => {
+			await updateManyWithHooks({ password }, [{
+				field: "userId",
+				value: userId
+			}, {
+				field: "providerId",
+				value: "credential"
+			}], "account", void 0);
+		},
+		findAccounts: async (userId) => {
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "account",
+				where: [{
+					field: "userId",
+					value: userId
+				}]
+			});
+		},
+		findAccount: async (accountId) => {
+			return await (await getCurrentAdapter(adapter)).findOne({
+				model: "account",
+				where: [{
+					field: "accountId",
+					value: accountId
+				}]
+			});
+		},
+		findAccountByProviderId: async (accountId, providerId) => {
+			return await (await getCurrentAdapter(adapter)).findOne({
+				model: "account",
+				where: [{
+					field: "accountId",
+					value: accountId
+				}, {
+					field: "providerId",
+					value: providerId
+				}]
+			});
+		},
+		findAccountByUserId: async (userId) => {
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "account",
+				where: [{
+					field: "userId",
+					value: userId
+				}]
+			});
+		},
+		updateAccount: async (id, data) => {
+			return await updateWithHooks(data, [{
+				field: "id",
+				value: id
+			}], "account", void 0);
+		},
+		createVerificationValue: async (data) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...data
+			}, "verification", void 0);
+		},
+		findVerificationValue: async (identifier) => {
+			const verification = await (await getCurrentAdapter(adapter)).findMany({
+				model: "verification",
+				where: [{
+					field: "identifier",
+					value: identifier
+				}],
+				sortBy: {
+					field: "createdAt",
+					direction: "desc"
+				},
+				limit: 1
+			});
+			if (!options.verification?.disableCleanup) await (await getCurrentAdapter(adapter)).deleteMany({
+				model: "verification",
+				where: [{
+					field: "expiresAt",
+					value: /* @__PURE__ */ new Date(),
+					operator: "lt"
+				}]
+			});
+			return verification[0];
+		},
+		deleteVerificationValue: async (id) => {
+			await (await getCurrentAdapter(adapter)).delete({
+				model: "verification",
+				where: [{
+					field: "id",
+					value: id
+				}]
+			});
+		},
+		deleteVerificationByIdentifier: async (identifier) => {
+			await (await getCurrentAdapter(adapter)).delete({
+				model: "verification",
+				where: [{
+					field: "identifier",
+					value: identifier
+				}]
+			});
+		},
+		updateVerificationValue: async (id, data) => {
+			return await updateWithHooks(data, [{
+				field: "id",
+				value: id
+			}], "verification", void 0);
+		}
+	};
+};
+
+//#endregion
+//#region src/db/to-zod.ts
+function toZodSchema({ fields, isClientSide }) {
+	const zodFields = Object.keys(fields).reduce((acc, key) => {
+		const field = fields[key];
+		if (!field) return acc;
+		if (isClientSide && field.input === false) return acc;		let schema;
+		if (field.type === "json") schema = z.any();
+		else if (field.type === "string[]" || field.type === "number[]") schema = z.array(field.type === "string[]" ? z.string() : z.number());
+		else if (Array.isArray(field.type)) schema = z.any();
+		else {
+			// Explicitly exclude "json" to prevent webpack from resolving z.json
+			const zodType = field.type === "json" ? "any" : field.type;
+			schema = zodType === "any" ? z.any() : z[zodType]();
+		}
+		if (field?.required === false) schema = schema.optional();
+		if (field?.returned === false) return acc;
+		return {
+			...acc,
+			[key]: schema
+		};
+	}, {});
+	return z.object(zodFields);
+}
+
+//#endregion
+//#region src/db/get-schema.ts
+function getSchema(config) {
+	const tables = getAuthTables(config);
+	let schema = {};
+	for (const key in tables) {
+		const table = tables[key];
+		const fields = table.fields;
+		let actualFields = {};
+		Object.entries(fields).forEach(([key$1, field]) => {
+			actualFields[field.fieldName || key$1] = field;
+			if (field.references) {
+				const refTable = tables[field.references.model];
+				if (refTable) actualFields[field.fieldName || key$1].references = {
+					...field.references,
+					model: refTable.modelName,
+					field: field.references.field
+				};
+			}
+		});
+		if (schema[table.modelName]) {
+			schema[table.modelName].fields = {
+				...schema[table.modelName].fields,
+				...actualFields
+			};
+			continue;
+		}
+		schema[table.modelName] = {
+			fields: actualFields,
+			order: table.order || Infinity
+		};
+	}
+	return schema;
+}
+
+//#endregion
+//#region src/db/get-migration.ts
+const map = {
+	postgres: {
+		string: [
+			"character varying",
+			"varchar",
+			"text",
+			"uuid"
+		],
+		number: [
+			"int4",
+			"integer",
+			"bigint",
+			"smallint",
+			"numeric",
+			"real",
+			"double precision"
+		],
+		boolean: ["bool", "boolean"],
+		date: [
+			"timestamptz",
+			"timestamp",
+			"date"
+		],
+		json: ["json", "jsonb"]
+	},
+	mysql: {
+		string: [
+			"varchar",
+			"text",
+			"uuid"
+		],
+		number: [
+			"integer",
+			"int",
+			"bigint",
+			"smallint",
+			"decimal",
+			"float",
+			"double"
+		],
+		boolean: ["boolean", "tinyint"],
+		date: [
+			"timestamp",
+			"datetime",
+			"date"
+		],
+		json: ["json"]
+	},
+	sqlite: {
+		string: ["TEXT"],
+		number: ["INTEGER", "REAL"],
+		boolean: ["INTEGER", "BOOLEAN"],
+		date: ["DATE", "INTEGER"],
+		json: ["TEXT"]
+	},
+	mssql: {
+		string: [
+			"varchar",
+			"nvarchar",
+			"uniqueidentifier"
+		],
+		number: [
+			"int",
+			"bigint",
+			"smallint",
+			"decimal",
+			"float",
+			"double"
+		],
+		boolean: ["bit", "smallint"],
+		date: [
+			"datetime2",
+			"date",
+			"datetime"
+		],
+		json: ["varchar", "nvarchar"]
+	}
+};
+function matchType(columnDataType, fieldType, dbType) {
+	function normalize(type) {
+		return type.toLowerCase().split("(")[0].trim();
+	}
+	if (fieldType === "string[]" || fieldType === "number[]") return columnDataType.toLowerCase().includes("json");
+	const types = map[dbType];
+	return (Array.isArray(fieldType) ? types["string"].map((t) => t.toLowerCase()) : types[fieldType].map((t) => t.toLowerCase())).includes(normalize(columnDataType));
+}
+/**
+* Get the current PostgreSQL schema (search_path) for the database connection
+* Returns the first schema in the search_path, defaulting to 'public' if not found
+*/
+async function getPostgresSchema(db) {
+	try {
+		const result = await sql`SHOW search_path`.execute(db);
+		if (result.rows[0]?.search_path) return result.rows[0].search_path.split(",").map((s) => s.trim()).map((s) => s.replace(/^["']|["']$/g, "")).filter((s) => !s.startsWith("$"))[0] || "public";
+	} catch (error) {}
+	return "public";
+}
+async function getMigrations(config) {
+	const betterAuthSchema = getSchema(config);
+	const logger$1 = createLogger(config.logger);
+	let { kysely: db, databaseType: dbType } = await createKyselyAdapter(config);
+	if (!dbType) {
+		logger$1.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.");
+		dbType = "sqlite";
+	}
+	if (!db) {
+		logger$1.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.");
+		process.exit(1);
+	}
+	let currentSchema = "public";
+	if (dbType === "postgres") {
+		currentSchema = await getPostgresSchema(db);
+		logger$1.debug(`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`);
+		try {
+			if (!(await sql`
+				SELECT schema_name 
+				FROM information_schema.schemata 
+				WHERE schema_name = ${currentSchema}
+			`.execute(db)).rows[0]) logger$1.warn(`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`);
+		} catch (error) {
+			logger$1.debug(`Could not verify schema existence: ${error instanceof Error ? error.message : String(error)}`);
+		}
+	}
+	const allTableMetadata = await db.introspection.getTables();
+	let tableMetadata = allTableMetadata;
+	if (dbType === "postgres") try {
+		const tablesInSchema = await sql`
+				SELECT table_name 
+				FROM information_schema.tables 
+				WHERE table_schema = ${currentSchema}
+				AND table_type = 'BASE TABLE'
+			`.execute(db);
+		const tableNamesInSchema = new Set(tablesInSchema.rows.map((row) => row.table_name));
+		tableMetadata = allTableMetadata.filter((table) => table.schema === currentSchema && tableNamesInSchema.has(table.name));
+		logger$1.debug(`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t) => t.name).join(", ") || "(none)"}`);
+	} catch (error) {
+		logger$1.warn(`Could not filter tables by schema. Using all discovered tables. Error: ${error instanceof Error ? error.message : String(error)}`);
+	}
+	const toBeCreated = [];
+	const toBeAdded = [];
+	for (const [key, value] of Object.entries(betterAuthSchema)) {
+		const table = tableMetadata.find((t) => t.name === key);
+		if (!table) {
+			const tIndex = toBeCreated.findIndex((t) => t.table === key);
+			const tableData = {
+				table: key,
+				fields: value.fields,
+				order: value.order || Infinity
+			};
+			const insertIndex = toBeCreated.findIndex((t) => (t.order || Infinity) > tableData.order);
+			if (insertIndex === -1) if (tIndex === -1) toBeCreated.push(tableData);
+			else toBeCreated[tIndex].fields = {
+				...toBeCreated[tIndex].fields,
+				...value.fields
+			};
+			else toBeCreated.splice(insertIndex, 0, tableData);
+			continue;
+		}
+		let toBeAddedFields = {};
+		for (const [fieldName, field] of Object.entries(value.fields)) {
+			const column = table.columns.find((c) => c.name === fieldName);
+			if (!column) {
+				toBeAddedFields[fieldName] = field;
+				continue;
+			}
+			if (matchType(column.dataType, field.type, dbType)) continue;
+			else logger$1.warn(`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`);
+		}
+		if (Object.keys(toBeAddedFields).length > 0) toBeAdded.push({
+			table: key,
+			fields: toBeAddedFields,
+			order: value.order || Infinity
+		});
+	}
+	const migrations = [];
+	const useUUIDs = config.advanced?.database?.generateId === "uuid";
+	const useNumberId = config.advanced?.database?.useNumberId || config.advanced?.database?.generateId === "serial";
+	function getType(field, fieldName) {
+		const type = field.type;
+		const typeMap = {
+			string: {
+				sqlite: "text",
+				postgres: "text",
+				mysql: field.unique ? "varchar(255)" : field.references ? "varchar(36)" : field.sortable ? "varchar(255)" : field.index ? "varchar(255)" : "text",
+				mssql: field.unique || field.sortable ? "varchar(255)" : field.references ? "varchar(36)" : "varchar(8000)"
+			},
+			boolean: {
+				sqlite: "integer",
+				postgres: "boolean",
+				mysql: "boolean",
+				mssql: "smallint"
+			},
+			number: {
+				sqlite: field.bigint ? "bigint" : "integer",
+				postgres: field.bigint ? "bigint" : "integer",
+				mysql: field.bigint ? "bigint" : "integer",
+				mssql: field.bigint ? "bigint" : "integer"
+			},
+			date: {
+				sqlite: "date",
+				postgres: "timestamptz",
+				mysql: "timestamp(3)",
+				mssql: sql`datetime2(3)`
+			},
+			json: {
+				sqlite: "text",
+				postgres: "jsonb",
+				mysql: "json",
+				mssql: "varchar(8000)"
+			},
+			id: {
+				postgres: useNumberId ? sql`integer GENERATED BY DEFAULT AS IDENTITY` : useUUIDs ? "uuid" : "text",
+				mysql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				mssql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				sqlite: useNumberId ? "integer" : "text"
+			},
+			foreignKeyId: {
+				postgres: useNumberId ? "integer" : useUUIDs ? "uuid" : "text",
+				mysql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				mssql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				sqlite: useNumberId ? "integer" : "text"
+			}
+		};
+		if (fieldName === "id" || field.references?.field === "id") {
+			if (fieldName === "id") return typeMap.id[dbType];
+			return typeMap.foreignKeyId[dbType];
+		}
+		if (dbType === "sqlite" && (type === "string[]" || type === "number[]")) return "text";
+		if (type === "string[]" || type === "number[]") return "jsonb";
+		if (Array.isArray(type)) return "text";
+		return typeMap[type][dbType || "sqlite"];
+	}
+	const getModelName = initGetModelName({
+		schema: getAuthTables(config),
+		usePlural: false
+	});
+	const getFieldName = initGetFieldName({
+		schema: getAuthTables(config),
+		usePlural: false
+	});
+	function getReferencePath(model, field) {
+		try {
+			return `${getModelName(model)}.${getFieldName({
+				model,
+				field
+			})}`;
+		} catch {
+			return `${model}.${field}`;
+		}
+	}
+	if (toBeAdded.length) for (const table of toBeAdded) for (const [fieldName, field] of Object.entries(table.fields)) {
+		const type = getType(field, fieldName);
+		let builder = db.schema.alterTable(table.table);
+		if (field.index) builder = builder.addIndex(`${table.table}_${fieldName}_idx`);
+		let built = builder.addColumn(fieldName, type, (col) => {
+			col = field.required !== false ? col.notNull() : col;
+			if (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || "cascade");
+			if (field.unique) col = col.unique();
+			if (field.type === "date" && typeof field.defaultValue === "function" && (dbType === "postgres" || dbType === "mysql" || dbType === "mssql")) if (dbType === "mysql") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);
+			else col = col.defaultTo(sql`CURRENT_TIMESTAMP`);
+			return col;
+		});
+		migrations.push(built);
+	}
+	let toBeIndexed = [];
+	if (config.advanced?.database?.useNumberId) logger$1.warn("`useNumberId` is deprecated. Please use `generateId` with `serial` instead.");
+	if (toBeCreated.length) for (const table of toBeCreated) {
+		const idType = getType({ type: useNumberId ? "number" : "string" }, "id");
+		let dbT = db.schema.createTable(table.table).addColumn("id", idType, (col) => {
+			if (useNumberId) {
+				if (dbType === "postgres") return col.primaryKey().notNull();
+				else if (dbType === "sqlite") return col.primaryKey().notNull();
+				else if (dbType === "mssql") return col.identity().primaryKey().notNull();
+				return col.autoIncrement().primaryKey().notNull();
+			}
+			if (useUUIDs) {
+				if (dbType === "postgres") return col.primaryKey().defaultTo(sql`pg_catalog.gen_random_uuid()`).notNull();
+				return col.primaryKey().notNull();
+			}
+			return col.primaryKey().notNull();
+		});
+		for (const [fieldName, field] of Object.entries(table.fields)) {
+			const type = getType(field, fieldName);
+			dbT = dbT.addColumn(fieldName, type, (col) => {
+				col = field.required !== false ? col.notNull() : col;
+				if (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || "cascade");
+				if (field.unique) col = col.unique();
+				if (field.type === "date" && typeof field.defaultValue === "function" && (dbType === "postgres" || dbType === "mysql" || dbType === "mssql")) if (dbType === "mysql") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);
+				else col = col.defaultTo(sql`CURRENT_TIMESTAMP`);
+				return col;
+			});
+			if (field.index) {
+				let builder = db.schema.createIndex(`${table.table}_${fieldName}_${field.unique ? "uidx" : "idx"}`).on(table.table).columns([fieldName]);
+				toBeIndexed.push(field.unique ? builder.unique() : builder);
+			}
+		}
+		migrations.push(dbT);
+	}
+	if (toBeIndexed.length) for (const index of toBeIndexed) migrations.push(index);
+	async function runMigrations() {
+		for (const migration of migrations) await migration.execute();
+	}
+	async function compileMigrations() {
+		return migrations.map((m) => m.compile().sql).join(";\n\n") + ";";
+	}
+	return {
+		toBeCreated,
+		toBeAdded,
+		runMigrations,
+		compileMigrations
+	};
+}
+
+//#endregion
+export { createInternalAdapter as a, convertToDB as c, getBaseAdapter as d, toZodSchema as i, createFieldAttribute as l, matchType as n, getWithHooks as o, getSchema as r, convertFromDB as s, getMigrations as t, getAdapter as u };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs.bak2 b/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs.bak2
new file mode 100644
index 0000000..55c862e
--- /dev/null
+++ b/node_modules/better-auth/dist/get-migration-C1tgKlQ6.mjs.bak2
@@ -0,0 +1,1174 @@
+import { t as createKyselyAdapter } from "./dialect-BhkkSrrx.mjs";
+import { a as getAuthTables, n as initGetFieldName, t as initGetModelName } from "./get-model-name-nJd9iPTo.mjs";
+import { t as generateId } from "./utils-F62c-ieM.mjs";
+import { l as parseUserOutput, s as parseSessionOutput, u as getDate } from "./schema-BevzneML.mjs";
+import { t as getIp } from "./get-request-ip-kbu825ez.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { getCurrentAdapter, getCurrentAuthContext, runWithTransaction } from "@better-auth/core/context";
+import { createLogger, logger } from "@better-auth/core/env";
+import { BetterAuthError } from "@better-auth/core/error";
+import { sql } from "kysely";
+import * as z from "zod";
+
+//#region src/db/adapter-base.ts
+async function getBaseAdapter(options, handleDirectDatabase) {
+	let adapter;
+	if (!options.database) {
+		const tables = getAuthTables(options);
+		const memoryDB = Object.keys(tables).reduce((acc, key) => {
+			acc[key] = [];
+			return acc;
+		}, {});
+		const { memoryAdapter } = await import("./adapters/memory-adapter/index.mjs");
+		adapter = memoryAdapter(memoryDB)(options);
+	} else if (typeof options.database === "function") adapter = options.database(options);
+	else adapter = await handleDirectDatabase(options);
+	if (!adapter.transaction) {
+		logger.warn("Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.");
+		adapter.transaction = async (cb) => {
+			return cb(adapter);
+		};
+	}
+	return adapter;
+}
+
+//#endregion
+//#region src/db/adapter-kysely.ts
+async function getAdapter(options) {
+	return getBaseAdapter(options, async (opts) => {
+		const { createKyselyAdapter: createKyselyAdapter$1 } = await import("./adapters/kysely-adapter/index.mjs");
+		const { kysely, databaseType, transaction } = await createKyselyAdapter$1(opts);
+		if (!kysely) throw new BetterAuthError("Failed to initialize database adapter");
+		const { kyselyAdapter } = await import("./adapters/kysely-adapter/index.mjs");
+		return kyselyAdapter(kysely, {
+			type: databaseType || "sqlite",
+			debugLogs: opts.database && "debugLogs" in opts.database ? opts.database.debugLogs : false,
+			transaction
+		})(opts);
+	});
+}
+
+//#endregion
+//#region src/db/field.ts
+const createFieldAttribute = (type, config) => {
+	return {
+		type,
+		...config
+	};
+};
+
+//#endregion
+//#region src/db/field-converter.ts
+function convertToDB(fields, values) {
+	let result = values.id ? { id: values.id } : {};
+	for (const key in fields) {
+		const field = fields[key];
+		const value = values[key];
+		if (value === void 0) continue;
+		result[field.fieldName || key] = value;
+	}
+	return result;
+}
+function convertFromDB(fields, values) {
+	if (!values) return null;
+	let result = { id: values.id };
+	for (const [key, value] of Object.entries(fields)) result[key] = values[value.fieldName || key];
+	return result;
+}
+
+//#endregion
+//#region src/db/with-hooks.ts
+function getWithHooks(adapter, ctx) {
+	const hooks = ctx.hooks;
+	async function createWithHooks(data, model, customCreateFn) {
+		const context = await getCurrentAuthContext();
+		let actualData = data;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.create?.before;
+			if (toRun) {
+				const result = await toRun(actualData, context);
+				if (result === false) return null;
+				if (typeof result === "object" && "data" in result) actualData = {
+					...actualData,
+					...result.data
+				};
+			}
+		}
+		const customCreated = customCreateFn ? await customCreateFn.fn(actualData) : null;
+		const created = !customCreateFn || customCreateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).create({
+			model,
+			data: actualData,
+			forceAllowId: true
+		}) : customCreated;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.create?.after;
+			if (toRun) await toRun(created, context);
+		}
+		return created;
+	}
+	async function updateWithHooks(data, where, model, customUpdateFn) {
+		const context = await getCurrentAuthContext();
+		let actualData = data;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.before;
+			if (toRun) {
+				const result = await toRun(data, context);
+				if (result === false) return null;
+				if (typeof result === "object" && "data" in result) actualData = {
+					...actualData,
+					...result.data
+				};
+			}
+		}
+		const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
+		const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).update({
+			model,
+			update: actualData,
+			where
+		}) : customUpdated;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.after;
+			if (toRun) await toRun(updated, context);
+		}
+		return updated;
+	}
+	async function updateManyWithHooks(data, where, model, customUpdateFn) {
+		const context = await getCurrentAuthContext();
+		let actualData = data;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.before;
+			if (toRun) {
+				const result = await toRun(data, context);
+				if (result === false) return null;
+				if (typeof result === "object" && "data" in result) actualData = {
+					...actualData,
+					...result.data
+				};
+			}
+		}
+		const customUpdated = customUpdateFn ? await customUpdateFn.fn(actualData) : null;
+		const updated = !customUpdateFn || customUpdateFn.executeMainFn ? await (await getCurrentAdapter(adapter)).updateMany({
+			model,
+			update: actualData,
+			where
+		}) : customUpdated;
+		for (const hook of hooks || []) {
+			const toRun = hook[model]?.update?.after;
+			if (toRun) await toRun(updated, context);
+		}
+		return updated;
+	}
+	async function deleteWithHooks(where, model, customDeleteFn) {
+		const context = await getCurrentAuthContext();
+		let entityToDelete = null;
+		try {
+			entityToDelete = (await (await getCurrentAdapter(adapter)).findMany({
+				model,
+				where,
+				limit: 1
+			}))[0] || null;
+		} catch (error) {}
+		if (entityToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.before;
+			if (toRun) {
+				if (await toRun(entityToDelete, context) === false) return null;
+			}
+		}
+		const customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;
+		const deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).delete({
+			model,
+			where
+		}) : customDeleted;
+		if (entityToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.after;
+			if (toRun) await toRun(entityToDelete, context);
+		}
+		return deleted;
+	}
+	async function deleteManyWithHooks(where, model, customDeleteFn) {
+		const context = await getCurrentAuthContext();
+		let entitiesToDelete = [];
+		try {
+			entitiesToDelete = await (await getCurrentAdapter(adapter)).findMany({
+				model,
+				where
+			});
+		} catch (error) {}
+		for (const entity of entitiesToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.before;
+			if (toRun) {
+				if (await toRun(entity, context) === false) return null;
+			}
+		}
+		const customDeleted = customDeleteFn ? await customDeleteFn.fn(where) : null;
+		const deleted = !customDeleteFn || customDeleteFn.executeMainFn ? await (await getCurrentAdapter(adapter)).deleteMany({
+			model,
+			where
+		}) : customDeleted;
+		for (const entity of entitiesToDelete) for (const hook of hooks || []) {
+			const toRun = hook[model]?.delete?.after;
+			if (toRun) await toRun(entity, context);
+		}
+		return deleted;
+	}
+	return {
+		createWithHooks,
+		updateWithHooks,
+		updateManyWithHooks,
+		deleteWithHooks,
+		deleteManyWithHooks
+	};
+}
+
+//#endregion
+//#region src/db/internal-adapter.ts
+const createInternalAdapter = (adapter, ctx) => {
+	const logger$1 = ctx.logger;
+	const options = ctx.options;
+	const secondaryStorage = options.secondaryStorage;
+	const sessionExpiration = options.session?.expiresIn || 3600 * 24 * 7;
+	const { createWithHooks, updateWithHooks, updateManyWithHooks, deleteWithHooks, deleteManyWithHooks } = getWithHooks(adapter, ctx);
+	async function refreshUserSessions(user) {
+		if (!secondaryStorage) return;
+		const listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);
+		if (!listRaw) return;
+		const now = Date.now();
+		const validSessions = (safeJSONParse(listRaw) || []).filter((s) => s.expiresAt > now);
+		await Promise.all(validSessions.map(async ({ token }) => {
+			const cached = await secondaryStorage.get(token);
+			if (!cached) return;
+			const parsed = safeJSONParse(cached);
+			if (!parsed) return;
+			const sessionTTL = Math.max(Math.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1e3, 0);
+			await secondaryStorage.set(token, JSON.stringify({
+				session: parsed.session,
+				user
+			}), Math.floor(sessionTTL));
+		}));
+	}
+	return {
+		createOAuthUser: async (user, account) => {
+			return runWithTransaction(adapter, async () => {
+				const createdUser = await createWithHooks({
+					createdAt: /* @__PURE__ */ new Date(),
+					updatedAt: /* @__PURE__ */ new Date(),
+					...user
+				}, "user", void 0);
+				return {
+					user: createdUser,
+					account: await createWithHooks({
+						...account,
+						userId: createdUser.id,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}, "account", void 0)
+				};
+			});
+		},
+		createUser: async (user) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...user,
+				email: user.email?.toLowerCase()
+			}, "user", void 0);
+		},
+		createAccount: async (account) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...account
+			}, "account", void 0);
+		},
+		listSessions: async (userId) => {
+			if (secondaryStorage) {
+				const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
+				if (!currentList) return [];
+				const list = safeJSONParse(currentList) || [];
+				const now = Date.now();
+				const validSessions = list.filter((s) => s.expiresAt > now);
+				const sessions = [];
+				for (const session of validSessions) {
+					const sessionStringified = await secondaryStorage.get(session.token);
+					if (sessionStringified) {
+						const s = safeJSONParse(sessionStringified);
+						if (!s) return [];
+						const parsedSession = parseSessionOutput(ctx.options, {
+							...s.session,
+							expiresAt: new Date(s.session.expiresAt)
+						});
+						sessions.push(parsedSession);
+					}
+				}
+				return sessions;
+			}
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "session",
+				where: [{
+					field: "userId",
+					value: userId
+				}]
+			});
+		},
+		listUsers: async (limit, offset, sortBy, where) => {
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "user",
+				limit,
+				offset,
+				sortBy,
+				where
+			});
+		},
+		countTotalUsers: async (where) => {
+			const total = await (await getCurrentAdapter(adapter)).count({
+				model: "user",
+				where
+			});
+			if (typeof total === "string") return parseInt(total);
+			return total;
+		},
+		deleteUser: async (userId) => {
+			if (secondaryStorage) await secondaryStorage.delete(`active-sessions-${userId}`);
+			if (!secondaryStorage || options.session?.storeSessionInDatabase) await deleteManyWithHooks([{
+				field: "userId",
+				value: userId
+			}], "session", void 0);
+			await deleteManyWithHooks([{
+				field: "userId",
+				value: userId
+			}], "account", void 0);
+			await deleteWithHooks([{
+				field: "id",
+				value: userId
+			}], "user", void 0);
+		},
+		createSession: async (userId, dontRememberMe, override, overrideAll) => {
+			const ctx$1 = await getCurrentAuthContext();
+			const headers = ctx$1.headers || ctx$1.request?.headers;
+			const { id: _,...rest } = override || {};
+			const data = {
+				ipAddress: ctx$1.request || ctx$1.headers ? getIp(ctx$1.request || ctx$1.headers, ctx$1.context.options) || "" : "",
+				userAgent: headers?.get("user-agent") || "",
+				...rest,
+				expiresAt: dontRememberMe ? getDate(3600 * 24, "sec") : getDate(sessionExpiration, "sec"),
+				userId,
+				token: generateId(32),
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...overrideAll ? rest : {}
+			};
+			return await createWithHooks(data, "session", secondaryStorage ? {
+				fn: async (sessionData) => {
+					/**
+					* store the session token for the user
+					* so we can retrieve it later for listing sessions
+					*/
+					const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
+					let list = [];
+					const now = Date.now();
+					if (currentList) {
+						list = safeJSONParse(currentList) || [];
+						list = list.filter((session) => session.expiresAt > now);
+					}
+					const sorted = list.sort((a, b) => a.expiresAt - b.expiresAt);
+					let furthestSessionExp = sorted.at(-1)?.expiresAt;
+					sorted.push({
+						token: data.token,
+						expiresAt: data.expiresAt.getTime()
+					});
+					if (!furthestSessionExp || furthestSessionExp < data.expiresAt.getTime()) furthestSessionExp = data.expiresAt.getTime();
+					const furthestSessionTTL = Math.max(Math.floor((furthestSessionExp - now) / 1e3), 0);
+					if (furthestSessionTTL > 0) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(sorted), furthestSessionTTL);
+					const user = await adapter.findOne({
+						model: "user",
+						where: [{
+							field: "id",
+							value: userId
+						}]
+					});
+					const sessionTTL = Math.max(Math.floor((data.expiresAt.getTime() - now) / 1e3), 0);
+					if (sessionTTL > 0) await secondaryStorage.set(data.token, JSON.stringify({
+						session: sessionData,
+						user
+					}), sessionTTL);
+					return sessionData;
+				},
+				executeMainFn: options.session?.storeSessionInDatabase
+			} : void 0);
+		},
+		findSession: async (token) => {
+			if (secondaryStorage) {
+				const sessionStringified = await secondaryStorage.get(token);
+				if (!sessionStringified && !options.session?.storeSessionInDatabase) return null;
+				if (sessionStringified) {
+					const s = safeJSONParse(sessionStringified);
+					if (!s) return null;
+					return {
+						session: parseSessionOutput(ctx.options, {
+							...s.session,
+							expiresAt: new Date(s.session.expiresAt),
+							createdAt: new Date(s.session.createdAt),
+							updatedAt: new Date(s.session.updatedAt)
+						}),
+						user: parseUserOutput(ctx.options, {
+							...s.user,
+							createdAt: new Date(s.user.createdAt),
+							updatedAt: new Date(s.user.updatedAt)
+						})
+					};
+				}
+			}
+			const session = await (await getCurrentAdapter(adapter)).findOne({
+				model: "session",
+				where: [{
+					value: token,
+					field: "token"
+				}]
+			});
+			if (!session) return null;
+			const user = await (await getCurrentAdapter(adapter)).findOne({
+				model: "user",
+				where: [{
+					value: session.userId,
+					field: "id"
+				}]
+			});
+			if (!user) return null;
+			return {
+				session: parseSessionOutput(ctx.options, session),
+				user: parseUserOutput(ctx.options, user)
+			};
+		},
+		findSessions: async (sessionTokens) => {
+			if (secondaryStorage) {
+				const sessions$1 = [];
+				for (const sessionToken of sessionTokens) {
+					const sessionStringified = await secondaryStorage.get(sessionToken);
+					if (sessionStringified) {
+						const s = safeJSONParse(sessionStringified);
+						if (!s) return [];
+						const session = {
+							session: {
+								...s.session,
+								expiresAt: new Date(s.session.expiresAt)
+							},
+							user: {
+								...s.user,
+								createdAt: new Date(s.user.createdAt),
+								updatedAt: new Date(s.user.updatedAt)
+							}
+						};
+						sessions$1.push(session);
+					}
+				}
+				return sessions$1;
+			}
+			const sessions = await (await getCurrentAdapter(adapter)).findMany({
+				model: "session",
+				where: [{
+					field: "token",
+					value: sessionTokens,
+					operator: "in"
+				}]
+			});
+			const userIds = sessions.map((session) => {
+				return session.userId;
+			});
+			if (!userIds.length) return [];
+			const users = await (await getCurrentAdapter(adapter)).findMany({
+				model: "user",
+				where: [{
+					field: "id",
+					value: userIds,
+					operator: "in"
+				}]
+			});
+			return sessions.map((session) => {
+				const user = users.find((u) => u.id === session.userId);
+				if (!user) return null;
+				return {
+					session,
+					user
+				};
+			});
+		},
+		updateSession: async (sessionToken, session) => {
+			return await updateWithHooks(session, [{
+				field: "token",
+				value: sessionToken
+			}], "session", secondaryStorage ? {
+				async fn(data) {
+					const currentSession = await secondaryStorage.get(sessionToken);
+					let updatedSession = null;
+					if (currentSession) {
+						const parsedSession = safeJSONParse(currentSession);
+						if (!parsedSession) return null;
+						updatedSession = {
+							...parsedSession.session,
+							...data
+						};
+						return updatedSession;
+					} else return null;
+				},
+				executeMainFn: options.session?.storeSessionInDatabase
+			} : void 0);
+		},
+		deleteSession: async (token) => {
+			if (secondaryStorage) {
+				const data = await secondaryStorage.get(token);
+				if (data) {
+					const { session } = safeJSONParse(data) ?? {};
+					if (!session) {
+						logger$1.error("Session not found in secondary storage");
+						return;
+					}
+					const userId = session.userId;
+					const currentList = await secondaryStorage.get(`active-sessions-${userId}`);
+					if (currentList) {
+						let list = safeJSONParse(currentList) || [];
+						const now = Date.now();
+						const filtered = list.filter((session$1) => session$1.expiresAt > now && session$1.token !== token);
+						const furthestSessionExp = filtered.sort((a, b) => a.expiresAt - b.expiresAt).at(-1)?.expiresAt;
+						if (filtered.length > 0 && furthestSessionExp && furthestSessionExp > Date.now()) await secondaryStorage.set(`active-sessions-${userId}`, JSON.stringify(filtered), Math.floor((furthestSessionExp - now) / 1e3));
+						else await secondaryStorage.delete(`active-sessions-${userId}`);
+					} else logger$1.error("Active sessions list not found in secondary storage");
+				}
+				await secondaryStorage.delete(token);
+				if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;
+			}
+			await (await getCurrentAdapter(adapter)).delete({
+				model: "session",
+				where: [{
+					field: "token",
+					value: token
+				}]
+			});
+		},
+		deleteAccounts: async (userId) => {
+			await deleteManyWithHooks([{
+				field: "userId",
+				value: userId
+			}], "account", void 0);
+		},
+		deleteAccount: async (accountId) => {
+			await deleteWithHooks([{
+				field: "id",
+				value: accountId
+			}], "account", void 0);
+		},
+		deleteSessions: async (userIdOrSessionTokens) => {
+			if (secondaryStorage) {
+				if (typeof userIdOrSessionTokens === "string") {
+					const activeSession = await secondaryStorage.get(`active-sessions-${userIdOrSessionTokens}`);
+					const sessions = activeSession ? safeJSONParse(activeSession) : [];
+					if (!sessions) return;
+					for (const session of sessions) await secondaryStorage.delete(session.token);
+				} else for (const sessionToken of userIdOrSessionTokens) if (await secondaryStorage.get(sessionToken)) await secondaryStorage.delete(sessionToken);
+				if (!options.session?.storeSessionInDatabase || ctx.options.session?.preserveSessionInDatabase) return;
+			}
+			await deleteManyWithHooks([{
+				field: Array.isArray(userIdOrSessionTokens) ? "token" : "userId",
+				value: userIdOrSessionTokens,
+				operator: Array.isArray(userIdOrSessionTokens) ? "in" : void 0
+			}], "session", void 0);
+		},
+		findOAuthUser: async (email, accountId, providerId) => {
+			const account = await (await getCurrentAdapter(adapter)).findMany({
+				model: "account",
+				where: [{
+					value: accountId,
+					field: "accountId"
+				}]
+			}).then((accounts) => {
+				return accounts.find((a) => a.providerId === providerId);
+			});
+			if (account) {
+				const user = await (await getCurrentAdapter(adapter)).findOne({
+					model: "user",
+					where: [{
+						value: account.userId,
+						field: "id"
+					}]
+				});
+				if (user) return {
+					user,
+					accounts: [account]
+				};
+				else {
+					const user$1 = await (await getCurrentAdapter(adapter)).findOne({
+						model: "user",
+						where: [{
+							value: email.toLowerCase(),
+							field: "email"
+						}]
+					});
+					if (user$1) return {
+						user: user$1,
+						accounts: [account]
+					};
+					return null;
+				}
+			} else {
+				const user = await (await getCurrentAdapter(adapter)).findOne({
+					model: "user",
+					where: [{
+						value: email.toLowerCase(),
+						field: "email"
+					}]
+				});
+				if (user) return {
+					user,
+					accounts: await (await getCurrentAdapter(adapter)).findMany({
+						model: "account",
+						where: [{
+							value: user.id,
+							field: "userId"
+						}]
+					}) || []
+				};
+				else return null;
+			}
+		},
+		findUserByEmail: async (email, options$1) => {
+			const user = await (await getCurrentAdapter(adapter)).findOne({
+				model: "user",
+				where: [{
+					value: email.toLowerCase(),
+					field: "email"
+				}]
+			});
+			if (!user) return null;
+			if (options$1?.includeAccounts) return {
+				user,
+				accounts: await (await getCurrentAdapter(adapter)).findMany({
+					model: "account",
+					where: [{
+						value: user.id,
+						field: "userId"
+					}]
+				})
+			};
+			return {
+				user,
+				accounts: []
+			};
+		},
+		findUserById: async (userId) => {
+			return await (await getCurrentAdapter(adapter)).findOne({
+				model: "user",
+				where: [{
+					field: "id",
+					value: userId
+				}]
+			});
+		},
+		linkAccount: async (account) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...account
+			}, "account", void 0);
+		},
+		updateUser: async (userId, data) => {
+			const user = await updateWithHooks(data, [{
+				field: "id",
+				value: userId
+			}], "user", void 0);
+			await refreshUserSessions(user);
+			await refreshUserSessions(user);
+			return user;
+		},
+		updateUserByEmail: async (email, data) => {
+			const user = await updateWithHooks(data, [{
+				field: "email",
+				value: email.toLowerCase()
+			}], "user", void 0);
+			await refreshUserSessions(user);
+			await refreshUserSessions(user);
+			return user;
+		},
+		updatePassword: async (userId, password) => {
+			await updateManyWithHooks({ password }, [{
+				field: "userId",
+				value: userId
+			}, {
+				field: "providerId",
+				value: "credential"
+			}], "account", void 0);
+		},
+		findAccounts: async (userId) => {
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "account",
+				where: [{
+					field: "userId",
+					value: userId
+				}]
+			});
+		},
+		findAccount: async (accountId) => {
+			return await (await getCurrentAdapter(adapter)).findOne({
+				model: "account",
+				where: [{
+					field: "accountId",
+					value: accountId
+				}]
+			});
+		},
+		findAccountByProviderId: async (accountId, providerId) => {
+			return await (await getCurrentAdapter(adapter)).findOne({
+				model: "account",
+				where: [{
+					field: "accountId",
+					value: accountId
+				}, {
+					field: "providerId",
+					value: providerId
+				}]
+			});
+		},
+		findAccountByUserId: async (userId) => {
+			return await (await getCurrentAdapter(adapter)).findMany({
+				model: "account",
+				where: [{
+					field: "userId",
+					value: userId
+				}]
+			});
+		},
+		updateAccount: async (id, data) => {
+			return await updateWithHooks(data, [{
+				field: "id",
+				value: id
+			}], "account", void 0);
+		},
+		createVerificationValue: async (data) => {
+			return await createWithHooks({
+				createdAt: /* @__PURE__ */ new Date(),
+				updatedAt: /* @__PURE__ */ new Date(),
+				...data
+			}, "verification", void 0);
+		},
+		findVerificationValue: async (identifier) => {
+			const verification = await (await getCurrentAdapter(adapter)).findMany({
+				model: "verification",
+				where: [{
+					field: "identifier",
+					value: identifier
+				}],
+				sortBy: {
+					field: "createdAt",
+					direction: "desc"
+				},
+				limit: 1
+			});
+			if (!options.verification?.disableCleanup) await (await getCurrentAdapter(adapter)).deleteMany({
+				model: "verification",
+				where: [{
+					field: "expiresAt",
+					value: /* @__PURE__ */ new Date(),
+					operator: "lt"
+				}]
+			});
+			return verification[0];
+		},
+		deleteVerificationValue: async (id) => {
+			await (await getCurrentAdapter(adapter)).delete({
+				model: "verification",
+				where: [{
+					field: "id",
+					value: id
+				}]
+			});
+		},
+		deleteVerificationByIdentifier: async (identifier) => {
+			await (await getCurrentAdapter(adapter)).delete({
+				model: "verification",
+				where: [{
+					field: "identifier",
+					value: identifier
+				}]
+			});
+		},
+		updateVerificationValue: async (id, data) => {
+			return await updateWithHooks(data, [{
+				field: "id",
+				value: id
+			}], "verification", void 0);
+		}
+	};
+};
+
+//#endregion
+//#region src/db/to-zod.ts
+function toZodSchema({ fields, isClientSide }) {
+	const zodFields = Object.keys(fields).reduce((acc, key) => {
+		const field = fields[key];
+		if (!field) return acc;
+		if (isClientSide && field.input === false) return acc;
+		let schema;
+		if (field.type === "json") schema = z.any();
+		else if (field.type === "string[]" || field.type === "number[]") schema = z.array(field.type === "string[]" ? z.string() : z.number());
+		else if (Array.isArray(field.type)) schema = z.any();
+		else if (field.type === "json") schema = z.any(); else schema = z[field.type]();
+		if (field?.required === false) schema = schema.optional();
+		if (field?.returned === false) return acc;
+		return {
+			...acc,
+			[key]: schema
+		};
+	}, {});
+	return z.object(zodFields);
+}
+
+//#endregion
+//#region src/db/get-schema.ts
+function getSchema(config) {
+	const tables = getAuthTables(config);
+	let schema = {};
+	for (const key in tables) {
+		const table = tables[key];
+		const fields = table.fields;
+		let actualFields = {};
+		Object.entries(fields).forEach(([key$1, field]) => {
+			actualFields[field.fieldName || key$1] = field;
+			if (field.references) {
+				const refTable = tables[field.references.model];
+				if (refTable) actualFields[field.fieldName || key$1].references = {
+					...field.references,
+					model: refTable.modelName,
+					field: field.references.field
+				};
+			}
+		});
+		if (schema[table.modelName]) {
+			schema[table.modelName].fields = {
+				...schema[table.modelName].fields,
+				...actualFields
+			};
+			continue;
+		}
+		schema[table.modelName] = {
+			fields: actualFields,
+			order: table.order || Infinity
+		};
+	}
+	return schema;
+}
+
+//#endregion
+//#region src/db/get-migration.ts
+const map = {
+	postgres: {
+		string: [
+			"character varying",
+			"varchar",
+			"text",
+			"uuid"
+		],
+		number: [
+			"int4",
+			"integer",
+			"bigint",
+			"smallint",
+			"numeric",
+			"real",
+			"double precision"
+		],
+		boolean: ["bool", "boolean"],
+		date: [
+			"timestamptz",
+			"timestamp",
+			"date"
+		],
+		json: ["json", "jsonb"]
+	},
+	mysql: {
+		string: [
+			"varchar",
+			"text",
+			"uuid"
+		],
+		number: [
+			"integer",
+			"int",
+			"bigint",
+			"smallint",
+			"decimal",
+			"float",
+			"double"
+		],
+		boolean: ["boolean", "tinyint"],
+		date: [
+			"timestamp",
+			"datetime",
+			"date"
+		],
+		json: ["json"]
+	},
+	sqlite: {
+		string: ["TEXT"],
+		number: ["INTEGER", "REAL"],
+		boolean: ["INTEGER", "BOOLEAN"],
+		date: ["DATE", "INTEGER"],
+		json: ["TEXT"]
+	},
+	mssql: {
+		string: [
+			"varchar",
+			"nvarchar",
+			"uniqueidentifier"
+		],
+		number: [
+			"int",
+			"bigint",
+			"smallint",
+			"decimal",
+			"float",
+			"double"
+		],
+		boolean: ["bit", "smallint"],
+		date: [
+			"datetime2",
+			"date",
+			"datetime"
+		],
+		json: ["varchar", "nvarchar"]
+	}
+};
+function matchType(columnDataType, fieldType, dbType) {
+	function normalize(type) {
+		return type.toLowerCase().split("(")[0].trim();
+	}
+	if (fieldType === "string[]" || fieldType === "number[]") return columnDataType.toLowerCase().includes("json");
+	const types = map[dbType];
+	return (Array.isArray(fieldType) ? types["string"].map((t) => t.toLowerCase()) : types[fieldType].map((t) => t.toLowerCase())).includes(normalize(columnDataType));
+}
+/**
+* Get the current PostgreSQL schema (search_path) for the database connection
+* Returns the first schema in the search_path, defaulting to 'public' if not found
+*/
+async function getPostgresSchema(db) {
+	try {
+		const result = await sql`SHOW search_path`.execute(db);
+		if (result.rows[0]?.search_path) return result.rows[0].search_path.split(",").map((s) => s.trim()).map((s) => s.replace(/^["']|["']$/g, "")).filter((s) => !s.startsWith("$"))[0] || "public";
+	} catch (error) {}
+	return "public";
+}
+async function getMigrations(config) {
+	const betterAuthSchema = getSchema(config);
+	const logger$1 = createLogger(config.logger);
+	let { kysely: db, databaseType: dbType } = await createKyselyAdapter(config);
+	if (!dbType) {
+		logger$1.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.");
+		dbType = "sqlite";
+	}
+	if (!db) {
+		logger$1.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.");
+		process.exit(1);
+	}
+	let currentSchema = "public";
+	if (dbType === "postgres") {
+		currentSchema = await getPostgresSchema(db);
+		logger$1.debug(`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`);
+		try {
+			if (!(await sql`
+				SELECT schema_name 
+				FROM information_schema.schemata 
+				WHERE schema_name = ${currentSchema}
+			`.execute(db)).rows[0]) logger$1.warn(`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`);
+		} catch (error) {
+			logger$1.debug(`Could not verify schema existence: ${error instanceof Error ? error.message : String(error)}`);
+		}
+	}
+	const allTableMetadata = await db.introspection.getTables();
+	let tableMetadata = allTableMetadata;
+	if (dbType === "postgres") try {
+		const tablesInSchema = await sql`
+				SELECT table_name 
+				FROM information_schema.tables 
+				WHERE table_schema = ${currentSchema}
+				AND table_type = 'BASE TABLE'
+			`.execute(db);
+		const tableNamesInSchema = new Set(tablesInSchema.rows.map((row) => row.table_name));
+		tableMetadata = allTableMetadata.filter((table) => table.schema === currentSchema && tableNamesInSchema.has(table.name));
+		logger$1.debug(`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t) => t.name).join(", ") || "(none)"}`);
+	} catch (error) {
+		logger$1.warn(`Could not filter tables by schema. Using all discovered tables. Error: ${error instanceof Error ? error.message : String(error)}`);
+	}
+	const toBeCreated = [];
+	const toBeAdded = [];
+	for (const [key, value] of Object.entries(betterAuthSchema)) {
+		const table = tableMetadata.find((t) => t.name === key);
+		if (!table) {
+			const tIndex = toBeCreated.findIndex((t) => t.table === key);
+			const tableData = {
+				table: key,
+				fields: value.fields,
+				order: value.order || Infinity
+			};
+			const insertIndex = toBeCreated.findIndex((t) => (t.order || Infinity) > tableData.order);
+			if (insertIndex === -1) if (tIndex === -1) toBeCreated.push(tableData);
+			else toBeCreated[tIndex].fields = {
+				...toBeCreated[tIndex].fields,
+				...value.fields
+			};
+			else toBeCreated.splice(insertIndex, 0, tableData);
+			continue;
+		}
+		let toBeAddedFields = {};
+		for (const [fieldName, field] of Object.entries(value.fields)) {
+			const column = table.columns.find((c) => c.name === fieldName);
+			if (!column) {
+				toBeAddedFields[fieldName] = field;
+				continue;
+			}
+			if (matchType(column.dataType, field.type, dbType)) continue;
+			else logger$1.warn(`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`);
+		}
+		if (Object.keys(toBeAddedFields).length > 0) toBeAdded.push({
+			table: key,
+			fields: toBeAddedFields,
+			order: value.order || Infinity
+		});
+	}
+	const migrations = [];
+	const useUUIDs = config.advanced?.database?.generateId === "uuid";
+	const useNumberId = config.advanced?.database?.useNumberId || config.advanced?.database?.generateId === "serial";
+	function getType(field, fieldName) {
+		const type = field.type;
+		const typeMap = {
+			string: {
+				sqlite: "text",
+				postgres: "text",
+				mysql: field.unique ? "varchar(255)" : field.references ? "varchar(36)" : field.sortable ? "varchar(255)" : field.index ? "varchar(255)" : "text",
+				mssql: field.unique || field.sortable ? "varchar(255)" : field.references ? "varchar(36)" : "varchar(8000)"
+			},
+			boolean: {
+				sqlite: "integer",
+				postgres: "boolean",
+				mysql: "boolean",
+				mssql: "smallint"
+			},
+			number: {
+				sqlite: field.bigint ? "bigint" : "integer",
+				postgres: field.bigint ? "bigint" : "integer",
+				mysql: field.bigint ? "bigint" : "integer",
+				mssql: field.bigint ? "bigint" : "integer"
+			},
+			date: {
+				sqlite: "date",
+				postgres: "timestamptz",
+				mysql: "timestamp(3)",
+				mssql: sql`datetime2(3)`
+			},
+			json: {
+				sqlite: "text",
+				postgres: "jsonb",
+				mysql: "json",
+				mssql: "varchar(8000)"
+			},
+			id: {
+				postgres: useNumberId ? sql`integer GENERATED BY DEFAULT AS IDENTITY` : useUUIDs ? "uuid" : "text",
+				mysql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				mssql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				sqlite: useNumberId ? "integer" : "text"
+			},
+			foreignKeyId: {
+				postgres: useNumberId ? "integer" : useUUIDs ? "uuid" : "text",
+				mysql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				mssql: useNumberId ? "integer" : useUUIDs ? "varchar(36)" : "varchar(36)",
+				sqlite: useNumberId ? "integer" : "text"
+			}
+		};
+		if (fieldName === "id" || field.references?.field === "id") {
+			if (fieldName === "id") return typeMap.id[dbType];
+			return typeMap.foreignKeyId[dbType];
+		}
+		if (dbType === "sqlite" && (type === "string[]" || type === "number[]")) return "text";
+		if (type === "string[]" || type === "number[]") return "jsonb";
+		if (Array.isArray(type)) return "text";
+		return typeMap[type][dbType || "sqlite"];
+	}
+	const getModelName = initGetModelName({
+		schema: getAuthTables(config),
+		usePlural: false
+	});
+	const getFieldName = initGetFieldName({
+		schema: getAuthTables(config),
+		usePlural: false
+	});
+	function getReferencePath(model, field) {
+		try {
+			return `${getModelName(model)}.${getFieldName({
+				model,
+				field
+			})}`;
+		} catch {
+			return `${model}.${field}`;
+		}
+	}
+	if (toBeAdded.length) for (const table of toBeAdded) for (const [fieldName, field] of Object.entries(table.fields)) {
+		const type = getType(field, fieldName);
+		let builder = db.schema.alterTable(table.table);
+		if (field.index) builder = builder.addIndex(`${table.table}_${fieldName}_idx`);
+		let built = builder.addColumn(fieldName, type, (col) => {
+			col = field.required !== false ? col.notNull() : col;
+			if (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || "cascade");
+			if (field.unique) col = col.unique();
+			if (field.type === "date" && typeof field.defaultValue === "function" && (dbType === "postgres" || dbType === "mysql" || dbType === "mssql")) if (dbType === "mysql") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);
+			else col = col.defaultTo(sql`CURRENT_TIMESTAMP`);
+			return col;
+		});
+		migrations.push(built);
+	}
+	let toBeIndexed = [];
+	if (config.advanced?.database?.useNumberId) logger$1.warn("`useNumberId` is deprecated. Please use `generateId` with `serial` instead.");
+	if (toBeCreated.length) for (const table of toBeCreated) {
+		const idType = getType({ type: useNumberId ? "number" : "string" }, "id");
+		let dbT = db.schema.createTable(table.table).addColumn("id", idType, (col) => {
+			if (useNumberId) {
+				if (dbType === "postgres") return col.primaryKey().notNull();
+				else if (dbType === "sqlite") return col.primaryKey().notNull();
+				else if (dbType === "mssql") return col.identity().primaryKey().notNull();
+				return col.autoIncrement().primaryKey().notNull();
+			}
+			if (useUUIDs) {
+				if (dbType === "postgres") return col.primaryKey().defaultTo(sql`pg_catalog.gen_random_uuid()`).notNull();
+				return col.primaryKey().notNull();
+			}
+			return col.primaryKey().notNull();
+		});
+		for (const [fieldName, field] of Object.entries(table.fields)) {
+			const type = getType(field, fieldName);
+			dbT = dbT.addColumn(fieldName, type, (col) => {
+				col = field.required !== false ? col.notNull() : col;
+				if (field.references) col = col.references(getReferencePath(field.references.model, field.references.field)).onDelete(field.references.onDelete || "cascade");
+				if (field.unique) col = col.unique();
+				if (field.type === "date" && typeof field.defaultValue === "function" && (dbType === "postgres" || dbType === "mysql" || dbType === "mssql")) if (dbType === "mysql") col = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);
+				else col = col.defaultTo(sql`CURRENT_TIMESTAMP`);
+				return col;
+			});
+			if (field.index) {
+				let builder = db.schema.createIndex(`${table.table}_${fieldName}_${field.unique ? "uidx" : "idx"}`).on(table.table).columns([fieldName]);
+				toBeIndexed.push(field.unique ? builder.unique() : builder);
+			}
+		}
+		migrations.push(dbT);
+	}
+	if (toBeIndexed.length) for (const index of toBeIndexed) migrations.push(index);
+	async function runMigrations() {
+		for (const migration of migrations) await migration.execute();
+	}
+	async function compileMigrations() {
+		return migrations.map((m) => m.compile().sql).join(";\n\n") + ";";
+	}
+	return {
+		toBeCreated,
+		toBeAdded,
+		runMigrations,
+		compileMigrations
+	};
+}
+
+//#endregion
+export { createInternalAdapter as a, convertToDB as c, getBaseAdapter as d, toZodSchema as i, createFieldAttribute as l, matchType as n, getWithHooks as o, getSchema as r, convertFromDB as s, getMigrations as t, getAdapter as u };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/get-model-name-nJd9iPTo.mjs.bak b/node_modules/better-auth/dist/get-model-name-nJd9iPTo.mjs.bak
new file mode 100644
index 0000000..df5be1f
--- /dev/null
+++ b/node_modules/better-auth/dist/get-model-name-nJd9iPTo.mjs.bak
@@ -0,0 +1,377 @@
+import { logger } from "@better-auth/core/env";
+import { BetterAuthError } from "@better-auth/core/error";
+
+//#region src/db/get-tables.ts
+const getAuthTables = (options) => {
+	const pluginSchema = (options.plugins ?? []).reduce((acc, plugin) => {
+		const schema = plugin.schema;
+		if (!schema) return acc;
+		for (const [key, value] of Object.entries(schema)) acc[key] = {
+			fields: {
+				...acc[key]?.fields,
+				...value.fields
+			},
+			modelName: value.modelName || key
+		};
+		return acc;
+	}, {});
+	const shouldAddRateLimitTable = options.rateLimit?.storage === "database";
+	const rateLimitTable = { rateLimit: {
+		modelName: options.rateLimit?.modelName || "rateLimit",
+		fields: {
+			key: {
+				type: "string",
+				fieldName: options.rateLimit?.fields?.key || "key"
+			},
+			count: {
+				type: "number",
+				fieldName: options.rateLimit?.fields?.count || "count"
+			},
+			lastRequest: {
+				type: "number",
+				bigint: true,
+				fieldName: options.rateLimit?.fields?.lastRequest || "lastRequest"
+			}
+		}
+	} };
+	const { user, session, account,...pluginTables } = pluginSchema;
+	const sessionTable = { session: {
+		modelName: options.session?.modelName || "session",
+		fields: {
+			expiresAt: {
+				type: "date",
+				required: true,
+				fieldName: options.session?.fields?.expiresAt || "expiresAt"
+			},
+			token: {
+				type: "string",
+				required: true,
+				fieldName: options.session?.fields?.token || "token",
+				unique: true
+			},
+			createdAt: {
+				type: "date",
+				required: true,
+				fieldName: options.session?.fields?.createdAt || "createdAt",
+				defaultValue: () => /* @__PURE__ */ new Date()
+			},
+			updatedAt: {
+				type: "date",
+				required: true,
+				fieldName: options.session?.fields?.updatedAt || "updatedAt",
+				onUpdate: () => /* @__PURE__ */ new Date()
+			},
+			ipAddress: {
+				type: "string",
+				required: false,
+				fieldName: options.session?.fields?.ipAddress || "ipAddress"
+			},
+			userAgent: {
+				type: "string",
+				required: false,
+				fieldName: options.session?.fields?.userAgent || "userAgent"
+			},
+			userId: {
+				type: "string",
+				fieldName: options.session?.fields?.userId || "userId",
+				references: {
+					model: options.user?.modelName || "user",
+					field: "id",
+					onDelete: "cascade"
+				},
+				required: true,
+				index: true
+			},
+			...session?.fields,
+			...options.session?.additionalFields
+		},
+		order: 2
+	} };
+	return {
+		user: {
+			modelName: options.user?.modelName || "user",
+			fields: {
+				name: {
+					type: "string",
+					required: true,
+					fieldName: options.user?.fields?.name || "name",
+					sortable: true
+				},
+				email: {
+					type: "string",
+					unique: true,
+					required: true,
+					fieldName: options.user?.fields?.email || "email",
+					sortable: true
+				},
+				emailVerified: {
+					type: "boolean",
+					defaultValue: false,
+					required: true,
+					fieldName: options.user?.fields?.emailVerified || "emailVerified",
+					input: false
+				},
+				image: {
+					type: "string",
+					required: false,
+					fieldName: options.user?.fields?.image || "image"
+				},
+				createdAt: {
+					type: "date",
+					defaultValue: () => /* @__PURE__ */ new Date(),
+					required: true,
+					fieldName: options.user?.fields?.createdAt || "createdAt"
+				},
+				updatedAt: {
+					type: "date",
+					defaultValue: () => /* @__PURE__ */ new Date(),
+					onUpdate: () => /* @__PURE__ */ new Date(),
+					required: true,
+					fieldName: options.user?.fields?.updatedAt || "updatedAt"
+				},
+				...user?.fields,
+				...options.user?.additionalFields
+			},
+			order: 1
+		},
+		...!options.secondaryStorage || options.session?.storeSessionInDatabase ? sessionTable : {},
+		account: {
+			modelName: options.account?.modelName || "account",
+			fields: {
+				accountId: {
+					type: "string",
+					required: true,
+					fieldName: options.account?.fields?.accountId || "accountId"
+				},
+				providerId: {
+					type: "string",
+					required: true,
+					fieldName: options.account?.fields?.providerId || "providerId"
+				},
+				userId: {
+					type: "string",
+					references: {
+						model: options.user?.modelName || "user",
+						field: "id",
+						onDelete: "cascade"
+					},
+					required: true,
+					fieldName: options.account?.fields?.userId || "userId",
+					index: true
+				},
+				accessToken: {
+					type: "string",
+					required: false,
+					fieldName: options.account?.fields?.accessToken || "accessToken"
+				},
+				refreshToken: {
+					type: "string",
+					required: false,
+					fieldName: options.account?.fields?.refreshToken || "refreshToken"
+				},
+				idToken: {
+					type: "string",
+					required: false,
+					fieldName: options.account?.fields?.idToken || "idToken"
+				},
+				accessTokenExpiresAt: {
+					type: "date",
+					required: false,
+					fieldName: options.account?.fields?.accessTokenExpiresAt || "accessTokenExpiresAt"
+				},
+				refreshTokenExpiresAt: {
+					type: "date",
+					required: false,
+					fieldName: options.account?.fields?.refreshTokenExpiresAt || "refreshTokenExpiresAt"
+				},
+				scope: {
+					type: "string",
+					required: false,
+					fieldName: options.account?.fields?.scope || "scope"
+				},
+				password: {
+					type: "string",
+					required: false,
+					fieldName: options.account?.fields?.password || "password"
+				},
+				createdAt: {
+					type: "date",
+					required: true,
+					fieldName: options.account?.fields?.createdAt || "createdAt",
+					defaultValue: () => /* @__PURE__ */ new Date()
+				},
+				updatedAt: {
+					type: "date",
+					required: true,
+					fieldName: options.account?.fields?.updatedAt || "updatedAt",
+					onUpdate: () => /* @__PURE__ */ new Date()
+				},
+				...account?.fields,
+				...options.account?.additionalFields
+			},
+			order: 3
+		},
+		verification: {
+			modelName: options.verification?.modelName || "verification",
+			fields: {
+				identifier: {
+					type: "string",
+					required: true,
+					fieldName: options.verification?.fields?.identifier || "identifier",
+					index: true
+				},
+				value: {
+					type: "string",
+					required: true,
+					fieldName: options.verification?.fields?.value || "value"
+				},
+				expiresAt: {
+					type: "date",
+					required: true,
+					fieldName: options.verification?.fields?.expiresAt || "expiresAt"
+				},
+				createdAt: {
+					type: "date",
+					required: true,
+					defaultValue: () => /* @__PURE__ */ new Date(),
+					fieldName: options.verification?.fields?.createdAt || "createdAt"
+				},
+				updatedAt: {
+					type: "date",
+					required: true,
+					defaultValue: () => /* @__PURE__ */ new Date(),
+					onUpdate: () => /* @__PURE__ */ new Date(),
+					fieldName: options.verification?.fields?.updatedAt || "updatedAt"
+				}
+			},
+			order: 4
+		},
+		...pluginTables,
+		...shouldAddRateLimitTable ? rateLimitTable : {}
+	};
+};
+
+//#endregion
+//#region src/adapters/adapter-factory/get-default-model-name.ts
+const initGetDefaultModelName = ({ usePlural, schema }) => {
+	/**
+	* This function helps us get the default model name from the schema defined by devs.
+	* Often times, the user will be using the `modelName` which could had been customized by the users.
+	* This function helps us get the actual model name useful to match against the schema. (eg: schema[model])
+	*
+	* If it's still unclear what this does:
+	*
+	* 1. User can define a custom modelName.
+	* 2. When using a custom modelName, doing something like `schema[model]` will not work.
+	* 3. Using this function helps us get the actual model name based on the user's defined custom modelName.
+	*/
+	const getDefaultModelName = (model) => {
+		if (usePlural && model.charAt(model.length - 1) === "s") {
+			let pluralessModel = model.slice(0, -1);
+			let m$1 = schema[pluralessModel] ? pluralessModel : void 0;
+			if (!m$1) m$1 = Object.entries(schema).find(([_, f]) => f.modelName === pluralessModel)?.[0];
+			if (m$1) return m$1;
+		}
+		let m = schema[model] ? model : void 0;
+		if (!m) m = Object.entries(schema).find(([_, f]) => f.modelName === model)?.[0];
+		if (!m) {
+			logger.error(`Model "${model}" not found in schema`);
+			logger.error(`Schema:`, schema);
+			logger.error(`Error stack:`, (/* @__PURE__ */ new Error()).stack?.replace("Error:", ""));
+			throw new BetterAuthError(`Model "${model}" not found in schema!`);
+		}
+		return m;
+	};
+	return getDefaultModelName;
+};
+
+//#endregion
+//#region src/adapters/adapter-factory/get-default-field-name.ts
+const initGetDefaultFieldName = ({ schema, usePlural }) => {
+	const getDefaultModelName = initGetDefaultModelName({
+		schema,
+		usePlural
+	});
+	/**
+	* This function helps us get the default field name from the schema defined by devs.
+	* Often times, the user will be using the `fieldName` which could had been customized by the users.
+	* This function helps us get the actual field name useful to match against the schema. (eg: schema[model].fields[field])
+	*
+	* If it's still unclear what this does:
+	*
+	* 1. User can define a custom fieldName.
+	* 2. When using a custom fieldName, doing something like `schema[model].fields[field]` will not work.
+	*/
+	const getDefaultFieldName = ({ field, model: unsafeModel }) => {
+		if (field === "id" || field === "_id") return "id";
+		const model = getDefaultModelName(unsafeModel);
+		let f = schema[model]?.fields[field];
+		if (!f) {
+			const result = Object.entries(schema[model].fields).find(([_, f$1]) => f$1.fieldName === field);
+			if (result) {
+				f = result[1];
+				field = result[0];
+			}
+		}
+		if (!f) {
+			logger.error(`Field "${field}" not found in schema`);
+			logger.error(`Schema:`, schema);
+			logger.error(`Error stack:`, (/* @__PURE__ */ new Error()).stack?.replace("Error:", ""));
+			throw new BetterAuthError(`Field ${field} not found in model ${model}`);
+		}
+		return field;
+	};
+	return getDefaultFieldName;
+};
+
+//#endregion
+//#region src/adapters/adapter-factory/get-field-name.ts
+const initGetFieldName = ({ schema, usePlural }) => {
+	const getDefaultModelName = initGetDefaultModelName({
+		schema,
+		usePlural
+	});
+	const getDefaultFieldName = initGetDefaultFieldName({
+		schema,
+		usePlural
+	});
+	/**
+	* Get the field name which is expected to be saved in the database based on the user's schema.
+	*
+	* This function is useful if you need to save the field name to the database.
+	*
+	* For example, if the user has defined a custom field name for the `user` model, then you can use this function to get the actual field name from the schema.
+	*/
+	function getFieldName({ model: modelName, field: fieldName }) {
+		const model = getDefaultModelName(modelName);
+		const field = getDefaultFieldName({
+			model,
+			field: fieldName
+		});
+		return schema[model]?.fields[field]?.fieldName || field;
+	}
+	return getFieldName;
+};
+
+//#endregion
+//#region src/adapters/adapter-factory/get-model-name.ts
+const initGetModelName = ({ usePlural, schema }) => {
+	const getDefaultModelName = initGetDefaultModelName({
+		schema,
+		usePlural
+	});
+	/**
+	* Users can overwrite the default model of some tables. This function helps find the correct model name.
+	* Furthermore, if the user passes `usePlural` as true in their adapter config,
+	* then we should return the model name ending with an `s`.
+	*/
+	const getModelName = (model) => {
+		const defaultModelKey = getDefaultModelName(model);
+		if (schema && schema[defaultModelKey] && schema[defaultModelKey].modelName !== model) return usePlural ? `${schema[defaultModelKey].modelName}s` : schema[defaultModelKey].modelName;
+		return usePlural ? `${model}s` : model;
+	};
+	return getModelName;
+};
+
+//#endregion
+export { getAuthTables as a, initGetDefaultModelName as i, initGetFieldName as n, initGetDefaultFieldName as r, initGetModelName as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/get-request-ip-kbu825ez.mjs b/node_modules/better-auth/dist/get-request-ip-kbu825ez.mjs
index 3707fe3..9ddab38 100644
--- a/node_modules/better-auth/dist/get-request-ip-kbu825ez.mjs
+++ b/node_modules/better-auth/dist/get-request-ip-kbu825ez.mjs
@@ -18,8 +18,8 @@ function getIp(req, options) {
 	return null;
 }
 function isValidIP(ip) {
-	if (z.ipv4().safeParse(ip).success) return true;
-	if (z.ipv6().safeParse(ip).success) return true;
+	if (z.string().ipv4().safeParse(ip).success) return true;
+	if (z.string().ipv6().safeParse(ip).success) return true;
 	return false;
 }
 
diff --git a/node_modules/better-auth/dist/get-request-ip-kbu825ez.mjs.bak b/node_modules/better-auth/dist/get-request-ip-kbu825ez.mjs.bak
new file mode 100644
index 0000000..9ddab38
--- /dev/null
+++ b/node_modules/better-auth/dist/get-request-ip-kbu825ez.mjs.bak
@@ -0,0 +1,27 @@
+import { isDevelopment, isTest } from "@better-auth/core/env";
+import * as z from "zod";
+
+//#region src/utils/get-request-ip.ts
+const LOCALHOST_IP = "127.0.0.1";
+function getIp(req, options) {
+	if (options.advanced?.ipAddress?.disableIpTracking) return null;
+	if (isTest() || isDevelopment()) return LOCALHOST_IP;
+	const headers = "headers" in req ? req.headers : req;
+	const ipHeaders = options.advanced?.ipAddress?.ipAddressHeaders || ["x-forwarded-for"];
+	for (const key of ipHeaders) {
+		const value = "get" in headers ? headers.get(key) : headers[key];
+		if (typeof value === "string") {
+			const ip = value.split(",")[0].trim();
+			if (isValidIP(ip)) return ip;
+		}
+	}
+	return null;
+}
+function isValidIP(ip) {
+	if (z.string().ipv4().safeParse(ip).success) return true;
+	if (z.string().ipv6().safeParse(ip).success) return true;
+	return false;
+}
+
+//#endregion
+export { getIp as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/has-permission-DhpFBOUO.mjs.bak b/node_modules/better-auth/dist/has-permission-DhpFBOUO.mjs.bak
new file mode 100644
index 0000000..dbf9651
--- /dev/null
+++ b/node_modules/better-auth/dist/has-permission-DhpFBOUO.mjs.bak
@@ -0,0 +1,14 @@
+import { r as defaultRoles } from "./access-BYnrn7CR.mjs";
+
+//#region src/plugins/admin/has-permission.ts
+const hasPermission = (input) => {
+	if (input.userId && input.options?.adminUserIds?.includes(input.userId)) return true;
+	if (!input.permissions && !input.permission) return false;
+	const roles = (input.role || input.options?.defaultRole || "user").split(",");
+	const acRoles = input.options?.roles || defaultRoles;
+	for (const role of roles) if ((acRoles[role]?.authorize(input.permission ?? input.permissions))?.success) return true;
+	return false;
+};
+
+//#endregion
+export { hasPermission as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/haveibeenpwned-lb4pgDiK.mjs.bak b/node_modules/better-auth/dist/haveibeenpwned-lb4pgDiK.mjs.bak
new file mode 100644
index 0000000..82bd4ac
--- /dev/null
+++ b/node_modules/better-auth/dist/haveibeenpwned-lb4pgDiK.mjs.bak
@@ -0,0 +1,53 @@
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { getCurrentAuthContext } from "@better-auth/core/context";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { createHash } from "@better-auth/utils/hash";
+import { betterFetch } from "@better-fetch/fetch";
+
+//#region src/plugins/haveibeenpwned/index.ts
+const ERROR_CODES = defineErrorCodes({ PASSWORD_COMPROMISED: "The password you entered has been compromised. Please choose a different password." });
+async function checkPasswordCompromise(password, customMessage) {
+	if (!password) return;
+	const sha1Hash = (await createHash("SHA-1", "hex").digest(password)).toUpperCase();
+	const prefix = sha1Hash.substring(0, 5);
+	const suffix = sha1Hash.substring(5);
+	try {
+		const { data, error } = await betterFetch(`https://api.pwnedpasswords.com/range/${prefix}`, { headers: {
+			"Add-Padding": "true",
+			"User-Agent": "BetterAuth Password Checker"
+		} });
+		if (error) throw new APIError("INTERNAL_SERVER_ERROR", { message: `Failed to check password. Status: ${error.status}` });
+		if (data.split("\n").some((line) => line.split(":")[0].toUpperCase() === suffix.toUpperCase())) throw new APIError("BAD_REQUEST", {
+			message: customMessage || ERROR_CODES.PASSWORD_COMPROMISED,
+			code: "PASSWORD_COMPROMISED"
+		});
+	} catch (error) {
+		if (error instanceof APIError) throw error;
+		throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to check password. Please try again later." });
+	}
+}
+const haveIBeenPwned = (options) => {
+	const paths = options?.paths || [
+		"/sign-up/email",
+		"/change-password",
+		"/reset-password"
+	];
+	return {
+		id: "haveIBeenPwned",
+		init(ctx) {
+			return { context: { password: {
+				...ctx.password,
+				async hash(password) {
+					const c = await getCurrentAuthContext();
+					if (!c.path || !paths.includes(c.path)) return ctx.password.hash(password);
+					await checkPasswordCompromise(password, options?.customPasswordCompromisedMessage);
+					return ctx.password.hash(password);
+				}
+			} } };
+		},
+		$ERROR_CODES: ERROR_CODES
+	};
+};
+
+//#endregion
+export { haveIBeenPwned as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/index.mjs.bak b/node_modules/better-auth/dist/index.mjs.bak
new file mode 100644
index 0000000..a16610d
--- /dev/null
+++ b/node_modules/better-auth/dist/index.mjs.bak
@@ -0,0 +1,34 @@
+import "./dialect-BhkkSrrx.mjs";
+import "./get-model-name-nJd9iPTo.mjs";
+import "./get-migration-C1tgKlQ6.mjs";
+import "./types-BReKsBV6.mjs";
+import { i as parseState, n as HIDE_METADATA, r as generateState, t as generateId } from "./utils-F62c-ieM.mjs";
+import "./crypto-DZW3hrq1.mjs";
+import "./jwt-CmxZAGe2.mjs";
+import { t as capitalizeFirstLetter } from "./misc-CADLxPeM.mjs";
+import "./schema-BevzneML.mjs";
+import "./get-request-ip-kbu825ez.mjs";
+import "./json-BS-nL3f-.mjs";
+import "./url-SXU3XD3W.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import "./cookies-Cl2L38B1.mjs";
+import "./session-Efap-vxj.mjs";
+import "./base-DtHhS6VT.mjs";
+import "./password-DWi8yN3A.mjs";
+import { t as betterAuth } from "./auth-DG0t9Q_P.mjs";
+import { getCurrentAdapter } from "@better-auth/core/context";
+import { createTelemetry, getTelemetryAuthConfig } from "@better-auth/telemetry";
+
+export * from "@better-auth/core"
+
+export * from "@better-auth/core/db"
+
+export * from "@better-auth/core/env"
+
+export * from "@better-auth/core/error"
+
+export * from "@better-auth/core/oauth2"
+
+export * from "@better-auth/core/utils"
+
+export { APIError, HIDE_METADATA, betterAuth, capitalizeFirstLetter, createTelemetry, generateId, generateState, getCurrentAdapter, getTelemetryAuthConfig, parseState };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/integrations/next-js.mjs.bak b/node_modules/better-auth/dist/integrations/next-js.mjs.bak
new file mode 100644
index 0000000..e9b5e95
--- /dev/null
+++ b/node_modules/better-auth/dist/integrations/next-js.mjs.bak
@@ -0,0 +1,65 @@
+import "../jwt-CmxZAGe2.mjs";
+import "../schema-BevzneML.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import { l as parseSetCookieHeader } from "../cookies-Cl2L38B1.mjs";
+import { createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/integrations/next-js.ts
+function toNextJsHandler(auth) {
+	const handler = async (request) => {
+		return "handler" in auth ? auth.handler(request) : auth(request);
+	};
+	return {
+		GET: handler,
+		POST: handler,
+		PATCH: handler,
+		PUT: handler,
+		DELETE: handler
+	};
+}
+const nextCookies = () => {
+	return {
+		id: "next-cookies",
+		hooks: { after: [{
+			matcher(ctx) {
+				return true;
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const returned = ctx.context.responseHeaders;
+				if ("_flag" in ctx && ctx._flag === "router") return;
+				if (returned instanceof Headers) {
+					const setCookies = returned?.get("set-cookie");
+					if (!setCookies) return;
+					const parsed = parseSetCookieHeader(setCookies);
+					const { cookies } = await import("next/headers");
+					let cookieHelper;
+					try {
+						cookieHelper = await cookies();
+					} catch (error) {
+						if (error instanceof Error && error.message.startsWith("`cookies` was called outside a request scope.")) return;
+						throw error;
+					}
+					parsed.forEach((value, key) => {
+						if (!key) return;
+						const opts = {
+							sameSite: value.samesite,
+							secure: value.secure,
+							maxAge: value["max-age"],
+							httpOnly: value.httponly,
+							domain: value.domain,
+							path: value.path
+						};
+						try {
+							cookieHelper.set(key, decodeURIComponent(value.value), opts);
+						} catch (e) {}
+					});
+					return;
+				}
+			})
+		}] }
+	};
+};
+
+//#endregion
+export { nextCookies, toNextJsHandler };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/integrations/node.mjs.bak b/node_modules/better-auth/dist/integrations/node.mjs.bak
new file mode 100644
index 0000000..5ab80f7
--- /dev/null
+++ b/node_modules/better-auth/dist/integrations/node.mjs.bak
@@ -0,0 +1,15 @@
+import { toNodeHandler as toNodeHandler$1 } from "better-call/node";
+
+//#region src/integrations/node.ts
+const toNodeHandler = (auth) => {
+	return "handler" in auth ? toNodeHandler$1(auth.handler) : toNodeHandler$1(auth);
+};
+function fromNodeHeaders(nodeHeaders) {
+	const webHeaders = new Headers();
+	for (const [key, value] of Object.entries(nodeHeaders)) if (value !== void 0) if (Array.isArray(value)) value.forEach((v) => webHeaders.append(key, v));
+	else webHeaders.set(key, value);
+	return webHeaders;
+}
+
+//#endregion
+export { fromNodeHeaders, toNodeHandler };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/integrations/react-start.mjs.bak b/node_modules/better-auth/dist/integrations/react-start.mjs.bak
new file mode 100644
index 0000000..c10b11a
--- /dev/null
+++ b/node_modules/better-auth/dist/integrations/react-start.mjs.bak
@@ -0,0 +1,46 @@
+import "../jwt-CmxZAGe2.mjs";
+import "../schema-BevzneML.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import { l as parseSetCookieHeader } from "../cookies-Cl2L38B1.mjs";
+import { createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/integrations/react-start.ts
+const reactStartCookies = () => {
+	return {
+		id: "react-start-cookies",
+		hooks: { after: [{
+			matcher(ctx) {
+				return true;
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const returned = ctx.context.responseHeaders;
+				if ("_flag" in ctx && ctx._flag === "router") return;
+				if (returned instanceof Headers) {
+					const setCookies = returned?.get("set-cookie");
+					if (!setCookies) return;
+					const parsed = parseSetCookieHeader(setCookies);
+					const { setCookie } = await import("@tanstack/start-server-core");
+					parsed.forEach((value, key) => {
+						if (!key) return;
+						const opts = {
+							sameSite: value.samesite,
+							secure: value.secure,
+							maxAge: value["max-age"],
+							httpOnly: value.httponly,
+							domain: value.domain,
+							path: value.path
+						};
+						try {
+							setCookie(key, decodeURIComponent(value.value), opts);
+						} catch (e) {}
+					});
+					return;
+				}
+			})
+		}] }
+	};
+};
+
+//#endregion
+export { reactStartCookies };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/integrations/solid-start.mjs.bak b/node_modules/better-auth/dist/integrations/solid-start.mjs.bak
new file mode 100644
index 0000000..466fee0
--- /dev/null
+++ b/node_modules/better-auth/dist/integrations/solid-start.mjs.bak
@@ -0,0 +1,16 @@
+//#region src/integrations/solid-start.ts
+function toSolidStartHandler(auth) {
+	const handler = async (event) => {
+		return "handler" in auth ? auth.handler(event.request) : auth(event.request);
+	};
+	return {
+		GET: handler,
+		POST: handler,
+		PATCH: handler,
+		PUT: handler,
+		DELETE: handler
+	};
+}
+
+//#endregion
+export { toSolidStartHandler };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/integrations/svelte-kit.mjs.bak b/node_modules/better-auth/dist/integrations/svelte-kit.mjs.bak
new file mode 100644
index 0000000..a79e322
--- /dev/null
+++ b/node_modules/better-auth/dist/integrations/svelte-kit.mjs.bak
@@ -0,0 +1,59 @@
+import "../jwt-CmxZAGe2.mjs";
+import "../schema-BevzneML.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import { l as parseSetCookieHeader } from "../cookies-Cl2L38B1.mjs";
+import { createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/integrations/svelte-kit.ts
+const toSvelteKitHandler = (auth) => {
+	return (event) => auth.handler(event.request);
+};
+const svelteKitHandler = async ({ auth, event, resolve, building }) => {
+	if (building) return resolve(event);
+	const { request, url } = event;
+	if (isAuthPath(url.toString(), auth.options)) return auth.handler(request);
+	return resolve(event);
+};
+function isAuthPath(url, options) {
+	const _url = new URL(url);
+	const baseURL = new URL(`${options.baseURL || _url.origin}${options.basePath || "/api/auth"}`);
+	if (_url.origin !== baseURL.origin) return false;
+	if (!_url.pathname.startsWith(baseURL.pathname.endsWith("/") ? baseURL.pathname : `${baseURL.pathname}/`)) return false;
+	return true;
+}
+const sveltekitCookies = (getRequestEvent) => {
+	return {
+		id: "sveltekit-cookies",
+		hooks: { after: [{
+			matcher() {
+				return true;
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const returned = ctx.context.responseHeaders;
+				if ("_flag" in ctx && ctx._flag === "router") return;
+				if (returned instanceof Headers) {
+					const setCookies = returned?.get("set-cookie");
+					if (!setCookies) return;
+					const event = getRequestEvent();
+					if (!event) return;
+					const parsed = parseSetCookieHeader(setCookies);
+					for (const [name, { value,...ops }] of parsed) try {
+						event.cookies.set(name, decodeURIComponent(value), {
+							sameSite: ops.samesite,
+							path: ops.path || "/",
+							expires: ops.expires,
+							secure: ops.secure,
+							httpOnly: ops.httponly,
+							domain: ops.domain,
+							maxAge: ops["max-age"]
+						});
+					} catch (e) {}
+				}
+			})
+		}] }
+	};
+};
+
+//#endregion
+export { isAuthPath, svelteKitHandler, sveltekitCookies, toSvelteKitHandler };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/json-BS-nL3f-.mjs.bak b/node_modules/better-auth/dist/json-BS-nL3f-.mjs.bak
new file mode 100644
index 0000000..c9d90e1
--- /dev/null
+++ b/node_modules/better-auth/dist/json-BS-nL3f-.mjs.bak
@@ -0,0 +1,24 @@
+import { logger } from "@better-auth/core/env";
+
+//#region src/utils/json.ts
+function safeJSONParse(data) {
+	function reviver(_, value) {
+		if (typeof value === "string") {
+			if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/.test(value)) {
+				const date = new Date(value);
+				if (!isNaN(date.getTime())) return date;
+			}
+		}
+		return value;
+	}
+	try {
+		if (typeof data !== "string") return data;
+		return JSON.parse(data, reviver);
+	} catch (e) {
+		logger.error("Error parsing JSON", { error: e });
+		return null;
+	}
+}
+
+//#endregion
+export { safeJSONParse as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/jwt-CLg_nnrd.mjs.bak b/node_modules/better-auth/dist/jwt-CLg_nnrd.mjs.bak
new file mode 100644
index 0000000..2d611bc
--- /dev/null
+++ b/node_modules/better-auth/dist/jwt-CLg_nnrd.mjs.bak
@@ -0,0 +1,182 @@
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { a as getJwksAdapter, n as signJWT, r as createJwk, t as getJwtToken } from "./sign-wCNCtKGh.mjs";
+import { BetterAuthError } from "@better-auth/core/error";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/jwt/schema.ts
+const schema = { jwks: { fields: {
+	publicKey: {
+		type: "string",
+		required: true
+	},
+	privateKey: {
+		type: "string",
+		required: true
+	},
+	createdAt: {
+		type: "date",
+		required: true
+	}
+} } };
+
+//#endregion
+//#region src/plugins/jwt/index.ts
+const jwt = (options) => {
+	if (options?.jwt?.sign && !options.jwks?.remoteUrl) throw new BetterAuthError("jwks_config", "jwks.remoteUrl must be set when using jwt.sign");
+	if (options?.jwks?.remoteUrl && !options.jwks?.keyPairConfig?.alg) throw new BetterAuthError("jwks_config", "must specify alg when using the oidc plugin and jwks.remoteUrl");
+	return {
+		id: "jwt",
+		options,
+		endpoints: {
+			getJwks: createAuthEndpoint("/jwks", {
+				method: "GET",
+				metadata: { openapi: {
+					operationId: "getJSONWebKeySet",
+					description: "Get the JSON Web Key Set",
+					responses: { "200": {
+						description: "JSON Web Key Set retrieved successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { keys: {
+								type: "array",
+								description: "Array of public JSON Web Keys",
+								items: {
+									type: "object",
+									properties: {
+										kid: {
+											type: "string",
+											description: "Key ID uniquely identifying the key, corresponds to the 'id' from the stored Jwk"
+										},
+										kty: {
+											type: "string",
+											description: "Key type (e.g., 'RSA', 'EC', 'OKP')"
+										},
+										alg: {
+											type: "string",
+											description: "Algorithm intended for use with the key (e.g., 'EdDSA', 'RS256')"
+										},
+										use: {
+											type: "string",
+											description: "Intended use of the public key (e.g., 'sig' for signature)",
+											enum: ["sig"],
+											nullable: true
+										},
+										n: {
+											type: "string",
+											description: "Modulus for RSA keys (base64url-encoded)",
+											nullable: true
+										},
+										e: {
+											type: "string",
+											description: "Exponent for RSA keys (base64url-encoded)",
+											nullable: true
+										},
+										crv: {
+											type: "string",
+											description: "Curve name for elliptic curve keys (e.g., 'Ed25519', 'P-256')",
+											nullable: true
+										},
+										x: {
+											type: "string",
+											description: "X coordinate for elliptic curve keys (base64url-encoded)",
+											nullable: true
+										},
+										y: {
+											type: "string",
+											description: "Y coordinate for elliptic curve keys (base64url-encoded)",
+											nullable: true
+										}
+									},
+									required: [
+										"kid",
+										"kty",
+										"alg"
+									]
+								}
+							} },
+							required: ["keys"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (options?.jwks?.remoteUrl) throw new APIError("NOT_FOUND");
+				let keySets = await getJwksAdapter(ctx.context.adapter).getAllKeys(ctx);
+				if (!keySets || keySets?.length === 0) keySets = [await createJwk(ctx, options)];
+				if (!keySets?.length) throw new BetterAuthError("No key sets found. Make sure you have a key in your database.");
+				const keyPairConfig = options?.jwks?.keyPairConfig;
+				const defaultCrv = keyPairConfig ? "crv" in keyPairConfig ? keyPairConfig.crv : void 0 : void 0;
+				return ctx.json({ keys: keySets.map((keySet) => {
+					return {
+						alg: keySet.alg ?? options?.jwks?.keyPairConfig?.alg ?? "EdDSA",
+						crv: keySet.crv ?? defaultCrv,
+						...JSON.parse(keySet.publicKey),
+						kid: keySet.id
+					};
+				}) });
+			}),
+			getToken: createAuthEndpoint("/token", {
+				method: "GET",
+				requireHeaders: true,
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					operationId: "getJSONWebToken",
+					description: "Get a JWT token",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { token: { type: "string" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const jwt$1 = await getJwtToken(ctx, options);
+				return ctx.json({ token: jwt$1 });
+			}),
+			signJWT: createAuthEndpoint("/sign-jwt", {
+				method: "POST",
+				metadata: {
+					SERVER_ONLY: true,
+					$Infer: { body: {} }
+				},
+				body: z.object({
+					payload: z.record(z.string(), z.any()),
+					overrideOptions: z.record(z.string(), z.any()).optional()
+				})
+			}, async (c) => {
+				const jwt$1 = await signJWT(c, {
+					options: {
+						...options,
+						...c.body.overrideOptions
+					},
+					payload: c.body.payload
+				});
+				return c.json({ token: jwt$1 });
+			})
+		},
+		hooks: { after: [{
+			matcher(context) {
+				return context.path === "/get-session";
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				if (options?.disableSettingJwtHeader) return;
+				const session = ctx.context.session || ctx.context.newSession;
+				if (session && session.session) {
+					const jwt$1 = await getJwtToken(ctx, options);
+					const exposedHeaders = ctx.context.responseHeaders?.get("access-control-expose-headers") || "";
+					const headersSet = new Set(exposedHeaders.split(",").map((header) => header.trim()).filter(Boolean));
+					headersSet.add("set-auth-jwt");
+					ctx.setHeader("set-auth-jwt", jwt$1);
+					ctx.setHeader("Access-Control-Expose-Headers", Array.from(headersSet).join(", "));
+				}
+			})
+		}] },
+		schema: mergeSchema(schema, options?.schema)
+	};
+};
+
+//#endregion
+export { jwt as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/jwt-CmxZAGe2.mjs.bak b/node_modules/better-auth/dist/jwt-CmxZAGe2.mjs.bak
new file mode 100644
index 0000000..025a295
--- /dev/null
+++ b/node_modules/better-auth/dist/jwt-CmxZAGe2.mjs.bak
@@ -0,0 +1,94 @@
+import { hkdf } from "@noble/hashes/hkdf.js";
+import { sha256 } from "@noble/hashes/sha2.js";
+import { EncryptJWT, SignJWT, base64url, calculateJwkThumbprint, jwtDecrypt, jwtVerify } from "jose";
+
+//#region src/crypto/jwt.ts
+async function signJWT(payload, secret, expiresIn = 3600) {
+	return await new SignJWT(payload).setProtectedHeader({ alg: "HS256" }).setIssuedAt().setExpirationTime(Math.floor(Date.now() / 1e3) + expiresIn).sign(new TextEncoder().encode(secret));
+}
+async function verifyJWT(token, secret) {
+	try {
+		return (await jwtVerify(token, new TextEncoder().encode(secret))).payload;
+	} catch (error) {
+		return null;
+	}
+}
+const info = new Uint8Array([
+	66,
+	101,
+	116,
+	116,
+	101,
+	114,
+	65,
+	117,
+	116,
+	104,
+	46,
+	106,
+	115,
+	32,
+	71,
+	101,
+	110,
+	101,
+	114,
+	97,
+	116,
+	101,
+	100,
+	32,
+	69,
+	110,
+	99,
+	114,
+	121,
+	112,
+	116,
+	105,
+	111,
+	110,
+	32,
+	75,
+	101,
+	121
+]);
+const now = () => Date.now() / 1e3 | 0;
+const alg = "dir";
+const enc = "A256CBC-HS512";
+async function symmetricEncodeJWT(payload, secret, salt, expiresIn = 3600) {
+	const encryptionSecret = hkdf(sha256, new TextEncoder().encode(secret), new TextEncoder().encode(salt), info, 64);
+	const thumbprint = await calculateJwkThumbprint({
+		kty: "oct",
+		k: base64url.encode(encryptionSecret)
+	}, "sha256");
+	return await new EncryptJWT(payload).setProtectedHeader({
+		alg,
+		enc,
+		kid: thumbprint
+	}).setIssuedAt().setExpirationTime(now() + expiresIn).setJti(crypto.randomUUID()).encrypt(encryptionSecret);
+}
+async function symmetricDecodeJWT(token, secret, salt) {
+	if (!token) return null;
+	try {
+		const { payload } = await jwtDecrypt(token, async ({ kid }) => {
+			const encryptionSecret = hkdf(sha256, new TextEncoder().encode(secret), new TextEncoder().encode(salt), info, 64);
+			if (kid === void 0) return encryptionSecret;
+			if (kid === await calculateJwkThumbprint({
+				kty: "oct",
+				k: base64url.encode(encryptionSecret)
+			}, "sha256")) return encryptionSecret;
+			throw new Error("no matching decryption secret");
+		}, {
+			clockTolerance: 15,
+			keyManagementAlgorithms: [alg],
+			contentEncryptionAlgorithms: [enc, "A256GCM"]
+		});
+		return payload;
+	} catch (error) {
+		return null;
+	}
+}
+
+//#endregion
+export { verifyJWT as i, symmetricDecodeJWT as n, symmetricEncodeJWT as r, signJWT as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/magic-link-DCBndC0L.mjs b/node_modules/better-auth/dist/magic-link-DCBndC0L.mjs
index ed4a8e0..1df62d0 100644
--- a/node_modules/better-auth/dist/magic-link-DCBndC0L.mjs
+++ b/node_modules/better-auth/dist/magic-link-DCBndC0L.mjs
@@ -33,11 +33,11 @@ const magicLink = (options) => {
 				method: "POST",
 				requireHeaders: true,
 				body: z.object({
-					email: z.email().meta({ description: "Email address to send the magic link" }),
-					name: z.string().meta({ description: "User display name. Only used if the user is registering for the first time. Eg: \"my-name\"" }).optional(),
-					callbackURL: z.string().meta({ description: "URL to redirect after magic link verification" }).optional(),
-					newUserCallbackURL: z.string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional(),
-					errorCallbackURL: z.string().meta({ description: "URL to redirect after error." }).optional()
+					email: z.string().email(),
+					name: z.string().optional(),
+					callbackURL: z.string().optional(),
+					newUserCallbackURL: z.string().optional(),
+					errorCallbackURL: z.string().optional()
 				}),
 				metadata: { openapi: {
 					operationId: "signInWithMagicLink",
@@ -83,10 +83,10 @@ const magicLink = (options) => {
 			magicLinkVerify: createAuthEndpoint("/magic-link/verify", {
 				method: "GET",
 				query: z.object({
-					token: z.string().meta({ description: "Verification token" }),
-					callbackURL: z.string().meta({ description: "URL to redirect after magic link verification, if not provided the user will be redirected to the root URL. Eg: \"/dashboard\"" }).optional(),
-					errorCallbackURL: z.string().meta({ description: "URL to redirect after error." }).optional(),
-					newUserCallbackURL: z.string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional()
+					token: z.string(),
+					callbackURL: z.string().optional(),
+					errorCallbackURL: z.string().optional(),
+					newUserCallbackURL: z.string().optional()
 				}),
 				use: [
 					originCheck((ctx) => {
diff --git a/node_modules/better-auth/dist/magic-link-DCBndC0L.mjs.bak b/node_modules/better-auth/dist/magic-link-DCBndC0L.mjs.bak
new file mode 100644
index 0000000..c7660aa
--- /dev/null
+++ b/node_modules/better-auth/dist/magic-link-DCBndC0L.mjs.bak
@@ -0,0 +1,178 @@
+import { r as generateRandomString } from "./crypto-DZW3hrq1.mjs";
+import { R as originCheck } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createHash } from "@better-auth/utils/hash";
+import { createAuthEndpoint } from "@better-auth/core/api";
+import { base64Url } from "@better-auth/utils/base64";
+
+//#region src/plugins/magic-link/utils.ts
+const defaultKeyHasher = async (otp) => {
+	const hash = await createHash("SHA-256").digest(new TextEncoder().encode(otp));
+	return base64Url.encode(new Uint8Array(hash), { padding: false });
+};
+
+//#endregion
+//#region src/plugins/magic-link/index.ts
+const magicLink = (options) => {
+	const opts = {
+		storeToken: "plain",
+		...options
+	};
+	async function storeToken(ctx, token) {
+		if (opts.storeToken === "hashed") return await defaultKeyHasher(token);
+		if (typeof opts.storeToken === "object" && "type" in opts.storeToken && opts.storeToken.type === "custom-hasher") return await opts.storeToken.hash(token);
+		return token;
+	}
+	return {
+		id: "magic-link",
+		endpoints: {
+			signInMagicLink: createAuthEndpoint("/sign-in/magic-link", {
+				method: "POST",
+				requireHeaders: true,
+				body: z.object({
+					email: z.string().email().meta({ description: "Email address to send the magic link" }),
+					name: z.string().meta({ description: "User display name. Only used if the user is registering for the first time. Eg: \"my-name\"" }).optional(),
+					callbackURL: z.string().meta({ description: "URL to redirect after magic link verification" }).optional(),
+					newUserCallbackURL: z.string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional(),
+					errorCallbackURL: z.string().meta({ description: "URL to redirect after error." }).optional()
+				}),
+				metadata: { openapi: {
+					operationId: "signInWithMagicLink",
+					description: "Sign in with magic link",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { email } = ctx.body;
+				if (opts.disableSignUp) {
+					if (!await ctx.context.internalAdapter.findUserByEmail(email)) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+				}
+				const verificationToken = opts?.generateToken ? await opts.generateToken(email) : generateRandomString(32, "a-z", "A-Z");
+				const storedToken = await storeToken(ctx, verificationToken);
+				await ctx.context.internalAdapter.createVerificationValue({
+					identifier: storedToken,
+					value: JSON.stringify({
+						email,
+						name: ctx.body.name
+					}),
+					expiresAt: new Date(Date.now() + (opts.expiresIn || 300) * 1e3)
+				});
+				const realBaseURL = new URL(ctx.context.baseURL);
+				const pathname = realBaseURL.pathname === "/" ? "" : realBaseURL.pathname;
+				const basePath = pathname ? "" : ctx.context.options.basePath || "";
+				const url = new URL(`${pathname}${basePath}/magic-link/verify`, realBaseURL.origin);
+				url.searchParams.set("token", verificationToken);
+				url.searchParams.set("callbackURL", ctx.body.callbackURL || "/");
+				if (ctx.body.newUserCallbackURL) url.searchParams.set("newUserCallbackURL", ctx.body.newUserCallbackURL);
+				if (ctx.body.errorCallbackURL) url.searchParams.set("errorCallbackURL", ctx.body.errorCallbackURL);
+				await options.sendMagicLink({
+					email,
+					url: url.toString(),
+					token: verificationToken
+				}, ctx);
+				return ctx.json({ status: true });
+			}),
+			magicLinkVerify: createAuthEndpoint("/magic-link/verify", {
+				method: "GET",
+				query: z.object({
+					token: z.string().meta({ description: "Verification token" }),
+					callbackURL: z.string().meta({ description: "URL to redirect after magic link verification, if not provided the user will be redirected to the root URL. Eg: \"/dashboard\"" }).optional(),
+					errorCallbackURL: z.string().meta({ description: "URL to redirect after error." }).optional(),
+					newUserCallbackURL: z.string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional()
+				}),
+				use: [
+					originCheck((ctx) => {
+						return ctx.query.callbackURL ? decodeURIComponent(ctx.query.callbackURL) : "/";
+					}),
+					originCheck((ctx) => {
+						return ctx.query.newUserCallbackURL ? decodeURIComponent(ctx.query.newUserCallbackURL) : "/";
+					}),
+					originCheck((ctx) => {
+						return ctx.query.errorCallbackURL ? decodeURIComponent(ctx.query.errorCallbackURL) : "/";
+					})
+				],
+				requireHeaders: true,
+				metadata: { openapi: {
+					operationId: "verifyMagicLink",
+					description: "Verify magic link",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								session: { $ref: "#/components/schemas/Session" },
+								user: { $ref: "#/components/schemas/User" }
+							}
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const token = ctx.query.token;
+				const callbackURL = new URL(ctx.query.callbackURL ? decodeURIComponent(ctx.query.callbackURL) : "/", ctx.context.baseURL).toString();
+				const errorCallbackURL = new URL(ctx.query.errorCallbackURL ? decodeURIComponent(ctx.query.errorCallbackURL) : callbackURL, ctx.context.baseURL).toString();
+				const newUserCallbackURL = new URL(ctx.query.newUserCallbackURL ? decodeURIComponent(ctx.query.newUserCallbackURL) : callbackURL, ctx.context.baseURL).toString();
+				callbackURL?.startsWith("http") || (callbackURL ? `${ctx.context.options.baseURL}${callbackURL}` : ctx.context.options.baseURL);
+				const storedToken = await storeToken(ctx, token);
+				const tokenValue = await ctx.context.internalAdapter.findVerificationValue(storedToken);
+				if (!tokenValue) throw ctx.redirect(`${errorCallbackURL}?error=INVALID_TOKEN`);
+				if (tokenValue.expiresAt < /* @__PURE__ */ new Date()) {
+					await ctx.context.internalAdapter.deleteVerificationValue(tokenValue.id);
+					throw ctx.redirect(`${errorCallbackURL}?error=EXPIRED_TOKEN`);
+				}
+				await ctx.context.internalAdapter.deleteVerificationValue(tokenValue.id);
+				const { email, name } = JSON.parse(tokenValue.value);
+				let isNewUser = false;
+				let user = await ctx.context.internalAdapter.findUserByEmail(email).then((res) => res?.user);
+				if (!user) if (!opts.disableSignUp) {
+					const newUser = await ctx.context.internalAdapter.createUser({
+						email,
+						emailVerified: true,
+						name: name || ""
+					});
+					isNewUser = true;
+					user = newUser;
+					if (!user) throw ctx.redirect(`${errorCallbackURL}?error=failed_to_create_user`);
+				} else throw ctx.redirect(`${errorCallbackURL}?error=new_user_signup_disabled`);
+				if (!user.emailVerified) await ctx.context.internalAdapter.updateUser(user.id, { emailVerified: true });
+				const session = await ctx.context.internalAdapter.createSession(user.id);
+				if (!session) throw ctx.redirect(`${errorCallbackURL}?error=failed_to_create_session`);
+				await setSessionCookie(ctx, {
+					session,
+					user
+				});
+				if (!ctx.query.callbackURL) return ctx.json({
+					token: session.token,
+					user: {
+						id: user.id,
+						email: user.email,
+						emailVerified: user.emailVerified,
+						name: user.name,
+						image: user.image,
+						createdAt: user.createdAt,
+						updatedAt: user.updatedAt
+					}
+				});
+				if (isNewUser) throw ctx.redirect(newUserCallbackURL);
+				throw ctx.redirect(callbackURL);
+			})
+		},
+		rateLimit: [{
+			pathMatcher(path) {
+				return path.startsWith("/sign-in/magic-link") || path.startsWith("/magic-link/verify");
+			},
+			window: opts.rateLimit?.window || 60,
+			max: opts.rateLimit?.max || 5
+		}]
+	};
+};
+
+//#endregion
+export { magicLink as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/misc-CADLxPeM.mjs.bak b/node_modules/better-auth/dist/misc-CADLxPeM.mjs.bak
new file mode 100644
index 0000000..83546db
--- /dev/null
+++ b/node_modules/better-auth/dist/misc-CADLxPeM.mjs.bak
@@ -0,0 +1,7 @@
+//#region src/utils/misc.ts
+function capitalizeFirstLetter(str) {
+	return str.charAt(0).toUpperCase() + str.slice(1);
+}
+
+//#endregion
+export { capitalizeFirstLetter as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/multi-session-CxgwAYRM.mjs b/node_modules/better-auth/dist/multi-session-CxgwAYRM.mjs
index a58295f..a10b7c1 100644
--- a/node_modules/better-auth/dist/multi-session-CxgwAYRM.mjs
+++ b/node_modules/better-auth/dist/multi-session-CxgwAYRM.mjs
@@ -33,7 +33,7 @@ const multiSession = (options) => {
 			}),
 			setActiveSession: createAuthEndpoint("/multi-session/set-active", {
 				method: "POST",
-				body: z.object({ sessionToken: z.string().meta({ description: "The session token to set as active" }) }),
+				body: z.object({ sessionToken: z.string() }),
 				requireHeaders: true,
 				use: [sessionMiddleware],
 				metadata: { openapi: {
@@ -63,7 +63,7 @@ const multiSession = (options) => {
 			}),
 			revokeDeviceSession: createAuthEndpoint("/multi-session/revoke", {
 				method: "POST",
-				body: z.object({ sessionToken: z.string().meta({ description: "The session token to revoke" }) }),
+				body: z.object({ sessionToken: z.string() }),
 				requireHeaders: true,
 				use: [sessionMiddleware],
 				metadata: { openapi: {
diff --git a/node_modules/better-auth/dist/multi-session-CxgwAYRM.mjs.bak b/node_modules/better-auth/dist/multi-session-CxgwAYRM.mjs.bak
new file mode 100644
index 0000000..a58295f
--- /dev/null
+++ b/node_modules/better-auth/dist/multi-session-CxgwAYRM.mjs.bak
@@ -0,0 +1,144 @@
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie, l as parseSetCookieHeader, n as deleteSessionCookie, o as parseCookies } from "./cookies-Cl2L38B1.mjs";
+import { u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/multi-session/index.ts
+const ERROR_CODES = defineErrorCodes({ INVALID_SESSION_TOKEN: "Invalid session token" });
+const multiSession = (options) => {
+	const opts = {
+		maximumSessions: 5,
+		...options
+	};
+	const isMultiSessionCookie = (key) => key.includes("_multi-");
+	return {
+		id: "multi-session",
+		endpoints: {
+			listDeviceSessions: createAuthEndpoint("/multi-session/list-device-sessions", {
+				method: "GET",
+				requireHeaders: true
+			}, async (ctx) => {
+				const cookieHeader = ctx.headers?.get("cookie");
+				if (!cookieHeader) return ctx.json([]);
+				const cookies = Object.fromEntries(parseCookies(cookieHeader));
+				const sessionTokens = (await Promise.all(Object.entries(cookies).filter(([key]) => isMultiSessionCookie(key)).map(async ([key]) => await ctx.getSignedCookie(key, ctx.context.secret)))).filter((v) => v !== null);
+				if (!sessionTokens.length) return ctx.json([]);
+				const uniqueUserSessions = (await ctx.context.internalAdapter.findSessions(sessionTokens)).filter((session) => session && session.session.expiresAt > /* @__PURE__ */ new Date()).reduce((acc, session) => {
+					if (!acc.find((s) => s.user.id === session.user.id)) acc.push(session);
+					return acc;
+				}, []);
+				return ctx.json(uniqueUserSessions);
+			}),
+			setActiveSession: createAuthEndpoint("/multi-session/set-active", {
+				method: "POST",
+				body: z.object({ sessionToken: z.string().meta({ description: "The session token to set as active" }) }),
+				requireHeaders: true,
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Set the active session",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { session: { $ref: "#/components/schemas/Session" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const sessionToken = ctx.body.sessionToken;
+				const multiSessionCookieName = `${ctx.context.authCookies.sessionToken.name}_multi-${sessionToken.toLowerCase()}`;
+				if (!await ctx.getSignedCookie(multiSessionCookieName, ctx.context.secret)) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.INVALID_SESSION_TOKEN });
+				const session = await ctx.context.internalAdapter.findSession(sessionToken);
+				if (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {
+					ctx.setCookie(multiSessionCookieName, "", {
+						...ctx.context.authCookies.sessionToken.options,
+						maxAge: 0
+					});
+					throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.INVALID_SESSION_TOKEN });
+				}
+				await setSessionCookie(ctx, session);
+				return ctx.json(session);
+			}),
+			revokeDeviceSession: createAuthEndpoint("/multi-session/revoke", {
+				method: "POST",
+				body: z.object({ sessionToken: z.string().meta({ description: "The session token to revoke" }) }),
+				requireHeaders: true,
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Revoke a device session",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const sessionToken = ctx.body.sessionToken;
+				const multiSessionCookieName = `${ctx.context.authCookies.sessionToken.name}_multi-${sessionToken.toLowerCase()}`;
+				if (!await ctx.getSignedCookie(multiSessionCookieName, ctx.context.secret)) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.INVALID_SESSION_TOKEN });
+				await ctx.context.internalAdapter.deleteSession(sessionToken);
+				ctx.setCookie(multiSessionCookieName, "", {
+					...ctx.context.authCookies.sessionToken.options,
+					maxAge: 0
+				});
+				if (!(ctx.context.session?.session.token === sessionToken)) return ctx.json({ status: true });
+				const cookieHeader = ctx.headers?.get("cookie");
+				if (cookieHeader) {
+					const cookies = Object.fromEntries(parseCookies(cookieHeader));
+					const sessionTokens = (await Promise.all(Object.entries(cookies).filter(([key]) => isMultiSessionCookie(key)).map(async ([key]) => await ctx.getSignedCookie(key, ctx.context.secret)))).filter((v) => v !== void 0);
+					const internalAdapter = ctx.context.internalAdapter;
+					if (sessionTokens.length > 0) {
+						const validSessions = (await internalAdapter.findSessions(sessionTokens)).filter((session) => session && session.session.expiresAt > /* @__PURE__ */ new Date());
+						if (validSessions.length > 0) {
+							const nextSession = validSessions[0];
+							await setSessionCookie(ctx, nextSession);
+						} else deleteSessionCookie(ctx);
+					} else deleteSessionCookie(ctx);
+				} else deleteSessionCookie(ctx);
+				return ctx.json({ status: true });
+			})
+		},
+		hooks: { after: [{
+			matcher: () => true,
+			handler: createAuthMiddleware(async (ctx) => {
+				const cookieString = ctx.context.responseHeaders?.get("set-cookie");
+				if (!cookieString) return;
+				const setCookies = parseSetCookieHeader(cookieString);
+				const sessionCookieConfig = ctx.context.authCookies.sessionToken;
+				const sessionToken = ctx.context.newSession?.session.token;
+				if (!sessionToken) return;
+				const cookies = parseCookies(ctx.headers?.get("cookie") || "");
+				const cookieName = `${sessionCookieConfig.name}_multi-${sessionToken.toLowerCase()}`;
+				if (setCookies.get(cookieName) || cookies.get(cookieName)) return;
+				if (Object.keys(Object.fromEntries(cookies)).filter(isMultiSessionCookie).length + (cookieString.includes("session_token") ? 1 : 0) >= opts.maximumSessions) return;
+				await ctx.setSignedCookie(cookieName, sessionToken, ctx.context.secret, sessionCookieConfig.options);
+			})
+		}, {
+			matcher: (context) => context.path === "/sign-out",
+			handler: createAuthMiddleware(async (ctx) => {
+				const cookieHeader = ctx.headers?.get("cookie");
+				if (!cookieHeader) return;
+				const cookies = Object.fromEntries(parseCookies(cookieHeader));
+				const ids = Object.keys(cookies).map((key) => {
+					if (isMultiSessionCookie(key)) {
+						ctx.setCookie(key.toLowerCase().replace("__secure-", "__Secure-"), "", {
+							...ctx.context.authCookies.sessionToken.options,
+							maxAge: 0
+						});
+						return cookies[key].split(".")[0];
+					}
+					return null;
+				}).filter((v) => v !== null);
+				await ctx.context.internalAdapter.deleteSessions(ids);
+			})
+		}] },
+		$ERROR_CODES: ERROR_CODES
+	};
+};
+
+//#endregion
+export { multiSession as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/node-sqlite-dialect-GK1cTZHJ.mjs.bak b/node_modules/better-auth/dist/node-sqlite-dialect-GK1cTZHJ.mjs.bak
new file mode 100644
index 0000000..b428f0e
--- /dev/null
+++ b/node_modules/better-auth/dist/node-sqlite-dialect-GK1cTZHJ.mjs.bak
@@ -0,0 +1,155 @@
+import { CompiledQuery, DEFAULT_MIGRATION_LOCK_TABLE, DEFAULT_MIGRATION_TABLE, DefaultQueryCompiler, Kysely, sql } from "kysely";
+
+//#region src/adapters/kysely-adapter/node-sqlite-dialect.ts
+var NodeSqliteAdapter = class {
+	get supportsCreateIfNotExists() {
+		return true;
+	}
+	get supportsTransactionalDdl() {
+		return false;
+	}
+	get supportsReturning() {
+		return true;
+	}
+	async acquireMigrationLock() {}
+	async releaseMigrationLock() {}
+	get supportsOutput() {
+		return true;
+	}
+};
+var NodeSqliteDriver = class {
+	#config;
+	#connectionMutex = new ConnectionMutex();
+	#db;
+	#connection;
+	constructor(config) {
+		this.#config = { ...config };
+	}
+	async init() {
+		this.#db = this.#config.database;
+		this.#connection = new NodeSqliteConnection(this.#db);
+		if (this.#config.onCreateConnection) await this.#config.onCreateConnection(this.#connection);
+	}
+	async acquireConnection() {
+		await this.#connectionMutex.lock();
+		return this.#connection;
+	}
+	async beginTransaction(connection) {
+		await connection.executeQuery(CompiledQuery.raw("begin"));
+	}
+	async commitTransaction(connection) {
+		await connection.executeQuery(CompiledQuery.raw("commit"));
+	}
+	async rollbackTransaction(connection) {
+		await connection.executeQuery(CompiledQuery.raw("rollback"));
+	}
+	async releaseConnection() {
+		this.#connectionMutex.unlock();
+	}
+	async destroy() {
+		this.#db?.close();
+	}
+};
+var NodeSqliteConnection = class {
+	#db;
+	constructor(db) {
+		this.#db = db;
+	}
+	executeQuery(compiledQuery) {
+		const { sql: sql$1, parameters } = compiledQuery;
+		const rows = this.#db.prepare(sql$1).all(...parameters);
+		return Promise.resolve({ rows });
+	}
+	async *streamQuery() {
+		throw new Error("Streaming query is not supported by SQLite driver.");
+	}
+};
+var ConnectionMutex = class {
+	#promise;
+	#resolve;
+	async lock() {
+		while (this.#promise) await this.#promise;
+		this.#promise = new Promise((resolve) => {
+			this.#resolve = resolve;
+		});
+	}
+	unlock() {
+		const resolve = this.#resolve;
+		this.#promise = void 0;
+		this.#resolve = void 0;
+		resolve?.();
+	}
+};
+var NodeSqliteIntrospector = class {
+	#db;
+	constructor(db) {
+		this.#db = db;
+	}
+	async getSchemas() {
+		return [];
+	}
+	async getTables(options = { withInternalKyselyTables: false }) {
+		let query = this.#db.selectFrom("sqlite_schema").where("type", "=", "table").where("name", "not like", "sqlite_%").select("name").$castTo();
+		if (!options.withInternalKyselyTables) query = query.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
+		const tables = await query.execute();
+		return Promise.all(tables.map(({ name }) => this.#getTableMetadata(name)));
+	}
+	async getMetadata(options) {
+		return { tables: await this.getTables(options) };
+	}
+	async #getTableMetadata(table) {
+		const db = this.#db;
+		const autoIncrementCol = (await db.selectFrom("sqlite_master").where("name", "=", table).select("sql").$castTo().execute())[0]?.sql?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
+		return {
+			name: table,
+			columns: (await db.selectFrom(sql`pragma_table_info(${table})`.as("table_info")).select([
+				"name",
+				"type",
+				"notnull",
+				"dflt_value"
+			]).execute()).map((col) => ({
+				name: col.name,
+				dataType: col.type,
+				isNullable: !col.notnull,
+				isAutoIncrementing: col.name === autoIncrementCol,
+				hasDefaultValue: col.dflt_value != null
+			})),
+			isView: true
+		};
+	}
+};
+var NodeSqliteQueryCompiler = class extends DefaultQueryCompiler {
+	getCurrentParameterPlaceholder() {
+		return "?";
+	}
+	getLeftIdentifierWrapper() {
+		return "\"";
+	}
+	getRightIdentifierWrapper() {
+		return "\"";
+	}
+	getAutoIncrement() {
+		return "autoincrement";
+	}
+};
+var NodeSqliteDialect = class {
+	#config;
+	constructor(config) {
+		this.#config = { ...config };
+	}
+	createDriver() {
+		return new NodeSqliteDriver(this.#config);
+	}
+	createQueryCompiler() {
+		return new NodeSqliteQueryCompiler();
+	}
+	createAdapter() {
+		return new NodeSqliteAdapter();
+	}
+	createIntrospector(db) {
+		return new NodeSqliteIntrospector(db);
+	}
+};
+
+//#endregion
+export { NodeSqliteAdapter, NodeSqliteDialect, NodeSqliteDriver, NodeSqliteIntrospector, NodeSqliteQueryCompiler };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/oauth-proxy-Dsp9ntvU.mjs b/node_modules/better-auth/dist/oauth-proxy-Dsp9ntvU.mjs
index a832d85..fe99bbb 100644
--- a/node_modules/better-auth/dist/oauth-proxy-Dsp9ntvU.mjs
+++ b/node_modules/better-auth/dist/oauth-proxy-Dsp9ntvU.mjs
@@ -40,8 +40,8 @@ const oAuthProxy = (opts) => {
 			method: "GET",
 			operationId: "oauthProxyCallback",
 			query: z.object({
-				callbackURL: z.string().meta({ description: "The URL to redirect to after the proxy" }),
-				cookies: z.string().meta({ description: "The cookies to set after the proxy" })
+				callbackURL: z.string(),
+				cookies: z.string()
 			}),
 			use: [originCheck((ctx) => ctx.query.callbackURL)],
 			metadata: { openapi: {
diff --git a/node_modules/better-auth/dist/oauth-proxy-Dsp9ntvU.mjs.bak b/node_modules/better-auth/dist/oauth-proxy-Dsp9ntvU.mjs.bak
new file mode 100644
index 0000000..a832d85
--- /dev/null
+++ b/node_modules/better-auth/dist/oauth-proxy-Dsp9ntvU.mjs.bak
@@ -0,0 +1,165 @@
+import { n as symmetricEncrypt, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { r as getOrigin } from "./url-SXU3XD3W.mjs";
+import { R as originCheck } from "./api-C0IsrmGz.mjs";
+import { t as parseJSON } from "./parser-DcrIEuXE.mjs";
+import { env } from "@better-auth/core/env";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/oauth-proxy/index.ts
+function getVendorBaseURL() {
+	const vercel = env.VERCEL_URL ? `https://${env.VERCEL_URL}` : void 0;
+	const netlify = env.NETLIFY_URL;
+	const render = env.RENDER_URL;
+	const aws = env.AWS_LAMBDA_FUNCTION_NAME;
+	const google = env.GOOGLE_CLOUD_FUNCTION_NAME;
+	const azure = env.AZURE_FUNCTION_NAME;
+	return vercel || netlify || render || aws || google || azure;
+}
+/**
+* A proxy plugin, that allows you to proxy OAuth requests.
+* Useful for development and preview deployments where
+* the redirect URL can't be known in advance to add to the OAuth provider.
+*/
+const oAuthProxy = (opts) => {
+	const resolveCurrentURL = (ctx) => {
+		return new URL(opts?.currentURL || ctx.request?.url || getVendorBaseURL() || ctx.context.baseURL);
+	};
+	const checkSkipProxy = (ctx) => {
+		if (ctx.request?.headers.get("x-skip-oauth-proxy")) return true;
+		const productionURL = opts?.productionURL || env.BETTER_AUTH_URL;
+		if (!productionURL) return false;
+		const currentURL = ctx.request?.url || getVendorBaseURL();
+		if (!currentURL) return false;
+		return getOrigin(productionURL) === getOrigin(currentURL);
+	};
+	return {
+		id: "oauth-proxy",
+		options: opts,
+		endpoints: { oAuthProxy: createAuthEndpoint("/oauth-proxy-callback", {
+			method: "GET",
+			operationId: "oauthProxyCallback",
+			query: z.object({
+				callbackURL: z.string().meta({ description: "The URL to redirect to after the proxy" }),
+				cookies: z.string().meta({ description: "The cookies to set after the proxy" })
+			}),
+			use: [originCheck((ctx) => ctx.query.callbackURL)],
+			metadata: { openapi: {
+				operationId: "oauthProxyCallback",
+				description: "OAuth Proxy Callback",
+				parameters: [{
+					in: "query",
+					name: "callbackURL",
+					required: true,
+					description: "The URL to redirect to after the proxy"
+				}, {
+					in: "query",
+					name: "cookies",
+					required: true,
+					description: "The cookies to set after the proxy"
+				}],
+				responses: { 302: {
+					description: "Redirect",
+					headers: { Location: {
+						description: "The URL to redirect to",
+						schema: { type: "string" }
+					} }
+				} }
+			} }
+		}, async (ctx) => {
+			const cookies = ctx.query.cookies;
+			const decryptedCookies = await symmetricDecrypt({
+				key: ctx.context.secret,
+				data: cookies
+			}).catch((e) => {
+				ctx.context.logger.error(e);
+				return null;
+			});
+			if (!decryptedCookies) {
+				const error = ctx.context.options.onAPIError?.errorURL || `${ctx.context.options.baseURL}/api/auth/error`;
+				throw ctx.redirect(`${error}?error=OAuthProxy - Invalid cookies or secret`);
+			}
+			const prefix = ctx.context.options.advanced?.cookiePrefix || "better-auth";
+			const securePrefix = `__Secure-${prefix}`;
+			const isSecureContext = resolveCurrentURL(ctx).protocol === "https:";
+			const processedCookies = decryptedCookies.split(/,(?=\s*[^,]+=)/).map((cookie) => {
+				const [nameValue = "", ...attrs] = cookie.split(";").map((p) => p.trim());
+				const eqIndex = nameValue.indexOf("=");
+				let name = eqIndex > 0 ? nameValue.slice(0, eqIndex) : nameValue;
+				const value = eqIndex > 0 ? nameValue.slice(eqIndex + 1) : "";
+				if (!isSecureContext && name.includes(securePrefix)) name = name.replace(securePrefix, prefix);
+				const filteredAttrs = attrs.filter((attr) => {
+					const lower = attr.toLowerCase();
+					return !lower.startsWith("domain=") && lower !== "secure";
+				});
+				if (isSecureContext) filteredAttrs.push("Secure");
+				return filteredAttrs.length > 0 ? `${name}=${value}; ${filteredAttrs.join("; ")}` : `${name}=${value}`;
+			});
+			ctx.setHeader("set-cookie", processedCookies.join(", "));
+			throw ctx.redirect(ctx.query.callbackURL);
+		}) },
+		hooks: {
+			after: [{
+				matcher(context) {
+					return !!(context.path?.startsWith("/callback") || context.path?.startsWith("/oauth2/callback"));
+				},
+				handler: createAuthMiddleware(async (ctx) => {
+					const headers = ctx.context.responseHeaders;
+					const location = headers?.get("location");
+					if (!location?.includes("/oauth-proxy-callback?callbackURL") || !location.startsWith("http")) return;
+					const productionOrigin = getOrigin(opts?.productionURL || ctx.context.options.baseURL || ctx.context.baseURL);
+					const locationURL = new URL(location);
+					if (locationURL.origin === productionOrigin) {
+						const newLocation = locationURL.searchParams.get("callbackURL");
+						if (!newLocation) return;
+						ctx.setHeader("location", newLocation);
+						return;
+					}
+					const setCookies = headers?.get("set-cookie");
+					if (!setCookies) return;
+					const encryptedCookies = await symmetricEncrypt({
+						key: ctx.context.secret,
+						data: setCookies
+					});
+					const locationWithCookies = `${location}&cookies=${encodeURIComponent(encryptedCookies)}`;
+					ctx.setHeader("location", locationWithCookies);
+				})
+			}],
+			before: [{
+				matcher() {
+					return true;
+				},
+				handler: createAuthMiddleware(async (ctx) => {
+					if (ctx.path !== "/callback/:id") return;
+					const state = ctx.query?.state || ctx.body?.state;
+					if (!state) return;
+					const data = await ctx.context.internalAdapter.findVerificationValue(state);
+					if (!data) return;
+					let parsedState;
+					try {
+						parsedState = parseJSON(data.value);
+					} catch {
+						parsedState = void 0;
+					}
+					if (!parsedState?.callbackURL?.includes("/oauth-proxy-callback")) return;
+					ctx.context.oauthConfig.skipStateCookieCheck = true;
+				})
+			}, {
+				matcher(context) {
+					return !!(context.path?.startsWith("/sign-in/social") || context.path?.startsWith("/sign-in/oauth2"));
+				},
+				handler: createAuthMiddleware(async (ctx) => {
+					if (!ctx.body) return;
+					if (checkSkipProxy(ctx)) return;
+					const currentURL = resolveCurrentURL(ctx);
+					const originalCallbackURL = ctx.body.callbackURL || ctx.context.baseURL;
+					const newCallbackURL = `${currentURL.origin}${ctx.context.options.basePath || "/api/auth"}/oauth-proxy-callback?callbackURL=${encodeURIComponent(originalCallbackURL)}`;
+					ctx.body.callbackURL = newCallbackURL;
+				})
+			}]
+		}
+	};
+};
+
+//#endregion
+export { oAuthProxy as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/oauth2/index.mjs.bak b/node_modules/better-auth/dist/oauth2/index.mjs.bak
new file mode 100644
index 0000000..3dd815d
--- /dev/null
+++ b/node_modules/better-auth/dist/oauth2/index.mjs.bak
@@ -0,0 +1,19 @@
+import "../dialect-BhkkSrrx.mjs";
+import "../get-model-name-nJd9iPTo.mjs";
+import "../get-migration-C1tgKlQ6.mjs";
+import "../types-BReKsBV6.mjs";
+import { i as parseState, r as generateState } from "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import "../schema-BevzneML.mjs";
+import "../get-request-ip-kbu825ez.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import { F as decryptOAuthToken, I as setTokenUtil, O as handleOAuthUserInfo } from "../api-C0IsrmGz.mjs";
+import "../cookies-Cl2L38B1.mjs";
+import "../session-Efap-vxj.mjs";
+
+export * from "@better-auth/core/oauth2"
+
+export { decryptOAuthToken, generateState, handleOAuthUserInfo, parseState, setTokenUtil };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs b/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs
index 925f837..db957cb 100644
--- a/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs
+++ b/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs
@@ -961,12 +961,12 @@ const oidcProvider = (options) => {
 			registerOAuthApplication: createAuthEndpoint("/oauth2/register", {
 				method: "POST",
 				body: z.object({
-					redirect_uris: z.array(z.string()).meta({ description: "A list of redirect URIs. Eg: [\"https://client.example.com/callback\"]" }),
+					redirect_uris: z.array(z.string()),
 					token_endpoint_auth_method: z.enum([
 						"none",
 						"client_secret_basic",
 						"client_secret_post"
-					]).meta({ description: "The authentication method for the token endpoint. Eg: \"client_secret_basic\"" }).default("client_secret_basic").optional(),
+					]).default("client_secret_basic").optional(),
 					grant_types: z.array(z.enum([
 						"authorization_code",
 						"implicit",
@@ -975,21 +975,21 @@ const oidcProvider = (options) => {
 						"refresh_token",
 						"urn:ietf:params:oauth:grant-type:jwt-bearer",
 						"urn:ietf:params:oauth:grant-type:saml2-bearer"
-					])).meta({ description: "The grant types supported by the application. Eg: [\"authorization_code\"]" }).default(["authorization_code"]).optional(),
-					response_types: z.array(z.enum(["code", "token"])).meta({ description: "The response types supported by the application. Eg: [\"code\"]" }).default(["code"]).optional(),
-					client_name: z.string().meta({ description: "The name of the application. Eg: \"My App\"" }).optional(),
-					client_uri: z.string().meta({ description: "The URI of the application. Eg: \"https://client.example.com\"" }).optional(),
-					logo_uri: z.string().meta({ description: "The URI of the application logo. Eg: \"https://client.example.com/logo.png\"" }).optional(),
-					scope: z.string().meta({ description: "The scopes supported by the application. Separated by spaces. Eg: \"profile email\"" }).optional(),
-					contacts: z.array(z.string()).meta({ description: "The contact information for the application. Eg: [\"admin@example.com\"]" }).optional(),
-					tos_uri: z.string().meta({ description: "The URI of the application terms of service. Eg: \"https://client.example.com/tos\"" }).optional(),
-					policy_uri: z.string().meta({ description: "The URI of the application privacy policy. Eg: \"https://client.example.com/policy\"" }).optional(),
-					jwks_uri: z.string().meta({ description: "The URI of the application JWKS. Eg: \"https://client.example.com/jwks\"" }).optional(),
-					jwks: z.record(z.any(), z.any()).meta({ description: "The JWKS of the application. Eg: {\"keys\": [{\"kty\": \"RSA\", \"alg\": \"RS256\", \"use\": \"sig\", \"n\": \"...\", \"e\": \"...\"}]}" }).optional(),
-					metadata: z.record(z.any(), z.any()).meta({ description: "The metadata of the application. Eg: {\"key\": \"value\"}" }).optional(),
-					software_id: z.string().meta({ description: "The software ID of the application. Eg: \"my-software\"" }).optional(),
-					software_version: z.string().meta({ description: "The software version of the application. Eg: \"1.0.0\"" }).optional(),
-					software_statement: z.string().meta({ description: "The software statement of the application." }).optional()
+					])).default(["authorization_code"]).optional(),
+					response_types: z.array(z.enum(["code", "token"])).default(["code"]).optional(),
+					client_name: z.string().optional(),
+					client_uri: z.string().optional(),
+					logo_uri: z.string().optional(),
+					scope: z.string().optional(),
+					contacts: z.array(z.string()).optional(),
+					tos_uri: z.string().optional(),
+					policy_uri: z.string().optional(),
+					jwks_uri: z.string().optional(),
+					jwks: z.record(z.any(), z.any()).optional(),
+					metadata: z.record(z.any(), z.any()).optional(),
+					software_id: z.string().optional(),
+					software_version: z.string().optional(),
+					software_statement: z.string().optional()
 				}),
 				metadata: { openapi: {
 					description: "Register an OAuth2 application",
diff --git a/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs.bak b/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs.bak
new file mode 100644
index 0000000..bb14b32
--- /dev/null
+++ b/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs.bak
@@ -0,0 +1,1200 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { t as APIError$1 } from "./api-C0IsrmGz.mjs";
+import { l as parseSetCookieHeader } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx, u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { t as getJwtToken } from "./sign-wCNCtKGh.mjs";
+import { getCurrentAuthContext } from "@better-auth/core/context";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createHash } from "@better-auth/utils/hash";
+import { SignJWT } from "jose";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+import { base64, base64Url } from "@better-auth/utils/base64";
+
+//#region src/plugins/oidc-provider/authorize.ts
+function formatErrorURL(url, error, description) {
+	return `${url.includes("?") ? "&" : "?"}error=${error}&error_description=${description}`;
+}
+function getErrorURL(ctx, error, description) {
+	return formatErrorURL(ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`, error, description);
+}
+async function authorize(ctx, options) {
+	const handleRedirect = (url) => {
+		if (ctx.request?.headers.get("sec-fetch-mode") === "cors") return ctx.json({
+			redirect: true,
+			url
+		});
+		else throw ctx.redirect(url);
+	};
+	const opts = {
+		codeExpiresIn: 600,
+		defaultScope: "openid",
+		...options,
+		scopes: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access",
+			...options?.scopes || []
+		]
+	};
+	if (!ctx.request) throw new APIError("UNAUTHORIZED", {
+		error_description: "request not found",
+		error: "invalid_request"
+	});
+	const session = await getSessionFromCtx(ctx);
+	if (!session) {
+		/**
+		* If the user is not logged in, we need to redirect them to the
+		* login page.
+		*/
+		await ctx.setSignedCookie("oidc_login_prompt", JSON.stringify(ctx.query), ctx.context.secret, {
+			maxAge: 600,
+			path: "/",
+			sameSite: "lax"
+		});
+		const queryFromURL = ctx.request.url?.split("?")[1];
+		return handleRedirect(`${options.loginPage}?${queryFromURL}`);
+	}
+	const query = ctx.query;
+	if (!query.client_id) {
+		const errorURL = getErrorURL(ctx, "invalid_client", "client_id is required");
+		throw ctx.redirect(errorURL);
+	}
+	if (!query.response_type) {
+		getErrorURL(ctx, "invalid_request", "response_type is required");
+		throw ctx.redirect(getErrorURL(ctx, "invalid_request", "response_type is required"));
+	}
+	const client = await getClient(ctx.query.client_id, options.trustedClients || []);
+	if (!client) {
+		const errorURL = getErrorURL(ctx, "invalid_client", "client_id is required");
+		throw ctx.redirect(errorURL);
+	}
+	const redirectURI = client.redirectUrls.find((url) => url === ctx.query.redirect_uri);
+	if (!redirectURI || !query.redirect_uri)
+ /**
+	* show UI error here warning the user that the redirect URI is invalid
+	*/
+	throw new APIError("BAD_REQUEST", { message: "Invalid redirect URI" });
+	if (client.disabled) {
+		const errorURL = getErrorURL(ctx, "client_disabled", "client is disabled");
+		throw ctx.redirect(errorURL);
+	}
+	if (query.response_type !== "code") {
+		const errorURL = getErrorURL(ctx, "unsupported_response_type", "unsupported response type");
+		throw ctx.redirect(errorURL);
+	}
+	const requestScope = query.scope?.split(" ").filter((s) => s) || opts.defaultScope.split(" ");
+	const invalidScopes = requestScope.filter((scope) => {
+		return !opts.scopes.includes(scope);
+	});
+	if (invalidScopes.length) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_scope", `The following scopes are invalid: ${invalidScopes.join(", ")}`));
+	if ((!query.code_challenge || !query.code_challenge_method) && options.requirePKCE) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_request", "pkce is required"));
+	if (!query.code_challenge_method) query.code_challenge_method = "plain";
+	if (!["s256", options.allowPlainCodeChallengeMethod ? "plain" : "s256"].includes(query.code_challenge_method?.toLowerCase() || "")) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_request", "invalid code_challenge method"));
+	const code = generateRandomString(32, "a-z", "A-Z", "0-9");
+	const codeExpiresInMs = opts.codeExpiresIn * 1e3;
+	const expiresAt = new Date(Date.now() + codeExpiresInMs);
+	const skipConsentForTrustedClient = client.skipConsent;
+	const hasAlreadyConsented = await ctx.context.adapter.findOne({
+		model: "oauthConsent",
+		where: [{
+			field: "clientId",
+			value: client.clientId
+		}, {
+			field: "userId",
+			value: session.user.id
+		}]
+	}).then((res) => !!res?.consentGiven);
+	const requireConsent = !skipConsentForTrustedClient && (!hasAlreadyConsented || query.prompt === "consent");
+	try {
+		/**
+		* Save the code in the database
+		*/
+		await ctx.context.internalAdapter.createVerificationValue({
+			value: JSON.stringify({
+				clientId: client.clientId,
+				redirectURI: query.redirect_uri,
+				scope: requestScope,
+				userId: session.user.id,
+				authTime: new Date(session.session.createdAt).getTime(),
+				requireConsent,
+				state: requireConsent ? query.state : null,
+				codeChallenge: query.code_challenge,
+				codeChallengeMethod: query.code_challenge_method,
+				nonce: query.nonce
+			}),
+			identifier: code,
+			expiresAt
+		});
+	} catch (e) {
+		return handleRedirect(formatErrorURL(query.redirect_uri, "server_error", "An error occurred while processing the request"));
+	}
+	if (!requireConsent) {
+		const redirectURIWithCode = new URL(redirectURI);
+		redirectURIWithCode.searchParams.set("code", code);
+		redirectURIWithCode.searchParams.set("state", ctx.query.state);
+		return handleRedirect(redirectURIWithCode.toString());
+	}
+	if (options?.consentPage) {
+		await ctx.setSignedCookie("oidc_consent_prompt", code, ctx.context.secret, {
+			maxAge: 600,
+			path: "/",
+			sameSite: "lax"
+		});
+		const urlParams = new URLSearchParams();
+		urlParams.set("consent_code", code);
+		urlParams.set("client_id", client.clientId);
+		urlParams.set("scope", requestScope.join(" "));
+		return handleRedirect(`${options.consentPage}?${urlParams.toString()}`);
+	}
+	const htmlFn = options?.getConsentHTML;
+	if (!htmlFn) throw new APIError("INTERNAL_SERVER_ERROR", { message: "No consent page provided" });
+	return new Response(htmlFn({
+		scopes: requestScope,
+		clientMetadata: client.metadata,
+		clientIcon: client?.icon,
+		clientId: client.clientId,
+		clientName: client.name,
+		code
+	}), { headers: { "content-type": "text/html" } });
+}
+
+//#endregion
+//#region src/plugins/oidc-provider/schema.ts
+const oAuthApplicationSchema = z.object({
+	clientId: z.string(),
+	clientSecret: z.string().optional(),
+	type: z.enum([
+		"web",
+		"native",
+		"user-agent-based",
+		"public"
+	]),
+	name: z.string(),
+	icon: z.string().optional(),
+	metadata: z.string().optional(),
+	disabled: z.boolean().optional().default(false),
+	redirectUrls: z.string(),
+	userId: z.string().optional(),
+	createdAt: z.date(),
+	updatedAt: z.date()
+});
+const schema = {
+	oauthApplication: {
+		modelName: "oauthApplication",
+		fields: {
+			name: { type: "string" },
+			icon: {
+				type: "string",
+				required: false
+			},
+			metadata: {
+				type: "string",
+				required: false
+			},
+			clientId: {
+				type: "string",
+				unique: true
+			},
+			clientSecret: {
+				type: "string",
+				required: false
+			},
+			redirectUrls: { type: "string" },
+			type: { type: "string" },
+			disabled: {
+				type: "boolean",
+				required: false,
+				defaultValue: false
+			},
+			userId: {
+				type: "string",
+				required: false,
+				references: {
+					model: "user",
+					field: "id",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			createdAt: { type: "date" },
+			updatedAt: { type: "date" }
+		}
+	},
+	oauthAccessToken: {
+		modelName: "oauthAccessToken",
+		fields: {
+			accessToken: {
+				type: "string",
+				unique: true
+			},
+			refreshToken: {
+				type: "string",
+				unique: true
+			},
+			accessTokenExpiresAt: { type: "date" },
+			refreshTokenExpiresAt: { type: "date" },
+			clientId: {
+				type: "string",
+				references: {
+					model: "oauthApplication",
+					field: "clientId",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			userId: {
+				type: "string",
+				required: false,
+				references: {
+					model: "user",
+					field: "id",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			scopes: { type: "string" },
+			createdAt: { type: "date" },
+			updatedAt: { type: "date" }
+		}
+	},
+	oauthConsent: {
+		modelName: "oauthConsent",
+		fields: {
+			clientId: {
+				type: "string",
+				references: {
+					model: "oauthApplication",
+					field: "clientId",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			userId: {
+				type: "string",
+				references: {
+					model: "user",
+					field: "id",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			scopes: { type: "string" },
+			createdAt: { type: "date" },
+			updatedAt: { type: "date" },
+			consentGiven: { type: "boolean" }
+		}
+	}
+};
+
+//#endregion
+//#region src/plugins/oidc-provider/utils.ts
+/**
+* Default client secret hasher using SHA-256
+*/
+const defaultClientSecretHasher = async (clientSecret) => {
+	const hash = await createHash("SHA-256").digest(new TextEncoder().encode(clientSecret));
+	return base64Url.encode(new Uint8Array(hash), { padding: false });
+};
+
+//#endregion
+//#region src/plugins/oidc-provider/index.ts
+const getJwtPlugin = (ctx) => {
+	return ctx.context.options.plugins?.find((plugin) => plugin.id === "jwt");
+};
+/**
+* Get a client by ID, checking trusted clients first, then database
+*/
+async function getClient(clientId, trustedClients = []) {
+	const { context: { adapter } } = await getCurrentAuthContext();
+	const trustedClient = trustedClients.find((client) => client.clientId === clientId);
+	if (trustedClient) return trustedClient;
+	return adapter.findOne({
+		model: "oauthApplication",
+		where: [{
+			field: "clientId",
+			value: clientId
+		}]
+	}).then((res) => {
+		if (!res) return null;
+		return {
+			clientId: res.clientId,
+			clientSecret: res.clientSecret,
+			type: res.type,
+			name: res.name,
+			icon: res.icon,
+			disabled: res.disabled,
+			redirectUrls: (res.redirectUrls ?? "").split(","),
+			metadata: res.metadata ? JSON.parse(res.metadata) : {}
+		};
+	});
+}
+const getMetadata = (ctx, options) => {
+	const jwtPlugin = getJwtPlugin(ctx);
+	const issuer = jwtPlugin && jwtPlugin.options?.jwt && jwtPlugin.options.jwt.issuer ? jwtPlugin.options.jwt.issuer : ctx.context.options.baseURL;
+	const baseURL = ctx.context.baseURL;
+	const supportedAlgs = options?.useJWTPlugin ? [
+		"RS256",
+		"EdDSA",
+		"none"
+	] : ["HS256", "none"];
+	return {
+		issuer,
+		authorization_endpoint: `${baseURL}/oauth2/authorize`,
+		token_endpoint: `${baseURL}/oauth2/token`,
+		userinfo_endpoint: `${baseURL}/oauth2/userinfo`,
+		jwks_uri: `${baseURL}/jwks`,
+		registration_endpoint: `${baseURL}/oauth2/register`,
+		scopes_supported: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access"
+		],
+		response_types_supported: ["code"],
+		response_modes_supported: ["query"],
+		grant_types_supported: ["authorization_code", "refresh_token"],
+		acr_values_supported: ["urn:mace:incommon:iap:silver", "urn:mace:incommon:iap:bronze"],
+		subject_types_supported: ["public"],
+		id_token_signing_alg_values_supported: supportedAlgs,
+		token_endpoint_auth_methods_supported: [
+			"client_secret_basic",
+			"client_secret_post",
+			"none"
+		],
+		code_challenge_methods_supported: ["S256"],
+		claims_supported: [
+			"sub",
+			"iss",
+			"aud",
+			"exp",
+			"nbf",
+			"iat",
+			"jti",
+			"email",
+			"email_verified",
+			"name"
+		],
+		...options?.metadata
+	};
+};
+/**
+* OpenID Connect (OIDC) plugin for Better Auth. This plugin implements the
+* authorization code flow and the token exchange flow. It also implements the
+* userinfo endpoint.
+*
+* @param options - The options for the OIDC plugin.
+* @returns A Better Auth plugin.
+*/
+const oidcProvider = (options) => {
+	const modelName = {
+		oauthClient: "oauthApplication",
+		oauthAccessToken: "oauthAccessToken",
+		oauthConsent: "oauthConsent"
+	};
+	const opts = {
+		codeExpiresIn: 600,
+		defaultScope: "openid",
+		accessTokenExpiresIn: 3600,
+		refreshTokenExpiresIn: 604800,
+		allowPlainCodeChallengeMethod: true,
+		storeClientSecret: "plain",
+		...options,
+		scopes: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access",
+			...options?.scopes || []
+		]
+	};
+	const trustedClients = options.trustedClients || [];
+	/**
+	* Store client secret according to the configured storage method
+	*/
+	async function storeClientSecret(ctx, clientSecret) {
+		if (opts.storeClientSecret === "encrypted") return await symmetricEncrypt({
+			key: ctx.context.secret,
+			data: clientSecret
+		});
+		if (opts.storeClientSecret === "hashed") return await defaultClientSecretHasher(clientSecret);
+		if (typeof opts.storeClientSecret === "object" && "hash" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret);
+		if (typeof opts.storeClientSecret === "object" && "encrypt" in opts.storeClientSecret) return await opts.storeClientSecret.encrypt(clientSecret);
+		return clientSecret;
+	}
+	/**
+	* Verify stored client secret against provided client secret
+	*/
+	async function verifyStoredClientSecret(ctx, storedClientSecret, clientSecret) {
+		if (opts.storeClientSecret === "encrypted") return await symmetricDecrypt({
+			key: ctx.context.secret,
+			data: storedClientSecret
+		}) === clientSecret;
+		if (opts.storeClientSecret === "hashed") return await defaultClientSecretHasher(clientSecret) === storedClientSecret;
+		if (typeof opts.storeClientSecret === "object" && "hash" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret) === storedClientSecret;
+		if (typeof opts.storeClientSecret === "object" && "decrypt" in opts.storeClientSecret) return await opts.storeClientSecret.decrypt(storedClientSecret) === clientSecret;
+		return clientSecret === storedClientSecret;
+	}
+	return {
+		id: "oidc",
+		hooks: { after: [{
+			matcher() {
+				return true;
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const cookie = await ctx.getSignedCookie("oidc_login_prompt", ctx.context.secret);
+				const cookieName = ctx.context.authCookies.sessionToken.name;
+				const parsedSetCookieHeader = parseSetCookieHeader(ctx.context.responseHeaders?.get("set-cookie") || "");
+				const hasSessionToken = parsedSetCookieHeader.has(cookieName);
+				if (!cookie || !hasSessionToken) return;
+				ctx.setCookie("oidc_login_prompt", "", { maxAge: 0 });
+				const sessionToken = (parsedSetCookieHeader.get(cookieName)?.value)?.split(".")[0];
+				if (!sessionToken) return;
+				const session = await ctx.context.internalAdapter.findSession(sessionToken);
+				if (!session) return;
+				ctx.query = JSON.parse(cookie);
+				ctx.context.session = session;
+				return await authorize(ctx, opts);
+			})
+		}] },
+		endpoints: {
+			getOpenIdConfig: createAuthEndpoint("/.well-known/openid-configuration", {
+				method: "GET",
+				operationId: "getOpenIdConfig",
+				metadata: { isAction: false }
+			}, async (ctx) => {
+				const metadata = getMetadata(ctx, options);
+				return ctx.json(metadata);
+			}),
+			oAuth2authorize: createAuthEndpoint("/oauth2/authorize", {
+				method: "GET",
+				operationId: "oauth2Authorize",
+				query: z.record(z.string(), z.any()),
+				metadata: { openapi: {
+					description: "Authorize an OAuth2 request",
+					responses: { "200": {
+						description: "Authorization response generated successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							additionalProperties: true,
+							description: "Authorization response, contents depend on the authorize function implementation"
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				return authorize(ctx, opts);
+			}),
+			oAuthConsent: createAuthEndpoint("/oauth2/consent", {
+				method: "POST",
+				operationId: "oauth2Consent",
+				body: z.object({
+					accept: z.boolean(),
+					consent_code: z.string().optional().nullish()
+				}),
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Handle OAuth2 consent. Supports both URL parameter-based flows (consent_code in body) and cookie-based flows (signed cookie).",
+					requestBody: {
+						required: true,
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								accept: {
+									type: "boolean",
+									description: "Whether the user accepts or denies the consent request"
+								},
+								consent_code: {
+									type: "string",
+									description: "The consent code from the authorization request. Optional if using cookie-based flow."
+								}
+							},
+							required: ["accept"]
+						} } }
+					},
+					responses: { "200": {
+						description: "Consent processed successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { redirectURI: {
+								type: "string",
+								format: "uri",
+								description: "The URI to redirect to, either with an authorization code or an error"
+							} },
+							required: ["redirectURI"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				let consentCode = ctx.body.consent_code || null;
+				if (!consentCode) consentCode = await ctx.getSignedCookie("oidc_consent_prompt", ctx.context.secret);
+				if (!consentCode) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "consent_code is required (either in body or cookie)",
+					error: "invalid_request"
+				});
+				const verification = await ctx.context.internalAdapter.findVerificationValue(consentCode);
+				if (!verification) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "Invalid code",
+					error: "invalid_request"
+				});
+				if (verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "Code expired",
+					error: "invalid_request"
+				});
+				ctx.setCookie("oidc_consent_prompt", "", { maxAge: 0 });
+				const value = JSON.parse(verification.value);
+				if (!value.requireConsent) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "Consent not required",
+					error: "invalid_request"
+				});
+				if (!ctx.body.accept) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
+					return ctx.json({ redirectURI: `${value.redirectURI}?error=access_denied&error_description=User denied access` });
+				}
+				const code = generateRandomString(32, "a-z", "A-Z", "0-9");
+				const codeExpiresInMs = opts.codeExpiresIn * 1e3;
+				const expiresAt = new Date(Date.now() + codeExpiresInMs);
+				await ctx.context.internalAdapter.updateVerificationValue(verification.id, {
+					value: JSON.stringify({
+						...value,
+						requireConsent: false
+					}),
+					identifier: code,
+					expiresAt
+				});
+				await ctx.context.adapter.create({
+					model: modelName.oauthConsent,
+					data: {
+						clientId: value.clientId,
+						userId: value.userId,
+						scopes: value.scope.join(" "),
+						consentGiven: true,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}
+				});
+				const redirectURI = new URL(value.redirectURI);
+				redirectURI.searchParams.set("code", code);
+				if (value.state) redirectURI.searchParams.set("state", value.state);
+				return ctx.json({ redirectURI: redirectURI.toString() });
+			}),
+			oAuth2token: createAuthEndpoint("/oauth2/token", {
+				method: "POST",
+				operationId: "oauth2Token",
+				body: z.record(z.any(), z.any()),
+				metadata: { isAction: false }
+			}, async (ctx) => {
+				let { body } = ctx;
+				if (!body) throw new APIError$1("BAD_REQUEST", {
+					error_description: "request body not found",
+					error: "invalid_request"
+				});
+				if (body instanceof FormData) body = Object.fromEntries(body.entries());
+				if (!(body instanceof Object)) throw new APIError$1("BAD_REQUEST", {
+					error_description: "request body is not an object",
+					error: "invalid_request"
+				});
+				let { client_id, client_secret } = body;
+				const authorization = ctx.request?.headers.get("authorization") || null;
+				if (authorization && !client_id && !client_secret && authorization.startsWith("Basic ")) try {
+					const encoded = authorization.replace("Basic ", "");
+					const decoded = new TextDecoder().decode(base64.decode(encoded));
+					if (!decoded.includes(":")) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+					const [id, secret] = decoded.split(":");
+					if (!id || !secret) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+					client_id = id;
+					client_secret = secret;
+				} catch (error) {
+					throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+				}
+				const now = Date.now();
+				const iat = Math.floor(now / 1e3);
+				const exp = iat + (opts.accessTokenExpiresIn ?? 3600);
+				const accessTokenExpiresAt = /* @__PURE__ */ new Date(exp * 1e3);
+				const refreshTokenExpiresAt = /* @__PURE__ */ new Date((iat + (opts.refreshTokenExpiresIn ?? 604800)) * 1e3);
+				const { grant_type, code, redirect_uri, refresh_token, code_verifier } = body;
+				if (grant_type === "refresh_token") {
+					if (!refresh_token) throw new APIError$1("BAD_REQUEST", {
+						error_description: "refresh_token is required",
+						error: "invalid_request"
+					});
+					const token = await ctx.context.adapter.findOne({
+						model: modelName.oauthAccessToken,
+						where: [{
+							field: "refreshToken",
+							value: refresh_token.toString()
+						}]
+					});
+					if (!token) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid refresh token",
+						error: "invalid_grant"
+					});
+					if (token.clientId !== client_id?.toString()) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid client_id",
+						error: "invalid_client"
+					});
+					if (token.refreshTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "refresh token expired",
+						error: "invalid_grant"
+					});
+					const accessToken$1 = generateRandomString(32, "a-z", "A-Z");
+					const newRefreshToken = generateRandomString(32, "a-z", "A-Z");
+					await ctx.context.adapter.create({
+						model: modelName.oauthAccessToken,
+						data: {
+							accessToken: accessToken$1,
+							refreshToken: newRefreshToken,
+							accessTokenExpiresAt,
+							refreshTokenExpiresAt,
+							clientId: client_id.toString(),
+							userId: token.userId,
+							scopes: token.scopes,
+							createdAt: /* @__PURE__ */ new Date(iat * 1e3),
+							updatedAt: /* @__PURE__ */ new Date(iat * 1e3)
+						}
+					});
+					return ctx.json({
+						access_token: accessToken$1,
+						token_type: "Bearer",
+						expires_in: opts.accessTokenExpiresIn,
+						refresh_token: newRefreshToken,
+						scope: token.scopes
+					});
+				}
+				if (!code) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code is required",
+					error: "invalid_request"
+				});
+				if (options.requirePKCE && !code_verifier) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code verifier is missing",
+					error: "invalid_request"
+				});
+				/**
+				* We need to check if the code is valid before we can proceed
+				* with the rest of the request.
+				*/
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(code.toString());
+				if (!verificationValue) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid code",
+					error: "invalid_grant"
+				});
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "code expired",
+					error: "invalid_grant"
+				});
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				if (!client_id) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client_id is required",
+					error: "invalid_client"
+				});
+				if (!grant_type) throw new APIError$1("BAD_REQUEST", {
+					error_description: "grant_type is required",
+					error: "invalid_request"
+				});
+				if (grant_type !== "authorization_code") throw new APIError$1("BAD_REQUEST", {
+					error_description: "grant_type must be 'authorization_code'",
+					error: "unsupported_grant_type"
+				});
+				if (!redirect_uri) throw new APIError$1("BAD_REQUEST", {
+					error_description: "redirect_uri is required",
+					error: "invalid_request"
+				});
+				const client = await getClient(client_id.toString(), trustedClients);
+				if (!client) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid client_id",
+					error: "invalid_client"
+				});
+				if (client.disabled) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client is disabled",
+					error: "invalid_client"
+				});
+				const value = JSON.parse(verificationValue.value);
+				if (value.clientId !== client_id.toString()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid client_id",
+					error: "invalid_client"
+				});
+				if (value.redirectURI !== redirect_uri.toString()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid redirect_uri",
+					error: "invalid_client"
+				});
+				if (value.codeChallenge && !code_verifier) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code verifier is missing",
+					error: "invalid_request"
+				});
+				if (client.type === "public") {
+					if (!code_verifier) throw new APIError$1("BAD_REQUEST", {
+						error_description: "code verifier is required for public clients",
+						error: "invalid_request"
+					});
+				} else {
+					if (!client.clientSecret || !client_secret) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "client_secret is required for confidential clients",
+						error: "invalid_client"
+					});
+					if (!await verifyStoredClientSecret(ctx, client.clientSecret, client_secret.toString())) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid client_secret",
+						error: "invalid_client"
+					});
+				}
+				if ((value.codeChallengeMethod === "plain" ? code_verifier : await createHash("SHA-256", "base64urlnopad").digest(code_verifier)) !== value.codeChallenge) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "code verification failed",
+					error: "invalid_request"
+				});
+				const requestedScopes = value.scope;
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				const accessToken = generateRandomString(32, "a-z", "A-Z");
+				const refreshToken = generateRandomString(32, "A-Z", "a-z");
+				await ctx.context.adapter.create({
+					model: modelName.oauthAccessToken,
+					data: {
+						accessToken,
+						refreshToken,
+						accessTokenExpiresAt,
+						refreshTokenExpiresAt,
+						clientId: client_id.toString(),
+						userId: value.userId,
+						scopes: requestedScopes.join(" "),
+						createdAt: /* @__PURE__ */ new Date(iat * 1e3),
+						updatedAt: /* @__PURE__ */ new Date(iat * 1e3)
+					}
+				});
+				const user = await ctx.context.internalAdapter.findUserById(value.userId);
+				if (!user) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "user not found",
+					error: "invalid_grant"
+				});
+				const profile = {
+					given_name: user.name.split(" ")[0],
+					family_name: user.name.split(" ")[1],
+					name: user.name,
+					profile: user.image,
+					updated_at: new Date(user.updatedAt).toISOString()
+				};
+				const email = {
+					email: user.email,
+					email_verified: user.emailVerified
+				};
+				const userClaims = {
+					...requestedScopes.includes("profile") ? profile : {},
+					...requestedScopes.includes("email") ? email : {}
+				};
+				const additionalUserClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : {};
+				const payload = {
+					sub: user.id,
+					aud: client_id.toString(),
+					iat,
+					auth_time: ctx.context.session ? new Date(ctx.context.session.session.createdAt).getTime() : void 0,
+					nonce: value.nonce,
+					acr: "urn:mace:incommon:iap:silver",
+					...userClaims,
+					...additionalUserClaims
+				};
+				const expirationTime = Math.floor(Date.now() / 1e3) + opts.accessTokenExpiresIn;
+				let idToken;
+				if (options.useJWTPlugin) {
+					const jwtPlugin = getJwtPlugin(ctx);
+					if (!jwtPlugin) {
+						ctx.context.logger.error("OIDC: `useJWTPlugin` is enabled but the JWT plugin is not available. Make sure you have the JWT Plugin in your plugins array or set `useJWTPlugin` to false.");
+						throw new APIError$1("INTERNAL_SERVER_ERROR", {
+							error_description: "JWT plugin is not enabled",
+							error: "internal_server_error"
+						});
+					}
+					idToken = await getJwtToken({
+						...ctx,
+						context: {
+							...ctx.context,
+							session: {
+								session: {
+									id: generateRandomString(32, "a-z", "A-Z"),
+									createdAt: /* @__PURE__ */ new Date(iat * 1e3),
+									updatedAt: /* @__PURE__ */ new Date(iat * 1e3),
+									userId: user.id,
+									expiresAt: accessTokenExpiresAt,
+									token: accessToken,
+									ipAddress: ctx.request?.headers.get("x-forwarded-for")
+								},
+								user
+							}
+						}
+					}, {
+						...jwtPlugin.options,
+						jwt: {
+							...jwtPlugin.options?.jwt,
+							getSubject: () => user.id,
+							audience: client_id.toString(),
+							issuer: jwtPlugin.options?.jwt?.issuer ?? ctx.context.options.baseURL,
+							expirationTime,
+							definePayload: () => payload
+						}
+					});
+				} else idToken = await new SignJWT(payload).setProtectedHeader({ alg: "HS256" }).setIssuedAt(iat).setExpirationTime(accessTokenExpiresAt).sign(new TextEncoder().encode(client.clientSecret));
+				return ctx.json({
+					access_token: accessToken,
+					token_type: "Bearer",
+					expires_in: opts.accessTokenExpiresIn,
+					refresh_token: requestedScopes.includes("offline_access") ? refreshToken : void 0,
+					scope: requestedScopes.join(" "),
+					id_token: requestedScopes.includes("openid") ? idToken : void 0
+				}, { headers: {
+					"Cache-Control": "no-store",
+					Pragma: "no-cache"
+				} });
+			}),
+			oAuth2userInfo: createAuthEndpoint("/oauth2/userinfo", {
+				method: "GET",
+				operationId: "oauth2Userinfo",
+				use: [sessionMiddleware],
+				metadata: {
+					isAction: false,
+					openapi: {
+						description: "Get OAuth2 user information",
+						responses: { "200": {
+							description: "User information retrieved successfully",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									sub: {
+										type: "string",
+										description: "Subject identifier (user ID)"
+									},
+									email: {
+										type: "string",
+										format: "email",
+										nullable: true,
+										description: "User's email address, included if 'email' scope is granted"
+									},
+									name: {
+										type: "string",
+										nullable: true,
+										description: "User's full name, included if 'profile' scope is granted"
+									},
+									picture: {
+										type: "string",
+										format: "uri",
+										nullable: true,
+										description: "User's profile picture URL, included if 'profile' scope is granted"
+									},
+									given_name: {
+										type: "string",
+										nullable: true,
+										description: "User's given name, included if 'profile' scope is granted"
+									},
+									family_name: {
+										type: "string",
+										nullable: true,
+										description: "User's family name, included if 'profile' scope is granted"
+									},
+									email_verified: {
+										type: "boolean",
+										nullable: true,
+										description: "Whether the email is verified, included if 'email' scope is granted"
+									}
+								},
+								required: ["sub"]
+							} } }
+						} }
+					}
+				}
+			}, async (ctx) => {
+				if (!ctx.request) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "request not found",
+					error: "invalid_request"
+				});
+				const authorization = ctx.request.headers.get("authorization");
+				if (!authorization) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "authorization header not found",
+					error: "invalid_request"
+				});
+				const token = authorization.replace("Bearer ", "");
+				const accessToken = await ctx.context.adapter.findOne({
+					model: modelName.oauthAccessToken,
+					where: [{
+						field: "accessToken",
+						value: token
+					}]
+				});
+				if (!accessToken) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid access token",
+					error: "invalid_token"
+				});
+				if (accessToken.accessTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "The Access Token expired",
+					error: "invalid_token"
+				});
+				const client = await getClient(accessToken.clientId, trustedClients);
+				if (!client) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client not found",
+					error: "invalid_token"
+				});
+				const user = await ctx.context.internalAdapter.findUserById(accessToken.userId);
+				if (!user) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "user not found",
+					error: "invalid_token"
+				});
+				const requestedScopes = accessToken.scopes.split(" ");
+				const baseUserClaims = {
+					sub: user.id,
+					email: requestedScopes.includes("email") ? user.email : void 0,
+					name: requestedScopes.includes("profile") ? user.name : void 0,
+					picture: requestedScopes.includes("profile") ? user.image : void 0,
+					given_name: requestedScopes.includes("profile") ? user.name.split(" ")[0] : void 0,
+					family_name: requestedScopes.includes("profile") ? user.name.split(" ")[1] : void 0,
+					email_verified: requestedScopes.includes("email") ? user.emailVerified : void 0
+				};
+				const userClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : baseUserClaims;
+				return ctx.json({
+					...baseUserClaims,
+					...userClaims
+				});
+			}),
+			registerOAuthApplication: createAuthEndpoint("/oauth2/register", {
+				method: "POST",
+				body: z.object({
+					redirect_uris: z.array(z.string()),
+					token_endpoint_auth_method: z.enum([
+						"none",
+						"client_secret_basic",
+						"client_secret_post"
+					]).default("client_secret_basic").optional(),
+					grant_types: z.array(z.enum([
+						"authorization_code",
+						"implicit",
+						"password",
+						"client_credentials",
+						"refresh_token",
+						"urn:ietf:params:oauth:grant-type:jwt-bearer",
+						"urn:ietf:params:oauth:grant-type:saml2-bearer"
+					])).default(["authorization_code"]).optional(),
+					response_types: z.array(z.enum(["code", "token"])).default(["code"]).optional(),
+					client_name: z.string().optional(),
+					client_uri: z.string().optional(),
+					logo_uri: z.string().optional(),
+					scope: z.string().optional(),
+					contacts: z.array(z.string()).optional(),
+					tos_uri: z.string().optional(),
+					policy_uri: z.string().optional(),
+					jwks_uri: z.string().optional(),
+					jwks: z.record(z.any(), z.any()).meta({ description: "The JWKS of the application. Eg: {\"keys\": [{\"kty\": \"RSA\", \"alg\": \"RS256\", \"use\": \"sig\", \"n\": \"...\", \"e\": \"...\"}]}" }).optional(),
+					metadata: z.record(z.any(), z.any()).meta({ description: "The metadata of the application. Eg: {\"key\": \"value\"}" }).optional(),
+					software_id: z.string().optional(),
+					software_version: z.string().optional(),
+					software_statement: z.string().optional()
+				}),
+				metadata: { openapi: {
+					description: "Register an OAuth2 application",
+					responses: { "200": {
+						description: "OAuth2 application registered successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								name: {
+									type: "string",
+									description: "Name of the OAuth2 application"
+								},
+								icon: {
+									type: "string",
+									nullable: true,
+									description: "Icon URL for the application"
+								},
+								metadata: {
+									type: "object",
+									additionalProperties: true,
+									nullable: true,
+									description: "Additional metadata for the application"
+								},
+								clientId: {
+									type: "string",
+									description: "Unique identifier for the client"
+								},
+								clientSecret: {
+									type: "string",
+									description: "Secret key for the client"
+								},
+								redirectURLs: {
+									type: "array",
+									items: {
+										type: "string",
+										format: "uri"
+									},
+									description: "List of allowed redirect URLs"
+								},
+								type: {
+									type: "string",
+									description: "Type of the client",
+									enum: ["web"]
+								},
+								authenticationScheme: {
+									type: "string",
+									description: "Authentication scheme used by the client",
+									enum: ["client_secret"]
+								},
+								disabled: {
+									type: "boolean",
+									description: "Whether the client is disabled",
+									enum: [false]
+								},
+								userId: {
+									type: "string",
+									nullable: true,
+									description: "ID of the user who registered the client, null if registered anonymously"
+								},
+								createdAt: {
+									type: "string",
+									format: "date-time",
+									description: "Creation timestamp"
+								},
+								updatedAt: {
+									type: "string",
+									format: "date-time",
+									description: "Last update timestamp"
+								}
+							},
+							required: [
+								"name",
+								"clientId",
+								"clientSecret",
+								"redirectURLs",
+								"type",
+								"authenticationScheme",
+								"disabled",
+								"createdAt",
+								"updatedAt"
+							]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const body = ctx.body;
+				const session = await getSessionFromCtx(ctx);
+				if (!session && !options.allowDynamicClientRegistration) throw new APIError$1("UNAUTHORIZED", {
+					error: "invalid_token",
+					error_description: "Authentication required for client registration"
+				});
+				if ((!body.grant_types || body.grant_types.includes("authorization_code") || body.grant_types.includes("implicit")) && (!body.redirect_uris || body.redirect_uris.length === 0)) throw new APIError$1("BAD_REQUEST", {
+					error: "invalid_redirect_uri",
+					error_description: "Redirect URIs are required for authorization_code and implicit grant types"
+				});
+				if (body.grant_types && body.response_types) {
+					if (body.grant_types.includes("authorization_code") && !body.response_types.includes("code")) throw new APIError$1("BAD_REQUEST", {
+						error: "invalid_client_metadata",
+						error_description: "When 'authorization_code' grant type is used, 'code' response type must be included"
+					});
+					if (body.grant_types.includes("implicit") && !body.response_types.includes("token")) throw new APIError$1("BAD_REQUEST", {
+						error: "invalid_client_metadata",
+						error_description: "When 'implicit' grant type is used, 'token' response type must be included"
+					});
+				}
+				const clientId = options.generateClientId?.() || generateRandomString(32, "a-z", "A-Z");
+				const clientSecret = options.generateClientSecret?.() || generateRandomString(32, "a-z", "A-Z");
+				const storedClientSecret = await storeClientSecret(ctx, clientSecret);
+				const client = await ctx.context.adapter.create({
+					model: modelName.oauthClient,
+					data: {
+						name: body.client_name,
+						icon: body.logo_uri,
+						metadata: body.metadata ? JSON.stringify(body.metadata) : null,
+						clientId,
+						clientSecret: storedClientSecret,
+						redirectUrls: body.redirect_uris.join(","),
+						type: "web",
+						authenticationScheme: body.token_endpoint_auth_method || "client_secret_basic",
+						disabled: false,
+						userId: session?.session.userId,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}
+				});
+				return ctx.json({
+					client_id: clientId,
+					...client.type !== "public" ? {
+						client_secret: clientSecret,
+						client_secret_expires_at: 0
+					} : {},
+					client_id_issued_at: Math.floor(Date.now() / 1e3),
+					client_secret_expires_at: 0,
+					redirect_uris: body.redirect_uris,
+					token_endpoint_auth_method: body.token_endpoint_auth_method || "client_secret_basic",
+					grant_types: body.grant_types || ["authorization_code"],
+					response_types: body.response_types || ["code"],
+					client_name: body.client_name,
+					client_uri: body.client_uri,
+					logo_uri: body.logo_uri,
+					scope: body.scope,
+					contacts: body.contacts,
+					tos_uri: body.tos_uri,
+					policy_uri: body.policy_uri,
+					jwks_uri: body.jwks_uri,
+					jwks: body.jwks,
+					software_id: body.software_id,
+					software_version: body.software_version,
+					software_statement: body.software_statement,
+					metadata: body.metadata
+				}, {
+					status: 201,
+					headers: {
+						"Cache-Control": "no-store",
+						Pragma: "no-cache"
+					}
+				});
+			}),
+			getOAuthClient: createAuthEndpoint("/oauth2/client/:id", {
+				method: "GET",
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Get OAuth2 client details",
+					responses: { "200": {
+						description: "OAuth2 client retrieved successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								clientId: {
+									type: "string",
+									description: "Unique identifier for the client"
+								},
+								name: {
+									type: "string",
+									description: "Name of the OAuth2 application"
+								},
+								icon: {
+									type: "string",
+									nullable: true,
+									description: "Icon URL for the application"
+								}
+							},
+							required: ["clientId", "name"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const client = await getClient(ctx.params.id, trustedClients);
+				if (!client) throw new APIError$1("NOT_FOUND", {
+					error_description: "client not found",
+					error: "not_found"
+				});
+				return ctx.json({
+					clientId: client.clientId,
+					name: client.name,
+					icon: client.icon || null
+				});
+			})
+		},
+		schema: mergeSchema(schema, options?.schema),
+		get options() {
+			return opts;
+		}
+	};
+};
+
+//#endregion
+export { schema as i, getMetadata as n, oidcProvider as r, getClient as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs.bak2 b/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs.bak2
new file mode 100644
index 0000000..71572de
--- /dev/null
+++ b/node_modules/better-auth/dist/oidc-provider-ComEKSEi.mjs.bak2
@@ -0,0 +1,1200 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { t as APIError$1 } from "./api-C0IsrmGz.mjs";
+import { l as parseSetCookieHeader } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx, u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { t as getJwtToken } from "./sign-wCNCtKGh.mjs";
+import { getCurrentAuthContext } from "@better-auth/core/context";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createHash } from "@better-auth/utils/hash";
+import { SignJWT } from "jose";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+import { base64, base64Url } from "@better-auth/utils/base64";
+
+//#region src/plugins/oidc-provider/authorize.ts
+function formatErrorURL(url, error, description) {
+	return `${url.includes("?") ? "&" : "?"}error=${error}&error_description=${description}`;
+}
+function getErrorURL(ctx, error, description) {
+	return formatErrorURL(ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`, error, description);
+}
+async function authorize(ctx, options) {
+	const handleRedirect = (url) => {
+		if (ctx.request?.headers.get("sec-fetch-mode") === "cors") return ctx.json({
+			redirect: true,
+			url
+		});
+		else throw ctx.redirect(url);
+	};
+	const opts = {
+		codeExpiresIn: 600,
+		defaultScope: "openid",
+		...options,
+		scopes: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access",
+			...options?.scopes || []
+		]
+	};
+	if (!ctx.request) throw new APIError("UNAUTHORIZED", {
+		error_description: "request not found",
+		error: "invalid_request"
+	});
+	const session = await getSessionFromCtx(ctx);
+	if (!session) {
+		/**
+		* If the user is not logged in, we need to redirect them to the
+		* login page.
+		*/
+		await ctx.setSignedCookie("oidc_login_prompt", JSON.stringify(ctx.query), ctx.context.secret, {
+			maxAge: 600,
+			path: "/",
+			sameSite: "lax"
+		});
+		const queryFromURL = ctx.request.url?.split("?")[1];
+		return handleRedirect(`${options.loginPage}?${queryFromURL}`);
+	}
+	const query = ctx.query;
+	if (!query.client_id) {
+		const errorURL = getErrorURL(ctx, "invalid_client", "client_id is required");
+		throw ctx.redirect(errorURL);
+	}
+	if (!query.response_type) {
+		getErrorURL(ctx, "invalid_request", "response_type is required");
+		throw ctx.redirect(getErrorURL(ctx, "invalid_request", "response_type is required"));
+	}
+	const client = await getClient(ctx.query.client_id, options.trustedClients || []);
+	if (!client) {
+		const errorURL = getErrorURL(ctx, "invalid_client", "client_id is required");
+		throw ctx.redirect(errorURL);
+	}
+	const redirectURI = client.redirectUrls.find((url) => url === ctx.query.redirect_uri);
+	if (!redirectURI || !query.redirect_uri)
+ /**
+	* show UI error here warning the user that the redirect URI is invalid
+	*/
+	throw new APIError("BAD_REQUEST", { message: "Invalid redirect URI" });
+	if (client.disabled) {
+		const errorURL = getErrorURL(ctx, "client_disabled", "client is disabled");
+		throw ctx.redirect(errorURL);
+	}
+	if (query.response_type !== "code") {
+		const errorURL = getErrorURL(ctx, "unsupported_response_type", "unsupported response type");
+		throw ctx.redirect(errorURL);
+	}
+	const requestScope = query.scope?.split(" ").filter((s) => s) || opts.defaultScope.split(" ");
+	const invalidScopes = requestScope.filter((scope) => {
+		return !opts.scopes.includes(scope);
+	});
+	if (invalidScopes.length) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_scope", `The following scopes are invalid: ${invalidScopes.join(", ")}`));
+	if ((!query.code_challenge || !query.code_challenge_method) && options.requirePKCE) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_request", "pkce is required"));
+	if (!query.code_challenge_method) query.code_challenge_method = "plain";
+	if (!["s256", options.allowPlainCodeChallengeMethod ? "plain" : "s256"].includes(query.code_challenge_method?.toLowerCase() || "")) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_request", "invalid code_challenge method"));
+	const code = generateRandomString(32, "a-z", "A-Z", "0-9");
+	const codeExpiresInMs = opts.codeExpiresIn * 1e3;
+	const expiresAt = new Date(Date.now() + codeExpiresInMs);
+	const skipConsentForTrustedClient = client.skipConsent;
+	const hasAlreadyConsented = await ctx.context.adapter.findOne({
+		model: "oauthConsent",
+		where: [{
+			field: "clientId",
+			value: client.clientId
+		}, {
+			field: "userId",
+			value: session.user.id
+		}]
+	}).then((res) => !!res?.consentGiven);
+	const requireConsent = !skipConsentForTrustedClient && (!hasAlreadyConsented || query.prompt === "consent");
+	try {
+		/**
+		* Save the code in the database
+		*/
+		await ctx.context.internalAdapter.createVerificationValue({
+			value: JSON.stringify({
+				clientId: client.clientId,
+				redirectURI: query.redirect_uri,
+				scope: requestScope,
+				userId: session.user.id,
+				authTime: new Date(session.session.createdAt).getTime(),
+				requireConsent,
+				state: requireConsent ? query.state : null,
+				codeChallenge: query.code_challenge,
+				codeChallengeMethod: query.code_challenge_method,
+				nonce: query.nonce
+			}),
+			identifier: code,
+			expiresAt
+		});
+	} catch (e) {
+		return handleRedirect(formatErrorURL(query.redirect_uri, "server_error", "An error occurred while processing the request"));
+	}
+	if (!requireConsent) {
+		const redirectURIWithCode = new URL(redirectURI);
+		redirectURIWithCode.searchParams.set("code", code);
+		redirectURIWithCode.searchParams.set("state", ctx.query.state);
+		return handleRedirect(redirectURIWithCode.toString());
+	}
+	if (options?.consentPage) {
+		await ctx.setSignedCookie("oidc_consent_prompt", code, ctx.context.secret, {
+			maxAge: 600,
+			path: "/",
+			sameSite: "lax"
+		});
+		const urlParams = new URLSearchParams();
+		urlParams.set("consent_code", code);
+		urlParams.set("client_id", client.clientId);
+		urlParams.set("scope", requestScope.join(" "));
+		return handleRedirect(`${options.consentPage}?${urlParams.toString()}`);
+	}
+	const htmlFn = options?.getConsentHTML;
+	if (!htmlFn) throw new APIError("INTERNAL_SERVER_ERROR", { message: "No consent page provided" });
+	return new Response(htmlFn({
+		scopes: requestScope,
+		clientMetadata: client.metadata,
+		clientIcon: client?.icon,
+		clientId: client.clientId,
+		clientName: client.name,
+		code
+	}), { headers: { "content-type": "text/html" } });
+}
+
+//#endregion
+//#region src/plugins/oidc-provider/schema.ts
+const oAuthApplicationSchema = z.object({
+	clientId: z.string(),
+	clientSecret: z.string().optional(),
+	type: z.enum([
+		"web",
+		"native",
+		"user-agent-based",
+		"public"
+	]),
+	name: z.string(),
+	icon: z.string().optional(),
+	metadata: z.string().optional(),
+	disabled: z.boolean().optional().default(false),
+	redirectUrls: z.string(),
+	userId: z.string().optional(),
+	createdAt: z.date(),
+	updatedAt: z.date()
+});
+const schema = {
+	oauthApplication: {
+		modelName: "oauthApplication",
+		fields: {
+			name: { type: "string" },
+			icon: {
+				type: "string",
+				required: false
+			},
+			metadata: {
+				type: "string",
+				required: false
+			},
+			clientId: {
+				type: "string",
+				unique: true
+			},
+			clientSecret: {
+				type: "string",
+				required: false
+			},
+			redirectUrls: { type: "string" },
+			type: { type: "string" },
+			disabled: {
+				type: "boolean",
+				required: false,
+				defaultValue: false
+			},
+			userId: {
+				type: "string",
+				required: false,
+				references: {
+					model: "user",
+					field: "id",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			createdAt: { type: "date" },
+			updatedAt: { type: "date" }
+		}
+	},
+	oauthAccessToken: {
+		modelName: "oauthAccessToken",
+		fields: {
+			accessToken: {
+				type: "string",
+				unique: true
+			},
+			refreshToken: {
+				type: "string",
+				unique: true
+			},
+			accessTokenExpiresAt: { type: "date" },
+			refreshTokenExpiresAt: { type: "date" },
+			clientId: {
+				type: "string",
+				references: {
+					model: "oauthApplication",
+					field: "clientId",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			userId: {
+				type: "string",
+				required: false,
+				references: {
+					model: "user",
+					field: "id",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			scopes: { type: "string" },
+			createdAt: { type: "date" },
+			updatedAt: { type: "date" }
+		}
+	},
+	oauthConsent: {
+		modelName: "oauthConsent",
+		fields: {
+			clientId: {
+				type: "string",
+				references: {
+					model: "oauthApplication",
+					field: "clientId",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			userId: {
+				type: "string",
+				references: {
+					model: "user",
+					field: "id",
+					onDelete: "cascade"
+				},
+				index: true
+			},
+			scopes: { type: "string" },
+			createdAt: { type: "date" },
+			updatedAt: { type: "date" },
+			consentGiven: { type: "boolean" }
+		}
+	}
+};
+
+//#endregion
+//#region src/plugins/oidc-provider/utils.ts
+/**
+* Default client secret hasher using SHA-256
+*/
+const defaultClientSecretHasher = async (clientSecret) => {
+	const hash = await createHash("SHA-256").digest(new TextEncoder().encode(clientSecret));
+	return base64Url.encode(new Uint8Array(hash), { padding: false });
+};
+
+//#endregion
+//#region src/plugins/oidc-provider/index.ts
+const getJwtPlugin = (ctx) => {
+	return ctx.context.options.plugins?.find((plugin) => plugin.id === "jwt");
+};
+/**
+* Get a client by ID, checking trusted clients first, then database
+*/
+async function getClient(clientId, trustedClients = []) {
+	const { context: { adapter } } = await getCurrentAuthContext();
+	const trustedClient = trustedClients.find((client) => client.clientId === clientId);
+	if (trustedClient) return trustedClient;
+	return adapter.findOne({
+		model: "oauthApplication",
+		where: [{
+			field: "clientId",
+			value: clientId
+		}]
+	}).then((res) => {
+		if (!res) return null;
+		return {
+			clientId: res.clientId,
+			clientSecret: res.clientSecret,
+			type: res.type,
+			name: res.name,
+			icon: res.icon,
+			disabled: res.disabled,
+			redirectUrls: (res.redirectUrls ?? "").split(","),
+			metadata: res.metadata ? JSON.parse(res.metadata) : {}
+		};
+	});
+}
+const getMetadata = (ctx, options) => {
+	const jwtPlugin = getJwtPlugin(ctx);
+	const issuer = jwtPlugin && jwtPlugin.options?.jwt && jwtPlugin.options.jwt.issuer ? jwtPlugin.options.jwt.issuer : ctx.context.options.baseURL;
+	const baseURL = ctx.context.baseURL;
+	const supportedAlgs = options?.useJWTPlugin ? [
+		"RS256",
+		"EdDSA",
+		"none"
+	] : ["HS256", "none"];
+	return {
+		issuer,
+		authorization_endpoint: `${baseURL}/oauth2/authorize`,
+		token_endpoint: `${baseURL}/oauth2/token`,
+		userinfo_endpoint: `${baseURL}/oauth2/userinfo`,
+		jwks_uri: `${baseURL}/jwks`,
+		registration_endpoint: `${baseURL}/oauth2/register`,
+		scopes_supported: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access"
+		],
+		response_types_supported: ["code"],
+		response_modes_supported: ["query"],
+		grant_types_supported: ["authorization_code", "refresh_token"],
+		acr_values_supported: ["urn:mace:incommon:iap:silver", "urn:mace:incommon:iap:bronze"],
+		subject_types_supported: ["public"],
+		id_token_signing_alg_values_supported: supportedAlgs,
+		token_endpoint_auth_methods_supported: [
+			"client_secret_basic",
+			"client_secret_post",
+			"none"
+		],
+		code_challenge_methods_supported: ["S256"],
+		claims_supported: [
+			"sub",
+			"iss",
+			"aud",
+			"exp",
+			"nbf",
+			"iat",
+			"jti",
+			"email",
+			"email_verified",
+			"name"
+		],
+		...options?.metadata
+	};
+};
+/**
+* OpenID Connect (OIDC) plugin for Better Auth. This plugin implements the
+* authorization code flow and the token exchange flow. It also implements the
+* userinfo endpoint.
+*
+* @param options - The options for the OIDC plugin.
+* @returns A Better Auth plugin.
+*/
+const oidcProvider = (options) => {
+	const modelName = {
+		oauthClient: "oauthApplication",
+		oauthAccessToken: "oauthAccessToken",
+		oauthConsent: "oauthConsent"
+	};
+	const opts = {
+		codeExpiresIn: 600,
+		defaultScope: "openid",
+		accessTokenExpiresIn: 3600,
+		refreshTokenExpiresIn: 604800,
+		allowPlainCodeChallengeMethod: true,
+		storeClientSecret: "plain",
+		...options,
+		scopes: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access",
+			...options?.scopes || []
+		]
+	};
+	const trustedClients = options.trustedClients || [];
+	/**
+	* Store client secret according to the configured storage method
+	*/
+	async function storeClientSecret(ctx, clientSecret) {
+		if (opts.storeClientSecret === "encrypted") return await symmetricEncrypt({
+			key: ctx.context.secret,
+			data: clientSecret
+		});
+		if (opts.storeClientSecret === "hashed") return await defaultClientSecretHasher(clientSecret);
+		if (typeof opts.storeClientSecret === "object" && "hash" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret);
+		if (typeof opts.storeClientSecret === "object" && "encrypt" in opts.storeClientSecret) return await opts.storeClientSecret.encrypt(clientSecret);
+		return clientSecret;
+	}
+	/**
+	* Verify stored client secret against provided client secret
+	*/
+	async function verifyStoredClientSecret(ctx, storedClientSecret, clientSecret) {
+		if (opts.storeClientSecret === "encrypted") return await symmetricDecrypt({
+			key: ctx.context.secret,
+			data: storedClientSecret
+		}) === clientSecret;
+		if (opts.storeClientSecret === "hashed") return await defaultClientSecretHasher(clientSecret) === storedClientSecret;
+		if (typeof opts.storeClientSecret === "object" && "hash" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret) === storedClientSecret;
+		if (typeof opts.storeClientSecret === "object" && "decrypt" in opts.storeClientSecret) return await opts.storeClientSecret.decrypt(storedClientSecret) === clientSecret;
+		return clientSecret === storedClientSecret;
+	}
+	return {
+		id: "oidc",
+		hooks: { after: [{
+			matcher() {
+				return true;
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const cookie = await ctx.getSignedCookie("oidc_login_prompt", ctx.context.secret);
+				const cookieName = ctx.context.authCookies.sessionToken.name;
+				const parsedSetCookieHeader = parseSetCookieHeader(ctx.context.responseHeaders?.get("set-cookie") || "");
+				const hasSessionToken = parsedSetCookieHeader.has(cookieName);
+				if (!cookie || !hasSessionToken) return;
+				ctx.setCookie("oidc_login_prompt", "", { maxAge: 0 });
+				const sessionToken = (parsedSetCookieHeader.get(cookieName)?.value)?.split(".")[0];
+				if (!sessionToken) return;
+				const session = await ctx.context.internalAdapter.findSession(sessionToken);
+				if (!session) return;
+				ctx.query = JSON.parse(cookie);
+				ctx.context.session = session;
+				return await authorize(ctx, opts);
+			})
+		}] },
+		endpoints: {
+			getOpenIdConfig: createAuthEndpoint("/.well-known/openid-configuration", {
+				method: "GET",
+				operationId: "getOpenIdConfig",
+				metadata: { isAction: false }
+			}, async (ctx) => {
+				const metadata = getMetadata(ctx, options);
+				return ctx.json(metadata);
+			}),
+			oAuth2authorize: createAuthEndpoint("/oauth2/authorize", {
+				method: "GET",
+				operationId: "oauth2Authorize",
+				query: z.record(z.string(), z.any()),
+				metadata: { openapi: {
+					description: "Authorize an OAuth2 request",
+					responses: { "200": {
+						description: "Authorization response generated successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							additionalProperties: true,
+							description: "Authorization response, contents depend on the authorize function implementation"
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				return authorize(ctx, opts);
+			}),
+			oAuthConsent: createAuthEndpoint("/oauth2/consent", {
+				method: "POST",
+				operationId: "oauth2Consent",
+				body: z.object({
+					accept: z.boolean(),
+					consent_code: z.string().optional().nullish()
+				}),
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Handle OAuth2 consent. Supports both URL parameter-based flows (consent_code in body) and cookie-based flows (signed cookie).",
+					requestBody: {
+						required: true,
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								accept: {
+									type: "boolean",
+									description: "Whether the user accepts or denies the consent request"
+								},
+								consent_code: {
+									type: "string",
+									description: "The consent code from the authorization request. Optional if using cookie-based flow."
+								}
+							},
+							required: ["accept"]
+						} } }
+					},
+					responses: { "200": {
+						description: "Consent processed successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { redirectURI: {
+								type: "string",
+								format: "uri",
+								description: "The URI to redirect to, either with an authorization code or an error"
+							} },
+							required: ["redirectURI"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				let consentCode = ctx.body.consent_code || null;
+				if (!consentCode) consentCode = await ctx.getSignedCookie("oidc_consent_prompt", ctx.context.secret);
+				if (!consentCode) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "consent_code is required (either in body or cookie)",
+					error: "invalid_request"
+				});
+				const verification = await ctx.context.internalAdapter.findVerificationValue(consentCode);
+				if (!verification) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "Invalid code",
+					error: "invalid_request"
+				});
+				if (verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "Code expired",
+					error: "invalid_request"
+				});
+				ctx.setCookie("oidc_consent_prompt", "", { maxAge: 0 });
+				const value = JSON.parse(verification.value);
+				if (!value.requireConsent) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "Consent not required",
+					error: "invalid_request"
+				});
+				if (!ctx.body.accept) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
+					return ctx.json({ redirectURI: `${value.redirectURI}?error=access_denied&error_description=User denied access` });
+				}
+				const code = generateRandomString(32, "a-z", "A-Z", "0-9");
+				const codeExpiresInMs = opts.codeExpiresIn * 1e3;
+				const expiresAt = new Date(Date.now() + codeExpiresInMs);
+				await ctx.context.internalAdapter.updateVerificationValue(verification.id, {
+					value: JSON.stringify({
+						...value,
+						requireConsent: false
+					}),
+					identifier: code,
+					expiresAt
+				});
+				await ctx.context.adapter.create({
+					model: modelName.oauthConsent,
+					data: {
+						clientId: value.clientId,
+						userId: value.userId,
+						scopes: value.scope.join(" "),
+						consentGiven: true,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}
+				});
+				const redirectURI = new URL(value.redirectURI);
+				redirectURI.searchParams.set("code", code);
+				if (value.state) redirectURI.searchParams.set("state", value.state);
+				return ctx.json({ redirectURI: redirectURI.toString() });
+			}),
+			oAuth2token: createAuthEndpoint("/oauth2/token", {
+				method: "POST",
+				operationId: "oauth2Token",
+				body: z.record(z.any(), z.any()),
+				metadata: { isAction: false }
+			}, async (ctx) => {
+				let { body } = ctx;
+				if (!body) throw new APIError$1("BAD_REQUEST", {
+					error_description: "request body not found",
+					error: "invalid_request"
+				});
+				if (body instanceof FormData) body = Object.fromEntries(body.entries());
+				if (!(body instanceof Object)) throw new APIError$1("BAD_REQUEST", {
+					error_description: "request body is not an object",
+					error: "invalid_request"
+				});
+				let { client_id, client_secret } = body;
+				const authorization = ctx.request?.headers.get("authorization") || null;
+				if (authorization && !client_id && !client_secret && authorization.startsWith("Basic ")) try {
+					const encoded = authorization.replace("Basic ", "");
+					const decoded = new TextDecoder().decode(base64.decode(encoded));
+					if (!decoded.includes(":")) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+					const [id, secret] = decoded.split(":");
+					if (!id || !secret) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+					client_id = id;
+					client_secret = secret;
+				} catch (error) {
+					throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+				}
+				const now = Date.now();
+				const iat = Math.floor(now / 1e3);
+				const exp = iat + (opts.accessTokenExpiresIn ?? 3600);
+				const accessTokenExpiresAt = /* @__PURE__ */ new Date(exp * 1e3);
+				const refreshTokenExpiresAt = /* @__PURE__ */ new Date((iat + (opts.refreshTokenExpiresIn ?? 604800)) * 1e3);
+				const { grant_type, code, redirect_uri, refresh_token, code_verifier } = body;
+				if (grant_type === "refresh_token") {
+					if (!refresh_token) throw new APIError$1("BAD_REQUEST", {
+						error_description: "refresh_token is required",
+						error: "invalid_request"
+					});
+					const token = await ctx.context.adapter.findOne({
+						model: modelName.oauthAccessToken,
+						where: [{
+							field: "refreshToken",
+							value: refresh_token.toString()
+						}]
+					});
+					if (!token) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid refresh token",
+						error: "invalid_grant"
+					});
+					if (token.clientId !== client_id?.toString()) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid client_id",
+						error: "invalid_client"
+					});
+					if (token.refreshTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "refresh token expired",
+						error: "invalid_grant"
+					});
+					const accessToken$1 = generateRandomString(32, "a-z", "A-Z");
+					const newRefreshToken = generateRandomString(32, "a-z", "A-Z");
+					await ctx.context.adapter.create({
+						model: modelName.oauthAccessToken,
+						data: {
+							accessToken: accessToken$1,
+							refreshToken: newRefreshToken,
+							accessTokenExpiresAt,
+							refreshTokenExpiresAt,
+							clientId: client_id.toString(),
+							userId: token.userId,
+							scopes: token.scopes,
+							createdAt: /* @__PURE__ */ new Date(iat * 1e3),
+							updatedAt: /* @__PURE__ */ new Date(iat * 1e3)
+						}
+					});
+					return ctx.json({
+						access_token: accessToken$1,
+						token_type: "Bearer",
+						expires_in: opts.accessTokenExpiresIn,
+						refresh_token: newRefreshToken,
+						scope: token.scopes
+					});
+				}
+				if (!code) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code is required",
+					error: "invalid_request"
+				});
+				if (options.requirePKCE && !code_verifier) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code verifier is missing",
+					error: "invalid_request"
+				});
+				/**
+				* We need to check if the code is valid before we can proceed
+				* with the rest of the request.
+				*/
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(code.toString());
+				if (!verificationValue) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid code",
+					error: "invalid_grant"
+				});
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "code expired",
+					error: "invalid_grant"
+				});
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				if (!client_id) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client_id is required",
+					error: "invalid_client"
+				});
+				if (!grant_type) throw new APIError$1("BAD_REQUEST", {
+					error_description: "grant_type is required",
+					error: "invalid_request"
+				});
+				if (grant_type !== "authorization_code") throw new APIError$1("BAD_REQUEST", {
+					error_description: "grant_type must be 'authorization_code'",
+					error: "unsupported_grant_type"
+				});
+				if (!redirect_uri) throw new APIError$1("BAD_REQUEST", {
+					error_description: "redirect_uri is required",
+					error: "invalid_request"
+				});
+				const client = await getClient(client_id.toString(), trustedClients);
+				if (!client) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid client_id",
+					error: "invalid_client"
+				});
+				if (client.disabled) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client is disabled",
+					error: "invalid_client"
+				});
+				const value = JSON.parse(verificationValue.value);
+				if (value.clientId !== client_id.toString()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid client_id",
+					error: "invalid_client"
+				});
+				if (value.redirectURI !== redirect_uri.toString()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid redirect_uri",
+					error: "invalid_client"
+				});
+				if (value.codeChallenge && !code_verifier) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code verifier is missing",
+					error: "invalid_request"
+				});
+				if (client.type === "public") {
+					if (!code_verifier) throw new APIError$1("BAD_REQUEST", {
+						error_description: "code verifier is required for public clients",
+						error: "invalid_request"
+					});
+				} else {
+					if (!client.clientSecret || !client_secret) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "client_secret is required for confidential clients",
+						error: "invalid_client"
+					});
+					if (!await verifyStoredClientSecret(ctx, client.clientSecret, client_secret.toString())) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid client_secret",
+						error: "invalid_client"
+					});
+				}
+				if ((value.codeChallengeMethod === "plain" ? code_verifier : await createHash("SHA-256", "base64urlnopad").digest(code_verifier)) !== value.codeChallenge) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "code verification failed",
+					error: "invalid_request"
+				});
+				const requestedScopes = value.scope;
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				const accessToken = generateRandomString(32, "a-z", "A-Z");
+				const refreshToken = generateRandomString(32, "A-Z", "a-z");
+				await ctx.context.adapter.create({
+					model: modelName.oauthAccessToken,
+					data: {
+						accessToken,
+						refreshToken,
+						accessTokenExpiresAt,
+						refreshTokenExpiresAt,
+						clientId: client_id.toString(),
+						userId: value.userId,
+						scopes: requestedScopes.join(" "),
+						createdAt: /* @__PURE__ */ new Date(iat * 1e3),
+						updatedAt: /* @__PURE__ */ new Date(iat * 1e3)
+					}
+				});
+				const user = await ctx.context.internalAdapter.findUserById(value.userId);
+				if (!user) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "user not found",
+					error: "invalid_grant"
+				});
+				const profile = {
+					given_name: user.name.split(" ")[0],
+					family_name: user.name.split(" ")[1],
+					name: user.name,
+					profile: user.image,
+					updated_at: new Date(user.updatedAt).toISOString()
+				};
+				const email = {
+					email: user.email,
+					email_verified: user.emailVerified
+				};
+				const userClaims = {
+					...requestedScopes.includes("profile") ? profile : {},
+					...requestedScopes.includes("email") ? email : {}
+				};
+				const additionalUserClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : {};
+				const payload = {
+					sub: user.id,
+					aud: client_id.toString(),
+					iat,
+					auth_time: ctx.context.session ? new Date(ctx.context.session.session.createdAt).getTime() : void 0,
+					nonce: value.nonce,
+					acr: "urn:mace:incommon:iap:silver",
+					...userClaims,
+					...additionalUserClaims
+				};
+				const expirationTime = Math.floor(Date.now() / 1e3) + opts.accessTokenExpiresIn;
+				let idToken;
+				if (options.useJWTPlugin) {
+					const jwtPlugin = getJwtPlugin(ctx);
+					if (!jwtPlugin) {
+						ctx.context.logger.error("OIDC: `useJWTPlugin` is enabled but the JWT plugin is not available. Make sure you have the JWT Plugin in your plugins array or set `useJWTPlugin` to false.");
+						throw new APIError$1("INTERNAL_SERVER_ERROR", {
+							error_description: "JWT plugin is not enabled",
+							error: "internal_server_error"
+						});
+					}
+					idToken = await getJwtToken({
+						...ctx,
+						context: {
+							...ctx.context,
+							session: {
+								session: {
+									id: generateRandomString(32, "a-z", "A-Z"),
+									createdAt: /* @__PURE__ */ new Date(iat * 1e3),
+									updatedAt: /* @__PURE__ */ new Date(iat * 1e3),
+									userId: user.id,
+									expiresAt: accessTokenExpiresAt,
+									token: accessToken,
+									ipAddress: ctx.request?.headers.get("x-forwarded-for")
+								},
+								user
+							}
+						}
+					}, {
+						...jwtPlugin.options,
+						jwt: {
+							...jwtPlugin.options?.jwt,
+							getSubject: () => user.id,
+							audience: client_id.toString(),
+							issuer: jwtPlugin.options?.jwt?.issuer ?? ctx.context.options.baseURL,
+							expirationTime,
+							definePayload: () => payload
+						}
+					});
+				} else idToken = await new SignJWT(payload).setProtectedHeader({ alg: "HS256" }).setIssuedAt(iat).setExpirationTime(accessTokenExpiresAt).sign(new TextEncoder().encode(client.clientSecret));
+				return ctx.json({
+					access_token: accessToken,
+					token_type: "Bearer",
+					expires_in: opts.accessTokenExpiresIn,
+					refresh_token: requestedScopes.includes("offline_access") ? refreshToken : void 0,
+					scope: requestedScopes.join(" "),
+					id_token: requestedScopes.includes("openid") ? idToken : void 0
+				}, { headers: {
+					"Cache-Control": "no-store",
+					Pragma: "no-cache"
+				} });
+			}),
+			oAuth2userInfo: createAuthEndpoint("/oauth2/userinfo", {
+				method: "GET",
+				operationId: "oauth2Userinfo",
+				use: [sessionMiddleware],
+				metadata: {
+					isAction: false,
+					openapi: {
+						description: "Get OAuth2 user information",
+						responses: { "200": {
+							description: "User information retrieved successfully",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									sub: {
+										type: "string",
+										description: "Subject identifier (user ID)"
+									},
+									email: {
+										type: "string",
+										format: "email",
+										nullable: true,
+										description: "User's email address, included if 'email' scope is granted"
+									},
+									name: {
+										type: "string",
+										nullable: true,
+										description: "User's full name, included if 'profile' scope is granted"
+									},
+									picture: {
+										type: "string",
+										format: "uri",
+										nullable: true,
+										description: "User's profile picture URL, included if 'profile' scope is granted"
+									},
+									given_name: {
+										type: "string",
+										nullable: true,
+										description: "User's given name, included if 'profile' scope is granted"
+									},
+									family_name: {
+										type: "string",
+										nullable: true,
+										description: "User's family name, included if 'profile' scope is granted"
+									},
+									email_verified: {
+										type: "boolean",
+										nullable: true,
+										description: "Whether the email is verified, included if 'email' scope is granted"
+									}
+								},
+								required: ["sub"]
+							} } }
+						} }
+					}
+				}
+			}, async (ctx) => {
+				if (!ctx.request) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "request not found",
+					error: "invalid_request"
+				});
+				const authorization = ctx.request.headers.get("authorization");
+				if (!authorization) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "authorization header not found",
+					error: "invalid_request"
+				});
+				const token = authorization.replace("Bearer ", "");
+				const accessToken = await ctx.context.adapter.findOne({
+					model: modelName.oauthAccessToken,
+					where: [{
+						field: "accessToken",
+						value: token
+					}]
+				});
+				if (!accessToken) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid access token",
+					error: "invalid_token"
+				});
+				if (accessToken.accessTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "The Access Token expired",
+					error: "invalid_token"
+				});
+				const client = await getClient(accessToken.clientId, trustedClients);
+				if (!client) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client not found",
+					error: "invalid_token"
+				});
+				const user = await ctx.context.internalAdapter.findUserById(accessToken.userId);
+				if (!user) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "user not found",
+					error: "invalid_token"
+				});
+				const requestedScopes = accessToken.scopes.split(" ");
+				const baseUserClaims = {
+					sub: user.id,
+					email: requestedScopes.includes("email") ? user.email : void 0,
+					name: requestedScopes.includes("profile") ? user.name : void 0,
+					picture: requestedScopes.includes("profile") ? user.image : void 0,
+					given_name: requestedScopes.includes("profile") ? user.name.split(" ")[0] : void 0,
+					family_name: requestedScopes.includes("profile") ? user.name.split(" ")[1] : void 0,
+					email_verified: requestedScopes.includes("email") ? user.emailVerified : void 0
+				};
+				const userClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : baseUserClaims;
+				return ctx.json({
+					...baseUserClaims,
+					...userClaims
+				});
+			}),
+			registerOAuthApplication: createAuthEndpoint("/oauth2/register", {
+				method: "POST",
+				body: z.object({
+					redirect_uris: z.array(z.string()),
+					token_endpoint_auth_method: z.enum([
+						"none",
+						"client_secret_basic",
+						"client_secret_post"
+					]).default("client_secret_basic").optional(),
+					grant_types: z.array(z.enum([
+						"authorization_code",
+						"implicit",
+						"password",
+						"client_credentials",
+						"refresh_token",
+						"urn:ietf:params:oauth:grant-type:jwt-bearer",
+						"urn:ietf:params:oauth:grant-type:saml2-bearer"
+					])).default(["authorization_code"]).optional(),
+					response_types: z.array(z.enum(["code", "token"])).default(["code"]).optional(),
+					client_name: z.string().optional(),
+					client_uri: z.string().optional(),
+					logo_uri: z.string().optional(),
+					scope: z.string().optional(),
+					contacts: z.array(z.string()).optional(),
+					tos_uri: z.string().optional(),
+					policy_uri: z.string().optional(),
+					jwks_uri: z.string().optional(),
+					jwks: z.record(z.any(), z.any()).optional(),
+					metadata: z.record(z.any(), z.any()).meta({ description: "The metadata of the application. Eg: {\"key\": \"value\"}" }).optional(),
+					software_id: z.string().optional(),
+					software_version: z.string().optional(),
+					software_statement: z.string().optional()
+				}),
+				metadata: { openapi: {
+					description: "Register an OAuth2 application",
+					responses: { "200": {
+						description: "OAuth2 application registered successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								name: {
+									type: "string",
+									description: "Name of the OAuth2 application"
+								},
+								icon: {
+									type: "string",
+									nullable: true,
+									description: "Icon URL for the application"
+								},
+								metadata: {
+									type: "object",
+									additionalProperties: true,
+									nullable: true,
+									description: "Additional metadata for the application"
+								},
+								clientId: {
+									type: "string",
+									description: "Unique identifier for the client"
+								},
+								clientSecret: {
+									type: "string",
+									description: "Secret key for the client"
+								},
+								redirectURLs: {
+									type: "array",
+									items: {
+										type: "string",
+										format: "uri"
+									},
+									description: "List of allowed redirect URLs"
+								},
+								type: {
+									type: "string",
+									description: "Type of the client",
+									enum: ["web"]
+								},
+								authenticationScheme: {
+									type: "string",
+									description: "Authentication scheme used by the client",
+									enum: ["client_secret"]
+								},
+								disabled: {
+									type: "boolean",
+									description: "Whether the client is disabled",
+									enum: [false]
+								},
+								userId: {
+									type: "string",
+									nullable: true,
+									description: "ID of the user who registered the client, null if registered anonymously"
+								},
+								createdAt: {
+									type: "string",
+									format: "date-time",
+									description: "Creation timestamp"
+								},
+								updatedAt: {
+									type: "string",
+									format: "date-time",
+									description: "Last update timestamp"
+								}
+							},
+							required: [
+								"name",
+								"clientId",
+								"clientSecret",
+								"redirectURLs",
+								"type",
+								"authenticationScheme",
+								"disabled",
+								"createdAt",
+								"updatedAt"
+							]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const body = ctx.body;
+				const session = await getSessionFromCtx(ctx);
+				if (!session && !options.allowDynamicClientRegistration) throw new APIError$1("UNAUTHORIZED", {
+					error: "invalid_token",
+					error_description: "Authentication required for client registration"
+				});
+				if ((!body.grant_types || body.grant_types.includes("authorization_code") || body.grant_types.includes("implicit")) && (!body.redirect_uris || body.redirect_uris.length === 0)) throw new APIError$1("BAD_REQUEST", {
+					error: "invalid_redirect_uri",
+					error_description: "Redirect URIs are required for authorization_code and implicit grant types"
+				});
+				if (body.grant_types && body.response_types) {
+					if (body.grant_types.includes("authorization_code") && !body.response_types.includes("code")) throw new APIError$1("BAD_REQUEST", {
+						error: "invalid_client_metadata",
+						error_description: "When 'authorization_code' grant type is used, 'code' response type must be included"
+					});
+					if (body.grant_types.includes("implicit") && !body.response_types.includes("token")) throw new APIError$1("BAD_REQUEST", {
+						error: "invalid_client_metadata",
+						error_description: "When 'implicit' grant type is used, 'token' response type must be included"
+					});
+				}
+				const clientId = options.generateClientId?.() || generateRandomString(32, "a-z", "A-Z");
+				const clientSecret = options.generateClientSecret?.() || generateRandomString(32, "a-z", "A-Z");
+				const storedClientSecret = await storeClientSecret(ctx, clientSecret);
+				const client = await ctx.context.adapter.create({
+					model: modelName.oauthClient,
+					data: {
+						name: body.client_name,
+						icon: body.logo_uri,
+						metadata: body.metadata ? JSON.stringify(body.metadata) : null,
+						clientId,
+						clientSecret: storedClientSecret,
+						redirectUrls: body.redirect_uris.join(","),
+						type: "web",
+						authenticationScheme: body.token_endpoint_auth_method || "client_secret_basic",
+						disabled: false,
+						userId: session?.session.userId,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}
+				});
+				return ctx.json({
+					client_id: clientId,
+					...client.type !== "public" ? {
+						client_secret: clientSecret,
+						client_secret_expires_at: 0
+					} : {},
+					client_id_issued_at: Math.floor(Date.now() / 1e3),
+					client_secret_expires_at: 0,
+					redirect_uris: body.redirect_uris,
+					token_endpoint_auth_method: body.token_endpoint_auth_method || "client_secret_basic",
+					grant_types: body.grant_types || ["authorization_code"],
+					response_types: body.response_types || ["code"],
+					client_name: body.client_name,
+					client_uri: body.client_uri,
+					logo_uri: body.logo_uri,
+					scope: body.scope,
+					contacts: body.contacts,
+					tos_uri: body.tos_uri,
+					policy_uri: body.policy_uri,
+					jwks_uri: body.jwks_uri,
+					jwks: body.jwks,
+					software_id: body.software_id,
+					software_version: body.software_version,
+					software_statement: body.software_statement,
+					metadata: body.metadata
+				}, {
+					status: 201,
+					headers: {
+						"Cache-Control": "no-store",
+						Pragma: "no-cache"
+					}
+				});
+			}),
+			getOAuthClient: createAuthEndpoint("/oauth2/client/:id", {
+				method: "GET",
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Get OAuth2 client details",
+					responses: { "200": {
+						description: "OAuth2 client retrieved successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								clientId: {
+									type: "string",
+									description: "Unique identifier for the client"
+								},
+								name: {
+									type: "string",
+									description: "Name of the OAuth2 application"
+								},
+								icon: {
+									type: "string",
+									nullable: true,
+									description: "Icon URL for the application"
+								}
+							},
+							required: ["clientId", "name"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const client = await getClient(ctx.params.id, trustedClients);
+				if (!client) throw new APIError$1("NOT_FOUND", {
+					error_description: "client not found",
+					error: "not_found"
+				});
+				return ctx.json({
+					clientId: client.clientId,
+					name: client.name,
+					icon: client.icon || null
+				});
+			})
+		},
+		schema: mergeSchema(schema, options?.schema),
+		get options() {
+			return opts;
+		}
+	};
+};
+
+//#endregion
+export { schema as i, getMetadata as n, oidcProvider as r, getClient as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/one-tap-thuUsT_P.mjs b/node_modules/better-auth/dist/one-tap-thuUsT_P.mjs
index c98f9d8..4748c34 100644
--- a/node_modules/better-auth/dist/one-tap-thuUsT_P.mjs
+++ b/node_modules/better-auth/dist/one-tap-thuUsT_P.mjs
@@ -15,7 +15,7 @@ const oneTap = (options) => ({
 	id: "one-tap",
 	endpoints: { oneTapCallback: createAuthEndpoint("/one-tap/callback", {
 		method: "POST",
-		body: z.object({ idToken: z.string().meta({ description: "Google ID token, which the client obtains from the One Tap API" }) }),
+		body: z.object({ idToken: z.string() }),
 		metadata: { openapi: {
 			summary: "One tap callback",
 			description: "Use this endpoint to authenticate with Google One Tap",
diff --git a/node_modules/better-auth/dist/one-tap-thuUsT_P.mjs.bak b/node_modules/better-auth/dist/one-tap-thuUsT_P.mjs.bak
new file mode 100644
index 0000000..c98f9d8
--- /dev/null
+++ b/node_modules/better-auth/dist/one-tap-thuUsT_P.mjs.bak
@@ -0,0 +1,113 @@
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import * as z from "zod";
+import { createRemoteJWKSet, jwtVerify } from "jose";
+import { createAuthEndpoint } from "@better-auth/core/api";
+
+//#region src/utils/boolean.ts
+function toBoolean(value) {
+	return value === "true" || value === true;
+}
+
+//#endregion
+//#region src/plugins/one-tap/index.ts
+const oneTap = (options) => ({
+	id: "one-tap",
+	endpoints: { oneTapCallback: createAuthEndpoint("/one-tap/callback", {
+		method: "POST",
+		body: z.object({ idToken: z.string().meta({ description: "Google ID token, which the client obtains from the One Tap API" }) }),
+		metadata: { openapi: {
+			summary: "One tap callback",
+			description: "Use this endpoint to authenticate with Google One Tap",
+			responses: {
+				200: {
+					description: "Successful response",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: {
+							session: { $ref: "#/components/schemas/Session" },
+							user: { $ref: "#/components/schemas/User" }
+						}
+					} } }
+				},
+				400: { description: "Invalid token" }
+			}
+		} }
+	}, async (ctx) => {
+		const { idToken } = ctx.body;
+		let payload;
+		try {
+			const { payload: verifiedPayload } = await jwtVerify(idToken, createRemoteJWKSet(new URL("https://www.googleapis.com/oauth2/v3/certs")), {
+				issuer: ["https://accounts.google.com", "accounts.google.com"],
+				audience: options?.clientId || ctx.context.options.socialProviders?.google?.clientId
+			});
+			payload = verifiedPayload;
+		} catch (error) {
+			throw new APIError("BAD_REQUEST", { message: "invalid id token" });
+		}
+		const { email, email_verified, name, picture, sub } = payload;
+		if (!email) return ctx.json({ error: "Email not available in token" });
+		const user = await ctx.context.internalAdapter.findUserByEmail(email);
+		if (!user) {
+			if (options?.disableSignup) throw new APIError("BAD_GATEWAY", { message: "User not found" });
+			const newUser = await ctx.context.internalAdapter.createOAuthUser({
+				email,
+				emailVerified: typeof email_verified === "boolean" ? email_verified : toBoolean(email_verified),
+				name,
+				image: picture
+			}, {
+				providerId: "google",
+				accountId: sub
+			});
+			if (!newUser) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Could not create user" });
+			const session$1 = await ctx.context.internalAdapter.createSession(newUser.user.id);
+			await setSessionCookie(ctx, {
+				user: newUser.user,
+				session: session$1
+			});
+			return ctx.json({
+				token: session$1.token,
+				user: {
+					id: newUser.user.id,
+					email: newUser.user.email,
+					emailVerified: newUser.user.emailVerified,
+					name: newUser.user.name,
+					image: newUser.user.image,
+					createdAt: newUser.user.createdAt,
+					updatedAt: newUser.user.updatedAt
+				}
+			});
+		}
+		if (!await ctx.context.internalAdapter.findAccount(sub)) {
+			const accountLinking = ctx.context.options.account?.accountLinking;
+			if (accountLinking?.enabled && (accountLinking.trustedProviders?.includes("google") || email_verified)) await ctx.context.internalAdapter.linkAccount({
+				userId: user.user.id,
+				providerId: "google",
+				accountId: sub,
+				scope: "openid,profile,email",
+				idToken
+			});
+			else throw new APIError("UNAUTHORIZED", { message: "Google sub doesn't match" });
+		}
+		const session = await ctx.context.internalAdapter.createSession(user.user.id);
+		await setSessionCookie(ctx, {
+			user: user.user,
+			session
+		});
+		return ctx.json({
+			token: session.token,
+			user: {
+				id: user.user.id,
+				email: user.user.email,
+				emailVerified: user.user.emailVerified,
+				name: user.user.name,
+				image: user.user.image,
+				createdAt: user.user.createdAt,
+				updatedAt: user.user.updatedAt
+			}
+		});
+	}) }
+});
+
+//#endregion
+export { oneTap as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/open-api-Cb5nhhNu.mjs.bak b/node_modules/better-auth/dist/open-api-Cb5nhhNu.mjs.bak
new file mode 100644
index 0000000..8890fe8
--- /dev/null
+++ b/node_modules/better-auth/dist/open-api-Cb5nhhNu.mjs.bak
@@ -0,0 +1,366 @@
+import { a as getAuthTables } from "./get-model-name-nJd9iPTo.mjs";
+import { a as getEndpoints, t as APIError } from "./api-C0IsrmGz.mjs";
+import * as z from "zod";
+import { createAuthEndpoint } from "@better-auth/core/api";
+
+//#region src/plugins/open-api/generator.ts
+const allowedType = new Set([
+	"string",
+	"number",
+	"boolean",
+	"array",
+	"object"
+]);
+function getTypeFromZodType(zodType) {
+	const type = zodType.type;
+	return allowedType.has(type) ? type : "string";
+}
+function getFieldSchema(field) {
+	const schema = { type: field.type === "date" ? "string" : field.type };
+	if (field.defaultValue !== void 0) schema.default = typeof field.defaultValue === "function" ? "Generated at runtime" : field.defaultValue;
+	if (field.input === false) schema.readOnly = true;
+	return schema;
+}
+function getParameters(options) {
+	const parameters = [];
+	if (options.metadata?.openapi?.parameters) {
+		parameters.push(...options.metadata.openapi.parameters);
+		return parameters;
+	}
+	if (options.query instanceof z.ZodObject) Object.entries(options.query.shape).forEach(([key, value]) => {
+		if (value instanceof z.ZodType) parameters.push({
+			name: key,
+			in: "query",
+			schema: {
+				...processZodType(value),
+				..."minLength" in value && value.minLength ? { minLength: value.minLength } : {}
+			}
+		});
+	});
+	return parameters;
+}
+function getRequestBody(options) {
+	if (options.metadata?.openapi?.requestBody) return options.metadata.openapi.requestBody;
+	if (!options.body) return void 0;
+	if (options.body instanceof z.ZodObject || options.body instanceof z.ZodOptional) {
+		const shape = options.body.shape;
+		if (!shape) return void 0;
+		const properties = {};
+		const required = [];
+		Object.entries(shape).forEach(([key, value]) => {
+			if (value instanceof z.ZodType) {
+				properties[key] = processZodType(value);
+				if (!(value instanceof z.ZodOptional)) required.push(key);
+			}
+		});
+		return {
+			required: options.body instanceof z.ZodOptional ? false : options.body ? true : false,
+			content: { "application/json": { schema: {
+				type: "object",
+				properties,
+				required
+			} } }
+		};
+	}
+}
+function processZodType(zodType) {
+	if (zodType instanceof z.ZodOptional) {
+		const innerType = zodType._def.innerType;
+		return {
+			...processZodType(innerType),
+			nullable: true
+		};
+	}
+	if (zodType instanceof z.ZodObject) {
+		const shape = zodType.shape;
+		if (shape) {
+			const properties = {};
+			const required = [];
+			Object.entries(shape).forEach(([key, value]) => {
+				if (value instanceof z.ZodType) {
+					properties[key] = processZodType(value);
+					if (!(value instanceof z.ZodOptional)) required.push(key);
+				}
+			});
+			return {
+				type: "object",
+				properties,
+				...required.length > 0 ? { required } : {},
+				description: zodType.description
+			};
+		}
+	}
+	return {
+		type: getTypeFromZodType(zodType),
+		description: zodType.description
+	};
+}
+function getResponse(responses) {
+	return {
+		"400": {
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: { type: "string" } },
+				required: ["message"]
+			} } },
+			description: "Bad Request. Usually due to missing parameters, or invalid parameters."
+		},
+		"401": {
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: { type: "string" } },
+				required: ["message"]
+			} } },
+			description: "Unauthorized. Due to missing or invalid authentication."
+		},
+		"403": {
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: { type: "string" } }
+			} } },
+			description: "Forbidden. You do not have permission to access this resource or to perform this action."
+		},
+		"404": {
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: { type: "string" } }
+			} } },
+			description: "Not Found. The requested resource was not found."
+		},
+		"429": {
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: { type: "string" } }
+			} } },
+			description: "Too Many Requests. You have exceeded the rate limit. Try again later."
+		},
+		"500": {
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: { type: "string" } }
+			} } },
+			description: "Internal Server Error. This is a problem with the server that you cannot fix."
+		},
+		...responses
+	};
+}
+function toOpenApiPath(path) {
+	return path.split("/").map((part) => part.startsWith(":") ? `{${part.slice(1)}}` : part).join("/");
+}
+async function generator(ctx, options) {
+	const baseEndpoints = getEndpoints(ctx, {
+		...options,
+		plugins: []
+	});
+	const tables = getAuthTables({
+		...options,
+		session: {
+			...options.session,
+			storeSessionInDatabase: true
+		}
+	});
+	const components = { schemas: { ...Object.entries(tables).reduce((acc, [key, value]) => {
+		const modelName = key.charAt(0).toUpperCase() + key.slice(1);
+		const fields = value.fields;
+		const required = [];
+		const properties = { id: { type: "string" } };
+		Object.entries(fields).forEach(([fieldKey, fieldValue]) => {
+			if (!fieldValue) return;
+			properties[fieldKey] = getFieldSchema(fieldValue);
+			if (fieldValue.required && fieldValue.input !== false) required.push(fieldKey);
+		});
+		Object.entries(properties).forEach(([key$1, prop]) => {
+			const field = value.fields[key$1];
+			if (field && field.type === "date" && prop.type === "string") prop.format = "date-time";
+		});
+		acc[modelName] = {
+			type: "object",
+			properties,
+			required
+		};
+		return acc;
+	}, {}) } };
+	const paths = {};
+	Object.entries(baseEndpoints.api).forEach(([_, value]) => {
+		if (ctx.options.disabledPaths?.includes(value.path)) return;
+		const options$1 = value.options;
+		if (options$1.metadata?.SERVER_ONLY) return;
+		const path = toOpenApiPath(value.path);
+		if (options$1.method === "GET" || options$1.method === "DELETE") paths[path] = {
+			...paths[path],
+			[options$1.method.toLowerCase()]: {
+				tags: ["Default", ...options$1.metadata?.openapi?.tags || []],
+				description: options$1.metadata?.openapi?.description,
+				operationId: options$1.metadata?.openapi?.operationId,
+				security: [{ bearerAuth: [] }],
+				parameters: getParameters(options$1),
+				responses: getResponse(options$1.metadata?.openapi?.responses)
+			}
+		};
+		if (options$1.method === "POST" || options$1.method === "PATCH" || options$1.method === "PUT") {
+			const body = getRequestBody(options$1);
+			paths[path] = {
+				...paths[path],
+				[options$1.method.toLowerCase()]: {
+					tags: ["Default", ...options$1.metadata?.openapi?.tags || []],
+					description: options$1.metadata?.openapi?.description,
+					operationId: options$1.metadata?.openapi?.operationId,
+					security: [{ bearerAuth: [] }],
+					parameters: getParameters(options$1),
+					...body ? { requestBody: body } : { requestBody: { content: { "application/json": { schema: {
+						type: "object",
+						properties: {}
+					} } } } },
+					responses: getResponse(options$1.metadata?.openapi?.responses)
+				}
+			};
+		}
+	});
+	for (const plugin of options.plugins || []) {
+		if (plugin.id === "open-api") continue;
+		const pluginEndpoints = getEndpoints(ctx, {
+			...options,
+			plugins: [plugin]
+		});
+		const api = Object.keys(pluginEndpoints.api).map((key) => {
+			if (baseEndpoints.api[key] === void 0) return pluginEndpoints.api[key];
+			return null;
+		}).filter((x) => x !== null);
+		Object.entries(api).forEach(([key, value]) => {
+			if (ctx.options.disabledPaths?.includes(value.path)) return;
+			const options$1 = value.options;
+			if (options$1.metadata?.SERVER_ONLY) return;
+			const path = toOpenApiPath(value.path);
+			if (options$1.method === "GET" || options$1.method === "DELETE") paths[path] = {
+				...paths[path],
+				[options$1.method.toLowerCase()]: {
+					tags: options$1.metadata?.openapi?.tags || [plugin.id.charAt(0).toUpperCase() + plugin.id.slice(1)],
+					description: options$1.metadata?.openapi?.description,
+					operationId: options$1.metadata?.openapi?.operationId,
+					security: [{ bearerAuth: [] }],
+					parameters: getParameters(options$1),
+					responses: getResponse(options$1.metadata?.openapi?.responses)
+				}
+			};
+			if (options$1.method === "POST" || options$1.method === "PATCH" || options$1.method === "PUT") paths[path] = {
+				...paths[path],
+				[options$1.method.toLowerCase()]: {
+					tags: options$1.metadata?.openapi?.tags || [plugin.id.charAt(0).toUpperCase() + plugin.id.slice(1)],
+					description: options$1.metadata?.openapi?.description,
+					operationId: options$1.metadata?.openapi?.operationId,
+					security: [{ bearerAuth: [] }],
+					parameters: getParameters(options$1),
+					requestBody: getRequestBody(options$1),
+					responses: getResponse(options$1.metadata?.openapi?.responses)
+				}
+			};
+		});
+	}
+	return {
+		openapi: "3.1.1",
+		info: {
+			title: "Better Auth",
+			description: "API Reference for your Better Auth Instance",
+			version: "1.1.0"
+		},
+		components: {
+			...components,
+			securitySchemes: {
+				apiKeyCookie: {
+					type: "apiKey",
+					in: "cookie",
+					name: "apiKeyCookie",
+					description: "API Key authentication via cookie"
+				},
+				bearerAuth: {
+					type: "http",
+					scheme: "bearer",
+					description: "Bearer token authentication"
+				}
+			}
+		},
+		security: [{
+			apiKeyCookie: [],
+			bearerAuth: []
+		}],
+		servers: [{ url: ctx.baseURL }],
+		tags: [{
+			name: "Default",
+			description: "Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin."
+		}],
+		paths
+	};
+}
+
+//#endregion
+//#region src/plugins/open-api/logo.ts
+const logo = `<svg width="75" height="75" viewBox="0 0 75 75" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
+<rect width="75" height="75" fill="url(#pattern0_21_12)"/>
+<defs>
+<pattern id="pattern0_21_12" patternContentUnits="objectBoundingBox" width="1" height="1">
+<use xlink:href="#image0_21_12" transform="scale(0.00094697)"/>
+</pattern>
+<image id="image0_21_12" width="1056" height="1056" xlink:href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAEIKADAAQAAAABAAAEIAAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/+ICKElDQ19QUk9GSUxFAAEBAAACGGFwcGwEAAAAbW50clJHQiBYWVogB+YAAQABAAAAAAAAYWNzcEFQUEwAAAAAQVBQTAAAAAAAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1hcHBs7P2jjjiFR8NttL1PetoYLwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKZGVzYwAAAPwAAAAwY3BydAAAASwAAABQd3RwdAAAAXwAAAAUclhZWgAAAZAAAAAUZ1hZWgAAAaQAAAAUYlhZWgAAAbgAAAAUclRSQwAAAcwAAAAgY2hhZAAAAewAAAAsYlRSQwAAAcwAAAAgZ1RSQwAAAcwAAAAgbWx1YwAAAAAAAAABAAAADGVuVVMAAAAUAAAAHABEAGkAcwBwAGwAYQB5ACAAUAAzbWx1YwAAAAAAAAABAAAADGVuVVMAAAA0AAAAHABDAG8AcAB5AHIAaQBnAGgAdAAgAEEAcABwAGwAZQAgAEkAbgBjAC4ALAAgADIAMAAyADJYWVogAAAAAAAA9tUAAQAAAADTLFhZWiAAAAAAAACD3wAAPb////+7WFlaIAAAAAAAAEq/AACxNwAACrlYWVogAAAAAAAAKDgAABELAADIuXBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbc2YzMgAAAAAAAQxCAAAF3v//8yYAAAeTAAD9kP//+6L///2jAAAD3AAAwG7/wAARCAQgBCADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9sAQwACAgICAgIDAgIDBAMDAwQFBAQEBAUHBQUFBQUHCAcHBwcHBwgICAgICAgICgoKCgoKCwsLCwsNDQ0NDQ0NDQ0N/9sAQwECAgIDAwMGAwMGDQkHCQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0N/90ABABC/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Ln/gq38a/in8Dvgp4T8R/CfxFdeG9SvvFMdlcXFoELyW5srqQxnzEcY3op4Gciv1Gr8Z/+C2X/JvXgj/sc4v/AE33lAH4z/8ADwv9tD/oq2tf9823/wAZo/4eF/tof9FW1r/vm2/+M18Z0UAfZn/Dwv8AbQ/6KtrX/fNt/wDGaP8Ah4X+2h/0VbWv++bb/wCM18Z0UAfZn/Dwv9tD/oq2tf8AfNt/8Zo/4eF/tof9FW1r/vm2/wDjNfGdFAH2Z/w8L/bQ/wCira1/3zbf/GaP+Hhf7aH/AEVbWv8Avm2/+M18Z0UAfZn/AA8L/bQ/6KtrX/fNt/8AGaP+Hhf7aH/RVta/75tv/jNfGdFAH2Z/w8L/AG0P+ira1/3zbf8Axmj/AIeF/tof9FW1r/vm2/8AjNfGdFAH63/sVftq/tTfEb9qb4deCfG3xF1TVtD1bVGgvbKdYBHPGIJW2ttiVsblB4I6V/UbX8Z//BPT/k9D4U/9hpv/AEmmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+M/wD4eF/tof8ARVta/wC+bb/4zR/w8L/bQ/6KtrX/AHzbf/Ga+M6KAPsz/h4X+2h/0VbWv++bb/4zR/w8L/bQ/wCira1/3zbf/Ga+M6KAPsz/AIeF/tof9FW1r/vm2/8AjNH/AA8L/bQ/6KtrX/fNt/8AGa+M6KAPsz/h4X+2h/0VbWv++bb/AOM0f8PC/wBtD/oq2tf9823/AMZr4zooA+zP+Hhf7aH/AEVbWv8Avm2/+M0f8PC/20P+ira1/wB823/xmvjOigD7M/4eF/tof9FW1r/vm2/+M0f8PC/20P8Aoq2tf9823/xmvjOigD7M/wCHhf7aH/RVta/75tv/AIzR/wAPC/20P+ira1/3zbf/ABmvjOigD7M/4eF/tof9FW1r/vm2/wDjNH/Dwv8AbQ/6KtrX/fNt/wDGa+M6KAPsz/h4X+2h/wBFW1r/AL5tv/jNH/Dwv9tD/oq2tf8AfNt/8Zr4zooA+zP+Hhf7aH/RVta/75tv/jNH/Dwv9tD/AKKtrX/fNt/8Zr4zooA+zP8Ah4X+2h/0VbWv++bb/wCM0f8ADwv9tD/oq2tf9823/wAZr4zooA+zP+Hhf7aH/RVta/75tv8A4zR/w8L/AG0P+ira1/3zbf8AxmvjOigD7M/4eF/tof8ARVta/wC+bb/4zR/w8L/bQ/6KtrX/AHzbf/Ga+M6KAP6tv+CUnxr+Kfxx+CnizxH8WPEV14k1Kx8UyWVvcXYQPHbiytZBGPLRBje7HkZya/Uavxn/AOCJv/JvXjf/ALHOX/032dfsxQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfxn/APBPT/k9D4U/9hpv/Saav7MKACiiigAooooAKKKKACiiigAooooAKKKKAP4A6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfwq/BT4r638Dvin4d+LHhy0tb7UvDd0bu3t70ObeRzG0eJBGyPjDnowOa/Ub/h9l+0L/ANCR4M/79ah/8m0Af0yUV/M3/wAPsv2hf+hI8Gf9+tQ/+TaP+H2X7Qv/AEJHgz/v1qH/AMm0Af0yUV/M3/w+y/aF/wChI8Gf9+tQ/wDk2j/h9l+0L/0JHgz/AL9ah/8AJtAH9MlFfzN/8Psv2hf+hI8Gf9+tQ/8Ak2j/AIfZftC/9CR4M/79ah/8m0Af0yUV/M3/AMPsv2hf+hI8Gf8AfrUP/k2j/h9l+0L/ANCR4M/79ah/8m0Af0yUV/M3/wAPsv2hf+hI8Gf9+tQ/+TaP+H2X7Qv/AEJHgz/v1qH/AMm0Af0yUV/M3/w+y/aF/wChI8Gf9+tQ/wDk2j/h9l+0L/0JHgz/AL9ah/8AJtAH4z0V/TJ/w5N/Z6/6Hfxn/wB/dP8A/kKj/hyb+z1/0O/jP/v7p/8A8hUAfzN0V/TJ/wAOTf2ev+h38Z/9/dP/APkKj/hyb+z1/wBDv4z/AO/un/8AyFQB/M3RX9Mn/Dk39nr/AKHfxn/390//AOQqP+HJv7PX/Q7+M/8Av7p//wAhUAfzN0V/TJ/w5N/Z6/6Hfxn/AN/dP/8AkKj/AIcm/s9f9Dv4z/7+6f8A/IVAH8zdFf0yf8OTf2ev+h38Z/8Af3T/AP5Co/4cm/s9f9Dv4z/7+6f/APIVAH8zdFf0yf8ADk39nr/od/Gf/f3T/wD5Co/4cm/s9f8AQ7+M/wDv7p//AMhUAfzN0V/TJ/w5N/Z6/wCh38Z/9/dP/wDkKvwV/ag+FGifA74++M/hP4cu7q+03w3fi0t7i9KG4kQxRyZkMaomcueigYoA8FooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/AOxzl/8ATfZ1+zFfjP8A8ETf+TevG/8A2Ocv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/v8ooooAKKKKACiiigAooooAKKKKACiiigAr+M//goX/wAnofFb/sNL/wCk0Nf2YV/Gf/wUL/5PQ+K3/YaX/wBJoaAPjOiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP7/KKKKACiiigAooooAKKKKACiiigAooooAK/jP/4KF/8AJ6HxW/7DS/8ApNDX9mFfxn/8FC/+T0Pit/2Gl/8ASaGgD4zooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+/yiiigAooooAKKKKACiiigAooooAKKKKACv4z/+Chf/ACeh8Vv+w0v/AKTQ1/ZhX8Z//BQv/k9D4rf9hpf/AEmhoA+M6KKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/v8ooooAKKKKACiiigAooooAKKKKACiiigAr+M//goX/wAnofFb/sNL/wCk0Nf2YV/Gf/wUL/5PQ+K3/YaX/wBJoaAPjOiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP7/KKKKACiiigAooooAKKKKACiiigAooooAK/jP/4KF/8AJ6HxW/7DS/8ApNDX9mFfxn/8FC/+T0Pit/2Gl/8ASaGgD4zooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+/yiiigAooooAKKKKACiiigAooooAKKKKACv4z/+Chf/ACeh8Vv+w0v/AKTQ1/ZhX8Z//BQv/k9D4rf9hpf/AEmhoA+M6KKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD1L4KfCjW/jj8U/Dvwn8OXdrY6l4kujaW9xelxbxuI2kzIY1d8YQ9FJzX6jf8OTf2hf8Aod/Bn/f3UP8A5Cr4z/4J6f8AJ6Hwp/7DTf8ApNNX9mFAH8zf/Dk39oX/AKHfwZ/391D/AOQqP+HJv7Qv/Q7+DP8Av7qH/wAhV/TJRQB/M3/w5N/aF/6HfwZ/391D/wCQqP8Ahyb+0L/0O/gz/v7qH/yFX9MlFAH8zf8Aw5N/aF/6HfwZ/wB/dQ/+QqP+HJv7Qv8A0O/gz/v7qH/yFX9MlFAH8zf/AA5N/aF/6HfwZ/391D/5Co/4cm/tC/8AQ7+DP+/uof8AyFX9MlFAH8zf/Dk39oX/AKHfwZ/391D/AOQqP+HJv7Qv/Q7+DP8Av7qH/wAhV/TJRQB/M3/w5N/aF/6HfwZ/391D/wCQqP8Ahyb+0L/0O/gz/v7qH/yFX9MlFAH4z/8AD7L9nr/oSPGf/frT/wD5No/4fZfs9f8AQkeM/wDv1p//AMm1/M3RQB/TJ/w+y/Z6/wChI8Z/9+tP/wDk2j/h9l+z1/0JHjP/AL9af/8AJtfzN0UAf0yf8Psv2ev+hI8Z/wDfrT//AJNo/wCH2X7PX/QkeM/+/Wn/APybX8zdFAH9Mn/D7L9nr/oSPGf/AH60/wD+TaP+H2X7PX/QkeM/+/Wn/wDybX8zdFAH9Mn/AA+y/Z6/6Ejxn/360/8A+TaP+H2X7PX/AEJHjP8A79af/wDJtfzN0UAf0yf8Psv2ev8AoSPGf/frT/8A5No/4fZfs9f9CR4z/wC/Wn//ACbX8zdFAH9Mn/D7L9nr/oSPGf8A360//wCTa/BX9qD4r6J8cfj74z+LHhy0urHTfEl+Lu3t70ILiNBFHHiQRs6Zyh6MRivBaKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/ACb143/7HOX/ANN9nX7MV+M//BE3/k3rxv8A9jnL/wCm+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfxn/APBPT/k9D4U/9hpv/Saav7MKACiiigAooooAKKKKACiiigAooooAKKKKAP4A6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+XP/BVv4KfFP44/BTwn4c+E/h268SalY+KY724t7QoHjtxZXUZkPmOgxvdRwc5NAH8pNFfZn/DvT9tD/olOtf99W3/AMeo/wCHen7aH/RKda/76tv/AI9QB8Z0V9mf8O9P20P+iU61/wB9W3/x6j/h3p+2h/0SnWv++rb/AOPUAfGdFfZn/DvT9tD/AKJTrX/fVt/8eo/4d6ftof8ARKda/wC+rb/49QB8Z0V9mf8ADvT9tD/olOtf99W3/wAeo/4d6ftof9Ep1r/vq2/+PUAfGdFfZn/DvT9tD/olOtf99W3/AMeo/wCHen7aH/RKda/76tv/AI9QB8Z0V9mf8O9P20P+iU61/wB9W3/x6j/h3p+2h/0SnWv++rb/AOPUAH/BPT/k9D4U/wDYab/0mmr+zCv5cv2Kv2Kv2pvhz+1N8OvG3jb4dappOh6TqjT3t7O0BjgjMEq7m2ys2NzAcA9a/qNoAKKKKACiiigAooooAKKKKACiiigAooooA/gDor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD9mP+CJv/JvXjf8A7HOX/wBN9nX7MV+XP/BKT4KfFP4HfBTxZ4c+LHh268N6lfeKZL23t7soXktzZWsYkHlu4xvRhyc5FfqNQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9f9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/2Q=="/>
+</defs>
+</svg>
+`;
+
+//#endregion
+//#region src/plugins/open-api/index.ts
+const getHTML = (apiReference, theme, nonce) => {
+	const nonceAttr = nonce ? `nonce="${nonce}"` : "";
+	return `<!doctype html>
+<html>
+  <head>
+    <title>Scalar API Reference</title>
+    <meta charset="utf-8" />
+    <meta
+      name="viewport"
+      content="width=device-width, initial-scale=1" />
+  </head>
+  <body>
+    <script
+      id="api-reference"
+      type="application/json">
+    ${JSON.stringify(apiReference)}
+    <\/script>
+	 <script ${nonceAttr}>
+      var configuration = {
+	  	favicon: "data:image/svg+xml;utf8,${encodeURIComponent(logo)}",
+	   	theme: "${theme || "default"}",
+        metaData: {
+			title: "Better Auth API",
+			description: "API Reference for your Better Auth Instance",
+		}
+      }
+
+      document.getElementById('api-reference').dataset.configuration =
+        JSON.stringify(configuration)
+    <\/script>
+	  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference" ${nonceAttr}><\/script>
+  </body>
+</html>`;
+};
+const openAPI = (options) => {
+	const path = options?.path ?? "/reference";
+	return {
+		id: "open-api",
+		endpoints: {
+			generateOpenAPISchema: createAuthEndpoint("/open-api/generate-schema", { method: "GET" }, async (ctx) => {
+				const schema = await generator(ctx.context, ctx.context.options);
+				return ctx.json(schema);
+			}),
+			openAPIReference: createAuthEndpoint(path, {
+				method: "GET",
+				metadata: { isAction: false }
+			}, async (ctx) => {
+				if (options?.disableDefaultReference) throw new APIError("NOT_FOUND");
+				const schema = await generator(ctx.context, ctx.context.options);
+				return new Response(getHTML(schema, options?.theme, options?.nonce), { headers: { "Content-Type": "text/html" } });
+			})
+		}
+	};
+};
+
+//#endregion
+export { openAPI as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/organization-D-mvr_hy.mjs b/node_modules/better-auth/dist/organization-D-mvr_hy.mjs
index 1863691..a82b5ab 100644
--- a/node_modules/better-auth/dist/organization-D-mvr_hy.mjs
+++ b/node_modules/better-auth/dist/organization-D-mvr_hy.mjs
@@ -818,9 +818,9 @@ const createOrgRole = (options) => {
 	return createAuthEndpoint("/organization/create-role", {
 		method: "POST",
 		body: z.object({
-			organizationId: z.string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }),
-			role: z.string().meta({ description: "The name of the role to create" }),
-			permission: z.record(z.string(), z.array(z.string())).meta({ description: "The permission to assign to the role" }),
+			organizationId: z.string().optional(),
+			role: z.string(),
+			permission: z.record(z.string(), z.array(z.string())),
 			additionalFields: z.object({ ...additionalFieldsSchema.shape }).optional()
 		}),
 		metadata: { $Infer: { body: {} } },
@@ -943,7 +943,7 @@ const createOrgRole = (options) => {
 const deleteOrgRole = (options) => {
 	return createAuthEndpoint("/organization/delete-role", {
 		method: "POST",
-		body: z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to delete" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to delete" }) })])),
+		body: z.object({ organizationId: z.string().optional() }).and(z.union([z.object({ roleName: z.string().nonempty() }), z.object({ roleId: z.string().nonempty() })])),
 		requireHeaders: true,
 		use: [orgSessionMiddleware],
 		metadata: { $Infer: { body: {} } }
@@ -1055,7 +1055,7 @@ const listOrgRoles = (options) => {
 	return createAuthEndpoint("/organization/list-roles", {
 		method: "GET",
 		use: [orgSessionMiddleware],
-		query: z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to list roles for. If not provided, the user's active organization will be used." }) }).optional()
+		query: z.object({ organizationId: z.string().optional() }).optional()
 	}, async (ctx) => {
 		const { session, user } = ctx.context.session;
 		const organizationId = ctx.query?.organizationId ?? session.activeOrganizationId;
@@ -1118,7 +1118,7 @@ const getOrgRole = (options) => {
 	return createAuthEndpoint("/organization/get-role", {
 		method: "GET",
 		use: [orgSessionMiddleware],
-		query: z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to read a role for. If not provided, the user's active organization will be used." }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to read" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to read" }) })])).optional(),
+		query: z.object({ organizationId: z.string().optional() }).and(z.union([z.object({ roleName: z.string().nonempty() }), z.object({ roleId: z.string().nonempty() })])).optional(),
 		metadata: { $Infer: { query: {} } }
 	}, async (ctx) => {
 		const { session, user } = ctx.context.session;
@@ -1203,13 +1203,13 @@ const updateOrgRole = (options) => {
 	return createAuthEndpoint("/organization/update-role", {
 		method: "POST",
 		body: z.object({
-			organizationId: z.string().optional().meta({ description: "The id of the organization to update the role in. If not provided, the user's active organization will be used." }),
+			organizationId: z.string().optional(),
 			data: z.object({
-				permission: z.record(z.string(), z.array(z.string())).optional().meta({ description: "The permission to update the role with" }),
-				roleName: z.string().optional().meta({ description: "The name of the role to update" }),
+				permission: z.record(z.string(), z.array(z.string())).optional(),
+				roleName: z.string().optional(),
 				...additionalFieldsSchema.shape
 			})
-		}).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to update" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to update" }) })])),
+		}).and(z.union([z.object({ roleName: z.string().nonempty() }), z.object({ roleId: z.string().nonempty() })])),
 		metadata: { $Infer: { body: {} } },
 		use: [orgSessionMiddleware]
 	}, async (ctx) => {
@@ -1505,11 +1505,11 @@ const createInvitation = (option) => {
 		isClientSide: true
 	});
 	const baseSchema = z.object({
-		email: z.string().meta({ description: "The email address of the user to invite" }),
-		role: z.union([z.string().meta({ description: "The role to assign to the user" }), z.array(z.string().meta({ description: "The roles to assign to the user" }))]).meta({ description: "The role(s) to assign to the user. It can be `admin`, `member`, owner. Eg: \"member\"" }),
-		organizationId: z.string().meta({ description: "The organization ID to invite the user to" }).optional(),
-		resend: z.boolean().meta({ description: "Resend the invitation email, if the user is already invited. Eg: true" }).optional(),
-		teamId: z.union([z.string().meta({ description: "The team ID to invite the user to" }).optional(), z.array(z.string()).meta({ description: "The team IDs to invite the user to" }).optional()])
+		email: z.string(),
+		role: z.union([z.string(), z.array(z.string())]),
+		organizationId: z.string().optional(),
+		resend: z.boolean().optional(),
+		teamId: z.union([z.string().optional(), z.array(z.string()).optional()])
 	});
 	return createAuthEndpoint("/organization/invite-member", {
 		method: "POST",
@@ -1556,7 +1556,7 @@ const createInvitation = (option) => {
 		const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
 		if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
 		const email = ctx.body.email.toLowerCase();
-		if (!z.email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+		if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
 		const adapter = getOrgAdapter(ctx.context, option);
 		const member = await adapter.findMemberByOrgId({
 			userId: session.user.id,
@@ -1687,7 +1687,7 @@ const createInvitation = (option) => {
 };
 const acceptInvitation = (options) => createAuthEndpoint("/organization/accept-invitation", {
 	method: "POST",
-	body: z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to accept" }) }),
+	body: z.object({ invitationId: z.string() }),
 	use: [orgMiddleware, orgSessionMiddleware],
 	metadata: { openapi: {
 		description: "Accept an invitation to an organization",
@@ -1771,7 +1771,7 @@ const acceptInvitation = (options) => createAuthEndpoint("/organization/accept-i
 });
 const rejectInvitation = (options) => createAuthEndpoint("/organization/reject-invitation", {
 	method: "POST",
-	body: z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to reject" }) }),
+	body: z.object({ invitationId: z.string() }),
 	use: [orgMiddleware, orgSessionMiddleware],
 	metadata: { openapi: {
 		description: "Reject an invitation to an organization",
@@ -1816,7 +1816,7 @@ const rejectInvitation = (options) => createAuthEndpoint("/organization/reject-i
 });
 const cancelInvitation = (options) => createAuthEndpoint("/organization/cancel-invitation", {
 	method: "POST",
-	body: z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to cancel" }) }),
+	body: z.object({ invitationId: z.string() }),
 	use: [orgMiddleware, orgSessionMiddleware],
 	openapi: {
 		operationId: "cancelOrganizationInvitation",
@@ -1867,7 +1867,7 @@ const getInvitation = (options) => createAuthEndpoint("/organization/get-invitat
 	method: "GET",
 	use: [orgMiddleware],
 	requireHeaders: true,
-	query: z.object({ id: z.string().meta({ description: "The ID of the invitation to get" }) }),
+	query: z.object({ id: z.string() }),
 	metadata: { openapi: {
 		description: "Get an invitation by ID",
 		responses: { "200": {
@@ -1925,7 +1925,7 @@ const getInvitation = (options) => createAuthEndpoint("/organization/get-invitat
 const listInvitations = (options) => createAuthEndpoint("/organization/list-invitations", {
 	method: "GET",
 	use: [orgMiddleware, orgSessionMiddleware],
-	query: z.object({ organizationId: z.string().meta({ description: "The ID of the organization to list invitations for" }).optional() }).optional()
+	query: z.object({ organizationId: z.string().optional() }).optional()
 }, async (ctx) => {
 	const session = await getSessionFromCtx(ctx);
 	if (!session) throw new APIError("UNAUTHORIZED", { message: "Not authenticated" });
@@ -1945,7 +1945,7 @@ const listInvitations = (options) => createAuthEndpoint("/organization/list-invi
 const listUserInvitations = (options) => createAuthEndpoint("/organization/list-user-invitations", {
 	method: "GET",
 	use: [orgMiddleware],
-	query: z.object({ email: z.string().meta({ description: "The email of the user to list invitations for. This only works for server side API calls." }).optional() }).optional()
+	query: z.object({ email: z.string().optional() }).optional()
 }, async (ctx) => {
 	const session = await getSessionFromCtx(ctx);
 	if (ctx.request && ctx.query?.email) throw new APIError("BAD_REQUEST", { message: "User email cannot be passed for client side API calls." });
@@ -1963,10 +1963,10 @@ const addMember = (option) => {
 		isClientSide: true
 	});
 	const baseSchema = z.object({
-		userId: z.coerce.string().meta({ description: "The user Id which represents the user to be added as a member. If `null` is provided, then it's expected to provide session headers. Eg: \"user-id\"" }),
-		role: z.union([z.string(), z.array(z.string())]).meta({ description: "The role(s) to assign to the new member. Eg: [\"admin\", \"sale\"]" }),
-		organizationId: z.string().meta({ description: "An optional organization ID to pass. If not provided, will default to the user's active organization. Eg: \"org-id\"" }).optional(),
-		teamId: z.string().meta({ description: "An optional team ID to add the member to. Eg: \"team-id\"" }).optional()
+		userId: z.coerce.string(),
+		role: z.union([z.string(), z.array(z.string())]),
+		organizationId: z.string().optional(),
+		teamId: z.string().optional()
 	});
 	return createAuthEndpoint("/organization/add-member", {
 		method: "POST",
@@ -2053,8 +2053,8 @@ const addMember = (option) => {
 const removeMember = (options) => createAuthEndpoint("/organization/remove-member", {
 	method: "POST",
 	body: z.object({
-		memberIdOrEmail: z.string().meta({ description: "The ID or email of the member to remove" }),
-		organizationId: z.string().meta({ description: "The ID of the organization to remove the member from. If not provided, the active organization will be used. Eg: \"org-id\"" }).optional()
+		memberIdOrEmail: z.string(),
+		organizationId: z.string().optional()
 	}),
 	use: [orgMiddleware, orgSessionMiddleware],
 	metadata: { openapi: {
@@ -2143,9 +2143,9 @@ const removeMember = (options) => createAuthEndpoint("/organization/remove-membe
 const updateMemberRole = (option) => createAuthEndpoint("/organization/update-member-role", {
 	method: "POST",
 	body: z.object({
-		role: z.union([z.string(), z.array(z.string())]).meta({ description: "The new role to be applied. This can be a string or array of strings representing the roles. Eg: [\"admin\", \"sale\"]" }),
-		memberId: z.string().meta({ description: "The member id to apply the role update to. Eg: \"member-id\"" }),
-		organizationId: z.string().meta({ description: "An optional organization ID which the member is a part of to apply the role update. If not provided, you must provide session headers to get the active organization. Eg: \"organization-id\"" }).optional()
+		role: z.union([z.string(), z.array(z.string())]),
+		memberId: z.string(),
+		organizationId: z.string().optional()
 	}),
 	use: [orgMiddleware, orgSessionMiddleware],
 	metadata: {
@@ -2296,7 +2296,7 @@ const getActiveMember = (options) => createAuthEndpoint("/organization/get-activ
 });
 const leaveOrganization = (options) => createAuthEndpoint("/organization/leave", {
 	method: "POST",
-	body: z.object({ organizationId: z.string().meta({ description: "The organization Id for the member to leave. Eg: \"organization-id\"" }) }),
+	body: z.object({ organizationId: z.string() }),
 	requireHeaders: true,
 	use: [sessionMiddleware, orgMiddleware]
 }, async (ctx) => {
@@ -2328,12 +2328,12 @@ const leaveOrganization = (options) => createAuthEndpoint("/organization/leave",
 const listMembers = (options) => createAuthEndpoint("/organization/list-members", {
 	method: "GET",
 	query: z.object({
-		limit: z.string().meta({ description: "The number of users to return" }).or(z.number()).optional(),
-		offset: z.string().meta({ description: "The offset to start from" }).or(z.number()).optional(),
-		sortBy: z.string().meta({ description: "The field to sort by" }).optional(),
-		sortDirection: z.enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
-		filterField: z.string().meta({ description: "The field to filter by" }).optional(),
-		filterValue: z.string().meta({ description: "The value to filter by" }).or(z.number()).or(z.boolean()).optional(),
+		limit: z.string().or(z.number()).optional(),
+		offset: z.string().or(z.number()).optional(),
+		sortBy: z.string().optional(),
+		sortDirection: z.enum(["asc", "desc"]).optional(),
+		filterField: z.string().optional(),
+		filterValue: z.string().or(z.number()).or(z.boolean()).optional(),
 		filterOperator: z.enum([
 			"eq",
 			"ne",
@@ -2342,8 +2342,8 @@ const listMembers = (options) => createAuthEndpoint("/organization/list-members"
 			"gt",
 			"gte",
 			"contains"
-		]).meta({ description: "The operator to use for the filter" }).optional(),
-		organizationId: z.string().meta({ description: "The organization ID to list members for. If not provided, will default to the user's active organization. Eg: \"organization-id\"" }).optional()
+		]).optional(),
+		organizationId: z.string().optional()
 	}).optional(),
 	use: [orgMiddleware, orgSessionMiddleware]
 }, async (ctx) => {
@@ -2375,8 +2375,8 @@ const listMembers = (options) => createAuthEndpoint("/organization/list-members"
 const getActiveMemberRole = (options) => createAuthEndpoint("/organization/get-active-member-role", {
 	method: "GET",
 	query: z.object({
-		userId: z.string().meta({ description: "The user ID to get the role for. If not provided, will default to the current user's" }).optional(),
-		organizationId: z.string().meta({ description: "The organization ID to list members for. If not provided, will default to the user's active organization. Eg: \"organization-id\"" }).optional()
+		userId: z.string().optional(),
+		organizationId: z.string().optional()
 	}).optional(),
 	use: [orgMiddleware, orgSessionMiddleware]
 }, async (ctx) => {
@@ -2400,12 +2400,12 @@ const createOrganization = (options) => {
 		isClientSide: true
 	});
 	const baseSchema = z.object({
-		name: z.string().min(1).meta({ description: "The name of the organization" }),
-		slug: z.string().min(1).meta({ description: "The slug of the organization" }),
-		userId: z.coerce.string().meta({ description: "The user id of the organization creator. If not provided, the current user will be used. Should only be used by admins or when called by the server. server-only. Eg: \"user-id\"" }).optional(),
-		logo: z.string().meta({ description: "The logo of the organization" }).optional(),
-		metadata: z.record(z.string(), z.any()).meta({ description: "The metadata of the organization" }).optional(),
-		keepCurrentActiveOrganization: z.boolean().meta({ description: "Whether to keep the current active organization active after creating a new one. Eg: true" }).optional()
+		name: z.string().min(1),
+		slug: z.string().min(1),
+		userId: z.coerce.string().optional(),
+		logo: z.string().optional(),
+		metadata: z.record(z.string(), z.any()).optional(),
+		keepCurrentActiveOrganization: z.boolean().optional()
 	});
 	return createAuthEndpoint("/organization/create", {
 		method: "POST",
@@ -2551,7 +2551,7 @@ const createOrganization = (options) => {
 };
 const checkOrganizationSlug = (options) => createAuthEndpoint("/organization/check-slug", {
 	method: "POST",
-	body: z.object({ slug: z.string().meta({ description: "The organization slug to check. Eg: \"my-org\"" }) }),
+	body: z.object({ slug: z.string() }),
 	use: [requestOnlySessionMiddleware, orgMiddleware]
 }, async (ctx) => {
 	if (!await getOrgAdapter(ctx.context, options).findOrganizationBySlug(ctx.body.slug)) return ctx.json({ status: true });
@@ -2567,12 +2567,12 @@ const updateOrganization = (options) => {
 		body: z.object({
 			data: z.object({
 				...additionalFieldsSchema.shape,
-				name: z.string().min(1).meta({ description: "The name of the organization" }).optional(),
-				slug: z.string().min(1).meta({ description: "The slug of the organization" }).optional(),
-				logo: z.string().meta({ description: "The logo of the organization" }).optional(),
-				metadata: z.record(z.string(), z.any()).meta({ description: "The metadata of the organization" }).optional()
+				name: z.string().min(1).optional(),
+				slug: z.string().min(1).optional(),
+				logo: z.string().optional(),
+				metadata: z.record(z.string(), z.any()).optional()
 			}).partial(),
-			organizationId: z.string().meta({ description: "The organization ID. Eg: \"org-id\"" }).optional()
+			organizationId: z.string().optional()
 		}),
 		requireHeaders: true,
 		use: [orgMiddleware],
@@ -2634,7 +2634,7 @@ const updateOrganization = (options) => {
 const deleteOrganization = (options) => {
 	return createAuthEndpoint("/organization/delete", {
 		method: "POST",
-		body: z.object({ organizationId: z.string().meta({ description: "The organization id to delete" }) }),
+		body: z.object({ organizationId: z.string() }),
 		requireHeaders: true,
 		use: [orgMiddleware],
 		metadata: { openapi: {
@@ -2693,9 +2693,9 @@ const deleteOrganization = (options) => {
 const getFullOrganization = (options) => createAuthEndpoint("/organization/get-full-organization", {
 	method: "GET",
 	query: z.optional(z.object({
-		organizationId: z.string().meta({ description: "The organization id to get" }).optional(),
-		organizationSlug: z.string().meta({ description: "The organization slug to get" }).optional(),
-		membersLimit: z.number().or(z.string().transform((val) => parseInt(val))).meta({ description: "The limit of members to get. By default, it uses the membershipLimit option which defaults to 100." }).optional()
+		organizationId: z.string().optional(),
+		organizationSlug: z.string().optional(),
+		membersLimit: z.number().or(z.string().transform((val) => parseInt(val))).optional()
 	})),
 	requireHeaders: true,
 	use: [orgMiddleware, orgSessionMiddleware],
@@ -2736,8 +2736,8 @@ const setActiveOrganization = (options) => {
 	return createAuthEndpoint("/organization/set-active", {
 		method: "POST",
 		body: z.object({
-			organizationId: z.string().meta({ description: "The organization id to set as active. It can be null to unset the active organization. Eg: \"org-id\"" }).nullable().optional(),
-			organizationSlug: z.string().meta({ description: "The organization slug to set as active. It can be null to unset the active organization if organizationId is not provided. Eg: \"org-slug\"" }).optional()
+			organizationId: z.string().nullable().optional(),
+			organizationSlug: z.string().optional()
 		}),
 		use: [orgSessionMiddleware, orgMiddleware],
 		metadata: { openapi: {
@@ -2818,8 +2818,8 @@ const createTeam = (options) => {
 		isClientSide: true
 	});
 	const baseSchema = z.object({
-		name: z.string().meta({ description: "The name of the team. Eg: \"my-team\"" }),
-		organizationId: z.string().meta({ description: "The organization ID which the team will be created in. Defaults to the active organization. Eg: \"organization-id\"" }).optional()
+		name: z.string(),
+		organizationId: z.string().optional()
 	});
 	return createAuthEndpoint("/organization/create-team", {
 		method: "POST",
@@ -2933,8 +2933,8 @@ const createTeam = (options) => {
 const removeTeam = (options) => createAuthEndpoint("/organization/remove-team", {
 	method: "POST",
 	body: z.object({
-		teamId: z.string().meta({ description: `The team ID of the team to remove. Eg: "team-id"` }),
-		organizationId: z.string().meta({ description: `The organization ID which the team falls under. If not provided, it will default to the user's active organization. Eg: "organization-id"` }).optional()
+		teamId: z.string(),
+		organizationId: z.string().optional()
 	}),
 	use: [orgMiddleware],
 	metadata: { openapi: {
@@ -3005,7 +3005,7 @@ const updateTeam = (options) => {
 	return createAuthEndpoint("/organization/update-team", {
 		method: "POST",
 		body: z.object({
-			teamId: z.string().meta({ description: `The ID of the team to be updated. Eg: "team-id"` }),
+			teamId: z.string(),
 			data: z.object({
 				...teamSchema.shape,
 				...additionalFieldsSchema.shape
@@ -3116,7 +3116,7 @@ const updateTeam = (options) => {
 };
 const listOrganizationTeams = (options) => createAuthEndpoint("/organization/list-teams", {
 	method: "GET",
-	query: z.optional(z.object({ organizationId: z.string().meta({ description: `The organization ID which the teams are under to list. Defaults to the users active organization. Eg: "organziation-id"` }).optional() })),
+	query: z.optional(z.object({ organizationId: z.string().optional() })),
 	requireHeaders: true,
 	metadata: { openapi: {
 		description: "List all teams in an organization",
@@ -3177,7 +3177,7 @@ const listOrganizationTeams = (options) => createAuthEndpoint("/organization/lis
 });
 const setActiveTeam = (options) => createAuthEndpoint("/organization/set-active-team", {
 	method: "POST",
-	body: z.object({ teamId: z.string().meta({ description: "The team id to set as active. It can be null to unset the active team" }).nullable().optional() }),
+	body: z.object({ teamId: z.string().nullable().optional() }),
 	use: [orgSessionMiddleware, orgMiddleware],
 	metadata: { openapi: {
 		description: "Set the active team",
@@ -3244,7 +3244,7 @@ const listUserTeams = (options) => createAuthEndpoint("/organization/list-user-t
 });
 const listTeamMembers = (options) => createAuthEndpoint("/organization/list-team-members", {
 	method: "GET",
-	query: z.optional(z.object({ teamId: z.string().optional().meta({ description: "The team whose members we should return. If this is not provided the members of the current active team get returned." }) })),
+	query: z.optional(z.object({ teamId: z.string().optional() })),
 	metadata: { openapi: {
 		description: "List the members of the given team.",
 		responses: { "200": {
@@ -3300,8 +3300,8 @@ const listTeamMembers = (options) => createAuthEndpoint("/organization/list-team
 const addTeamMember = (options) => createAuthEndpoint("/organization/add-team-member", {
 	method: "POST",
 	body: z.object({
-		teamId: z.string().meta({ description: "The team the user should be a member of." }),
-		userId: z.coerce.string().meta({ description: "The user Id which represents the user to be added as a member." })
+		teamId: z.string(),
+		userId: z.coerce.string()
 	}),
 	metadata: { openapi: {
 		description: "The newly created member",
@@ -3394,8 +3394,8 @@ const addTeamMember = (options) => createAuthEndpoint("/organization/add-team-me
 const removeTeamMember = (options) => createAuthEndpoint("/organization/remove-team-member", {
 	method: "POST",
 	body: z.object({
-		teamId: z.string().meta({ description: "The team the user should be removed from." }),
-		userId: z.coerce.string().meta({ description: "The user which should be removed from the team." })
+		teamId: z.string(),
+		userId: z.coerce.string()
 	}),
 	metadata: { openapi: {
 		description: "Remove a member from a team",
diff --git a/node_modules/better-auth/dist/organization-D-mvr_hy.mjs.bak b/node_modules/better-auth/dist/organization-D-mvr_hy.mjs.bak
new file mode 100644
index 0000000..1513187
--- /dev/null
+++ b/node_modules/better-auth/dist/organization-D-mvr_hy.mjs.bak
@@ -0,0 +1,3874 @@
+import { i as toZodSchema } from "./get-migration-C1tgKlQ6.mjs";
+import { t as generateId } from "./utils-F62c-ieM.mjs";
+import { u as getDate } from "./schema-BevzneML.mjs";
+import { t as APIError$1 } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { a as requestOnlySessionMiddleware, r as getSessionFromCtx, u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { n as parser_default } from "./parser-DcrIEuXE.mjs";
+import { r as defaultRoles } from "./access-HdxSBEa0.mjs";
+import { n as hasPermissionFn, t as cacheAllRoles } from "./permission-CDDWgA_O.mjs";
+import { getCurrentAdapter } from "@better-auth/core/context";
+import { BASE_ERROR_CODES, BetterAuthError } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/utils/shim.ts
+const shimContext = (originalObject, newContext) => {
+	const shimmedObj = {};
+	for (const [key, value] of Object.entries(originalObject)) {
+		shimmedObj[key] = (ctx) => {
+			return value({
+				...ctx,
+				context: {
+					...newContext,
+					...ctx.context
+				}
+			});
+		};
+		shimmedObj[key].path = value.path;
+		shimmedObj[key].method = value.method;
+		shimmedObj[key].options = value.options;
+		shimmedObj[key].headers = value.headers;
+	}
+	return shimmedObj;
+};
+
+//#endregion
+//#region src/plugins/organization/adapter.ts
+const getOrgAdapter = (context, options) => {
+	const baseAdapter = context.adapter;
+	return {
+		findOrganizationBySlug: async (slug) => {
+			return await (await getCurrentAdapter(baseAdapter)).findOne({
+				model: "organization",
+				where: [{
+					field: "slug",
+					value: slug
+				}]
+			});
+		},
+		createOrganization: async (data) => {
+			const organization$1 = await (await getCurrentAdapter(baseAdapter)).create({
+				model: "organization",
+				data: {
+					...data.organization,
+					metadata: data.organization.metadata ? JSON.stringify(data.organization.metadata) : void 0
+				},
+				forceAllowId: true
+			});
+			return {
+				...organization$1,
+				metadata: organization$1.metadata && typeof organization$1.metadata === "string" ? JSON.parse(organization$1.metadata) : void 0
+			};
+		},
+		findMemberByEmail: async (data) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const user = await adapter.findOne({
+				model: "user",
+				where: [{
+					field: "email",
+					value: data.email.toLowerCase()
+				}]
+			});
+			if (!user) return null;
+			const member = await adapter.findOne({
+				model: "member",
+				where: [{
+					field: "organizationId",
+					value: data.organizationId
+				}, {
+					field: "userId",
+					value: user.id
+				}]
+			});
+			if (!member) return null;
+			return {
+				...member,
+				user: {
+					id: user.id,
+					name: user.name,
+					email: user.email,
+					image: user.image
+				}
+			};
+		},
+		listMembers: async (data) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const members = await Promise.all([adapter.findMany({
+				model: "member",
+				where: [{
+					field: "organizationId",
+					value: data.organizationId
+				}, ...data.filter?.field ? [{
+					field: data.filter?.field,
+					value: data.filter?.value
+				}] : []],
+				limit: data.limit || options?.membershipLimit || 100,
+				offset: data.offset || 0,
+				sortBy: data.sortBy ? {
+					field: data.sortBy,
+					direction: data.sortOrder || "asc"
+				} : void 0
+			}), adapter.count({
+				model: "member",
+				where: [{
+					field: "organizationId",
+					value: data.organizationId
+				}, ...data.filter?.field ? [{
+					field: data.filter?.field,
+					value: data.filter?.value
+				}] : []]
+			})]);
+			const users = await adapter.findMany({
+				model: "user",
+				where: [{
+					field: "id",
+					value: members[0].map((member) => member.userId),
+					operator: "in"
+				}]
+			});
+			return {
+				members: members[0].map((member) => {
+					const user = users.find((user$1) => user$1.id === member.userId);
+					if (!user) throw new BetterAuthError("Unexpected error: User not found for member");
+					return {
+						...member,
+						user: {
+							id: user.id,
+							name: user.name,
+							email: user.email,
+							image: user.image
+						}
+					};
+				}),
+				total: members[1]
+			};
+		},
+		findMemberByOrgId: async (data) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const [member, user] = await Promise.all([await adapter.findOne({
+				model: "member",
+				where: [{
+					field: "userId",
+					value: data.userId
+				}, {
+					field: "organizationId",
+					value: data.organizationId
+				}]
+			}), await adapter.findOne({
+				model: "user",
+				where: [{
+					field: "id",
+					value: data.userId
+				}]
+			})]);
+			if (!user || !member) return null;
+			return {
+				...member,
+				user: {
+					id: user.id,
+					name: user.name,
+					email: user.email,
+					image: user.image
+				}
+			};
+		},
+		findMemberById: async (memberId) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const member = await adapter.findOne({
+				model: "member",
+				where: [{
+					field: "id",
+					value: memberId
+				}]
+			});
+			if (!member) return null;
+			const user = await adapter.findOne({
+				model: "user",
+				where: [{
+					field: "id",
+					value: member.userId
+				}]
+			});
+			if (!user) return null;
+			return {
+				...member,
+				user: {
+					id: user.id,
+					name: user.name,
+					email: user.email,
+					image: user.image
+				}
+			};
+		},
+		createMember: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).create({
+				model: "member",
+				data: {
+					...data,
+					createdAt: /* @__PURE__ */ new Date()
+				}
+			});
+		},
+		updateMember: async (memberId, role) => {
+			return await (await getCurrentAdapter(baseAdapter)).update({
+				model: "member",
+				where: [{
+					field: "id",
+					value: memberId
+				}],
+				update: { role }
+			});
+		},
+		deleteMember: async ({ memberId, organizationId, userId: _userId }) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			let userId;
+			if (!_userId) {
+				const member$1 = await adapter.findOne({
+					model: "member",
+					where: [{
+						field: "id",
+						value: memberId
+					}]
+				});
+				if (!member$1) throw new BetterAuthError("Member not found");
+				userId = member$1.userId;
+			} else userId = _userId;
+			const member = await adapter.delete({
+				model: "member",
+				where: [{
+					field: "id",
+					value: memberId
+				}]
+			});
+			if (options?.teams?.enabled) {
+				const teams = await adapter.findMany({
+					model: "team",
+					where: [{
+						field: "organizationId",
+						value: organizationId
+					}]
+				});
+				await Promise.all(teams.map((team) => adapter.deleteMany({
+					model: "teamMember",
+					where: [{
+						field: "teamId",
+						value: team.id
+					}, {
+						field: "userId",
+						value: userId
+					}]
+				})));
+			}
+			return member;
+		},
+		updateOrganization: async (organizationId, data) => {
+			const organization$1 = await (await getCurrentAdapter(baseAdapter)).update({
+				model: "organization",
+				where: [{
+					field: "id",
+					value: organizationId
+				}],
+				update: {
+					...data,
+					metadata: typeof data.metadata === "object" ? JSON.stringify(data.metadata) : data.metadata
+				}
+			});
+			if (!organization$1) return null;
+			return {
+				...organization$1,
+				metadata: organization$1.metadata ? parser_default(organization$1.metadata) : void 0
+			};
+		},
+		deleteOrganization: async (organizationId) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			await adapter.delete({
+				model: "member",
+				where: [{
+					field: "organizationId",
+					value: organizationId
+				}]
+			});
+			await adapter.delete({
+				model: "invitation",
+				where: [{
+					field: "organizationId",
+					value: organizationId
+				}]
+			});
+			await adapter.delete({
+				model: "organization",
+				where: [{
+					field: "id",
+					value: organizationId
+				}]
+			});
+			return organizationId;
+		},
+		setActiveOrganization: async (sessionToken, organizationId, ctx) => {
+			return await context.internalAdapter.updateSession(sessionToken, { activeOrganizationId: organizationId });
+		},
+		findOrganizationById: async (organizationId) => {
+			return await (await getCurrentAdapter(baseAdapter)).findOne({
+				model: "organization",
+				where: [{
+					field: "id",
+					value: organizationId
+				}]
+			});
+		},
+		checkMembership: async ({ userId, organizationId }) => {
+			return await (await getCurrentAdapter(baseAdapter)).findOne({
+				model: "member",
+				where: [{
+					field: "userId",
+					value: userId
+				}, {
+					field: "organizationId",
+					value: organizationId
+				}]
+			});
+		},
+		findFullOrganization: async ({ organizationId, isSlug, includeTeams, membersLimit }) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const org = await adapter.findOne({
+				model: "organization",
+				where: [{
+					field: isSlug ? "slug" : "id",
+					value: organizationId
+				}]
+			});
+			if (!org) return null;
+			const [invitations, members, teams] = await Promise.all([
+				adapter.findMany({
+					model: "invitation",
+					where: [{
+						field: "organizationId",
+						value: org.id
+					}]
+				}),
+				adapter.findMany({
+					model: "member",
+					where: [{
+						field: "organizationId",
+						value: org.id
+					}],
+					limit: membersLimit ?? options?.membershipLimit ?? 100
+				}),
+				includeTeams ? adapter.findMany({
+					model: "team",
+					where: [{
+						field: "organizationId",
+						value: org.id
+					}]
+				}) : null
+			]);
+			if (!org) return null;
+			const userIds = members.map((member) => member.userId);
+			const users = userIds.length > 0 ? await adapter.findMany({
+				model: "user",
+				where: [{
+					field: "id",
+					value: userIds,
+					operator: "in"
+				}],
+				limit: options?.membershipLimit || 100
+			}) : [];
+			const userMap = new Map(users.map((user) => [user.id, user]));
+			const membersWithUsers = members.map((member) => {
+				const user = userMap.get(member.userId);
+				if (!user) throw new BetterAuthError("Unexpected error: User not found for member");
+				return {
+					...member,
+					user: {
+						id: user.id,
+						name: user.name,
+						email: user.email,
+						image: user.image
+					}
+				};
+			});
+			return {
+				...org,
+				invitations,
+				members: membersWithUsers,
+				teams
+			};
+		},
+		listOrganizations: async (userId) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const members = await adapter.findMany({
+				model: "member",
+				where: [{
+					field: "userId",
+					value: userId
+				}]
+			});
+			if (!members || members.length === 0) return [];
+			const organizationIds = members.map((member) => member.organizationId);
+			return await adapter.findMany({
+				model: "organization",
+				where: [{
+					field: "id",
+					value: organizationIds,
+					operator: "in"
+				}]
+			});
+		},
+		createTeam: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).create({
+				model: "team",
+				data
+			});
+		},
+		findTeamById: async ({ teamId, organizationId, includeTeamMembers }) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const team = await adapter.findOne({
+				model: "team",
+				where: [{
+					field: "id",
+					value: teamId
+				}, ...organizationId ? [{
+					field: "organizationId",
+					value: organizationId
+				}] : []]
+			});
+			if (!team) return null;
+			let members = [];
+			if (includeTeamMembers) {
+				members = await adapter.findMany({
+					model: "teamMember",
+					where: [{
+						field: "teamId",
+						value: teamId
+					}],
+					limit: options?.membershipLimit || 100
+				});
+				return {
+					...team,
+					members
+				};
+			}
+			return team;
+		},
+		updateTeam: async (teamId, data) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			if ("id" in data) data.id = void 0;
+			return await adapter.update({
+				model: "team",
+				where: [{
+					field: "id",
+					value: teamId
+				}],
+				update: { ...data }
+			});
+		},
+		deleteTeam: async (teamId) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			await adapter.deleteMany({
+				model: "teamMember",
+				where: [{
+					field: "teamId",
+					value: teamId
+				}]
+			});
+			return await adapter.delete({
+				model: "team",
+				where: [{
+					field: "id",
+					value: teamId
+				}]
+			});
+		},
+		listTeams: async (organizationId) => {
+			return await (await getCurrentAdapter(baseAdapter)).findMany({
+				model: "team",
+				where: [{
+					field: "organizationId",
+					value: organizationId
+				}]
+			});
+		},
+		createTeamInvitation: async ({ email, role, teamId, organizationId, inviterId, expiresIn = 1e3 * 60 * 60 * 48 }) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const expiresAt = getDate(expiresIn);
+			return await adapter.create({
+				model: "invitation",
+				data: {
+					email,
+					role,
+					organizationId,
+					teamId,
+					inviterId,
+					status: "pending",
+					expiresAt
+				}
+			});
+		},
+		setActiveTeam: async (sessionToken, teamId, ctx) => {
+			return await context.internalAdapter.updateSession(sessionToken, { activeTeamId: teamId });
+		},
+		listTeamMembers: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).findMany({
+				model: "teamMember",
+				where: [{
+					field: "teamId",
+					value: data.teamId
+				}]
+			});
+		},
+		countTeamMembers: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).count({
+				model: "teamMember",
+				where: [{
+					field: "teamId",
+					value: data.teamId
+				}]
+			});
+		},
+		countMembers: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).count({
+				model: "member",
+				where: [{
+					field: "organizationId",
+					value: data.organizationId
+				}]
+			});
+		},
+		listTeamsByUser: async (data) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const members = await adapter.findMany({
+				model: "teamMember",
+				where: [{
+					field: "userId",
+					value: data.userId
+				}]
+			});
+			return await adapter.findMany({
+				model: "team",
+				where: [{
+					field: "id",
+					operator: "in",
+					value: members.map((m) => m.teamId)
+				}]
+			});
+		},
+		findTeamMember: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).findOne({
+				model: "teamMember",
+				where: [{
+					field: "teamId",
+					value: data.teamId
+				}, {
+					field: "userId",
+					value: data.userId
+				}]
+			});
+		},
+		findOrCreateTeamMember: async (data) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const member = await adapter.findOne({
+				model: "teamMember",
+				where: [{
+					field: "teamId",
+					value: data.teamId
+				}, {
+					field: "userId",
+					value: data.userId
+				}]
+			});
+			if (member) return member;
+			return await adapter.create({
+				model: "teamMember",
+				data: {
+					teamId: data.teamId,
+					userId: data.userId,
+					createdAt: /* @__PURE__ */ new Date()
+				}
+			});
+		},
+		removeTeamMember: async (data) => {
+			await (await getCurrentAdapter(baseAdapter)).deleteMany({
+				model: "teamMember",
+				where: [{
+					field: "teamId",
+					value: data.teamId
+				}, {
+					field: "userId",
+					value: data.userId
+				}]
+			});
+		},
+		findInvitationsByTeamId: async (teamId) => {
+			return await (await getCurrentAdapter(baseAdapter)).findMany({
+				model: "invitation",
+				where: [{
+					field: "teamId",
+					value: teamId
+				}]
+			});
+		},
+		listUserInvitations: async (email) => {
+			return await (await getCurrentAdapter(baseAdapter)).findMany({
+				model: "invitation",
+				where: [{
+					field: "email",
+					value: email.toLowerCase()
+				}]
+			});
+		},
+		createInvitation: async ({ invitation, user }) => {
+			const adapter = await getCurrentAdapter(baseAdapter);
+			const expiresAt = getDate(options?.invitationExpiresIn || 3600 * 48, "sec");
+			return await adapter.create({
+				model: "invitation",
+				data: {
+					status: "pending",
+					expiresAt,
+					createdAt: /* @__PURE__ */ new Date(),
+					inviterId: user.id,
+					...invitation,
+					teamId: invitation.teamIds.length > 0 ? invitation.teamIds.join(",") : null
+				}
+			});
+		},
+		findInvitationById: async (id) => {
+			return await (await getCurrentAdapter(baseAdapter)).findOne({
+				model: "invitation",
+				where: [{
+					field: "id",
+					value: id
+				}]
+			});
+		},
+		findPendingInvitation: async (data) => {
+			return (await (await getCurrentAdapter(baseAdapter)).findMany({
+				model: "invitation",
+				where: [
+					{
+						field: "email",
+						value: data.email.toLowerCase()
+					},
+					{
+						field: "organizationId",
+						value: data.organizationId
+					},
+					{
+						field: "status",
+						value: "pending"
+					}
+				]
+			})).filter((invite) => new Date(invite.expiresAt) > /* @__PURE__ */ new Date());
+		},
+		findPendingInvitations: async (data) => {
+			return (await (await getCurrentAdapter(baseAdapter)).findMany({
+				model: "invitation",
+				where: [{
+					field: "organizationId",
+					value: data.organizationId
+				}, {
+					field: "status",
+					value: "pending"
+				}]
+			})).filter((invite) => new Date(invite.expiresAt) > /* @__PURE__ */ new Date());
+		},
+		listInvitations: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).findMany({
+				model: "invitation",
+				where: [{
+					field: "organizationId",
+					value: data.organizationId
+				}]
+			});
+		},
+		updateInvitation: async (data) => {
+			return await (await getCurrentAdapter(baseAdapter)).update({
+				model: "invitation",
+				where: [{
+					field: "id",
+					value: data.invitationId
+				}],
+				update: { status: data.status }
+			});
+		}
+	};
+};
+
+//#endregion
+//#region src/plugins/organization/call.ts
+const orgMiddleware = createAuthMiddleware(async () => {
+	return {};
+});
+/**
+* The middleware forces the endpoint to require a valid session by utilizing the `sessionMiddleware`.
+* It also appends additional types to the session type regarding organizations.
+*/
+const orgSessionMiddleware = createAuthMiddleware({ use: [sessionMiddleware] }, async (ctx) => {
+	return { session: ctx.context.session };
+});
+
+//#endregion
+//#region src/plugins/organization/error-codes.ts
+const ORGANIZATION_ERROR_CODES = defineErrorCodes({
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_ORGANIZATION: "You are not allowed to create a new organization",
+	YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_ORGANIZATIONS: "You have reached the maximum number of organizations",
+	ORGANIZATION_ALREADY_EXISTS: "Organization already exists",
+	ORGANIZATION_SLUG_ALREADY_TAKEN: "Organization slug already taken",
+	ORGANIZATION_NOT_FOUND: "Organization not found",
+	USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION: "User is not a member of the organization",
+	YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_ORGANIZATION: "You are not allowed to update this organization",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_ORGANIZATION: "You are not allowed to delete this organization",
+	NO_ACTIVE_ORGANIZATION: "No active organization",
+	USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION: "User is already a member of this organization",
+	MEMBER_NOT_FOUND: "Member not found",
+	ROLE_NOT_FOUND: "Role not found",
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM: "You are not allowed to create a new team",
+	TEAM_ALREADY_EXISTS: "Team already exists",
+	TEAM_NOT_FOUND: "Team not found",
+	YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER: "You cannot leave the organization as the only owner",
+	YOU_CANNOT_LEAVE_THE_ORGANIZATION_WITHOUT_AN_OWNER: "You cannot leave the organization without an owner",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_MEMBER: "You are not allowed to delete this member",
+	YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION: "You are not allowed to invite users to this organization",
+	USER_IS_ALREADY_INVITED_TO_THIS_ORGANIZATION: "User is already invited to this organization",
+	INVITATION_NOT_FOUND: "Invitation not found",
+	YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION: "You are not the recipient of the invitation",
+	EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION: "Email verification required before accepting or rejecting invitation",
+	YOU_ARE_NOT_ALLOWED_TO_CANCEL_THIS_INVITATION: "You are not allowed to cancel this invitation",
+	INVITER_IS_NO_LONGER_A_MEMBER_OF_THE_ORGANIZATION: "Inviter is no longer a member of the organization",
+	YOU_ARE_NOT_ALLOWED_TO_INVITE_USER_WITH_THIS_ROLE: "You are not allowed to invite a user with this role",
+	FAILED_TO_RETRIEVE_INVITATION: "Failed to retrieve invitation",
+	YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_TEAMS: "You have reached the maximum number of teams",
+	UNABLE_TO_REMOVE_LAST_TEAM: "Unable to remove last team",
+	YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER: "You are not allowed to update this member",
+	ORGANIZATION_MEMBERSHIP_LIMIT_REACHED: "Organization membership limit reached",
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_TEAMS_IN_THIS_ORGANIZATION: "You are not allowed to create teams in this organization",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_TEAMS_IN_THIS_ORGANIZATION: "You are not allowed to delete teams in this organization",
+	YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM: "You are not allowed to update this team",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_TEAM: "You are not allowed to delete this team",
+	INVITATION_LIMIT_REACHED: "Invitation limit reached",
+	TEAM_MEMBER_LIMIT_REACHED: "Team member limit reached",
+	USER_IS_NOT_A_MEMBER_OF_THE_TEAM: "User is not a member of the team",
+	YOU_CAN_NOT_ACCESS_THE_MEMBERS_OF_THIS_TEAM: "You are not allowed to list the members of this team",
+	YOU_DO_NOT_HAVE_AN_ACTIVE_TEAM: "You do not have an active team",
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM_MEMBER: "You are not allowed to create a new member",
+	YOU_ARE_NOT_ALLOWED_TO_REMOVE_A_TEAM_MEMBER: "You are not allowed to remove a team member",
+	YOU_ARE_NOT_ALLOWED_TO_ACCESS_THIS_ORGANIZATION: "You are not allowed to access this organization as an owner",
+	YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION: "You are not a member of this organization",
+	MISSING_AC_INSTANCE: "Dynamic Access Control requires a pre-defined ac instance on the server auth plugin. Read server logs for more information",
+	YOU_MUST_BE_IN_AN_ORGANIZATION_TO_CREATE_A_ROLE: "You must be in an organization to create a role",
+	YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE: "You are not allowed to create a role",
+	YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE: "You are not allowed to update a role",
+	YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE: "You are not allowed to delete a role",
+	YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE: "You are not allowed to read a role",
+	YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE: "You are not allowed to list a role",
+	YOU_ARE_NOT_ALLOWED_TO_GET_A_ROLE: "You are not allowed to get a role",
+	TOO_MANY_ROLES: "This organization has too many roles",
+	INVALID_RESOURCE: "The provided permission includes an invalid resource",
+	ROLE_NAME_IS_ALREADY_TAKEN: "That role name is already taken",
+	CANNOT_DELETE_A_PRE_DEFINED_ROLE: "Cannot delete a pre-defined role"
+});
+
+//#endregion
+//#region src/plugins/organization/has-permission.ts
+const hasPermission = async (input, ctx) => {
+	let acRoles = { ...input.options.roles || defaultRoles };
+	if (ctx && input.organizationId && input.options.dynamicAccessControl?.enabled && input.options.ac && !input.useMemoryCache) {
+		const roles = await ctx.context.adapter.findMany({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: input.organizationId
+			}]
+		});
+		for (const { role, permission: permissionsString } of roles) {
+			if (role in acRoles) continue;
+			const result = z.record(z.string(), z.array(z.string())).safeParse(JSON.parse(permissionsString));
+			if (!result.success) {
+				ctx.context.logger.error("[hasPermission] Invalid permissions for role " + role, { permissions: JSON.parse(permissionsString) });
+				throw new APIError$1("INTERNAL_SERVER_ERROR", { message: "Invalid permissions for role " + role });
+			}
+			acRoles[role] = input.options.ac.newRole(result.data);
+		}
+	}
+	if (input.useMemoryCache) acRoles = cacheAllRoles.get(input.organizationId) || acRoles;
+	cacheAllRoles.set(input.organizationId, acRoles);
+	return hasPermissionFn(input, acRoles);
+};
+
+//#endregion
+//#region src/plugins/organization/routes/crud-access-control.ts
+const normalizeRoleName = (role) => role.toLowerCase();
+const DEFAULT_MAXIMUM_ROLES_PER_ORGANIZATION = Number.POSITIVE_INFINITY;
+const getAdditionalFields = (options, shouldBePartial = false) => {
+	let additionalFields = options?.schema?.organizationRole?.additionalFields || {};
+	if (shouldBePartial) for (const key in additionalFields) additionalFields[key].required = false;
+	return {
+		additionalFieldsSchema: toZodSchema({
+			fields: additionalFields,
+			isClientSide: true
+		}),
+		$AdditionalFields: {},
+		$ReturnAdditionalFields: {}
+	};
+};
+const createOrgRole = (options) => {
+	const { additionalFieldsSchema, $AdditionalFields, $ReturnAdditionalFields } = getAdditionalFields(options, false);
+	return createAuthEndpoint("/organization/create-role", {
+		method: "POST",
+		body: z.object({
+			organizationId: z.string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }),
+			role: z.string().meta({ description: "The name of the role to create" }),
+			permission: z.record(z.string(), z.array(z.string())).meta({ description: "The permission to assign to the role" }),
+			additionalFields: z.object({ ...additionalFieldsSchema.shape }).optional()
+		}),
+		metadata: { $Infer: { body: {} } },
+		requireHeaders: true,
+		use: [orgSessionMiddleware]
+	}, async (ctx) => {
+		const { session, user } = ctx.context.session;
+		let roleName = ctx.body.role;
+		const permission = ctx.body.permission;
+		const additionalFields = ctx.body.additionalFields;
+		const ac = options.ac;
+		if (!ac) {
+			ctx.context.logger.error(`[Dynamic Access Control] The organization plugin is missing a pre-defined ac instance.`, `\nPlease refer to the documentation here: https://better-auth.com/docs/plugins/organization#dynamic-access-control`);
+			throw new APIError$1("NOT_IMPLEMENTED", { message: ORGANIZATION_ERROR_CODES.MISSING_AC_INSTANCE });
+		}
+		const organizationId = ctx.body.organizationId ?? session.activeOrganizationId;
+		if (!organizationId) {
+			ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to create a role. Either set an active org id, or pass an organizationId in the request body.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_MUST_BE_IN_AN_ORGANIZATION_TO_CREATE_A_ROLE });
+		}
+		roleName = normalizeRoleName(roleName);
+		await checkIfRoleNameIsTakenByPreDefinedRole({
+			role: roleName,
+			organizationId,
+			options,
+			ctx
+		});
+		const member = await ctx.context.adapter.findOne({
+			model: "member",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, {
+				field: "userId",
+				value: user.id,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		if (!member) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to create a role.`, {
+				userId: user.id,
+				organizationId
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
+		}
+		if (!await hasPermission({
+			options,
+			organizationId,
+			permissions: { ac: ["create"] },
+			role: member.role
+		}, ctx)) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to create a role. If this is unexpected, please make sure the role associated to that member has the "ac" resource with the "create" permission.`, {
+				userId: user.id,
+				organizationId,
+				role: member.role
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE });
+		}
+		const maximumRolesPerOrganization = typeof options.dynamicAccessControl?.maximumRolesPerOrganization === "function" ? await options.dynamicAccessControl.maximumRolesPerOrganization(organizationId) : options.dynamicAccessControl?.maximumRolesPerOrganization ?? DEFAULT_MAXIMUM_ROLES_PER_ORGANIZATION;
+		const rolesInDB = await ctx.context.adapter.count({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		if (rolesInDB >= maximumRolesPerOrganization) {
+			ctx.context.logger.error(`[Dynamic Access Control] Failed to create a new role, the organization has too many roles. Maximum allowed roles is ${maximumRolesPerOrganization}.`, {
+				organizationId,
+				maximumRolesPerOrganization,
+				rolesInDB
+			});
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TOO_MANY_ROLES });
+		}
+		await checkForInvalidResources({
+			ac,
+			ctx,
+			permission
+		});
+		await checkIfMemberHasPermission({
+			ctx,
+			member,
+			options,
+			organizationId,
+			permissionRequired: permission,
+			user,
+			action: "create"
+		});
+		await checkIfRoleNameIsTakenByRoleInDB({
+			ctx,
+			organizationId,
+			role: roleName
+		});
+		const newRole = ac.newRole(permission);
+		const data = {
+			...await ctx.context.adapter.create({
+				model: "organizationRole",
+				data: {
+					createdAt: /* @__PURE__ */ new Date(),
+					organizationId,
+					permission: JSON.stringify(permission),
+					role: roleName,
+					...additionalFields
+				}
+			}),
+			permission
+		};
+		return ctx.json({
+			success: true,
+			roleData: data,
+			statements: newRole.statements
+		});
+	});
+};
+const deleteOrgRole = (options) => {
+	return createAuthEndpoint("/organization/delete-role", {
+		method: "POST",
+		body: z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to delete" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to delete" }) })])),
+		requireHeaders: true,
+		use: [orgSessionMiddleware],
+		metadata: { $Infer: { body: {} } }
+	}, async (ctx) => {
+		const { session, user } = ctx.context.session;
+		const organizationId = ctx.body.organizationId ?? session.activeOrganizationId;
+		if (!organizationId) {
+			ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to delete a role. Either set an active org id, or pass an organizationId in the request body.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+		}
+		const member = await ctx.context.adapter.findOne({
+			model: "member",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, {
+				field: "userId",
+				value: user.id,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		if (!member) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to delete a role.`, {
+				userId: user.id,
+				organizationId
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
+		}
+		if (!await hasPermission({
+			options,
+			organizationId,
+			permissions: { ac: ["delete"] },
+			role: member.role
+		}, ctx)) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to delete a role. If this is unexpected, please make sure the role associated to that member has the "ac" resource with the "delete" permission.`, {
+				userId: user.id,
+				organizationId,
+				role: member.role
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE });
+		}
+		if (ctx.body.roleName) {
+			const roleName = ctx.body.roleName;
+			const defaultRoles$2 = options.roles ? Object.keys(options.roles) : [
+				"owner",
+				"admin",
+				"member"
+			];
+			if (defaultRoles$2.includes(roleName)) {
+				ctx.context.logger.error(`[Dynamic Access Control] Cannot delete a pre-defined role.`, {
+					roleName,
+					organizationId,
+					defaultRoles: defaultRoles$2
+				});
+				throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.CANNOT_DELETE_A_PRE_DEFINED_ROLE });
+			}
+		}
+		let condition;
+		if (ctx.body.roleName) condition = {
+			field: "role",
+			value: ctx.body.roleName,
+			operator: "eq",
+			connector: "AND"
+		};
+		else if (ctx.body.roleId) condition = {
+			field: "id",
+			value: ctx.body.roleId,
+			operator: "eq",
+			connector: "AND"
+		};
+		else {
+			ctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request body.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
+		}
+		const existingRoleInDB = await ctx.context.adapter.findOne({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, condition]
+		});
+		if (!existingRoleInDB) {
+			ctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {
+				..."roleName" in ctx.body ? { roleName: ctx.body.roleName } : { roleId: ctx.body.roleId },
+				organizationId
+			});
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
+		}
+		existingRoleInDB.permission = JSON.parse(existingRoleInDB.permission);
+		await ctx.context.adapter.delete({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, condition]
+		});
+		return ctx.json({ success: true });
+	});
+};
+const listOrgRoles = (options) => {
+	const { $ReturnAdditionalFields } = getAdditionalFields(options, false);
+	return createAuthEndpoint("/organization/list-roles", {
+		method: "GET",
+		use: [orgSessionMiddleware],
+		query: z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to list roles for. If not provided, the user's active organization will be used." }) }).optional()
+	}, async (ctx) => {
+		const { session, user } = ctx.context.session;
+		const organizationId = ctx.query?.organizationId ?? session.activeOrganizationId;
+		if (!organizationId) {
+			ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to list roles. Either set an active org id, or pass an organizationId in the request query.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+		}
+		const member = await ctx.context.adapter.findOne({
+			model: "member",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, {
+				field: "userId",
+				value: user.id,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		if (!member) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to list roles.`, {
+				userId: user.id,
+				organizationId
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
+		}
+		if (!await hasPermission({
+			options,
+			organizationId,
+			permissions: { ac: ["read"] },
+			role: member.role
+		}, ctx)) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to list roles.`, {
+				userId: user.id,
+				organizationId,
+				role: member.role
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE });
+		}
+		let roles = await ctx.context.adapter.findMany({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		roles = roles.map((x) => ({
+			...x,
+			permission: JSON.parse(x.permission)
+		}));
+		return ctx.json(roles);
+	});
+};
+const getOrgRole = (options) => {
+	const { $ReturnAdditionalFields } = getAdditionalFields(options, false);
+	return createAuthEndpoint("/organization/get-role", {
+		method: "GET",
+		use: [orgSessionMiddleware],
+		query: z.object({ organizationId: z.string().optional().meta({ description: "The id of the organization to read a role for. If not provided, the user's active organization will be used." }) }).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to read" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to read" }) })])).optional(),
+		metadata: { $Infer: { query: {} } }
+	}, async (ctx) => {
+		const { session, user } = ctx.context.session;
+		const organizationId = ctx.query?.organizationId ?? session.activeOrganizationId;
+		if (!organizationId) {
+			ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to read a role. Either set an active org id, or pass an organizationId in the request query.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+		}
+		const member = await ctx.context.adapter.findOne({
+			model: "member",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, {
+				field: "userId",
+				value: user.id,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		if (!member) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to read a role.`, {
+				userId: user.id,
+				organizationId
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
+		}
+		if (!await hasPermission({
+			options,
+			organizationId,
+			permissions: { ac: ["read"] },
+			role: member.role
+		}, ctx)) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to read a role.`, {
+				userId: user.id,
+				organizationId,
+				role: member.role
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE });
+		}
+		let condition;
+		if (ctx.query.roleName) condition = {
+			field: "role",
+			value: ctx.query.roleName,
+			operator: "eq",
+			connector: "AND"
+		};
+		else if (ctx.query.roleId) condition = {
+			field: "id",
+			value: ctx.query.roleId,
+			operator: "eq",
+			connector: "AND"
+		};
+		else {
+			ctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request query.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
+		}
+		let role = await ctx.context.adapter.findOne({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, condition]
+		});
+		if (!role) {
+			ctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {
+				..."roleName" in ctx.query ? { roleName: ctx.query.roleName } : { roleId: ctx.query.roleId },
+				organizationId
+			});
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
+		}
+		role.permission = JSON.parse(role.permission);
+		return ctx.json(role);
+	});
+};
+const updateOrgRole = (options) => {
+	const { additionalFieldsSchema, $AdditionalFields, $ReturnAdditionalFields } = getAdditionalFields(options, true);
+	return createAuthEndpoint("/organization/update-role", {
+		method: "POST",
+		body: z.object({
+			organizationId: z.string().optional().meta({ description: "The id of the organization to update the role in. If not provided, the user's active organization will be used." }),
+			data: z.object({
+				permission: z.record(z.string(), z.array(z.string())).optional().meta({ description: "The permission to update the role with" }),
+				roleName: z.string().optional().meta({ description: "The name of the role to update" }),
+				...additionalFieldsSchema.shape
+			})
+		}).and(z.union([z.object({ roleName: z.string().nonempty().meta({ description: "The name of the role to update" }) }), z.object({ roleId: z.string().nonempty().meta({ description: "The id of the role to update" }) })])),
+		metadata: { $Infer: { body: {} } },
+		use: [orgSessionMiddleware]
+	}, async (ctx) => {
+		const { session, user } = ctx.context.session;
+		const ac = options.ac;
+		if (!ac) {
+			ctx.context.logger.error(`[Dynamic Access Control] The organization plugin is missing a pre-defined ac instance.`, `\nPlease refer to the documentation here: https://better-auth.com/docs/plugins/organization#dynamic-access-control`);
+			throw new APIError$1("NOT_IMPLEMENTED", { message: ORGANIZATION_ERROR_CODES.MISSING_AC_INSTANCE });
+		}
+		const organizationId = ctx.body.organizationId ?? session.activeOrganizationId;
+		if (!organizationId) {
+			ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to update a role. Either set an active org id, or pass an organizationId in the request body.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+		}
+		const member = await ctx.context.adapter.findOne({
+			model: "member",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, {
+				field: "userId",
+				value: user.id,
+				operator: "eq",
+				connector: "AND"
+			}]
+		});
+		if (!member) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to update a role.`, {
+				userId: user.id,
+				organizationId
+			});
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
+		}
+		if (!await hasPermission({
+			options,
+			organizationId,
+			role: member.role,
+			permissions: { ac: ["update"] }
+		}, ctx)) {
+			ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to update a role.`);
+			throw new APIError$1("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE });
+		}
+		let condition;
+		if (ctx.body.roleName) condition = {
+			field: "role",
+			value: ctx.body.roleName,
+			operator: "eq",
+			connector: "AND"
+		};
+		else if (ctx.body.roleId) condition = {
+			field: "id",
+			value: ctx.body.roleId,
+			operator: "eq",
+			connector: "AND"
+		};
+		else {
+			ctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request body.`);
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
+		}
+		let role = await ctx.context.adapter.findOne({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, condition]
+		});
+		if (!role) {
+			ctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {
+				..."roleName" in ctx.body ? { roleName: ctx.body.roleName } : { roleId: ctx.body.roleId },
+				organizationId
+			});
+			throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
+		}
+		role.permission = role.permission ? JSON.parse(role.permission) : void 0;
+		const { permission: _, roleName: __,...additionalFields } = ctx.body.data;
+		let updateData = { ...additionalFields };
+		if (ctx.body.data.permission) {
+			let newPermission = ctx.body.data.permission;
+			await checkForInvalidResources({
+				ac,
+				ctx,
+				permission: newPermission
+			});
+			await checkIfMemberHasPermission({
+				ctx,
+				member,
+				options,
+				organizationId,
+				permissionRequired: newPermission,
+				user,
+				action: "update"
+			});
+			updateData.permission = newPermission;
+		}
+		if (ctx.body.data.roleName) {
+			let newRoleName = ctx.body.data.roleName;
+			newRoleName = normalizeRoleName(newRoleName);
+			await checkIfRoleNameIsTakenByPreDefinedRole({
+				role: newRoleName,
+				organizationId,
+				options,
+				ctx
+			});
+			await checkIfRoleNameIsTakenByRoleInDB({
+				role: newRoleName,
+				organizationId,
+				ctx
+			});
+			updateData.role = newRoleName;
+		}
+		const update = {
+			...updateData,
+			...updateData.permission ? { permission: JSON.stringify(updateData.permission) } : {}
+		};
+		await ctx.context.adapter.update({
+			model: "organizationRole",
+			where: [{
+				field: "organizationId",
+				value: organizationId,
+				operator: "eq",
+				connector: "AND"
+			}, condition],
+			update
+		});
+		return ctx.json({
+			success: true,
+			roleData: {
+				...role,
+				...update,
+				permission: updateData.permission || role.permission || null
+			}
+		});
+	});
+};
+async function checkForInvalidResources({ ac, ctx, permission }) {
+	const validResources = Object.keys(ac.statements);
+	const providedResources = Object.keys(permission);
+	if (providedResources.some((r) => !validResources.includes(r))) {
+		ctx.context.logger.error(`[Dynamic Access Control] The provided permission includes an invalid resource.`, {
+			providedResources,
+			validResources
+		});
+		throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVALID_RESOURCE });
+	}
+}
+async function checkIfMemberHasPermission({ ctx, permissionRequired: permission, options, organizationId, member, user, action }) {
+	const hasNecessaryPermissions = [];
+	const permissionEntries = Object.entries(permission);
+	for await (const [resource, permissions] of permissionEntries) for await (const perm of permissions) hasNecessaryPermissions.push({
+		resource: { [resource]: [perm] },
+		hasPermission: await hasPermission({
+			options,
+			organizationId,
+			permissions: { [resource]: [perm] },
+			useMemoryCache: true,
+			role: member.role
+		}, ctx)
+	});
+	const missingPermissions = hasNecessaryPermissions.filter((x) => x.hasPermission === false).map((x) => {
+		const key = Object.keys(x.resource)[0];
+		return `${key}:${x.resource[key][0]}`;
+	});
+	if (missingPermissions.length > 0) {
+		ctx.context.logger.error(`[Dynamic Access Control] The user is missing permissions nessesary to ${action} a role with those set of permissions.\n`, {
+			userId: user.id,
+			organizationId,
+			role: member.role,
+			missingPermissions
+		});
+		let errorMessage;
+		if (action === "create") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE;
+		else if (action === "update") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE;
+		else if (action === "delete") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE;
+		else if (action === "read") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE;
+		else if (action === "list") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE;
+		else errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_A_ROLE;
+		throw new APIError$1("FORBIDDEN", {
+			message: errorMessage,
+			missingPermissions
+		});
+	}
+}
+async function checkIfRoleNameIsTakenByPreDefinedRole({ options, organizationId, role, ctx }) {
+	const defaultRoles$2 = options.roles ? Object.keys(options.roles) : [
+		"owner",
+		"admin",
+		"member"
+	];
+	if (defaultRoles$2.includes(role)) {
+		ctx.context.logger.error(`[Dynamic Access Control] The role name "${role}" is already taken by a pre-defined role.`, {
+			role,
+			organizationId,
+			defaultRoles: defaultRoles$2
+		});
+		throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NAME_IS_ALREADY_TAKEN });
+	}
+}
+async function checkIfRoleNameIsTakenByRoleInDB({ organizationId, role, ctx }) {
+	if (await ctx.context.adapter.findOne({
+		model: "organizationRole",
+		where: [{
+			field: "organizationId",
+			value: organizationId,
+			operator: "eq",
+			connector: "AND"
+		}, {
+			field: "role",
+			value: role,
+			operator: "eq",
+			connector: "AND"
+		}]
+	})) {
+		ctx.context.logger.error(`[Dynamic Access Control] The role name "${role}" is already taken by a role in the database.`, {
+			role,
+			organizationId
+		});
+		throw new APIError$1("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NAME_IS_ALREADY_TAKEN });
+	}
+}
+
+//#endregion
+//#region src/plugins/organization/schema.ts
+const roleSchema = z.string();
+const invitationStatus = z.enum([
+	"pending",
+	"accepted",
+	"rejected",
+	"canceled"
+]).default("pending");
+const organizationSchema = z.object({
+	id: z.string().default(generateId),
+	name: z.string(),
+	slug: z.string(),
+	logo: z.string().nullish().optional(),
+	metadata: z.record(z.string(), z.unknown()).or(z.string().transform((v) => JSON.parse(v))).optional(),
+	createdAt: z.date()
+});
+const memberSchema = z.object({
+	id: z.string().default(generateId),
+	organizationId: z.string(),
+	userId: z.coerce.string(),
+	role: roleSchema,
+	createdAt: z.date().default(() => /* @__PURE__ */ new Date())
+});
+const invitationSchema = z.object({
+	id: z.string().default(generateId),
+	organizationId: z.string(),
+	email: z.string(),
+	role: roleSchema,
+	status: invitationStatus,
+	teamId: z.string().nullish(),
+	inviterId: z.string(),
+	expiresAt: z.date(),
+	createdAt: z.date().default(() => /* @__PURE__ */ new Date())
+});
+const teamSchema = z.object({
+	id: z.string().default(generateId),
+	name: z.string().min(1),
+	organizationId: z.string(),
+	createdAt: z.date(),
+	updatedAt: z.date().optional()
+});
+const teamMemberSchema = z.object({
+	id: z.string().default(generateId),
+	teamId: z.string(),
+	userId: z.string(),
+	createdAt: z.date().default(() => /* @__PURE__ */ new Date())
+});
+const organizationRoleSchema = z.object({
+	id: z.string().default(generateId),
+	organizationId: z.string(),
+	role: z.string(),
+	permission: z.record(z.string(), z.array(z.string())),
+	createdAt: z.date().default(() => /* @__PURE__ */ new Date()),
+	updatedAt: z.date().optional()
+});
+const defaultRoles$1 = [
+	"admin",
+	"member",
+	"owner"
+];
+const defaultRolesSchema = z.union([z.enum(defaultRoles$1), z.array(z.enum(defaultRoles$1))]);
+
+//#endregion
+//#region src/plugins/organization/routes/crud-invites.ts
+const createInvitation = (option) => {
+	const additionalFieldsSchema = toZodSchema({
+		fields: option?.schema?.invitation?.additionalFields || {},
+		isClientSide: true
+	});
+	const baseSchema = z.object({
+		email: z.string().meta({ description: "The email address of the user to invite" }),
+		role: z.union([z.string().meta({ description: "The role to assign to the user" }), z.array(z.string().meta({ description: "The roles to assign to the user" }))]).meta({ description: "The role(s) to assign to the user. It can be `admin`, `member`, owner. Eg: \"member\"" }),
+		organizationId: z.string().meta({ description: "The organization ID to invite the user to" }).optional(),
+		resend: z.boolean().meta({ description: "Resend the invitation email, if the user is already invited. Eg: true" }).optional(),
+		teamId: z.union([z.string().meta({ description: "The team ID to invite the user to" }).optional(), z.array(z.string()).meta({ description: "The team IDs to invite the user to" }).optional()])
+	});
+	return createAuthEndpoint("/organization/invite-member", {
+		method: "POST",
+		use: [orgMiddleware, orgSessionMiddleware],
+		body: z.object({
+			...baseSchema.shape,
+			...additionalFieldsSchema.shape
+		}),
+		metadata: {
+			$Infer: { body: {} },
+			openapi: {
+				operationId: "createOrganizationInvitation",
+				description: "Create an invitation to an organization",
+				responses: { "200": {
+					description: "Success",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: {
+							id: { type: "string" },
+							email: { type: "string" },
+							role: { type: "string" },
+							organizationId: { type: "string" },
+							inviterId: { type: "string" },
+							status: { type: "string" },
+							expiresAt: { type: "string" },
+							createdAt: { type: "string" }
+						},
+						required: [
+							"id",
+							"email",
+							"role",
+							"organizationId",
+							"inviterId",
+							"status",
+							"expiresAt",
+							"createdAt"
+						]
+					} } }
+				} }
+			}
+		}
+	}, async (ctx) => {
+		const session = ctx.context.session;
+		const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
+		if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		const email = ctx.body.email.toLowerCase();
+		if (!z.string().email().safeParse(email).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
+		const adapter = getOrgAdapter(ctx.context, option);
+		const member = await adapter.findMemberByOrgId({
+			userId: session.user.id,
+			organizationId
+		});
+		if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+		if (!await hasPermission({
+			role: member.role,
+			options: ctx.context.orgOptions,
+			permissions: { invitation: ["create"] },
+			organizationId
+		}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION });
+		const creatorRole = ctx.context.orgOptions.creatorRole || "owner";
+		const roles = parseRoles(ctx.body.role);
+		if (member.role !== creatorRole && roles.split(",").includes(creatorRole)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USER_WITH_THIS_ROLE });
+		if (await adapter.findMemberByEmail({
+			email,
+			organizationId
+		})) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION });
+		const alreadyInvited = await adapter.findPendingInvitation({
+			email,
+			organizationId
+		});
+		if (alreadyInvited.length && !ctx.body.resend) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_INVITED_TO_THIS_ORGANIZATION });
+		const organization$1 = await adapter.findOrganizationById(organizationId);
+		if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		if (alreadyInvited.length && ctx.body.resend) {
+			const existingInvitation = alreadyInvited[0];
+			const newExpiresAt = getDate(ctx.context.orgOptions.invitationExpiresIn || 3600 * 48, "sec");
+			await ctx.context.adapter.update({
+				model: "invitation",
+				where: [{
+					field: "id",
+					value: existingInvitation.id
+				}],
+				update: { expiresAt: newExpiresAt }
+			});
+			const updatedInvitation = {
+				...existingInvitation,
+				expiresAt: newExpiresAt
+			};
+			await ctx.context.orgOptions.sendInvitationEmail?.({
+				id: updatedInvitation.id,
+				role: updatedInvitation.role,
+				email: updatedInvitation.email.toLowerCase(),
+				organization: organization$1,
+				inviter: {
+					...member,
+					user: session.user
+				},
+				invitation: updatedInvitation
+			}, ctx.request);
+			return ctx.json(updatedInvitation);
+		}
+		if (alreadyInvited.length && ctx.context.orgOptions.cancelPendingInvitationsOnReInvite) await adapter.updateInvitation({
+			invitationId: alreadyInvited[0].id,
+			status: "canceled"
+		});
+		const invitationLimit = typeof ctx.context.orgOptions.invitationLimit === "function" ? await ctx.context.orgOptions.invitationLimit({
+			user: session.user,
+			organization: organization$1,
+			member
+		}, ctx.context) : ctx.context.orgOptions.invitationLimit ?? 100;
+		if ((await adapter.findPendingInvitations({ organizationId })).length >= invitationLimit) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.INVITATION_LIMIT_REACHED });
+		if (ctx.context.orgOptions.teams && ctx.context.orgOptions.teams.enabled && typeof ctx.context.orgOptions.teams.maximumMembersPerTeam !== "undefined" && "teamId" in ctx.body && ctx.body.teamId) {
+			const teamIds$1 = typeof ctx.body.teamId === "string" ? [ctx.body.teamId] : ctx.body.teamId;
+			for (const teamId of teamIds$1) {
+				const team = await adapter.findTeamById({
+					teamId,
+					organizationId,
+					includeTeamMembers: true
+				});
+				if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
+				const maximumMembersPerTeam = typeof ctx.context.orgOptions.teams.maximumMembersPerTeam === "function" ? await ctx.context.orgOptions.teams.maximumMembersPerTeam({
+					teamId,
+					session,
+					organizationId
+				}) : ctx.context.orgOptions.teams.maximumMembersPerTeam;
+				if (team.members.length >= maximumMembersPerTeam) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.TEAM_MEMBER_LIMIT_REACHED });
+			}
+		}
+		const teamIds = "teamId" in ctx.body ? typeof ctx.body.teamId === "string" ? [ctx.body.teamId] : ctx.body.teamId ?? [] : [];
+		const { email: _, role: __, organizationId: ___, resend: ____,...additionalFields } = ctx.body;
+		let invitationData = {
+			role: roles,
+			email,
+			organizationId,
+			teamIds,
+			...additionalFields ? additionalFields : {}
+		};
+		if (option?.organizationHooks?.beforeCreateInvitation) {
+			const response = await option?.organizationHooks.beforeCreateInvitation({
+				invitation: {
+					...invitationData,
+					inviterId: session.user.id,
+					teamId: teamIds.length > 0 ? teamIds[0] : void 0
+				},
+				inviter: session.user,
+				organization: organization$1
+			});
+			if (response && typeof response === "object" && "data" in response) invitationData = {
+				...invitationData,
+				...response.data
+			};
+		}
+		const invitation = await adapter.createInvitation({
+			invitation: invitationData,
+			user: session.user
+		});
+		await ctx.context.orgOptions.sendInvitationEmail?.({
+			id: invitation.id,
+			role: invitation.role,
+			email: invitation.email.toLowerCase(),
+			organization: organization$1,
+			inviter: {
+				...member,
+				user: session.user
+			},
+			invitation
+		}, ctx.request);
+		if (option?.organizationHooks?.afterCreateInvitation) await option?.organizationHooks.afterCreateInvitation({
+			invitation,
+			inviter: session.user,
+			organization: organization$1
+		});
+		return ctx.json(invitation);
+	});
+};
+const acceptInvitation = (options) => createAuthEndpoint("/organization/accept-invitation", {
+	method: "POST",
+	body: z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to accept" }) }),
+	use: [orgMiddleware, orgSessionMiddleware],
+	metadata: { openapi: {
+		description: "Accept an invitation to an organization",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					invitation: { type: "object" },
+					member: { type: "object" }
+				}
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const adapter = getOrgAdapter(ctx.context, options);
+	const invitation = await adapter.findInvitationById(ctx.body.invitationId);
+	if (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== "pending") throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND });
+	if (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });
+	if (ctx.context.orgOptions.requireEmailVerificationOnInvitation && !session.user.emailVerified) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION });
+	const membershipLimit = ctx.context.orgOptions?.membershipLimit || 100;
+	if (await adapter.countMembers({ organizationId: invitation.organizationId }) >= membershipLimit) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_MEMBERSHIP_LIMIT_REACHED });
+	const organization$1 = await adapter.findOrganizationById(invitation.organizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	if (options?.organizationHooks?.beforeAcceptInvitation) await options?.organizationHooks.beforeAcceptInvitation({
+		invitation,
+		user: session.user,
+		organization: organization$1
+	});
+	const acceptedI = await adapter.updateInvitation({
+		invitationId: ctx.body.invitationId,
+		status: "accepted"
+	});
+	if (!acceptedI) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.FAILED_TO_RETRIEVE_INVITATION });
+	if (ctx.context.orgOptions.teams && ctx.context.orgOptions.teams.enabled && "teamId" in acceptedI && acceptedI.teamId) {
+		const teamIds = acceptedI.teamId.split(",");
+		const onlyOne = teamIds.length === 1;
+		for (const teamId of teamIds) {
+			await adapter.findOrCreateTeamMember({
+				teamId,
+				userId: session.user.id
+			});
+			if (typeof ctx.context.orgOptions.teams.maximumMembersPerTeam !== "undefined") {
+				if (await adapter.countTeamMembers({ teamId }) >= (typeof ctx.context.orgOptions.teams.maximumMembersPerTeam === "function" ? await ctx.context.orgOptions.teams.maximumMembersPerTeam({
+					teamId,
+					session,
+					organizationId: invitation.organizationId
+				}) : ctx.context.orgOptions.teams.maximumMembersPerTeam)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.TEAM_MEMBER_LIMIT_REACHED });
+			}
+		}
+		if (onlyOne) {
+			const teamId = teamIds[0];
+			await setSessionCookie(ctx, {
+				session: await adapter.setActiveTeam(session.session.token, teamId, ctx),
+				user: session.user
+			});
+		}
+	}
+	const member = await adapter.createMember({
+		organizationId: invitation.organizationId,
+		userId: session.user.id,
+		role: invitation.role,
+		createdAt: /* @__PURE__ */ new Date()
+	});
+	await adapter.setActiveOrganization(session.session.token, invitation.organizationId, ctx);
+	if (!acceptedI) return ctx.json(null, {
+		status: 400,
+		body: { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND }
+	});
+	if (options?.organizationHooks?.afterAcceptInvitation) await options?.organizationHooks.afterAcceptInvitation({
+		invitation: acceptedI,
+		member,
+		user: session.user,
+		organization: organization$1
+	});
+	return ctx.json({
+		invitation: acceptedI,
+		member
+	});
+});
+const rejectInvitation = (options) => createAuthEndpoint("/organization/reject-invitation", {
+	method: "POST",
+	body: z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to reject" }) }),
+	use: [orgMiddleware, orgSessionMiddleware],
+	metadata: { openapi: {
+		description: "Reject an invitation to an organization",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					invitation: { type: "object" },
+					member: { type: "null" }
+				}
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
+	const invitation = await adapter.findInvitationById(ctx.body.invitationId);
+	if (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== "pending") throw new APIError("BAD_REQUEST", { message: "Invitation not found!" });
+	if (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });
+	if (ctx.context.orgOptions.requireEmailVerificationOnInvitation && !session.user.emailVerified) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION });
+	const organization$1 = await adapter.findOrganizationById(invitation.organizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	if (options?.organizationHooks?.beforeRejectInvitation) await options?.organizationHooks.beforeRejectInvitation({
+		invitation,
+		user: session.user,
+		organization: organization$1
+	});
+	const rejectedI = await adapter.updateInvitation({
+		invitationId: ctx.body.invitationId,
+		status: "rejected"
+	});
+	if (options?.organizationHooks?.afterRejectInvitation) await options?.organizationHooks.afterRejectInvitation({
+		invitation: rejectedI || invitation,
+		user: session.user,
+		organization: organization$1
+	});
+	return ctx.json({
+		invitation: rejectedI,
+		member: null
+	});
+});
+const cancelInvitation = (options) => createAuthEndpoint("/organization/cancel-invitation", {
+	method: "POST",
+	body: z.object({ invitationId: z.string().meta({ description: "The ID of the invitation to cancel" }) }),
+	use: [orgMiddleware, orgSessionMiddleware],
+	openapi: {
+		operationId: "cancelOrganizationInvitation",
+		description: "Cancel an invitation to an organization",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { invitation: { type: "object" } }
+			} } }
+		} }
+	}
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const adapter = getOrgAdapter(ctx.context, options);
+	const invitation = await adapter.findInvitationById(ctx.body.invitationId);
+	if (!invitation) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND });
+	const member = await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId: invitation.organizationId
+	});
+	if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	if (!await hasPermission({
+		role: member.role,
+		options: ctx.context.orgOptions,
+		permissions: { invitation: ["cancel"] },
+		organizationId: invitation.organizationId
+	}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CANCEL_THIS_INVITATION });
+	const organization$1 = await adapter.findOrganizationById(invitation.organizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	if (options?.organizationHooks?.beforeCancelInvitation) await options?.organizationHooks.beforeCancelInvitation({
+		invitation,
+		cancelledBy: session.user,
+		organization: organization$1
+	});
+	const canceledI = await adapter.updateInvitation({
+		invitationId: ctx.body.invitationId,
+		status: "canceled"
+	});
+	if (options?.organizationHooks?.afterCancelInvitation) await options?.organizationHooks.afterCancelInvitation({
+		invitation: canceledI || invitation,
+		cancelledBy: session.user,
+		organization: organization$1
+	});
+	return ctx.json(canceledI);
+});
+const getInvitation = (options) => createAuthEndpoint("/organization/get-invitation", {
+	method: "GET",
+	use: [orgMiddleware],
+	requireHeaders: true,
+	query: z.object({ id: z.string().meta({ description: "The ID of the invitation to get" }) }),
+	metadata: { openapi: {
+		description: "Get an invitation by ID",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					id: { type: "string" },
+					email: { type: "string" },
+					role: { type: "string" },
+					organizationId: { type: "string" },
+					inviterId: { type: "string" },
+					status: { type: "string" },
+					expiresAt: { type: "string" },
+					organizationName: { type: "string" },
+					organizationSlug: { type: "string" },
+					inviterEmail: { type: "string" }
+				},
+				required: [
+					"id",
+					"email",
+					"role",
+					"organizationId",
+					"inviterId",
+					"status",
+					"expiresAt",
+					"organizationName",
+					"organizationSlug",
+					"inviterEmail"
+				]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = await getSessionFromCtx(ctx);
+	if (!session) throw new APIError("UNAUTHORIZED", { message: "Not authenticated" });
+	const adapter = getOrgAdapter(ctx.context, options);
+	const invitation = await adapter.findInvitationById(ctx.query.id);
+	if (!invitation || invitation.status !== "pending" || invitation.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: "Invitation not found!" });
+	if (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });
+	const organization$1 = await adapter.findOrganizationById(invitation.organizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	const member = await adapter.findMemberByOrgId({
+		userId: invitation.inviterId,
+		organizationId: invitation.organizationId
+	});
+	if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVITER_IS_NO_LONGER_A_MEMBER_OF_THE_ORGANIZATION });
+	return ctx.json({
+		...invitation,
+		organizationName: organization$1.name,
+		organizationSlug: organization$1.slug,
+		inviterEmail: member.user.email
+	});
+});
+const listInvitations = (options) => createAuthEndpoint("/organization/list-invitations", {
+	method: "GET",
+	use: [orgMiddleware, orgSessionMiddleware],
+	query: z.object({ organizationId: z.string().meta({ description: "The ID of the organization to list invitations for" }).optional() }).optional()
+}, async (ctx) => {
+	const session = await getSessionFromCtx(ctx);
+	if (!session) throw new APIError("UNAUTHORIZED", { message: "Not authenticated" });
+	const orgId = ctx.query?.organizationId || session.session.activeOrganizationId;
+	if (!orgId) throw new APIError("BAD_REQUEST", { message: "Organization ID is required" });
+	const adapter = getOrgAdapter(ctx.context, options);
+	if (!await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId: orgId
+	})) throw new APIError("FORBIDDEN", { message: "You are not a member of this organization" });
+	const invitations = await adapter.listInvitations({ organizationId: orgId });
+	return ctx.json(invitations);
+});
+/**
+* List all invitations a user has received
+*/
+const listUserInvitations = (options) => createAuthEndpoint("/organization/list-user-invitations", {
+	method: "GET",
+	use: [orgMiddleware],
+	query: z.object({ email: z.string().meta({ description: "The email of the user to list invitations for. This only works for server side API calls." }).optional() }).optional()
+}, async (ctx) => {
+	const session = await getSessionFromCtx(ctx);
+	if (ctx.request && ctx.query?.email) throw new APIError("BAD_REQUEST", { message: "User email cannot be passed for client side API calls." });
+	const userEmail = session?.user.email || ctx.query?.email;
+	if (!userEmail) throw new APIError("BAD_REQUEST", { message: "Missing session headers, or email query parameter." });
+	const invitations = await getOrgAdapter(ctx.context, options).listUserInvitations(userEmail);
+	return ctx.json(invitations);
+});
+
+//#endregion
+//#region src/plugins/organization/routes/crud-members.ts
+const addMember = (option) => {
+	const additionalFieldsSchema = toZodSchema({
+		fields: option?.schema?.member?.additionalFields || {},
+		isClientSide: true
+	});
+	const baseSchema = z.object({
+		userId: z.coerce.string().meta({ description: "The user Id which represents the user to be added as a member. If `null` is provided, then it's expected to provide session headers. Eg: \"user-id\"" }),
+		role: z.union([z.string(), z.array(z.string())]).meta({ description: "The role(s) to assign to the new member. Eg: [\"admin\", \"sale\"]" }),
+		organizationId: z.string().meta({ description: "An optional organization ID to pass. If not provided, will default to the user's active organization. Eg: \"org-id\"" }).optional(),
+		teamId: z.string().meta({ description: "An optional team ID to add the member to. Eg: \"team-id\"" }).optional()
+	});
+	return createAuthEndpoint("/organization/add-member", {
+		method: "POST",
+		body: z.object({
+			...baseSchema.shape,
+			...additionalFieldsSchema.shape
+		}),
+		use: [orgMiddleware],
+		metadata: {
+			SERVER_ONLY: true,
+			$Infer: { body: {} },
+			openapi: {
+				operationId: "addOrganizationMember",
+				description: "Add a member to an organization"
+			}
+		}
+	}, async (ctx) => {
+		const session = ctx.body.userId ? await getSessionFromCtx(ctx).catch((e) => null) : null;
+		const orgId = ctx.body.organizationId || session?.session.activeOrganizationId;
+		if (!orgId) return ctx.json(null, {
+			status: 400,
+			body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
+		});
+		const teamId = "teamId" in ctx.body ? ctx.body.teamId : void 0;
+		if (teamId && !ctx.context.orgOptions.teams?.enabled) {
+			ctx.context.logger.error("Teams are not enabled");
+			throw new APIError("BAD_REQUEST", { message: "Teams are not enabled" });
+		}
+		const adapter = getOrgAdapter(ctx.context, option);
+		const user = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+		if (!user) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+		if (await adapter.findMemberByEmail({
+			email: user.email,
+			organizationId: orgId
+		})) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION });
+		if (teamId) {
+			const team = await adapter.findTeamById({
+				teamId,
+				organizationId: orgId
+			});
+			if (!team || team.organizationId !== orgId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
+		}
+		const membershipLimit = ctx.context.orgOptions?.membershipLimit || 100;
+		if (await adapter.countMembers({ organizationId: orgId }) >= membershipLimit) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_MEMBERSHIP_LIMIT_REACHED });
+		const { role: _, userId: __, organizationId: ___,...additionalFields } = ctx.body;
+		const organization$1 = await adapter.findOrganizationById(orgId);
+		if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		let memberData = {
+			organizationId: orgId,
+			userId: user.id,
+			role: parseRoles(ctx.body.role),
+			createdAt: /* @__PURE__ */ new Date(),
+			...additionalFields ? additionalFields : {}
+		};
+		if (option?.organizationHooks?.beforeAddMember) {
+			const response = await option?.organizationHooks.beforeAddMember({
+				member: {
+					userId: user.id,
+					organizationId: orgId,
+					role: parseRoles(ctx.body.role),
+					...additionalFields
+				},
+				user,
+				organization: organization$1
+			});
+			if (response && typeof response === "object" && "data" in response) memberData = {
+				...memberData,
+				...response.data
+			};
+		}
+		const createdMember = await adapter.createMember(memberData);
+		if (teamId) await adapter.findOrCreateTeamMember({
+			userId: user.id,
+			teamId
+		});
+		if (option?.organizationHooks?.afterAddMember) await option?.organizationHooks.afterAddMember({
+			member: createdMember,
+			user,
+			organization: organization$1
+		});
+		return ctx.json(createdMember);
+	});
+};
+const removeMember = (options) => createAuthEndpoint("/organization/remove-member", {
+	method: "POST",
+	body: z.object({
+		memberIdOrEmail: z.string().meta({ description: "The ID or email of the member to remove" }),
+		organizationId: z.string().meta({ description: "The ID of the organization to remove the member from. If not provided, the active organization will be used. Eg: \"org-id\"" }).optional()
+	}),
+	use: [orgMiddleware, orgSessionMiddleware],
+	metadata: { openapi: {
+		description: "Remove a member from an organization",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { member: {
+					type: "object",
+					properties: {
+						id: { type: "string" },
+						userId: { type: "string" },
+						organizationId: { type: "string" },
+						role: { type: "string" }
+					},
+					required: [
+						"id",
+						"userId",
+						"organizationId",
+						"role"
+					]
+				} },
+				required: ["member"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
+	if (!organizationId) return ctx.json(null, {
+		status: 400,
+		body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
+	});
+	const adapter = getOrgAdapter(ctx.context, options);
+	const member = await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId
+	});
+	if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	let toBeRemovedMember = null;
+	if (ctx.body.memberIdOrEmail.includes("@")) toBeRemovedMember = await adapter.findMemberByEmail({
+		email: ctx.body.memberIdOrEmail,
+		organizationId
+	});
+	else toBeRemovedMember = await adapter.findMemberById(ctx.body.memberIdOrEmail);
+	if (!toBeRemovedMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	const roles = toBeRemovedMember.role.split(",");
+	const creatorRole = ctx.context.orgOptions?.creatorRole || "owner";
+	if (roles.includes(creatorRole)) {
+		if (member.role !== creatorRole) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });
+		const { members } = await adapter.listMembers({ organizationId });
+		if (members.filter((member$1) => {
+			return member$1.role.split(",").includes(creatorRole);
+		}).length <= 1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });
+	}
+	if (!await hasPermission({
+		role: member.role,
+		options: ctx.context.orgOptions,
+		permissions: { member: ["delete"] },
+		organizationId
+	}, ctx)) throw new APIError("UNAUTHORIZED", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_MEMBER });
+	if (toBeRemovedMember?.organizationId !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	const organization$1 = await adapter.findOrganizationById(organizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	const userBeingRemoved = await ctx.context.internalAdapter.findUserById(toBeRemovedMember.userId);
+	if (!userBeingRemoved) throw new APIError("BAD_REQUEST", { message: "User not found" });
+	if (options?.organizationHooks?.beforeRemoveMember) await options?.organizationHooks.beforeRemoveMember({
+		member: toBeRemovedMember,
+		user: userBeingRemoved,
+		organization: organization$1
+	});
+	await adapter.deleteMember({
+		memberId: toBeRemovedMember.id,
+		organizationId,
+		userId: toBeRemovedMember.userId
+	});
+	if (session.user.id === toBeRemovedMember.userId && session.session.activeOrganizationId === toBeRemovedMember.organizationId) await adapter.setActiveOrganization(session.session.token, null, ctx);
+	if (options?.organizationHooks?.afterRemoveMember) await options?.organizationHooks.afterRemoveMember({
+		member: toBeRemovedMember,
+		user: userBeingRemoved,
+		organization: organization$1
+	});
+	return ctx.json({ member: toBeRemovedMember });
+});
+const updateMemberRole = (option) => createAuthEndpoint("/organization/update-member-role", {
+	method: "POST",
+	body: z.object({
+		role: z.union([z.string(), z.array(z.string())]).meta({ description: "The new role to be applied. This can be a string or array of strings representing the roles. Eg: [\"admin\", \"sale\"]" }),
+		memberId: z.string().meta({ description: "The member id to apply the role update to. Eg: \"member-id\"" }),
+		organizationId: z.string().meta({ description: "An optional organization ID which the member is a part of to apply the role update. If not provided, you must provide session headers to get the active organization. Eg: \"organization-id\"" }).optional()
+	}),
+	use: [orgMiddleware, orgSessionMiddleware],
+	metadata: {
+		$Infer: { body: {} },
+		openapi: {
+			operationId: "updateOrganizationMemberRole",
+			description: "Update the role of a member in an organization",
+			responses: { "200": {
+				description: "Success",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { member: {
+						type: "object",
+						properties: {
+							id: { type: "string" },
+							userId: { type: "string" },
+							organizationId: { type: "string" },
+							role: { type: "string" }
+						},
+						required: [
+							"id",
+							"userId",
+							"organizationId",
+							"role"
+						]
+					} },
+					required: ["member"]
+				} } }
+			} }
+		}
+	}
+}, async (ctx) => {
+	const session = ctx.context.session;
+	if (!ctx.body.role) throw new APIError("BAD_REQUEST");
+	const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
+	if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+	const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
+	const roleToSet = Array.isArray(ctx.body.role) ? ctx.body.role : ctx.body.role ? [ctx.body.role] : [];
+	const member = await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId
+	});
+	if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	const toBeUpdatedMember = member.id !== ctx.body.memberId ? await adapter.findMemberById(ctx.body.memberId) : member;
+	if (!toBeUpdatedMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	if (!(toBeUpdatedMember.organizationId === organizationId)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });
+	const creatorRole = ctx.context.orgOptions?.creatorRole || "owner";
+	const updatingMemberRoles = member.role.split(",");
+	const isUpdatingCreator = toBeUpdatedMember.role.split(",").includes(creatorRole);
+	const updaterIsCreator = updatingMemberRoles.includes(creatorRole);
+	const isSettingCreatorRole = roleToSet.includes(creatorRole);
+	const memberIsUpdatingThemselves = member.id === toBeUpdatedMember.id;
+	if (isUpdatingCreator && !updaterIsCreator || isSettingCreatorRole && !updaterIsCreator) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });
+	if (updaterIsCreator && memberIsUpdatingThemselves) {
+		if ((await ctx.context.adapter.findMany({
+			model: "member",
+			where: [{
+				field: "organizationId",
+				value: organizationId
+			}]
+		})).filter((member$1) => {
+			return member$1.role.split(",").includes(creatorRole);
+		}).length <= 1 && !isSettingCreatorRole) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_WITHOUT_AN_OWNER });
+	}
+	if (!await hasPermission({
+		role: member.role,
+		options: ctx.context.orgOptions,
+		permissions: { member: ["update"] },
+		allowCreatorAllPermissions: true,
+		organizationId
+	}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });
+	const organization$1 = await adapter.findOrganizationById(organizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	const userBeingUpdated = await ctx.context.internalAdapter.findUserById(toBeUpdatedMember.userId);
+	if (!userBeingUpdated) throw new APIError("BAD_REQUEST", { message: "User not found" });
+	const previousRole = toBeUpdatedMember.role;
+	const newRole = parseRoles(ctx.body.role);
+	if (option?.organizationHooks?.beforeUpdateMemberRole) {
+		const response = await option?.organizationHooks.beforeUpdateMemberRole({
+			member: toBeUpdatedMember,
+			newRole,
+			user: userBeingUpdated,
+			organization: organization$1
+		});
+		if (response && typeof response === "object" && "data" in response) {
+			const updatedMember$1 = await adapter.updateMember(ctx.body.memberId, response.data.role || newRole);
+			if (!updatedMember$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+			if (option?.organizationHooks?.afterUpdateMemberRole) await option?.organizationHooks.afterUpdateMemberRole({
+				member: updatedMember$1,
+				previousRole,
+				user: userBeingUpdated,
+				organization: organization$1
+			});
+			return ctx.json(updatedMember$1);
+		}
+	}
+	const updatedMember = await adapter.updateMember(ctx.body.memberId, newRole);
+	if (!updatedMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	if (option?.organizationHooks?.afterUpdateMemberRole) await option?.organizationHooks.afterUpdateMemberRole({
+		member: updatedMember,
+		previousRole,
+		user: userBeingUpdated,
+		organization: organization$1
+	});
+	return ctx.json(updatedMember);
+});
+const getActiveMember = (options) => createAuthEndpoint("/organization/get-active-member", {
+	method: "GET",
+	use: [orgMiddleware, orgSessionMiddleware],
+	requireHeaders: true,
+	metadata: { openapi: {
+		description: "Get the member details of the active organization",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					id: { type: "string" },
+					userId: { type: "string" },
+					organizationId: { type: "string" },
+					role: { type: "string" }
+				},
+				required: [
+					"id",
+					"userId",
+					"organizationId",
+					"role"
+				]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const organizationId = session.session.activeOrganizationId;
+	if (!organizationId) return ctx.json(null, {
+		status: 400,
+		body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
+	});
+	const member = await getOrgAdapter(ctx.context, options).findMemberByOrgId({
+		userId: session.user.id,
+		organizationId
+	});
+	if (!member) return ctx.json(null, {
+		status: 400,
+		body: { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND }
+	});
+	return ctx.json(member);
+});
+const leaveOrganization = (options) => createAuthEndpoint("/organization/leave", {
+	method: "POST",
+	body: z.object({ organizationId: z.string().meta({ description: "The organization Id for the member to leave. Eg: \"organization-id\"" }) }),
+	requireHeaders: true,
+	use: [sessionMiddleware, orgMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const adapter = getOrgAdapter(ctx.context, options);
+	const member = await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId: ctx.body.organizationId
+	});
+	if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
+	const creatorRole = ctx.context.orgOptions?.creatorRole || "owner";
+	if (member.role.split(",").includes(creatorRole)) {
+		if ((await ctx.context.adapter.findMany({
+			model: "member",
+			where: [{
+				field: "organizationId",
+				value: ctx.body.organizationId
+			}]
+		})).filter((member$1) => member$1.role.split(",").includes(creatorRole)).length <= 1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });
+	}
+	await adapter.deleteMember({
+		memberId: member.id,
+		organizationId: ctx.body.organizationId,
+		userId: session.user.id
+	});
+	if (session.session.activeOrganizationId === ctx.body.organizationId) await adapter.setActiveOrganization(session.session.token, null, ctx);
+	return ctx.json(member);
+});
+const listMembers = (options) => createAuthEndpoint("/organization/list-members", {
+	method: "GET",
+	query: z.object({
+		limit: z.string().meta({ description: "The number of users to return" }).or(z.number()).optional(),
+		offset: z.string().meta({ description: "The offset to start from" }).or(z.number()).optional(),
+		sortBy: z.string().meta({ description: "The field to sort by" }).optional(),
+		sortDirection: z.enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
+		filterField: z.string().meta({ description: "The field to filter by" }).optional(),
+		filterValue: z.string().meta({ description: "The value to filter by" }).or(z.number()).or(z.boolean()).optional(),
+		filterOperator: z.enum([
+			"eq",
+			"ne",
+			"lt",
+			"lte",
+			"gt",
+			"gte",
+			"contains"
+		]).meta({ description: "The operator to use for the filter" }).optional(),
+		organizationId: z.string().meta({ description: "The organization ID to list members for. If not provided, will default to the user's active organization. Eg: \"organization-id\"" }).optional()
+	}).optional(),
+	use: [orgMiddleware, orgSessionMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const organizationId = ctx.query?.organizationId || session.session.activeOrganizationId;
+	if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+	const adapter = getOrgAdapter(ctx.context, options);
+	if (!await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId
+	})) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
+	const { members, total } = await adapter.listMembers({
+		organizationId,
+		limit: ctx.query?.limit ? Number(ctx.query.limit) : void 0,
+		offset: ctx.query?.offset ? Number(ctx.query.offset) : void 0,
+		sortBy: ctx.query?.sortBy,
+		sortOrder: ctx.query?.sortDirection,
+		filter: ctx.query?.filterField ? {
+			field: ctx.query?.filterField,
+			operator: ctx.query.filterOperator,
+			value: ctx.query.filterValue
+		} : void 0
+	});
+	return ctx.json({
+		members,
+		total
+	});
+});
+const getActiveMemberRole = (options) => createAuthEndpoint("/organization/get-active-member-role", {
+	method: "GET",
+	query: z.object({
+		userId: z.string().meta({ description: "The user ID to get the role for. If not provided, will default to the current user's" }).optional(),
+		organizationId: z.string().meta({ description: "The organization ID to list members for. If not provided, will default to the user's active organization. Eg: \"organization-id\"" }).optional()
+	}).optional(),
+	use: [orgMiddleware, orgSessionMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const organizationId = ctx.query?.organizationId || session.session.activeOrganizationId;
+	if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+	const userId = ctx.query?.userId || session.user.id;
+	const member = await getOrgAdapter(ctx.context, options).findMemberByOrgId({
+		userId,
+		organizationId
+	});
+	if (!member) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
+	return ctx.json({ role: member?.role });
+});
+
+//#endregion
+//#region src/plugins/organization/routes/crud-org.ts
+const createOrganization = (options) => {
+	const additionalFieldsSchema = toZodSchema({
+		fields: options?.schema?.organization?.additionalFields || {},
+		isClientSide: true
+	});
+	const baseSchema = z.object({
+		name: z.string().min(1).meta({ description: "The name of the organization" }),
+		slug: z.string().min(1).meta({ description: "The slug of the organization" }),
+		userId: z.coerce.string().meta({ description: "The user id of the organization creator. If not provided, the current user will be used. Should only be used by admins or when called by the server. server-only. Eg: \"user-id\"" }).optional(),
+		logo: z.string().meta({ description: "The logo of the organization" }).optional(),
+		metadata: z.record(z.string(), z.any()).meta({ description: "The metadata of the organization" }).optional(),
+		keepCurrentActiveOrganization: z.boolean().meta({ description: "Whether to keep the current active organization active after creating a new one. Eg: true" }).optional()
+	});
+	return createAuthEndpoint("/organization/create", {
+		method: "POST",
+		body: z.object({
+			...baseSchema.shape,
+			...additionalFieldsSchema.shape
+		}),
+		use: [orgMiddleware],
+		metadata: {
+			$Infer: { body: {} },
+			openapi: {
+				description: "Create an organization",
+				responses: { "200": {
+					description: "Success",
+					content: { "application/json": { schema: {
+						type: "object",
+						description: "The organization that was created",
+						$ref: "#/components/schemas/Organization"
+					} } }
+				} }
+			}
+		}
+	}, async (ctx) => {
+		const session = await getSessionFromCtx(ctx);
+		if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
+		let user = session?.user || null;
+		if (!user) {
+			if (!ctx.body.userId) throw new APIError("UNAUTHORIZED");
+			user = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+		}
+		if (!user) return ctx.json(null, { status: 401 });
+		const options$1 = ctx.context.orgOptions;
+		if (!(typeof options$1?.allowUserToCreateOrganization === "function" ? await options$1.allowUserToCreateOrganization(user) : options$1?.allowUserToCreateOrganization === void 0 ? true : options$1.allowUserToCreateOrganization)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_ORGANIZATION });
+		const adapter = getOrgAdapter(ctx.context, options$1);
+		const userOrganizations = await adapter.listOrganizations(user.id);
+		if (typeof options$1.organizationLimit === "number" ? userOrganizations.length >= options$1.organizationLimit : typeof options$1.organizationLimit === "function" ? await options$1.organizationLimit(user) : false) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_ORGANIZATIONS });
+		if (await adapter.findOrganizationBySlug(ctx.body.slug)) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_ALREADY_EXISTS });
+		let { keepCurrentActiveOrganization: _, userId: __,...orgData } = ctx.body;
+		if (options$1.organizationCreation?.beforeCreate) {
+			const response = await options$1.organizationCreation.beforeCreate({
+				organization: {
+					...orgData,
+					createdAt: /* @__PURE__ */ new Date()
+				},
+				user
+			}, ctx.request);
+			if (response && typeof response === "object" && "data" in response) orgData = {
+				...ctx.body,
+				...response.data
+			};
+		}
+		if (options$1?.organizationHooks?.beforeCreateOrganization) {
+			const response = await options$1?.organizationHooks.beforeCreateOrganization({
+				organization: orgData,
+				user
+			});
+			if (response && typeof response === "object" && "data" in response) orgData = {
+				...ctx.body,
+				...response.data
+			};
+		}
+		const organization$1 = await adapter.createOrganization({ organization: {
+			...orgData,
+			createdAt: /* @__PURE__ */ new Date()
+		} });
+		let member;
+		let teamMember = null;
+		let data = {
+			userId: user.id,
+			organizationId: organization$1.id,
+			role: ctx.context.orgOptions.creatorRole || "owner"
+		};
+		if (options$1?.organizationHooks?.beforeAddMember) {
+			const response = await options$1?.organizationHooks.beforeAddMember({
+				member: {
+					userId: user.id,
+					organizationId: organization$1.id,
+					role: ctx.context.orgOptions.creatorRole || "owner"
+				},
+				user,
+				organization: organization$1
+			});
+			if (response && typeof response === "object" && "data" in response) data = {
+				...data,
+				...response.data
+			};
+		}
+		member = await adapter.createMember(data);
+		if (options$1?.organizationHooks?.afterAddMember) await options$1?.organizationHooks.afterAddMember({
+			member,
+			user,
+			organization: organization$1
+		});
+		if (options$1?.teams?.enabled && options$1.teams.defaultTeam?.enabled !== false) {
+			let teamData = {
+				organizationId: organization$1.id,
+				name: `${organization$1.name}`,
+				createdAt: /* @__PURE__ */ new Date()
+			};
+			if (options$1?.organizationHooks?.beforeCreateTeam) {
+				const response = await options$1?.organizationHooks.beforeCreateTeam({
+					team: {
+						organizationId: organization$1.id,
+						name: `${organization$1.name}`
+					},
+					user,
+					organization: organization$1
+				});
+				if (response && typeof response === "object" && "data" in response) teamData = {
+					...teamData,
+					...response.data
+				};
+			}
+			const defaultTeam = await options$1.teams.defaultTeam?.customCreateDefaultTeam?.(organization$1, ctx) || await adapter.createTeam(teamData);
+			teamMember = await adapter.findOrCreateTeamMember({
+				teamId: defaultTeam.id,
+				userId: user.id
+			});
+			if (options$1?.organizationHooks?.afterCreateTeam) await options$1?.organizationHooks.afterCreateTeam({
+				team: defaultTeam,
+				user,
+				organization: organization$1
+			});
+		}
+		if (options$1.organizationCreation?.afterCreate) await options$1.organizationCreation.afterCreate({
+			organization: organization$1,
+			user,
+			member
+		}, ctx.request);
+		if (options$1?.organizationHooks?.afterCreateOrganization) await options$1?.organizationHooks.afterCreateOrganization({
+			organization: organization$1,
+			user,
+			member
+		});
+		if (ctx.context.session && !ctx.body.keepCurrentActiveOrganization) await adapter.setActiveOrganization(ctx.context.session.session.token, organization$1.id, ctx);
+		if (teamMember && ctx.context.session && !ctx.body.keepCurrentActiveOrganization) await adapter.setActiveTeam(ctx.context.session.session.token, teamMember.teamId, ctx);
+		return ctx.json({
+			...organization$1,
+			metadata: organization$1.metadata && typeof organization$1.metadata === "string" ? JSON.parse(organization$1.metadata) : organization$1.metadata,
+			members: [member]
+		});
+	});
+};
+const checkOrganizationSlug = (options) => createAuthEndpoint("/organization/check-slug", {
+	method: "POST",
+	body: z.object({ slug: z.string().meta({ description: "The organization slug to check. Eg: \"my-org\"" }) }),
+	use: [requestOnlySessionMiddleware, orgMiddleware]
+}, async (ctx) => {
+	if (!await getOrgAdapter(ctx.context, options).findOrganizationBySlug(ctx.body.slug)) return ctx.json({ status: true });
+	throw new APIError("BAD_REQUEST", { message: "slug is taken" });
+});
+const updateOrganization = (options) => {
+	const additionalFieldsSchema = toZodSchema({
+		fields: options?.schema?.organization?.additionalFields || {},
+		isClientSide: true
+	});
+	return createAuthEndpoint("/organization/update", {
+		method: "POST",
+		body: z.object({
+			data: z.object({
+				...additionalFieldsSchema.shape,
+				name: z.string().min(1).meta({ description: "The name of the organization" }).optional(),
+				slug: z.string().min(1).meta({ description: "The slug of the organization" }).optional(),
+				logo: z.string().meta({ description: "The logo of the organization" }).optional(),
+				metadata: z.record(z.string(), z.any()).meta({ description: "The metadata of the organization" }).optional()
+			}).partial(),
+			organizationId: z.string().meta({ description: "The organization ID. Eg: \"org-id\"" }).optional()
+		}),
+		requireHeaders: true,
+		use: [orgMiddleware],
+		metadata: {
+			$Infer: { body: {} },
+			openapi: {
+				description: "Update an organization",
+				responses: { "200": {
+					description: "Success",
+					content: { "application/json": { schema: {
+						type: "object",
+						description: "The updated organization",
+						$ref: "#/components/schemas/Organization"
+					} } }
+				} }
+			}
+		}
+	}, async (ctx) => {
+		const session = await ctx.context.getSession(ctx);
+		if (!session) throw new APIError("UNAUTHORIZED", { message: "User not found" });
+		const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
+		if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		const adapter = getOrgAdapter(ctx.context, options);
+		const member = await adapter.findMemberByOrgId({
+			userId: session.user.id,
+			organizationId
+		});
+		if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+		if (!await hasPermission({
+			permissions: { organization: ["update"] },
+			role: member.role,
+			options: ctx.context.orgOptions,
+			organizationId
+		}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_ORGANIZATION });
+		if (typeof ctx.body.data.slug === "string") {
+			const existingOrganization = await adapter.findOrganizationBySlug(ctx.body.data.slug);
+			if (existingOrganization && existingOrganization.id !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_SLUG_ALREADY_TAKEN });
+		}
+		if (options?.organizationHooks?.beforeUpdateOrganization) {
+			const response = await options.organizationHooks.beforeUpdateOrganization({
+				organization: ctx.body.data,
+				user: session.user,
+				member
+			});
+			if (response && typeof response === "object" && "data" in response) ctx.body.data = {
+				...ctx.body.data,
+				...response.data
+			};
+		}
+		const updatedOrg = await adapter.updateOrganization(organizationId, ctx.body.data);
+		if (options?.organizationHooks?.afterUpdateOrganization) await options.organizationHooks.afterUpdateOrganization({
+			organization: updatedOrg,
+			user: session.user,
+			member
+		});
+		return ctx.json(updatedOrg);
+	});
+};
+const deleteOrganization = (options) => {
+	return createAuthEndpoint("/organization/delete", {
+		method: "POST",
+		body: z.object({ organizationId: z.string().meta({ description: "The organization id to delete" }) }),
+		requireHeaders: true,
+		use: [orgMiddleware],
+		metadata: { openapi: {
+			description: "Delete an organization",
+			responses: { "200": {
+				description: "Success",
+				content: { "application/json": { schema: {
+					type: "string",
+					description: "The organization id that was deleted"
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		if (ctx.context.orgOptions.organizationDeletion?.disabled || ctx.context.orgOptions.disableOrganizationDeletion) {
+			if (ctx.context.orgOptions.organizationDeletion?.disabled) ctx.context.logger.info("`organizationDeletion.disabled` is deprecated. Use `disableOrganizationDeletion` instead");
+			throw new APIError("NOT_FOUND", { message: "Organization deletion is disabled" });
+		}
+		const session = await ctx.context.getSession(ctx);
+		if (!session) throw new APIError("UNAUTHORIZED", { status: 401 });
+		const organizationId = ctx.body.organizationId;
+		if (!organizationId) return ctx.json(null, {
+			status: 400,
+			body: { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND }
+		});
+		const adapter = getOrgAdapter(ctx.context, options);
+		const member = await adapter.findMemberByOrgId({
+			userId: session.user.id,
+			organizationId
+		});
+		if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+		if (!await hasPermission({
+			role: member.role,
+			permissions: { organization: ["delete"] },
+			organizationId,
+			options: ctx.context.orgOptions
+		}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_ORGANIZATION });
+		if (organizationId === session.session.activeOrganizationId)
+ /**
+		* If the organization is deleted, we set the active organization to null
+		*/
+		await adapter.setActiveOrganization(session.session.token, null, ctx);
+		const org = await adapter.findOrganizationById(organizationId);
+		if (!org) throw new APIError("BAD_REQUEST");
+		if (options?.organizationHooks?.beforeDeleteOrganization) await options.organizationHooks.beforeDeleteOrganization({
+			organization: org,
+			user: session.user
+		});
+		await adapter.deleteOrganization(organizationId);
+		if (options?.organizationHooks?.afterDeleteOrganization) await options.organizationHooks.afterDeleteOrganization({
+			organization: org,
+			user: session.user
+		});
+		return ctx.json(org);
+	});
+};
+const getFullOrganization = (options) => createAuthEndpoint("/organization/get-full-organization", {
+	method: "GET",
+	query: z.optional(z.object({
+		organizationId: z.string().meta({ description: "The organization id to get" }).optional(),
+		organizationSlug: z.string().meta({ description: "The organization slug to get" }).optional(),
+		membersLimit: z.number().or(z.string().transform((val) => parseInt(val))).meta({ description: "The limit of members to get. By default, it uses the membershipLimit option which defaults to 100." }).optional()
+	})),
+	requireHeaders: true,
+	use: [orgMiddleware, orgSessionMiddleware],
+	metadata: { openapi: {
+		operationId: "getOrganization",
+		description: "Get the full organization",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				description: "The organization",
+				$ref: "#/components/schemas/Organization"
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const organizationId = ctx.query?.organizationSlug || ctx.query?.organizationId || session.session.activeOrganizationId;
+	if (!organizationId) return ctx.json(null, { status: 200 });
+	const adapter = getOrgAdapter(ctx.context, options);
+	const organization$1 = await adapter.findFullOrganization({
+		organizationId,
+		isSlug: !!ctx.query?.organizationSlug,
+		includeTeams: ctx.context.orgOptions.teams?.enabled,
+		membersLimit: ctx.query?.membersLimit
+	});
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	if (!await adapter.checkMembership({
+		userId: session.user.id,
+		organizationId: organization$1.id
+	})) {
+		await adapter.setActiveOrganization(session.session.token, null, ctx);
+		throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+	}
+	return ctx.json(organization$1);
+});
+const setActiveOrganization = (options) => {
+	return createAuthEndpoint("/organization/set-active", {
+		method: "POST",
+		body: z.object({
+			organizationId: z.string().meta({ description: "The organization id to set as active. It can be null to unset the active organization. Eg: \"org-id\"" }).nullable().optional(),
+			organizationSlug: z.string().meta({ description: "The organization slug to set as active. It can be null to unset the active organization if organizationId is not provided. Eg: \"org-slug\"" }).optional()
+		}),
+		use: [orgSessionMiddleware, orgMiddleware],
+		metadata: { openapi: {
+			operationId: "setActiveOrganization",
+			description: "Set the active organization",
+			responses: { "200": {
+				description: "Success",
+				content: { "application/json": { schema: {
+					type: "object",
+					description: "The organization",
+					$ref: "#/components/schemas/Organization"
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		const adapter = getOrgAdapter(ctx.context, options);
+		const session = ctx.context.session;
+		let organizationId = ctx.body.organizationId;
+		let organizationSlug = ctx.body.organizationSlug;
+		if (organizationId === null) {
+			if (!session.session.activeOrganizationId) return ctx.json(null);
+			await setSessionCookie(ctx, {
+				session: await adapter.setActiveOrganization(session.session.token, null, ctx),
+				user: session.user
+			});
+			return ctx.json(null);
+		}
+		if (!organizationId && !organizationSlug) {
+			const sessionOrgId = session.session.activeOrganizationId;
+			if (!sessionOrgId) return ctx.json(null);
+			organizationId = sessionOrgId;
+		}
+		if (organizationSlug && !organizationId) {
+			const organization$2 = await adapter.findOrganizationBySlug(organizationSlug);
+			if (!organization$2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+			organizationId = organization$2.id;
+		}
+		if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		if (!await adapter.checkMembership({
+			userId: session.user.id,
+			organizationId
+		})) {
+			await adapter.setActiveOrganization(session.session.token, null, ctx);
+			throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+		}
+		let organization$1 = await adapter.findOrganizationById(organizationId);
+		if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		await setSessionCookie(ctx, {
+			session: await adapter.setActiveOrganization(session.session.token, organization$1.id, ctx),
+			user: session.user
+		});
+		return ctx.json(organization$1);
+	});
+};
+const listOrganizations = (options) => createAuthEndpoint("/organization/list", {
+	method: "GET",
+	use: [orgMiddleware, orgSessionMiddleware],
+	metadata: { openapi: {
+		description: "List all organizations",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "array",
+				items: { $ref: "#/components/schemas/Organization" }
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const organizations = await getOrgAdapter(ctx.context, options).listOrganizations(ctx.context.session.user.id);
+	return ctx.json(organizations);
+});
+
+//#endregion
+//#region src/plugins/organization/routes/crud-team.ts
+const createTeam = (options) => {
+	const additionalFieldsSchema = toZodSchema({
+		fields: options?.schema?.team?.additionalFields ?? {},
+		isClientSide: true
+	});
+	const baseSchema = z.object({
+		name: z.string().meta({ description: "The name of the team. Eg: \"my-team\"" }),
+		organizationId: z.string().meta({ description: "The organization ID which the team will be created in. Defaults to the active organization. Eg: \"organization-id\"" }).optional()
+	});
+	return createAuthEndpoint("/organization/create-team", {
+		method: "POST",
+		body: z.object({
+			...baseSchema.shape,
+			...additionalFieldsSchema.shape
+		}),
+		use: [orgMiddleware],
+		metadata: {
+			$Infer: { body: {} },
+			openapi: {
+				description: "Create a new team within an organization",
+				responses: { "200": {
+					description: "Team created successfully",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: {
+							id: {
+								type: "string",
+								description: "Unique identifier of the created team"
+							},
+							name: {
+								type: "string",
+								description: "Name of the team"
+							},
+							organizationId: {
+								type: "string",
+								description: "ID of the organization the team belongs to"
+							},
+							createdAt: {
+								type: "string",
+								format: "date-time",
+								description: "Timestamp when the team was created"
+							},
+							updatedAt: {
+								type: "string",
+								format: "date-time",
+								description: "Timestamp when the team was last updated"
+							}
+						},
+						required: [
+							"id",
+							"name",
+							"organizationId",
+							"createdAt",
+							"updatedAt"
+						]
+					} } }
+				} }
+			}
+		}
+	}, async (ctx) => {
+		const session = await getSessionFromCtx(ctx);
+		const organizationId = ctx.body.organizationId || session?.session.activeOrganizationId;
+		if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
+		if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+		const adapter = getOrgAdapter(ctx.context, options);
+		if (session) {
+			const member = await adapter.findMemberByOrgId({
+				userId: session.user.id,
+				organizationId
+			});
+			if (!member) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION });
+			if (!await hasPermission({
+				role: member.role,
+				options: ctx.context.orgOptions,
+				permissions: { team: ["create"] },
+				organizationId
+			}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_TEAMS_IN_THIS_ORGANIZATION });
+		}
+		const existingTeams = await adapter.listTeams(organizationId);
+		const maximum = typeof ctx.context.orgOptions.teams?.maximumTeams === "function" ? await ctx.context.orgOptions.teams?.maximumTeams({
+			organizationId,
+			session
+		}, ctx) : ctx.context.orgOptions.teams?.maximumTeams;
+		if (maximum ? existingTeams.length >= maximum : false) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_TEAMS });
+		const { name, organizationId: _,...additionalFields } = ctx.body;
+		const organization$1 = await adapter.findOrganizationById(organizationId);
+		if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		let teamData = {
+			name,
+			organizationId,
+			createdAt: /* @__PURE__ */ new Date(),
+			updatedAt: /* @__PURE__ */ new Date(),
+			...additionalFields
+		};
+		if (options?.organizationHooks?.beforeCreateTeam) {
+			const response = await options?.organizationHooks.beforeCreateTeam({
+				team: {
+					name,
+					organizationId,
+					...additionalFields
+				},
+				user: session?.user,
+				organization: organization$1
+			});
+			if (response && typeof response === "object" && "data" in response) teamData = {
+				...teamData,
+				...response.data
+			};
+		}
+		const createdTeam = await adapter.createTeam(teamData);
+		if (options?.organizationHooks?.afterCreateTeam) await options?.organizationHooks.afterCreateTeam({
+			team: createdTeam,
+			user: session?.user,
+			organization: organization$1
+		});
+		return ctx.json(createdTeam);
+	});
+};
+const removeTeam = (options) => createAuthEndpoint("/organization/remove-team", {
+	method: "POST",
+	body: z.object({
+		teamId: z.string().meta({ description: `The team ID of the team to remove. Eg: "team-id"` }),
+		organizationId: z.string().meta({ description: `The organization ID which the team falls under. If not provided, it will default to the user's active organization. Eg: "organization-id"` }).optional()
+	}),
+	use: [orgMiddleware],
+	metadata: { openapi: {
+		description: "Remove a team from an organization",
+		responses: { "200": {
+			description: "Team removed successfully",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: {
+					type: "string",
+					description: "Confirmation message indicating successful removal",
+					enum: ["Team removed successfully."]
+				} },
+				required: ["message"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = await getSessionFromCtx(ctx);
+	const organizationId = ctx.body.organizationId || session?.session.activeOrganizationId;
+	if (!organizationId) return ctx.json(null, {
+		status: 400,
+		body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
+	});
+	if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
+	const adapter = getOrgAdapter(ctx.context, options);
+	if (session) {
+		const member = await adapter.findMemberByOrgId({
+			userId: session.user.id,
+			organizationId
+		});
+		if (!member || session.session?.activeTeamId === ctx.body.teamId) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_TEAM });
+		if (!await hasPermission({
+			role: member.role,
+			options: ctx.context.orgOptions,
+			permissions: { team: ["delete"] },
+			organizationId
+		}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_TEAMS_IN_THIS_ORGANIZATION });
+	}
+	const team = await adapter.findTeamById({
+		teamId: ctx.body.teamId,
+		organizationId
+	});
+	if (!team || team.organizationId !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
+	if (!ctx.context.orgOptions.teams?.allowRemovingAllTeams) {
+		if ((await adapter.listTeams(organizationId)).length <= 1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.UNABLE_TO_REMOVE_LAST_TEAM });
+	}
+	const organization$1 = await adapter.findOrganizationById(organizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	if (options?.organizationHooks?.beforeDeleteTeam) await options?.organizationHooks.beforeDeleteTeam({
+		team,
+		user: session?.user,
+		organization: organization$1
+	});
+	await adapter.deleteTeam(team.id);
+	if (options?.organizationHooks?.afterDeleteTeam) await options?.organizationHooks.afterDeleteTeam({
+		team,
+		user: session?.user,
+		organization: organization$1
+	});
+	return ctx.json({ message: "Team removed successfully." });
+});
+const updateTeam = (options) => {
+	const additionalFieldsSchema = toZodSchema({
+		fields: options?.schema?.team?.additionalFields ?? {},
+		isClientSide: true
+	});
+	return createAuthEndpoint("/organization/update-team", {
+		method: "POST",
+		body: z.object({
+			teamId: z.string().meta({ description: `The ID of the team to be updated. Eg: "team-id"` }),
+			data: z.object({
+				...teamSchema.shape,
+				...additionalFieldsSchema.shape
+			}).partial()
+		}),
+		requireHeaders: true,
+		use: [orgMiddleware, orgSessionMiddleware],
+		metadata: {
+			$Infer: { body: {} },
+			openapi: {
+				description: "Update an existing team in an organization",
+				responses: { "200": {
+					description: "Team updated successfully",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: {
+							id: {
+								type: "string",
+								description: "Unique identifier of the updated team"
+							},
+							name: {
+								type: "string",
+								description: "Updated name of the team"
+							},
+							organizationId: {
+								type: "string",
+								description: "ID of the organization the team belongs to"
+							},
+							createdAt: {
+								type: "string",
+								format: "date-time",
+								description: "Timestamp when the team was created"
+							},
+							updatedAt: {
+								type: "string",
+								format: "date-time",
+								description: "Timestamp when the team was last updated"
+							}
+						},
+						required: [
+							"id",
+							"name",
+							"organizationId",
+							"createdAt",
+							"updatedAt"
+						]
+					} } }
+				} }
+			}
+		}
+	}, async (ctx) => {
+		const session = ctx.context.session;
+		const organizationId = ctx.body.data.organizationId || session.session.activeOrganizationId;
+		if (!organizationId) return ctx.json(null, {
+			status: 400,
+			body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
+		});
+		const adapter = getOrgAdapter(ctx.context, options);
+		const member = await adapter.findMemberByOrgId({
+			userId: session.user.id,
+			organizationId
+		});
+		if (!member) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM });
+		if (!await hasPermission({
+			role: member.role,
+			options: ctx.context.orgOptions,
+			permissions: { team: ["update"] },
+			organizationId
+		}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM });
+		const team = await adapter.findTeamById({
+			teamId: ctx.body.teamId,
+			organizationId
+		});
+		if (!team || team.organizationId !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
+		const { name, organizationId: __,...additionalFields } = ctx.body.data;
+		const organization$1 = await adapter.findOrganizationById(organizationId);
+		if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+		const updates = {
+			name,
+			...additionalFields
+		};
+		if (options?.organizationHooks?.beforeUpdateTeam) {
+			const response = await options?.organizationHooks.beforeUpdateTeam({
+				team,
+				updates,
+				user: session.user,
+				organization: organization$1
+			});
+			if (response && typeof response === "object" && "data" in response) {
+				const modifiedUpdates = response.data;
+				const updatedTeam$1 = await adapter.updateTeam(team.id, modifiedUpdates);
+				if (options?.organizationHooks?.afterUpdateTeam) await options?.organizationHooks.afterUpdateTeam({
+					team: updatedTeam$1,
+					user: session.user,
+					organization: organization$1
+				});
+				return ctx.json(updatedTeam$1);
+			}
+		}
+		const updatedTeam = await adapter.updateTeam(team.id, updates);
+		if (options?.organizationHooks?.afterUpdateTeam) await options?.organizationHooks.afterUpdateTeam({
+			team: updatedTeam,
+			user: session.user,
+			organization: organization$1
+		});
+		return ctx.json(updatedTeam);
+	});
+};
+const listOrganizationTeams = (options) => createAuthEndpoint("/organization/list-teams", {
+	method: "GET",
+	query: z.optional(z.object({ organizationId: z.string().meta({ description: `The organization ID which the teams are under to list. Defaults to the users active organization. Eg: "organziation-id"` }).optional() })),
+	requireHeaders: true,
+	metadata: { openapi: {
+		description: "List all teams in an organization",
+		responses: { "200": {
+			description: "Teams retrieved successfully",
+			content: { "application/json": { schema: {
+				type: "array",
+				items: {
+					type: "object",
+					properties: {
+						id: {
+							type: "string",
+							description: "Unique identifier of the team"
+						},
+						name: {
+							type: "string",
+							description: "Name of the team"
+						},
+						organizationId: {
+							type: "string",
+							description: "ID of the organization the team belongs to"
+						},
+						createdAt: {
+							type: "string",
+							format: "date-time",
+							description: "Timestamp when the team was created"
+						},
+						updatedAt: {
+							type: "string",
+							format: "date-time",
+							description: "Timestamp when the team was last updated"
+						}
+					},
+					required: [
+						"id",
+						"name",
+						"organizationId",
+						"createdAt",
+						"updatedAt"
+					]
+				},
+				description: "Array of team objects within the organization"
+			} } }
+		} }
+	} },
+	use: [orgMiddleware, orgSessionMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const organizationId = ctx.query?.organizationId || session?.session.activeOrganizationId;
+	if (!organizationId) throw ctx.error("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+	const adapter = getOrgAdapter(ctx.context, options);
+	if (!await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId: organizationId || ""
+	})) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_ACCESS_THIS_ORGANIZATION });
+	const teams = await adapter.listTeams(organizationId);
+	return ctx.json(teams);
+});
+const setActiveTeam = (options) => createAuthEndpoint("/organization/set-active-team", {
+	method: "POST",
+	body: z.object({ teamId: z.string().meta({ description: "The team id to set as active. It can be null to unset the active team" }).nullable().optional() }),
+	use: [orgSessionMiddleware, orgMiddleware],
+	metadata: { openapi: {
+		description: "Set the active team",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				description: "The team",
+				$ref: "#/components/schemas/Team"
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
+	const session = ctx.context.session;
+	if (ctx.body.teamId === null) {
+		if (!session.session.activeTeamId) return ctx.json(null);
+		await setSessionCookie(ctx, {
+			session: await adapter.setActiveTeam(session.session.token, null, ctx),
+			user: session.user
+		});
+		return ctx.json(null);
+	}
+	let teamId;
+	if (!ctx.body.teamId) {
+		const sessionTeamId = session.session.activeTeamId;
+		if (!sessionTeamId) return ctx.json(null);
+		else teamId = sessionTeamId;
+	} else teamId = ctx.body.teamId;
+	const team = await adapter.findTeamById({ teamId });
+	if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
+	if (!await adapter.findTeamMember({
+		teamId,
+		userId: session.user.id
+	})) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });
+	await setSessionCookie(ctx, {
+		session: await adapter.setActiveTeam(session.session.token, team.id, ctx),
+		user: session.user
+	});
+	return ctx.json(team);
+});
+const listUserTeams = (options) => createAuthEndpoint("/organization/list-user-teams", {
+	method: "GET",
+	metadata: { openapi: {
+		description: "List all teams that the current user is a part of.",
+		responses: { "200": {
+			description: "Teams retrieved successfully",
+			content: { "application/json": { schema: {
+				type: "array",
+				items: {
+					type: "object",
+					description: "The team",
+					$ref: "#/components/schemas/Team"
+				},
+				description: "Array of team objects within the organization"
+			} } }
+		} }
+	} },
+	use: [orgMiddleware, orgSessionMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const teams = await getOrgAdapter(ctx.context, ctx.context.orgOptions).listTeamsByUser({ userId: session.user.id });
+	return ctx.json(teams);
+});
+const listTeamMembers = (options) => createAuthEndpoint("/organization/list-team-members", {
+	method: "GET",
+	query: z.optional(z.object({ teamId: z.string().optional().meta({ description: "The team whose members we should return. If this is not provided the members of the current active team get returned." }) })),
+	metadata: { openapi: {
+		description: "List the members of the given team.",
+		responses: { "200": {
+			description: "Teams retrieved successfully",
+			content: { "application/json": { schema: {
+				type: "array",
+				items: {
+					type: "object",
+					description: "The team member",
+					properties: {
+						id: {
+							type: "string",
+							description: "Unique identifier of the team member"
+						},
+						userId: {
+							type: "string",
+							description: "The user ID of the team member"
+						},
+						teamId: {
+							type: "string",
+							description: "The team ID of the team the team member is in"
+						},
+						createdAt: {
+							type: "string",
+							format: "date-time",
+							description: "Timestamp when the team member was created"
+						}
+					},
+					required: [
+						"id",
+						"userId",
+						"teamId",
+						"createdAt"
+					]
+				},
+				description: "Array of team member objects within the team"
+			} } }
+		} }
+	} },
+	use: [orgMiddleware, orgSessionMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
+	let teamId = ctx.query?.teamId || session?.session.activeTeamId;
+	if (!teamId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_DO_NOT_HAVE_AN_ACTIVE_TEAM });
+	if (!await adapter.findTeamMember({
+		userId: session.user.id,
+		teamId
+	})) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });
+	const members = await adapter.listTeamMembers({ teamId });
+	return ctx.json(members);
+});
+const addTeamMember = (options) => createAuthEndpoint("/organization/add-team-member", {
+	method: "POST",
+	body: z.object({
+		teamId: z.string().meta({ description: "The team the user should be a member of." }),
+		userId: z.coerce.string().meta({ description: "The user Id which represents the user to be added as a member." })
+	}),
+	metadata: { openapi: {
+		description: "The newly created member",
+		responses: { "200": {
+			description: "Team member created successfully",
+			content: { "application/json": { schema: {
+				type: "object",
+				description: "The team member",
+				properties: {
+					id: {
+						type: "string",
+						description: "Unique identifier of the team member"
+					},
+					userId: {
+						type: "string",
+						description: "The user ID of the team member"
+					},
+					teamId: {
+						type: "string",
+						description: "The team ID of the team the team member is in"
+					},
+					createdAt: {
+						type: "string",
+						format: "date-time",
+						description: "Timestamp when the team member was created"
+					}
+				},
+				required: [
+					"id",
+					"userId",
+					"teamId",
+					"createdAt"
+				]
+			} } }
+		} }
+	} },
+	use: [orgMiddleware, orgSessionMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
+	if (!session.session.activeOrganizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+	const currentMember = await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId: session.session.activeOrganizationId
+	});
+	if (!currentMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+	if (!await hasPermission({
+		role: currentMember.role,
+		options: ctx.context.orgOptions,
+		permissions: { member: ["update"] },
+		organizationId: session.session.activeOrganizationId
+	}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM_MEMBER });
+	if (!await adapter.findMemberByOrgId({
+		userId: ctx.body.userId,
+		organizationId: session.session.activeOrganizationId
+	})) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+	const team = await adapter.findTeamById({
+		teamId: ctx.body.teamId,
+		organizationId: session.session.activeOrganizationId
+	});
+	if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
+	const organization$1 = await adapter.findOrganizationById(session.session.activeOrganizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	const userBeingAdded = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+	if (!userBeingAdded) throw new APIError("BAD_REQUEST", { message: "User not found" });
+	if (options?.organizationHooks?.beforeAddTeamMember) {
+		const response = await options?.organizationHooks.beforeAddTeamMember({
+			teamMember: {
+				teamId: ctx.body.teamId,
+				userId: ctx.body.userId
+			},
+			team,
+			user: userBeingAdded,
+			organization: organization$1
+		});
+		if (response && typeof response === "object" && "data" in response) {}
+	}
+	const teamMember = await adapter.findOrCreateTeamMember({
+		teamId: ctx.body.teamId,
+		userId: ctx.body.userId
+	});
+	if (options?.organizationHooks?.afterAddTeamMember) await options?.organizationHooks.afterAddTeamMember({
+		teamMember,
+		team,
+		user: userBeingAdded,
+		organization: organization$1
+	});
+	return ctx.json(teamMember);
+});
+const removeTeamMember = (options) => createAuthEndpoint("/organization/remove-team-member", {
+	method: "POST",
+	body: z.object({
+		teamId: z.string().meta({ description: "The team the user should be removed from." }),
+		userId: z.coerce.string().meta({ description: "The user which should be removed from the team." })
+	}),
+	metadata: { openapi: {
+		description: "Remove a member from a team",
+		responses: { "200": {
+			description: "Team member removed successfully",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { message: {
+					type: "string",
+					description: "Confirmation message indicating successful removal",
+					enum: ["Team member removed successfully."]
+				} },
+				required: ["message"]
+			} } }
+		} }
+	} },
+	use: [orgMiddleware, orgSessionMiddleware]
+}, async (ctx) => {
+	const session = ctx.context.session;
+	const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
+	if (!session.session.activeOrganizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+	const currentMember = await adapter.findMemberByOrgId({
+		userId: session.user.id,
+		organizationId: session.session.activeOrganizationId
+	});
+	if (!currentMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+	if (!await hasPermission({
+		role: currentMember.role,
+		options: ctx.context.orgOptions,
+		permissions: { member: ["delete"] },
+		organizationId: session.session.activeOrganizationId
+	}, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REMOVE_A_TEAM_MEMBER });
+	if (!await adapter.findMemberByOrgId({
+		userId: ctx.body.userId,
+		organizationId: session.session.activeOrganizationId
+	})) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+	const team = await adapter.findTeamById({
+		teamId: ctx.body.teamId,
+		organizationId: session.session.activeOrganizationId
+	});
+	if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
+	const organization$1 = await adapter.findOrganizationById(session.session.activeOrganizationId);
+	if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
+	const userBeingRemoved = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
+	if (!userBeingRemoved) throw new APIError("BAD_REQUEST", { message: "User not found" });
+	const teamMember = await adapter.findTeamMember({
+		teamId: ctx.body.teamId,
+		userId: ctx.body.userId
+	});
+	if (!teamMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });
+	if (options?.organizationHooks?.beforeRemoveTeamMember) await options?.organizationHooks.beforeRemoveTeamMember({
+		teamMember,
+		team,
+		user: userBeingRemoved,
+		organization: organization$1
+	});
+	await adapter.removeTeamMember({
+		teamId: ctx.body.teamId,
+		userId: ctx.body.userId
+	});
+	if (options?.organizationHooks?.afterRemoveTeamMember) await options?.organizationHooks.afterRemoveTeamMember({
+		teamMember,
+		team,
+		user: userBeingRemoved,
+		organization: organization$1
+	});
+	return ctx.json({ message: "Team member removed successfully." });
+});
+
+//#endregion
+//#region src/plugins/organization/organization.ts
+function parseRoles(roles) {
+	return Array.isArray(roles) ? roles.join(",") : roles;
+}
+const createHasPermission = (options) => {
+	return createAuthEndpoint("/organization/has-permission", {
+		method: "POST",
+		requireHeaders: true,
+		body: z.object({ organizationId: z.string().optional() }).and(z.union([z.object({
+			permission: z.record(z.string(), z.array(z.string())),
+			permissions: z.undefined()
+		}), z.object({
+			permission: z.undefined(),
+			permissions: z.record(z.string(), z.array(z.string()))
+		})])),
+		use: [orgSessionMiddleware],
+		metadata: {
+			$Infer: { body: {} },
+			openapi: {
+				description: "Check if the user has permission",
+				requestBody: { content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						permission: {
+							type: "object",
+							description: "The permission to check",
+							deprecated: true
+						},
+						permissions: {
+							type: "object",
+							description: "The permission to check"
+						}
+					},
+					required: ["permissions"]
+				} } } },
+				responses: { "200": {
+					description: "Success",
+					content: { "application/json": { schema: {
+						type: "object",
+						properties: {
+							error: { type: "string" },
+							success: { type: "boolean" }
+						},
+						required: ["success"]
+					} } }
+				} }
+			}
+		}
+	}, async (ctx) => {
+		const activeOrganizationId = ctx.body.organizationId || ctx.context.session.session.activeOrganizationId;
+		if (!activeOrganizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
+		const member = await getOrgAdapter(ctx.context, options).findMemberByOrgId({
+			userId: ctx.context.session.user.id,
+			organizationId: activeOrganizationId
+		});
+		if (!member) throw new APIError("UNAUTHORIZED", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
+		const result = await hasPermission({
+			role: member.role,
+			options: options || {},
+			permissions: ctx.body.permissions ?? ctx.body.permission,
+			organizationId: activeOrganizationId
+		}, ctx);
+		return ctx.json({
+			error: null,
+			success: result
+		});
+	});
+};
+function organization(options) {
+	let endpoints = {
+		createOrganization: createOrganization(options),
+		updateOrganization: updateOrganization(options),
+		deleteOrganization: deleteOrganization(options),
+		setActiveOrganization: setActiveOrganization(options),
+		getFullOrganization: getFullOrganization(options),
+		listOrganizations: listOrganizations(options),
+		createInvitation: createInvitation(options),
+		cancelInvitation: cancelInvitation(options),
+		acceptInvitation: acceptInvitation(options),
+		getInvitation: getInvitation(options),
+		rejectInvitation: rejectInvitation(options),
+		listInvitations: listInvitations(options),
+		getActiveMember: getActiveMember(options),
+		checkOrganizationSlug: checkOrganizationSlug(options),
+		addMember: addMember(options),
+		removeMember: removeMember(options),
+		updateMemberRole: updateMemberRole(options),
+		leaveOrganization: leaveOrganization(options),
+		listUserInvitations: listUserInvitations(options),
+		listMembers: listMembers(options),
+		getActiveMemberRole: getActiveMemberRole(options)
+	};
+	const teamSupport = options?.teams?.enabled;
+	const teamEndpoints = {
+		createTeam: createTeam(options),
+		listOrganizationTeams: listOrganizationTeams(options),
+		removeTeam: removeTeam(options),
+		updateTeam: updateTeam(options),
+		setActiveTeam: setActiveTeam(options),
+		listUserTeams: listUserTeams(options),
+		listTeamMembers: listTeamMembers(options),
+		addTeamMember: addTeamMember(options),
+		removeTeamMember: removeTeamMember(options)
+	};
+	if (teamSupport) endpoints = {
+		...endpoints,
+		...teamEndpoints
+	};
+	const dynamicAccessControlEndpoints = {
+		createOrgRole: createOrgRole(options),
+		deleteOrgRole: deleteOrgRole(options),
+		listOrgRoles: listOrgRoles(options),
+		getOrgRole: getOrgRole(options),
+		updateOrgRole: updateOrgRole(options)
+	};
+	if (options?.dynamicAccessControl?.enabled) endpoints = {
+		...endpoints,
+		...dynamicAccessControlEndpoints
+	};
+	const roles = {
+		...defaultRoles,
+		...options?.roles
+	};
+	const teamSchema$1 = teamSupport ? {
+		team: {
+			modelName: options?.schema?.team?.modelName,
+			fields: {
+				name: {
+					type: "string",
+					required: true,
+					fieldName: options?.schema?.team?.fields?.name
+				},
+				organizationId: {
+					type: "string",
+					required: true,
+					references: {
+						model: "organization",
+						field: "id"
+					},
+					fieldName: options?.schema?.team?.fields?.organizationId,
+					index: true
+				},
+				createdAt: {
+					type: "date",
+					required: true,
+					fieldName: options?.schema?.team?.fields?.createdAt
+				},
+				updatedAt: {
+					type: "date",
+					required: false,
+					fieldName: options?.schema?.team?.fields?.updatedAt,
+					onUpdate: () => /* @__PURE__ */ new Date()
+				},
+				...options?.schema?.team?.additionalFields || {}
+			}
+		},
+		teamMember: {
+			modelName: options?.schema?.teamMember?.modelName,
+			fields: {
+				teamId: {
+					type: "string",
+					required: true,
+					references: {
+						model: "team",
+						field: "id"
+					},
+					fieldName: options?.schema?.teamMember?.fields?.teamId,
+					index: true
+				},
+				userId: {
+					type: "string",
+					required: true,
+					references: {
+						model: "user",
+						field: "id"
+					},
+					fieldName: options?.schema?.teamMember?.fields?.userId,
+					index: true
+				},
+				createdAt: {
+					type: "date",
+					required: false,
+					fieldName: options?.schema?.teamMember?.fields?.createdAt
+				}
+			}
+		}
+	} : {};
+	const organizationRoleSchema$1 = options?.dynamicAccessControl?.enabled ? { organizationRole: {
+		fields: {
+			organizationId: {
+				type: "string",
+				required: true,
+				references: {
+					model: "organization",
+					field: "id"
+				},
+				fieldName: options?.schema?.organizationRole?.fields?.organizationId,
+				index: true
+			},
+			role: {
+				type: "string",
+				required: true,
+				fieldName: options?.schema?.organizationRole?.fields?.role,
+				index: true
+			},
+			permission: {
+				type: "string",
+				required: true,
+				fieldName: options?.schema?.organizationRole?.fields?.permission
+			},
+			createdAt: {
+				type: "date",
+				required: true,
+				defaultValue: () => /* @__PURE__ */ new Date(),
+				fieldName: options?.schema?.organizationRole?.fields?.createdAt
+			},
+			updatedAt: {
+				type: "date",
+				required: false,
+				fieldName: options?.schema?.organizationRole?.fields?.updatedAt,
+				onUpdate: () => /* @__PURE__ */ new Date()
+			},
+			...options?.schema?.organizationRole?.additionalFields || {}
+		},
+		modelName: options?.schema?.organizationRole?.modelName
+	} } : {};
+	const schema = {
+		organization: {
+			modelName: options?.schema?.organization?.modelName,
+			fields: {
+				name: {
+					type: "string",
+					required: true,
+					sortable: true,
+					fieldName: options?.schema?.organization?.fields?.name
+				},
+				slug: {
+					type: "string",
+					required: true,
+					unique: true,
+					sortable: true,
+					fieldName: options?.schema?.organization?.fields?.slug
+				},
+				logo: {
+					type: "string",
+					required: false,
+					fieldName: options?.schema?.organization?.fields?.logo
+				},
+				createdAt: {
+					type: "date",
+					required: true,
+					fieldName: options?.schema?.organization?.fields?.createdAt
+				},
+				metadata: {
+					type: "string",
+					required: false,
+					fieldName: options?.schema?.organization?.fields?.metadata
+				},
+				...options?.schema?.organization?.additionalFields || {}
+			}
+		},
+		...organizationRoleSchema$1,
+		...teamSchema$1,
+		member: {
+			modelName: options?.schema?.member?.modelName,
+			fields: {
+				organizationId: {
+					type: "string",
+					required: true,
+					references: {
+						model: "organization",
+						field: "id"
+					},
+					fieldName: options?.schema?.member?.fields?.organizationId,
+					index: true
+				},
+				userId: {
+					type: "string",
+					required: true,
+					fieldName: options?.schema?.member?.fields?.userId,
+					references: {
+						model: "user",
+						field: "id"
+					},
+					index: true
+				},
+				role: {
+					type: "string",
+					required: true,
+					sortable: true,
+					defaultValue: "member",
+					fieldName: options?.schema?.member?.fields?.role
+				},
+				createdAt: {
+					type: "date",
+					required: true,
+					fieldName: options?.schema?.member?.fields?.createdAt
+				},
+				...options?.schema?.member?.additionalFields || {}
+			}
+		},
+		invitation: {
+			modelName: options?.schema?.invitation?.modelName,
+			fields: {
+				organizationId: {
+					type: "string",
+					required: true,
+					references: {
+						model: "organization",
+						field: "id"
+					},
+					fieldName: options?.schema?.invitation?.fields?.organizationId,
+					index: true
+				},
+				email: {
+					type: "string",
+					required: true,
+					sortable: true,
+					fieldName: options?.schema?.invitation?.fields?.email,
+					index: true
+				},
+				role: {
+					type: "string",
+					required: false,
+					sortable: true,
+					fieldName: options?.schema?.invitation?.fields?.role
+				},
+				...teamSupport ? { teamId: {
+					type: "string",
+					required: false,
+					sortable: true,
+					fieldName: options?.schema?.invitation?.fields?.teamId
+				} } : {},
+				status: {
+					type: "string",
+					required: true,
+					sortable: true,
+					defaultValue: "pending",
+					fieldName: options?.schema?.invitation?.fields?.status
+				},
+				expiresAt: {
+					type: "date",
+					required: true,
+					fieldName: options?.schema?.invitation?.fields?.expiresAt
+				},
+				createdAt: {
+					type: "date",
+					required: true,
+					fieldName: options?.schema?.invitation?.fields?.createdAt,
+					defaultValue: () => /* @__PURE__ */ new Date()
+				},
+				inviterId: {
+					type: "string",
+					references: {
+						model: "user",
+						field: "id"
+					},
+					fieldName: options?.schema?.invitation?.fields?.inviterId,
+					required: true
+				},
+				...options?.schema?.invitation?.additionalFields || {}
+			}
+		}
+	};
+	return {
+		id: "organization",
+		endpoints: {
+			...shimContext(endpoints, {
+				orgOptions: options || {},
+				roles,
+				getSession: async (context) => {
+					return await getSessionFromCtx(context);
+				}
+			}),
+			hasPermission: createHasPermission(options)
+		},
+		schema: {
+			...schema,
+			session: { fields: {
+				activeOrganizationId: {
+					type: "string",
+					required: false,
+					fieldName: options?.schema?.session?.fields?.activeOrganizationId
+				},
+				...teamSupport ? { activeTeamId: {
+					type: "string",
+					required: false,
+					fieldName: options?.schema?.session?.fields?.activeTeamId
+				} } : {}
+			} }
+		},
+		$Infer: {
+			Organization: {},
+			Invitation: {},
+			Member: {},
+			Team: teamSupport ? {} : {},
+			TeamMember: teamSupport ? {} : {},
+			ActiveOrganization: {}
+		},
+		$ERROR_CODES: ORGANIZATION_ERROR_CODES,
+		options
+	};
+}
+
+//#endregion
+export { parseRoles as n, organization as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/parser-DcrIEuXE.mjs.bak b/node_modules/better-auth/dist/parser-DcrIEuXE.mjs.bak
new file mode 100644
index 0000000..8a550bd
--- /dev/null
+++ b/node_modules/better-auth/dist/parser-DcrIEuXE.mjs.bak
@@ -0,0 +1,73 @@
+//#region src/client/parser.ts
+const PROTO_POLLUTION_PATTERNS = {
+	proto: /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
+	constructor: /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
+	protoShort: /"__proto__"\s*:/,
+	constructorShort: /"constructor"\s*:/
+};
+const JSON_SIGNATURE = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
+const SPECIAL_VALUES = {
+	true: true,
+	false: false,
+	null: null,
+	undefined: void 0,
+	nan: NaN,
+	infinity: Number.POSITIVE_INFINITY,
+	"-infinity": Number.NEGATIVE_INFINITY
+};
+const ISO_DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{1,7}))?(?:Z|([+-])(\d{2}):(\d{2}))$/;
+function isValidDate(date) {
+	return date instanceof Date && !isNaN(date.getTime());
+}
+function parseISODate(value) {
+	const match = ISO_DATE_REGEX.exec(value);
+	if (!match) return null;
+	const [, year, month, day, hour, minute, second, ms, offsetSign, offsetHour, offsetMinute] = match;
+	let date = new Date(Date.UTC(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10), parseInt(hour, 10), parseInt(minute, 10), parseInt(second, 10), ms ? parseInt(ms.padEnd(3, "0"), 10) : 0));
+	if (offsetSign) {
+		const offset = (parseInt(offsetHour, 10) * 60 + parseInt(offsetMinute, 10)) * (offsetSign === "+" ? -1 : 1);
+		date.setUTCMinutes(date.getUTCMinutes() + offset);
+	}
+	return isValidDate(date) ? date : null;
+}
+function betterJSONParse(value, options = {}) {
+	const { strict = false, warnings = false, reviver, parseDates = true } = options;
+	if (typeof value !== "string") return value;
+	const trimmed = value.trim();
+	if (trimmed.length > 0 && trimmed[0] === "\"" && trimmed.endsWith("\"") && !trimmed.slice(1, -1).includes("\"")) return trimmed.slice(1, -1);
+	const lowerValue = trimmed.toLowerCase();
+	if (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) return SPECIAL_VALUES[lowerValue];
+	if (!JSON_SIGNATURE.test(trimmed)) {
+		if (strict) throw new SyntaxError("[better-json] Invalid JSON");
+		return value;
+	}
+	if (Object.entries(PROTO_POLLUTION_PATTERNS).some(([key, pattern]) => {
+		const matches = pattern.test(trimmed);
+		if (matches && warnings) console.warn(`[better-json] Detected potential prototype pollution attempt using ${key} pattern`);
+		return matches;
+	}) && strict) throw new Error("[better-json] Potential prototype pollution attempt detected");
+	try {
+		const secureReviver = (key, value$1) => {
+			if (key === "__proto__" || key === "constructor" && value$1 && typeof value$1 === "object" && "prototype" in value$1) {
+				if (warnings) console.warn(`[better-json] Dropping "${key}" key to prevent prototype pollution`);
+				return;
+			}
+			if (parseDates && typeof value$1 === "string") {
+				const date = parseISODate(value$1);
+				if (date) return date;
+			}
+			return reviver ? reviver(key, value$1) : value$1;
+		};
+		return JSON.parse(trimmed, secureReviver);
+	} catch (error) {
+		if (strict) throw error;
+		return value;
+	}
+}
+function parseJSON(value, options = { strict: true }) {
+	return betterJSONParse(value, options);
+}
+var parser_default = parseJSON;
+
+//#endregion
+export { parser_default as n, parseJSON as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/password-DWi8yN3A.mjs.bak b/node_modules/better-auth/dist/password-DWi8yN3A.mjs.bak
new file mode 100644
index 0000000..2dd1b02
--- /dev/null
+++ b/node_modules/better-auth/dist/password-DWi8yN3A.mjs.bak
@@ -0,0 +1,25 @@
+import { APIError } from "better-call";
+
+//#region src/utils/password.ts
+async function validatePassword(ctx, data) {
+	const credentialAccount = (await ctx.context.internalAdapter.findAccounts(data.userId))?.find((account) => account.providerId === "credential");
+	const currentPassword = credentialAccount?.password;
+	if (!credentialAccount || !currentPassword) return false;
+	return await ctx.context.password.verify({
+		hash: currentPassword,
+		password: data.password
+	});
+}
+async function checkPassword(userId, c) {
+	const credentialAccount = (await c.context.internalAdapter.findAccounts(userId))?.find((account) => account.providerId === "credential");
+	const currentPassword = credentialAccount?.password;
+	if (!credentialAccount || !currentPassword || !c.body.password) throw new APIError("BAD_REQUEST", { message: "No password credential found" });
+	if (!await c.context.password.verify({
+		hash: currentPassword,
+		password: c.body.password
+	})) throw new APIError("BAD_REQUEST", { message: "Invalid password" });
+	return true;
+}
+
+//#endregion
+export { validatePassword as n, checkPassword as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/permission-CDDWgA_O.mjs.bak b/node_modules/better-auth/dist/permission-CDDWgA_O.mjs.bak
new file mode 100644
index 0000000..8e1a5e7
--- /dev/null
+++ b/node_modules/better-auth/dist/permission-CDDWgA_O.mjs.bak
@@ -0,0 +1,15 @@
+//#region src/plugins/organization/permission.ts
+const hasPermissionFn = (input, acRoles) => {
+	if (!input.permissions && !input.permission) return false;
+	const roles = input.role.split(",");
+	const creatorRole = input.options.creatorRole || "owner";
+	const isCreator = roles.includes(creatorRole);
+	const allowCreatorsAllPermissions = input.allowCreatorAllPermissions || false;
+	if (isCreator && allowCreatorsAllPermissions) return true;
+	for (const role of roles) if ((acRoles[role]?.authorize(input.permissions ?? input.permission))?.success) return true;
+	return false;
+};
+let cacheAllRoles = /* @__PURE__ */ new Map();
+
+//#endregion
+export { hasPermissionFn as n, cacheAllRoles as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/phone-number-WeAgIbHL.mjs b/node_modules/better-auth/dist/phone-number-WeAgIbHL.mjs
index a44f765..fe1bb67 100644
--- a/node_modules/better-auth/dist/phone-number-WeAgIbHL.mjs
+++ b/node_modules/better-auth/dist/phone-number-WeAgIbHL.mjs
@@ -69,9 +69,9 @@ const phoneNumber = (options) => {
 			signInPhoneNumber: createAuthEndpoint("/sign-in/phone-number", {
 				method: "POST",
 				body: z.object({
-					phoneNumber: z.string().meta({ description: "Phone number to sign in. Eg: \"+1234567890\"" }),
-					password: z.string().meta({ description: "Password to use for sign in." }),
-					rememberMe: z.boolean().meta({ description: "Remember the session. Eg: true" }).optional()
+					phoneNumber: z.string(),
+					password: z.string(),
+					rememberMe: z.boolean().optional()
 				}),
 				metadata: { openapi: {
 					summary: "Sign in with phone number",
@@ -161,7 +161,7 @@ const phoneNumber = (options) => {
 			}),
 			sendPhoneNumberOTP: createAuthEndpoint("/phone-number/send-otp", {
 				method: "POST",
-				body: z.object({ phoneNumber: z.string().meta({ description: "Phone number to send OTP. Eg: \"+1234567890\"" }) }),
+				body: z.object({ phoneNumber: z.string() }),
 				metadata: { openapi: {
 					summary: "Send OTP to phone number",
 					description: "Use this endpoint to send OTP to phone number",
@@ -196,10 +196,10 @@ const phoneNumber = (options) => {
 			verifyPhoneNumber: createAuthEndpoint("/phone-number/verify", {
 				method: "POST",
 				body: z.object({
-					phoneNumber: z.string().meta({ description: "Phone number to verify. Eg: \"+1234567890\"" }),
-					code: z.string().meta({ description: "OTP code. Eg: \"123456\"" }),
-					disableSession: z.boolean().meta({ description: "Disable session creation after verification. Eg: false" }).optional(),
-					updatePhoneNumber: z.boolean().meta({ description: "Check if there is a session and update the phone number. Eg: true" }).optional()
+					phoneNumber: z.string(),
+					code: z.string(),
+					disableSession: z.boolean().optional(),
+					updatePhoneNumber: z.boolean().optional()
 				}),
 				metadata: { openapi: {
 					summary: "Verify phone number",
@@ -444,9 +444,9 @@ const phoneNumber = (options) => {
 			resetPasswordPhoneNumber: createAuthEndpoint("/phone-number/reset-password", {
 				method: "POST",
 				body: z.object({
-					otp: z.string().meta({ description: "The one time password to reset the password. Eg: \"123456\"" }),
-					phoneNumber: z.string().meta({ description: "The phone number to the account which intends to reset the password for. Eg: \"+1234567890\"" }),
-					newPassword: z.string().meta({ description: `The new password. Eg: "new-and-secure-password"` })
+					otp: z.string(),
+					phoneNumber: z.string(),
+					newPassword: z.string()
 				}),
 				metadata: { openapi: {
 					description: "Reset password using phone number OTP",
diff --git a/node_modules/better-auth/dist/phone-number-WeAgIbHL.mjs.bak b/node_modules/better-auth/dist/phone-number-WeAgIbHL.mjs.bak
new file mode 100644
index 0000000..a44f765
--- /dev/null
+++ b/node_modules/better-auth/dist/phone-number-WeAgIbHL.mjs.bak
@@ -0,0 +1,507 @@
+import { r as generateRandomString } from "./crypto-DZW3hrq1.mjs";
+import { t as mergeSchema, u as getDate } from "./schema-BevzneML.mjs";
+import { c as setSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx } from "./session-Efap-vxj.mjs";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/phone-number/error-codes.ts
+const PHONE_NUMBER_ERROR_CODES = defineErrorCodes({
+	INVALID_PHONE_NUMBER: "Invalid phone number",
+	PHONE_NUMBER_EXIST: "Phone number already exists",
+	PHONE_NUMBER_NOT_EXIST: "phone number isn't registered",
+	INVALID_PHONE_NUMBER_OR_PASSWORD: "Invalid phone number or password",
+	UNEXPECTED_ERROR: "Unexpected error",
+	OTP_NOT_FOUND: "OTP not found",
+	OTP_EXPIRED: "OTP expired",
+	INVALID_OTP: "Invalid OTP",
+	PHONE_NUMBER_NOT_VERIFIED: "Phone number not verified",
+	PHONE_NUMBER_CANNOT_BE_UPDATED: "Phone number cannot be updated",
+	SEND_OTP_NOT_IMPLEMENTED: "sendOTP not implemented",
+	TOO_MANY_ATTEMPTS: "Too many attempts"
+});
+
+//#endregion
+//#region src/plugins/phone-number/schema.ts
+const schema = { user: { fields: {
+	phoneNumber: {
+		type: "string",
+		required: false,
+		unique: true,
+		sortable: true,
+		returned: true
+	},
+	phoneNumberVerified: {
+		type: "boolean",
+		required: false,
+		returned: true,
+		input: false
+	}
+} } };
+
+//#endregion
+//#region src/plugins/phone-number/index.ts
+function generateOTP(size) {
+	return generateRandomString(size, "0-9");
+}
+const phoneNumber = (options) => {
+	const opts = {
+		expiresIn: options?.expiresIn || 300,
+		otpLength: options?.otpLength || 6,
+		...options,
+		phoneNumber: "phoneNumber",
+		phoneNumberVerified: "phoneNumberVerified",
+		code: "code",
+		createdAt: "createdAt"
+	};
+	return {
+		id: "phone-number",
+		hooks: { before: [{
+			matcher: (ctx) => ctx.path === "/update-user" && "phoneNumber" in ctx.body,
+			handler: createAuthMiddleware(async (_ctx) => {
+				throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_CANNOT_BE_UPDATED });
+			})
+		}] },
+		endpoints: {
+			signInPhoneNumber: createAuthEndpoint("/sign-in/phone-number", {
+				method: "POST",
+				body: z.object({
+					phoneNumber: z.string().meta({ description: "Phone number to sign in. Eg: \"+1234567890\"" }),
+					password: z.string().meta({ description: "Password to use for sign in." }),
+					rememberMe: z.boolean().meta({ description: "Remember the session. Eg: true" }).optional()
+				}),
+				metadata: { openapi: {
+					summary: "Sign in with phone number",
+					description: "Use this endpoint to sign in with phone number",
+					responses: {
+						200: {
+							description: "Success",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									user: { $ref: "#/components/schemas/User" },
+									session: { $ref: "#/components/schemas/Session" }
+								}
+							} } }
+						},
+						400: { description: "Invalid phone number or password" }
+					}
+				} }
+			}, async (ctx) => {
+				const { password, phoneNumber: phoneNumber$1 } = ctx.body;
+				if (opts.phoneNumberValidator) {
+					if (!await opts.phoneNumberValidator(ctx.body.phoneNumber)) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER });
+				}
+				const user = await ctx.context.adapter.findOne({
+					model: "user",
+					where: [{
+						field: "phoneNumber",
+						value: phoneNumber$1
+					}]
+				});
+				if (!user) throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });
+				if (opts.requireVerification) {
+					if (!user.phoneNumberVerified) {
+						const otp = generateOTP(opts.otpLength);
+						await ctx.context.internalAdapter.createVerificationValue({
+							value: otp,
+							identifier: phoneNumber$1,
+							expiresAt: getDate(opts.expiresIn, "sec")
+						});
+						await opts.sendOTP?.({
+							phoneNumber: phoneNumber$1,
+							code: otp
+						}, ctx);
+						throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_NOT_VERIFIED });
+					}
+				}
+				const credentialAccount = (await ctx.context.internalAdapter.findAccountByUserId(user.id)).find((a) => a.providerId === "credential");
+				if (!credentialAccount) {
+					ctx.context.logger.error("Credential account not found", { phoneNumber: phoneNumber$1 });
+					throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });
+				}
+				const currentPassword = credentialAccount?.password;
+				if (!currentPassword) {
+					ctx.context.logger.error("Password not found", { phoneNumber: phoneNumber$1 });
+					throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.UNEXPECTED_ERROR });
+				}
+				if (!await ctx.context.password.verify({
+					hash: currentPassword,
+					password
+				})) {
+					ctx.context.logger.error("Invalid password");
+					throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });
+				}
+				const session = await ctx.context.internalAdapter.createSession(user.id, ctx.body.rememberMe === false);
+				if (!session) {
+					ctx.context.logger.error("Failed to create session");
+					throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
+				}
+				await setSessionCookie(ctx, {
+					session,
+					user
+				}, ctx.body.rememberMe === false);
+				return ctx.json({
+					token: session.token,
+					user: {
+						id: user.id,
+						email: user.email,
+						emailVerified: user.emailVerified,
+						name: user.name,
+						image: user.image,
+						phoneNumber: user.phoneNumber,
+						phoneNumberVerified: user.phoneNumberVerified,
+						createdAt: user.createdAt,
+						updatedAt: user.updatedAt
+					}
+				});
+			}),
+			sendPhoneNumberOTP: createAuthEndpoint("/phone-number/send-otp", {
+				method: "POST",
+				body: z.object({ phoneNumber: z.string().meta({ description: "Phone number to send OTP. Eg: \"+1234567890\"" }) }),
+				metadata: { openapi: {
+					summary: "Send OTP to phone number",
+					description: "Use this endpoint to send OTP to phone number",
+					responses: { 200: {
+						description: "Success",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { message: { type: "string" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!options?.sendOTP) {
+					ctx.context.logger.warn("sendOTP not implemented");
+					throw new APIError("NOT_IMPLEMENTED", { message: PHONE_NUMBER_ERROR_CODES.SEND_OTP_NOT_IMPLEMENTED });
+				}
+				if (opts.phoneNumberValidator) {
+					if (!await opts.phoneNumberValidator(ctx.body.phoneNumber)) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER });
+				}
+				const code = generateOTP(opts.otpLength);
+				await ctx.context.internalAdapter.createVerificationValue({
+					value: `${code}:0`,
+					identifier: ctx.body.phoneNumber,
+					expiresAt: getDate(opts.expiresIn, "sec")
+				});
+				await options.sendOTP({
+					phoneNumber: ctx.body.phoneNumber,
+					code
+				}, ctx);
+				return ctx.json({ message: "code sent" });
+			}),
+			verifyPhoneNumber: createAuthEndpoint("/phone-number/verify", {
+				method: "POST",
+				body: z.object({
+					phoneNumber: z.string().meta({ description: "Phone number to verify. Eg: \"+1234567890\"" }),
+					code: z.string().meta({ description: "OTP code. Eg: \"123456\"" }),
+					disableSession: z.boolean().meta({ description: "Disable session creation after verification. Eg: false" }).optional(),
+					updatePhoneNumber: z.boolean().meta({ description: "Check if there is a session and update the phone number. Eg: true" }).optional()
+				}),
+				metadata: { openapi: {
+					summary: "Verify phone number",
+					description: "Use this endpoint to verify phone number",
+					responses: {
+						"200": {
+							description: "Phone number verified successfully",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									status: {
+										type: "boolean",
+										description: "Indicates if the verification was successful",
+										enum: [true]
+									},
+									token: {
+										type: "string",
+										nullable: true,
+										description: "Session token if session is created, null if disableSession is true or no session is created"
+									},
+									user: {
+										type: "object",
+										nullable: true,
+										properties: {
+											id: {
+												type: "string",
+												description: "Unique identifier of the user"
+											},
+											email: {
+												type: "string",
+												format: "email",
+												nullable: true,
+												description: "User's email address"
+											},
+											emailVerified: {
+												type: "boolean",
+												nullable: true,
+												description: "Whether the email is verified"
+											},
+											name: {
+												type: "string",
+												nullable: true,
+												description: "User's name"
+											},
+											image: {
+												type: "string",
+												format: "uri",
+												nullable: true,
+												description: "User's profile image URL"
+											},
+											phoneNumber: {
+												type: "string",
+												description: "User's phone number"
+											},
+											phoneNumberVerified: {
+												type: "boolean",
+												description: "Whether the phone number is verified"
+											},
+											createdAt: {
+												type: "string",
+												format: "date-time",
+												description: "Timestamp when the user was created"
+											},
+											updatedAt: {
+												type: "string",
+												format: "date-time",
+												description: "Timestamp when the user was last updated"
+											}
+										},
+										required: [
+											"id",
+											"phoneNumber",
+											"phoneNumberVerified",
+											"createdAt",
+											"updatedAt"
+										],
+										description: "User object with phone number details, null if no user is created or found"
+									}
+								},
+								required: ["status"]
+							} } }
+						},
+						400: { description: "Invalid OTP" }
+					}
+				} }
+			}, async (ctx) => {
+				if (options?.verifyOTP) {
+					if (!await options.verifyOTP({
+						phoneNumber: ctx.body.phoneNumber,
+						code: ctx.body.code
+					}, ctx)) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });
+					const otp = await ctx.context.internalAdapter.findVerificationValue(ctx.body.phoneNumber);
+					if (otp) await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
+				} else {
+					const otp = await ctx.context.internalAdapter.findVerificationValue(ctx.body.phoneNumber);
+					if (!otp || otp.expiresAt < /* @__PURE__ */ new Date()) {
+						if (otp && otp.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_EXPIRED });
+						throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_NOT_FOUND });
+					}
+					const [otpValue, attempts] = otp.value.split(":");
+					const allowedAttempts = options?.allowedAttempts || 3;
+					if (attempts && parseInt(attempts) >= allowedAttempts) {
+						await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
+						throw new APIError("FORBIDDEN", { message: PHONE_NUMBER_ERROR_CODES.TOO_MANY_ATTEMPTS });
+					}
+					if (otpValue !== ctx.body.code) {
+						await ctx.context.internalAdapter.updateVerificationValue(otp.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
+						throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });
+					}
+					await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
+				}
+				if (ctx.body.updatePhoneNumber) {
+					const session = await getSessionFromCtx(ctx);
+					if (!session) throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
+					if ((await ctx.context.adapter.findMany({
+						model: "user",
+						where: [{
+							field: "phoneNumber",
+							value: ctx.body.phoneNumber
+						}]
+					})).length) throw ctx.error("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_EXIST });
+					let user$1 = await ctx.context.internalAdapter.updateUser(session.user.id, {
+						[opts.phoneNumber]: ctx.body.phoneNumber,
+						[opts.phoneNumberVerified]: true
+					});
+					return ctx.json({
+						status: true,
+						token: session.session.token,
+						user: {
+							id: user$1.id,
+							email: user$1.email,
+							emailVerified: user$1.emailVerified,
+							name: user$1.name,
+							image: user$1.image,
+							phoneNumber: user$1.phoneNumber,
+							phoneNumberVerified: user$1.phoneNumberVerified,
+							createdAt: user$1.createdAt,
+							updatedAt: user$1.updatedAt
+						}
+					});
+				}
+				let user = await ctx.context.adapter.findOne({
+					model: "user",
+					where: [{
+						value: ctx.body.phoneNumber,
+						field: opts.phoneNumber
+					}]
+				});
+				if (!user) {
+					if (options?.signUpOnVerification) {
+						user = await ctx.context.internalAdapter.createUser({
+							email: options.signUpOnVerification.getTempEmail(ctx.body.phoneNumber),
+							name: options.signUpOnVerification.getTempName ? options.signUpOnVerification.getTempName(ctx.body.phoneNumber) : ctx.body.phoneNumber,
+							[opts.phoneNumber]: ctx.body.phoneNumber,
+							[opts.phoneNumberVerified]: true
+						});
+						if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });
+					}
+				} else user = await ctx.context.internalAdapter.updateUser(user.id, { [opts.phoneNumberVerified]: true });
+				if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_UPDATE_USER });
+				await options?.callbackOnVerification?.({
+					phoneNumber: ctx.body.phoneNumber,
+					user
+				}, ctx);
+				if (!ctx.body.disableSession) {
+					const session = await ctx.context.internalAdapter.createSession(user.id);
+					if (!session) throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
+					await setSessionCookie(ctx, {
+						session,
+						user
+					});
+					return ctx.json({
+						status: true,
+						token: session.token,
+						user: {
+							id: user.id,
+							email: user.email,
+							emailVerified: user.emailVerified,
+							name: user.name,
+							image: user.image,
+							phoneNumber: user.phoneNumber,
+							phoneNumberVerified: user.phoneNumberVerified,
+							createdAt: user.createdAt,
+							updatedAt: user.updatedAt
+						}
+					});
+				}
+				return ctx.json({
+					status: true,
+					token: null,
+					user: {
+						id: user.id,
+						email: user.email,
+						emailVerified: user.emailVerified,
+						name: user.name,
+						image: user.image,
+						phoneNumber: user.phoneNumber,
+						phoneNumberVerified: user.phoneNumberVerified,
+						createdAt: user.createdAt,
+						updatedAt: user.updatedAt
+					}
+				});
+			}),
+			requestPasswordResetPhoneNumber: createAuthEndpoint("/phone-number/request-password-reset", {
+				method: "POST",
+				body: z.object({ phoneNumber: z.string() }),
+				metadata: { openapi: {
+					description: "Request OTP for password reset via phone number",
+					responses: { "200": {
+						description: "OTP sent successfully for password reset",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: {
+								type: "boolean",
+								description: "Indicates if the OTP was sent successfully",
+								enum: [true]
+							} },
+							required: ["status"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!await ctx.context.adapter.findOne({
+					model: "user",
+					where: [{
+						value: ctx.body.phoneNumber,
+						field: opts.phoneNumber
+					}]
+				})) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_NOT_EXIST });
+				const code = generateOTP(opts.otpLength);
+				await ctx.context.internalAdapter.createVerificationValue({
+					value: `${code}:0`,
+					identifier: `${ctx.body.phoneNumber}-request-password-reset`,
+					expiresAt: getDate(opts.expiresIn, "sec")
+				});
+				await options?.sendPasswordResetOTP?.({
+					phoneNumber: ctx.body.phoneNumber,
+					code
+				}, ctx);
+				return ctx.json({ status: true });
+			}),
+			resetPasswordPhoneNumber: createAuthEndpoint("/phone-number/reset-password", {
+				method: "POST",
+				body: z.object({
+					otp: z.string().meta({ description: "The one time password to reset the password. Eg: \"123456\"" }),
+					phoneNumber: z.string().meta({ description: "The phone number to the account which intends to reset the password for. Eg: \"+1234567890\"" }),
+					newPassword: z.string().meta({ description: `The new password. Eg: "new-and-secure-password"` })
+				}),
+				metadata: { openapi: {
+					description: "Reset password using phone number OTP",
+					responses: { "200": {
+						description: "Password reset successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: {
+								type: "boolean",
+								description: "Indicates if the password was reset successfully",
+								enum: [true]
+							} },
+							required: ["status"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const verification = await ctx.context.internalAdapter.findVerificationValue(`${ctx.body.phoneNumber}-request-password-reset`);
+				if (!verification) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_NOT_FOUND });
+				if (verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_EXPIRED });
+				const [otpValue, attempts] = verification.value.split(":");
+				const allowedAttempts = options?.allowedAttempts || 3;
+				if (attempts && parseInt(attempts) >= allowedAttempts) {
+					await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
+					throw new APIError("FORBIDDEN", { message: PHONE_NUMBER_ERROR_CODES.TOO_MANY_ATTEMPTS });
+				}
+				if (ctx.body.otp !== otpValue) {
+					await ctx.context.internalAdapter.updateVerificationValue(verification.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
+					throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });
+				}
+				const user = await ctx.context.adapter.findOne({
+					model: "user",
+					where: [{
+						field: "phoneNumber",
+						value: ctx.body.phoneNumber
+					}]
+				});
+				if (!user) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.UNEXPECTED_ERROR });
+				const hashedPassword = await ctx.context.password.hash(ctx.body.newPassword);
+				await ctx.context.internalAdapter.updatePassword(user.id, hashedPassword);
+				await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
+				return ctx.json({ status: true });
+			})
+		},
+		schema: mergeSchema(schema, options?.schema),
+		rateLimit: [{
+			pathMatcher(path) {
+				return path.startsWith("/phone-number");
+			},
+			window: 60 * 1e3,
+			max: 10
+		}],
+		$ERROR_CODES: PHONE_NUMBER_ERROR_CODES
+	};
+};
+
+//#endregion
+export { phoneNumber as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugin-helper-RJJBTOba.mjs.bak b/node_modules/better-auth/dist/plugin-helper-RJJBTOba.mjs.bak
new file mode 100644
index 0000000..6df3292
--- /dev/null
+++ b/node_modules/better-auth/dist/plugin-helper-RJJBTOba.mjs.bak
@@ -0,0 +1,16 @@
+import { APIError } from "better-call";
+
+//#region src/utils/plugin-helper.ts
+const getEndpointResponse = async (ctx) => {
+	const returned = ctx.context.returned;
+	if (!returned) return null;
+	if (returned instanceof Response) {
+		if (returned.status !== 200) return null;
+		return await returned.clone().json();
+	}
+	if (returned instanceof APIError) return null;
+	return returned;
+};
+
+//#endregion
+export { getEndpointResponse as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins-D9JjA_z3.mjs b/node_modules/better-auth/dist/plugins-D9JjA_z3.mjs
index 39a35d8..2c0da1f 100644
--- a/node_modules/better-auth/dist/plugins-D9JjA_z3.mjs
+++ b/node_modules/better-auth/dist/plugins-D9JjA_z3.mjs
@@ -150,18 +150,18 @@ function createApiKey({ keyGenerator, opts, schema: schema$1, deleteAllExpiredAp
 	return createAuthEndpoint("/api-key/create", {
 		method: "POST",
 		body: z.object({
-			name: z.string().meta({ description: "Name of the Api Key" }).optional(),
-			expiresIn: z.number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable().default(null),
-			userId: z.coerce.string().meta({ description: "User Id of the user that the Api Key belongs to. server-only. Eg: \"user-id\"" }).optional(),
-			prefix: z.string().meta({ description: "Prefix of the Api Key" }).regex(/^[a-zA-Z0-9_-]+$/, { message: "Invalid prefix format, must be alphanumeric and contain only underscores and hyphens." }).optional(),
-			remaining: z.number().meta({ description: "Remaining number of requests. Server side only" }).min(0).optional().nullable().default(null),
+			name: z.string().optional(),
+			expiresIn: z.number().min(1).optional().nullable().default(null),
+			userId: z.coerce.string().optional(),
+			prefix: z.string().regex(/^[a-zA-Z0-9_-]+$/, { message: "Invalid prefix format, must be alphanumeric and contain only underscores and hyphens." }).optional(),
+			remaining: z.number().min(0).optional().nullable().default(null),
 			metadata: z.any().optional(),
-			refillAmount: z.number().meta({ description: "Amount to refill the remaining count of the Api Key. server-only. Eg: 100" }).min(1).optional(),
-			refillInterval: z.number().meta({ description: "Interval to refill the Api Key in milliseconds. server-only. Eg: 1000" }).optional(),
-			rateLimitTimeWindow: z.number().meta({ description: "The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 1000" }).optional(),
-			rateLimitMax: z.number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
-			rateLimitEnabled: z.boolean().meta({ description: "Whether the key has rate limiting enabled. server-only. Eg: true" }).optional(),
-			permissions: z.record(z.string(), z.array(z.string())).meta({ description: "Permissions of the Api Key." }).optional()
+			refillAmount: z.number().min(1).optional(),
+			refillInterval: z.number().optional(),
+			rateLimitTimeWindow: z.number().optional(),
+			rateLimitMax: z.number().optional(),
+			rateLimitEnabled: z.boolean().optional(),
+			permissions: z.record(z.string(), z.array(z.string())).optional()
 		}),
 		metadata: { openapi: {
 			description: "Create a new API key for a user",
@@ -398,7 +398,7 @@ function deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys: deleteAllExp
 function deleteApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
 	return createAuthEndpoint("/api-key/delete", {
 		method: "POST",
-		body: z.object({ keyId: z.string().meta({ description: "The id of the Api Key" }) }),
+		body: z.object({ keyId: z.string() }),
 		use: [sessionMiddleware],
 		metadata: { openapi: {
 			description: "Delete an existing API key",
@@ -455,7 +455,7 @@ function deleteApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteA
 function getApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
 	return createAuthEndpoint("/api-key/get", {
 		method: "GET",
-		query: z.object({ id: z.string().meta({ description: "The id of the Api Key" }) }),
+		query: z.object({ id: z.string() }),
 		use: [sessionMiddleware],
 		metadata: { openapi: {
 			description: "Retrieve an existing API key by ID",
@@ -763,19 +763,19 @@ function updateApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteA
 	return createAuthEndpoint("/api-key/update", {
 		method: "POST",
 		body: z.object({
-			keyId: z.string().meta({ description: "The id of the Api Key" }),
-			userId: z.coerce.string().meta({ description: "The id of the user which the api key belongs to. server-only. Eg: \"some-user-id\"" }).optional(),
-			name: z.string().meta({ description: "The name of the key" }).optional(),
-			enabled: z.boolean().meta({ description: "Whether the Api Key is enabled or not" }).optional(),
-			remaining: z.number().meta({ description: "The number of remaining requests" }).min(1).optional(),
-			refillAmount: z.number().meta({ description: "The refill amount" }).optional(),
-			refillInterval: z.number().meta({ description: "The refill interval" }).optional(),
+			keyId: z.string(),
+			userId: z.coerce.string().optional(),
+			name: z.string().optional(),
+			enabled: z.boolean().optional(),
+			remaining: z.number().min(1).optional(),
+			refillAmount: z.number().optional(),
+			refillInterval: z.number().optional(),
 			metadata: z.any().optional(),
-			expiresIn: z.number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable(),
-			rateLimitEnabled: z.boolean().meta({ description: "Whether the key has rate limiting enabled." }).optional(),
-			rateLimitTimeWindow: z.number().meta({ description: "The duration in milliseconds where each request is counted. server-only. Eg: 1000" }).optional(),
-			rateLimitMax: z.number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
-			permissions: z.record(z.string(), z.array(z.string())).meta({ description: "Update the permissions on the API Key. server-only." }).optional().nullable()
+			expiresIn: z.number().min(1).optional().nullable(),
+			rateLimitEnabled: z.boolean().optional(),
+			rateLimitTimeWindow: z.number().optional(),
+			rateLimitMax: z.number().optional(),
+			permissions: z.record(z.string(), z.array(z.string())).optional().nullable()
 		}),
 		metadata: { openapi: {
 			description: "Update an existing API key by ID",
@@ -1151,8 +1151,8 @@ function verifyApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteA
 	return createAuthEndpoint("/api-key/verify", {
 		method: "POST",
 		body: z.object({
-			key: z.string().meta({ description: "The key to verify" }),
-			permissions: z.record(z.string(), z.array(z.string())).meta({ description: "The permissions to verify." }).optional()
+			key: z.string(),
+			permissions: z.record(z.string(), z.array(z.string())).optional()
 		}),
 		metadata: { SERVER_ONLY: true }
 	}, async (ctx) => {
@@ -2332,7 +2332,7 @@ const oneTimeToken = (options) => {
 			}),
 			verifyOneTimeToken: createAuthEndpoint("/one-time-token/verify", {
 				method: "POST",
-				body: z.object({ token: z.string().meta({ description: "The token to verify. Eg: \"some-token\"" }) })
+				body: z.object({ token: z.string() })
 			}, async (c) => {
 				const { token } = c.body;
 				const storedToken = await storeToken(c, token);
diff --git a/node_modules/better-auth/dist/plugins-D9JjA_z3.mjs.bak b/node_modules/better-auth/dist/plugins-D9JjA_z3.mjs.bak
new file mode 100644
index 0000000..39a35d8
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins-D9JjA_z3.mjs.bak
@@ -0,0 +1,2352 @@
+import { r as generateRandomString } from "./crypto-DZW3hrq1.mjs";
+import { t as mergeSchema, u as getDate } from "./schema-BevzneML.mjs";
+import { t as getIp } from "./get-request-ip-kbu825ez.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { t as getBaseURL } from "./url-SXU3XD3W.mjs";
+import { t as APIError$1 } from "./api-C0IsrmGz.mjs";
+import { l as parseSetCookieHeader } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx, u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { n as parser_default } from "./parser-DcrIEuXE.mjs";
+import { n as role } from "./access-6c2-Np4U.mjs";
+import { i as schema, r as oidcProvider } from "./oidc-provider-ComEKSEi.mjs";
+import { isProduction, logger } from "@better-auth/core/env";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createHash } from "@better-auth/utils/hash";
+import { SignJWT } from "jose";
+import { createAuthEndpoint, createAuthEndpoint as createAuthEndpoint$1, createAuthMiddleware, createAuthMiddleware as createAuthMiddleware$1, optionsMiddleware } from "@better-auth/core/api";
+import { base64, base64Url } from "@better-auth/utils/base64";
+import { getWebcryptoSubtle } from "@better-auth/utils";
+
+//#region src/plugins/api-key/schema.ts
+const apiKeySchema = ({ timeWindow, rateLimitMax }) => ({ apikey: { fields: {
+	name: {
+		type: "string",
+		required: false,
+		input: false
+	},
+	start: {
+		type: "string",
+		required: false,
+		input: false
+	},
+	prefix: {
+		type: "string",
+		required: false,
+		input: false
+	},
+	key: {
+		type: "string",
+		required: true,
+		input: false,
+		index: true
+	},
+	userId: {
+		type: "string",
+		references: {
+			model: "user",
+			field: "id",
+			onDelete: "cascade"
+		},
+		required: true,
+		input: false,
+		index: true
+	},
+	refillInterval: {
+		type: "number",
+		required: false,
+		input: false
+	},
+	refillAmount: {
+		type: "number",
+		required: false,
+		input: false
+	},
+	lastRefillAt: {
+		type: "date",
+		required: false,
+		input: false
+	},
+	enabled: {
+		type: "boolean",
+		required: false,
+		input: false,
+		defaultValue: true
+	},
+	rateLimitEnabled: {
+		type: "boolean",
+		required: false,
+		input: false,
+		defaultValue: true
+	},
+	rateLimitTimeWindow: {
+		type: "number",
+		required: false,
+		input: false,
+		defaultValue: timeWindow
+	},
+	rateLimitMax: {
+		type: "number",
+		required: false,
+		input: false,
+		defaultValue: rateLimitMax
+	},
+	requestCount: {
+		type: "number",
+		required: false,
+		input: false,
+		defaultValue: 0
+	},
+	remaining: {
+		type: "number",
+		required: false,
+		input: false
+	},
+	lastRequest: {
+		type: "date",
+		required: false,
+		input: false
+	},
+	expiresAt: {
+		type: "date",
+		required: false,
+		input: false
+	},
+	createdAt: {
+		type: "date",
+		required: true,
+		input: false
+	},
+	updatedAt: {
+		type: "date",
+		required: true,
+		input: false
+	},
+	permissions: {
+		type: "string",
+		required: false,
+		input: false
+	},
+	metadata: {
+		type: "string",
+		required: false,
+		input: true,
+		transform: {
+			input(value) {
+				return JSON.stringify(value);
+			},
+			output(value) {
+				if (!value) return null;
+				return parser_default(value);
+			}
+		}
+	}
+} } });
+
+//#endregion
+//#region src/plugins/api-key/routes/create-api-key.ts
+function createApiKey({ keyGenerator, opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
+	return createAuthEndpoint("/api-key/create", {
+		method: "POST",
+		body: z.object({
+			name: z.string().meta({ description: "Name of the Api Key" }).optional(),
+			expiresIn: z.number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable().default(null),
+			userId: z.coerce.string().meta({ description: "User Id of the user that the Api Key belongs to. server-only. Eg: \"user-id\"" }).optional(),
+			prefix: z.string().meta({ description: "Prefix of the Api Key" }).regex(/^[a-zA-Z0-9_-]+$/, { message: "Invalid prefix format, must be alphanumeric and contain only underscores and hyphens." }).optional(),
+			remaining: z.number().meta({ description: "Remaining number of requests. Server side only" }).min(0).optional().nullable().default(null),
+			metadata: z.any().optional(),
+			refillAmount: z.number().meta({ description: "Amount to refill the remaining count of the Api Key. server-only. Eg: 100" }).min(1).optional(),
+			refillInterval: z.number().meta({ description: "Interval to refill the Api Key in milliseconds. server-only. Eg: 1000" }).optional(),
+			rateLimitTimeWindow: z.number().meta({ description: "The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 1000" }).optional(),
+			rateLimitMax: z.number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
+			rateLimitEnabled: z.boolean().meta({ description: "Whether the key has rate limiting enabled. server-only. Eg: true" }).optional(),
+			permissions: z.record(z.string(), z.array(z.string())).meta({ description: "Permissions of the Api Key." }).optional()
+		}),
+		metadata: { openapi: {
+			description: "Create a new API key for a user",
+			responses: { "200": {
+				description: "API key created successfully",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						id: {
+							type: "string",
+							description: "Unique identifier of the API key"
+						},
+						createdAt: {
+							type: "string",
+							format: "date-time",
+							description: "Creation timestamp"
+						},
+						updatedAt: {
+							type: "string",
+							format: "date-time",
+							description: "Last update timestamp"
+						},
+						name: {
+							type: "string",
+							nullable: true,
+							description: "Name of the API key"
+						},
+						prefix: {
+							type: "string",
+							nullable: true,
+							description: "Prefix of the API key"
+						},
+						start: {
+							type: "string",
+							nullable: true,
+							description: "Starting characters of the key (if configured)"
+						},
+						key: {
+							type: "string",
+							description: "The full API key (only returned on creation)"
+						},
+						enabled: {
+							type: "boolean",
+							description: "Whether the key is enabled"
+						},
+						expiresAt: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "Expiration timestamp"
+						},
+						userId: {
+							type: "string",
+							description: "ID of the user owning the key"
+						},
+						lastRefillAt: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "Last refill timestamp"
+						},
+						lastRequest: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "Last request timestamp"
+						},
+						metadata: {
+							type: "object",
+							nullable: true,
+							additionalProperties: true,
+							description: "Metadata associated with the key"
+						},
+						rateLimitMax: {
+							type: "number",
+							nullable: true,
+							description: "Maximum requests in time window"
+						},
+						rateLimitTimeWindow: {
+							type: "number",
+							nullable: true,
+							description: "Rate limit time window in milliseconds"
+						},
+						remaining: {
+							type: "number",
+							nullable: true,
+							description: "Remaining requests"
+						},
+						refillAmount: {
+							type: "number",
+							nullable: true,
+							description: "Amount to refill"
+						},
+						refillInterval: {
+							type: "number",
+							nullable: true,
+							description: "Refill interval in milliseconds"
+						},
+						rateLimitEnabled: {
+							type: "boolean",
+							description: "Whether rate limiting is enabled"
+						},
+						requestCount: {
+							type: "number",
+							description: "Current request count in window"
+						},
+						permissions: {
+							type: "object",
+							nullable: true,
+							additionalProperties: {
+								type: "array",
+								items: { type: "string" }
+							},
+							description: "Permissions associated with the key"
+						}
+					},
+					required: [
+						"id",
+						"createdAt",
+						"updatedAt",
+						"key",
+						"enabled",
+						"userId",
+						"rateLimitEnabled",
+						"requestCount"
+					]
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		const { name, expiresIn, prefix, remaining, metadata, refillAmount, refillInterval, permissions, rateLimitMax, rateLimitTimeWindow, rateLimitEnabled } = ctx.body;
+		const session = await getSessionFromCtx(ctx);
+		const authRequired = ctx.request || ctx.headers;
+		const user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };
+		if (!user?.id) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
+		if (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
+		if (authRequired) {
+			if (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || permissions !== void 0 || remaining !== null) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });
+		}
+		if (metadata) {
+			if (opts.enableMetadata === false) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.METADATA_DISABLED });
+			if (typeof metadata !== "object") throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_METADATA_TYPE });
+		}
+		if (refillAmount && !refillInterval) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });
+		if (refillInterval && !refillAmount) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });
+		if (expiresIn) {
+			if (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });
+			const expiresIn_in_days = expiresIn / (3600 * 24);
+			if (opts.keyExpiration.minExpiresIn > expiresIn_in_days) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });
+			else if (opts.keyExpiration.maxExpiresIn < expiresIn_in_days) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });
+		}
+		if (prefix) {
+			if (prefix.length < opts.minimumPrefixLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });
+			if (prefix.length > opts.maximumPrefixLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });
+		}
+		if (name) {
+			if (name.length < opts.minimumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
+			if (name.length > opts.maximumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
+		} else if (opts.requireName) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.NAME_REQUIRED });
+		deleteAllExpiredApiKeys$1(ctx.context);
+		const key = await keyGenerator({
+			length: opts.defaultKeyLength,
+			prefix: prefix || opts.defaultPrefix
+		});
+		const hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);
+		let start = null;
+		if (opts.startingCharactersConfig.shouldStore) start = key.substring(0, opts.startingCharactersConfig.charactersLength);
+		const defaultPermissions = opts.permissions?.defaultPermissions ? typeof opts.permissions.defaultPermissions === "function" ? await opts.permissions.defaultPermissions(user.id, ctx) : opts.permissions.defaultPermissions : void 0;
+		const permissionsToApply = permissions ? JSON.stringify(permissions) : defaultPermissions ? JSON.stringify(defaultPermissions) : void 0;
+		let data = {
+			createdAt: /* @__PURE__ */ new Date(),
+			updatedAt: /* @__PURE__ */ new Date(),
+			name: name ?? null,
+			prefix: prefix ?? opts.defaultPrefix ?? null,
+			start,
+			key: hashed,
+			enabled: true,
+			expiresAt: expiresIn ? getDate(expiresIn, "sec") : opts.keyExpiration.defaultExpiresIn ? getDate(opts.keyExpiration.defaultExpiresIn, "sec") : null,
+			userId: user.id,
+			lastRefillAt: null,
+			lastRequest: null,
+			metadata: null,
+			rateLimitMax: rateLimitMax ?? opts.rateLimit.maxRequests ?? null,
+			rateLimitTimeWindow: rateLimitTimeWindow ?? opts.rateLimit.timeWindow ?? null,
+			remaining: remaining === null ? remaining : remaining ?? refillAmount ?? null,
+			refillAmount: refillAmount ?? null,
+			refillInterval: refillInterval ?? null,
+			rateLimitEnabled: rateLimitEnabled === void 0 ? opts.rateLimit.enabled ?? true : rateLimitEnabled,
+			requestCount: 0,
+			permissions: permissionsToApply
+		};
+		if (metadata) data.metadata = schema$1.apikey.fields.metadata.transform.input(metadata);
+		const apiKey$1 = await ctx.context.adapter.create({
+			model: API_KEY_TABLE_NAME,
+			data
+		});
+		return ctx.json({
+			...apiKey$1,
+			key,
+			metadata: metadata ?? null,
+			permissions: apiKey$1.permissions ? safeJSONParse(apiKey$1.permissions) : null
+		});
+	});
+}
+
+//#endregion
+//#region src/plugins/api-key/routes/delete-all-expired-api-keys.ts
+function deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
+	return createAuthEndpoint("/api-key/delete-all-expired-api-keys", {
+		method: "POST",
+		metadata: {
+			SERVER_ONLY: true,
+			client: false
+		}
+	}, async (ctx) => {
+		try {
+			await deleteAllExpiredApiKeys$1(ctx.context, true);
+		} catch (error) {
+			ctx.context.logger.error("[API KEY PLUGIN] Failed to delete expired API keys:", error);
+			return ctx.json({
+				success: false,
+				error
+			});
+		}
+		return ctx.json({
+			success: true,
+			error: null
+		});
+	});
+}
+
+//#endregion
+//#region src/plugins/api-key/routes/delete-api-key.ts
+function deleteApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
+	return createAuthEndpoint("/api-key/delete", {
+		method: "POST",
+		body: z.object({ keyId: z.string().meta({ description: "The id of the Api Key" }) }),
+		use: [sessionMiddleware],
+		metadata: { openapi: {
+			description: "Delete an existing API key",
+			requestBody: { content: { "application/json": { schema: {
+				type: "object",
+				properties: { keyId: {
+					type: "string",
+					description: "The id of the API key to delete"
+				} },
+				required: ["keyId"]
+			} } } },
+			responses: { "200": {
+				description: "API key deleted successfully",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: { success: {
+						type: "boolean",
+						description: "Indicates if the API key was successfully deleted"
+					} },
+					required: ["success"]
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		const { keyId } = ctx.body;
+		const session = ctx.context.session;
+		if (session.user.banned === true) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.USER_BANNED });
+		const apiKey$1 = await ctx.context.adapter.findOne({
+			model: API_KEY_TABLE_NAME,
+			where: [{
+				field: "id",
+				value: keyId
+			}]
+		});
+		if (!apiKey$1 || apiKey$1.userId !== session.user.id) throw new APIError$1("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
+		try {
+			await ctx.context.adapter.delete({
+				model: API_KEY_TABLE_NAME,
+				where: [{
+					field: "id",
+					value: apiKey$1.id
+				}]
+			});
+		} catch (error) {
+			throw new APIError$1("INTERNAL_SERVER_ERROR", { message: error?.message });
+		}
+		deleteAllExpiredApiKeys$1(ctx.context);
+		return ctx.json({ success: true });
+	});
+}
+
+//#endregion
+//#region src/plugins/api-key/routes/get-api-key.ts
+function getApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
+	return createAuthEndpoint("/api-key/get", {
+		method: "GET",
+		query: z.object({ id: z.string().meta({ description: "The id of the Api Key" }) }),
+		use: [sessionMiddleware],
+		metadata: { openapi: {
+			description: "Retrieve an existing API key by ID",
+			responses: { "200": {
+				description: "API key retrieved successfully",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						id: {
+							type: "string",
+							description: "ID"
+						},
+						name: {
+							type: "string",
+							nullable: true,
+							description: "The name of the key"
+						},
+						start: {
+							type: "string",
+							nullable: true,
+							description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
+						},
+						prefix: {
+							type: "string",
+							nullable: true,
+							description: "The API Key prefix. Stored as plain text."
+						},
+						userId: {
+							type: "string",
+							description: "The owner of the user id"
+						},
+						refillInterval: {
+							type: "number",
+							nullable: true,
+							description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
+						},
+						refillAmount: {
+							type: "number",
+							nullable: true,
+							description: "The amount to refill"
+						},
+						lastRefillAt: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "The last refill date"
+						},
+						enabled: {
+							type: "boolean",
+							description: "Sets if key is enabled or disabled",
+							default: true
+						},
+						rateLimitEnabled: {
+							type: "boolean",
+							description: "Whether the key has rate limiting enabled"
+						},
+						rateLimitTimeWindow: {
+							type: "number",
+							nullable: true,
+							description: "The duration in milliseconds"
+						},
+						rateLimitMax: {
+							type: "number",
+							nullable: true,
+							description: "Maximum amount of requests allowed within a window"
+						},
+						requestCount: {
+							type: "number",
+							description: "The number of requests made within the rate limit time window"
+						},
+						remaining: {
+							type: "number",
+							nullable: true,
+							description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
+						},
+						lastRequest: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "When last request occurred"
+						},
+						expiresAt: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "Expiry date of a key"
+						},
+						createdAt: {
+							type: "string",
+							format: "date-time",
+							description: "created at"
+						},
+						updatedAt: {
+							type: "string",
+							format: "date-time",
+							description: "updated at"
+						},
+						metadata: {
+							type: "object",
+							nullable: true,
+							additionalProperties: true,
+							description: "Extra metadata about the apiKey"
+						},
+						permissions: {
+							type: "string",
+							nullable: true,
+							description: "Permissions for the api key (stored as JSON string)"
+						}
+					},
+					required: [
+						"id",
+						"userId",
+						"enabled",
+						"rateLimitEnabled",
+						"requestCount",
+						"createdAt",
+						"updatedAt"
+					]
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		const { id } = ctx.query;
+		const session = ctx.context.session;
+		let apiKey$1 = await ctx.context.adapter.findOne({
+			model: API_KEY_TABLE_NAME,
+			where: [{
+				field: "id",
+				value: id
+			}, {
+				field: "userId",
+				value: session.user.id
+			}]
+		});
+		if (!apiKey$1) throw new APIError$1("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
+		deleteAllExpiredApiKeys$1(ctx.context);
+		apiKey$1.metadata = schema$1.apikey.fields.metadata.transform.output(apiKey$1.metadata);
+		const { key,...returningApiKey } = apiKey$1;
+		return ctx.json({
+			...returningApiKey,
+			permissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null
+		});
+	});
+}
+
+//#endregion
+//#region src/plugins/api-key/routes/list-api-keys.ts
+function listApiKeys({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
+	return createAuthEndpoint("/api-key/list", {
+		method: "GET",
+		use: [sessionMiddleware],
+		metadata: { openapi: {
+			description: "List all API keys for the authenticated user",
+			responses: { "200": {
+				description: "API keys retrieved successfully",
+				content: { "application/json": { schema: {
+					type: "array",
+					items: {
+						type: "object",
+						properties: {
+							id: {
+								type: "string",
+								description: "ID"
+							},
+							name: {
+								type: "string",
+								nullable: true,
+								description: "The name of the key"
+							},
+							start: {
+								type: "string",
+								nullable: true,
+								description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
+							},
+							prefix: {
+								type: "string",
+								nullable: true,
+								description: "The API Key prefix. Stored as plain text."
+							},
+							userId: {
+								type: "string",
+								description: "The owner of the user id"
+							},
+							refillInterval: {
+								type: "number",
+								nullable: true,
+								description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
+							},
+							refillAmount: {
+								type: "number",
+								nullable: true,
+								description: "The amount to refill"
+							},
+							lastRefillAt: {
+								type: "string",
+								format: "date-time",
+								nullable: true,
+								description: "The last refill date"
+							},
+							enabled: {
+								type: "boolean",
+								description: "Sets if key is enabled or disabled",
+								default: true
+							},
+							rateLimitEnabled: {
+								type: "boolean",
+								description: "Whether the key has rate limiting enabled"
+							},
+							rateLimitTimeWindow: {
+								type: "number",
+								nullable: true,
+								description: "The duration in milliseconds"
+							},
+							rateLimitMax: {
+								type: "number",
+								nullable: true,
+								description: "Maximum amount of requests allowed within a window"
+							},
+							requestCount: {
+								type: "number",
+								description: "The number of requests made within the rate limit time window"
+							},
+							remaining: {
+								type: "number",
+								nullable: true,
+								description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
+							},
+							lastRequest: {
+								type: "string",
+								format: "date-time",
+								nullable: true,
+								description: "When last request occurred"
+							},
+							expiresAt: {
+								type: "string",
+								format: "date-time",
+								nullable: true,
+								description: "Expiry date of a key"
+							},
+							createdAt: {
+								type: "string",
+								format: "date-time",
+								description: "created at"
+							},
+							updatedAt: {
+								type: "string",
+								format: "date-time",
+								description: "updated at"
+							},
+							metadata: {
+								type: "object",
+								nullable: true,
+								additionalProperties: true,
+								description: "Extra metadata about the apiKey"
+							},
+							permissions: {
+								type: "string",
+								nullable: true,
+								description: "Permissions for the api key (stored as JSON string)"
+							}
+						},
+						required: [
+							"id",
+							"userId",
+							"enabled",
+							"rateLimitEnabled",
+							"requestCount",
+							"createdAt",
+							"updatedAt"
+						]
+					}
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		const session = ctx.context.session;
+		let apiKeys = await ctx.context.adapter.findMany({
+			model: API_KEY_TABLE_NAME,
+			where: [{
+				field: "userId",
+				value: session.user.id
+			}]
+		});
+		deleteAllExpiredApiKeys$1(ctx.context);
+		apiKeys = apiKeys.map((apiKey$1) => {
+			return {
+				...apiKey$1,
+				metadata: schema$1.apikey.fields.metadata.transform.output(apiKey$1.metadata)
+			};
+		});
+		let returningApiKey = apiKeys.map((x) => {
+			const { key,...returningApiKey$1 } = x;
+			return {
+				...returningApiKey$1,
+				permissions: returningApiKey$1.permissions ? safeJSONParse(returningApiKey$1.permissions) : null
+			};
+		});
+		return ctx.json(returningApiKey);
+	});
+}
+
+//#endregion
+//#region src/plugins/api-key/routes/update-api-key.ts
+function updateApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
+	return createAuthEndpoint("/api-key/update", {
+		method: "POST",
+		body: z.object({
+			keyId: z.string().meta({ description: "The id of the Api Key" }),
+			userId: z.coerce.string().meta({ description: "The id of the user which the api key belongs to. server-only. Eg: \"some-user-id\"" }).optional(),
+			name: z.string().meta({ description: "The name of the key" }).optional(),
+			enabled: z.boolean().meta({ description: "Whether the Api Key is enabled or not" }).optional(),
+			remaining: z.number().meta({ description: "The number of remaining requests" }).min(1).optional(),
+			refillAmount: z.number().meta({ description: "The refill amount" }).optional(),
+			refillInterval: z.number().meta({ description: "The refill interval" }).optional(),
+			metadata: z.any().optional(),
+			expiresIn: z.number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable(),
+			rateLimitEnabled: z.boolean().meta({ description: "Whether the key has rate limiting enabled." }).optional(),
+			rateLimitTimeWindow: z.number().meta({ description: "The duration in milliseconds where each request is counted. server-only. Eg: 1000" }).optional(),
+			rateLimitMax: z.number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
+			permissions: z.record(z.string(), z.array(z.string())).meta({ description: "Update the permissions on the API Key. server-only." }).optional().nullable()
+		}),
+		metadata: { openapi: {
+			description: "Update an existing API key by ID",
+			responses: { "200": {
+				description: "API key updated successfully",
+				content: { "application/json": { schema: {
+					type: "object",
+					properties: {
+						id: {
+							type: "string",
+							description: "ID"
+						},
+						name: {
+							type: "string",
+							nullable: true,
+							description: "The name of the key"
+						},
+						start: {
+							type: "string",
+							nullable: true,
+							description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
+						},
+						prefix: {
+							type: "string",
+							nullable: true,
+							description: "The API Key prefix. Stored as plain text."
+						},
+						userId: {
+							type: "string",
+							description: "The owner of the user id"
+						},
+						refillInterval: {
+							type: "number",
+							nullable: true,
+							description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
+						},
+						refillAmount: {
+							type: "number",
+							nullable: true,
+							description: "The amount to refill"
+						},
+						lastRefillAt: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "The last refill date"
+						},
+						enabled: {
+							type: "boolean",
+							description: "Sets if key is enabled or disabled",
+							default: true
+						},
+						rateLimitEnabled: {
+							type: "boolean",
+							description: "Whether the key has rate limiting enabled"
+						},
+						rateLimitTimeWindow: {
+							type: "number",
+							nullable: true,
+							description: "The duration in milliseconds"
+						},
+						rateLimitMax: {
+							type: "number",
+							nullable: true,
+							description: "Maximum amount of requests allowed within a window"
+						},
+						requestCount: {
+							type: "number",
+							description: "The number of requests made within the rate limit time window"
+						},
+						remaining: {
+							type: "number",
+							nullable: true,
+							description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
+						},
+						lastRequest: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "When last request occurred"
+						},
+						expiresAt: {
+							type: "string",
+							format: "date-time",
+							nullable: true,
+							description: "Expiry date of a key"
+						},
+						createdAt: {
+							type: "string",
+							format: "date-time",
+							description: "created at"
+						},
+						updatedAt: {
+							type: "string",
+							format: "date-time",
+							description: "updated at"
+						},
+						metadata: {
+							type: "object",
+							nullable: true,
+							additionalProperties: true,
+							description: "Extra metadata about the apiKey"
+						},
+						permissions: {
+							type: "string",
+							nullable: true,
+							description: "Permissions for the api key (stored as JSON string)"
+						}
+					},
+					required: [
+						"id",
+						"userId",
+						"enabled",
+						"rateLimitEnabled",
+						"requestCount",
+						"createdAt",
+						"updatedAt"
+					]
+				} } }
+			} }
+		} }
+	}, async (ctx) => {
+		const { keyId, expiresIn, enabled, metadata, refillAmount, refillInterval, remaining, name, permissions, rateLimitEnabled, rateLimitTimeWindow, rateLimitMax } = ctx.body;
+		const session = await getSessionFromCtx(ctx);
+		const authRequired = ctx.request || ctx.headers;
+		const user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };
+		if (!user?.id) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
+		if (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
+		if (authRequired) {
+			if (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || remaining !== void 0 || permissions !== void 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });
+		}
+		const apiKey$1 = await ctx.context.adapter.findOne({
+			model: API_KEY_TABLE_NAME,
+			where: [{
+				field: "id",
+				value: keyId
+			}, {
+				field: "userId",
+				value: user.id
+			}]
+		});
+		if (!apiKey$1) throw new APIError$1("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
+		let newValues = {};
+		if (name !== void 0) {
+			if (name.length < opts.minimumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
+			else if (name.length > opts.maximumNameLength) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
+			newValues.name = name;
+		}
+		if (enabled !== void 0) newValues.enabled = enabled;
+		if (expiresIn !== void 0) {
+			if (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });
+			if (expiresIn !== null) {
+				const expiresIn_in_days = expiresIn / (3600 * 24);
+				if (expiresIn_in_days < opts.keyExpiration.minExpiresIn) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });
+				else if (expiresIn_in_days > opts.keyExpiration.maxExpiresIn) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });
+			}
+			newValues.expiresAt = expiresIn ? getDate(expiresIn, "sec") : null;
+		}
+		if (metadata !== void 0) {
+			if (typeof metadata !== "object") throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_METADATA_TYPE });
+			newValues.metadata = schema$1.apikey.fields.metadata.transform.input(metadata);
+		}
+		if (remaining !== void 0) newValues.remaining = remaining;
+		if (refillAmount !== void 0 || refillInterval !== void 0) {
+			if (refillAmount !== void 0 && refillInterval === void 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });
+			else if (refillInterval !== void 0 && refillAmount === void 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });
+			newValues.refillAmount = refillAmount;
+			newValues.refillInterval = refillInterval;
+		}
+		if (rateLimitEnabled !== void 0) newValues.rateLimitEnabled = rateLimitEnabled;
+		if (rateLimitTimeWindow !== void 0) newValues.rateLimitTimeWindow = rateLimitTimeWindow;
+		if (rateLimitMax !== void 0) newValues.rateLimitMax = rateLimitMax;
+		if (permissions !== void 0) newValues.permissions = JSON.stringify(permissions);
+		if (Object.keys(newValues).length === 0) throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.NO_VALUES_TO_UPDATE });
+		let newApiKey = apiKey$1;
+		try {
+			let result = await ctx.context.adapter.update({
+				model: API_KEY_TABLE_NAME,
+				where: [{
+					field: "id",
+					value: apiKey$1.id
+				}],
+				update: { ...newValues }
+			});
+			if (result) newApiKey = result;
+		} catch (error) {
+			throw new APIError$1("INTERNAL_SERVER_ERROR", { message: error?.message });
+		}
+		deleteAllExpiredApiKeys$1(ctx.context);
+		newApiKey.metadata = schema$1.apikey.fields.metadata.transform.output(newApiKey.metadata);
+		const { key,...returningApiKey } = newApiKey;
+		return ctx.json({
+			...returningApiKey,
+			permissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null
+		});
+	});
+}
+
+//#endregion
+//#region src/plugins/api-key/rate-limit.ts
+/**
+* Determines if a request is allowed based on rate limiting parameters.
+*
+* @returns An object indicating whether the request is allowed and, if not,
+*          a message and updated ApiKey data.
+*/
+function isRateLimited(apiKey$1, opts) {
+	const now = /* @__PURE__ */ new Date();
+	const lastRequest = apiKey$1.lastRequest;
+	const rateLimitTimeWindow = apiKey$1.rateLimitTimeWindow;
+	const rateLimitMax = apiKey$1.rateLimitMax;
+	let requestCount = apiKey$1.requestCount;
+	if (opts.rateLimit.enabled === false) return {
+		success: true,
+		message: null,
+		update: { lastRequest: now },
+		tryAgainIn: null
+	};
+	if (apiKey$1.rateLimitEnabled === false) return {
+		success: true,
+		message: null,
+		update: { lastRequest: now },
+		tryAgainIn: null
+	};
+	if (rateLimitTimeWindow === null || rateLimitMax === null) return {
+		success: true,
+		message: null,
+		update: null,
+		tryAgainIn: null
+	};
+	if (lastRequest === null) return {
+		success: true,
+		message: null,
+		update: {
+			lastRequest: now,
+			requestCount: 1
+		},
+		tryAgainIn: null
+	};
+	const timeSinceLastRequest = now.getTime() - new Date(lastRequest).getTime();
+	if (timeSinceLastRequest > rateLimitTimeWindow) return {
+		success: true,
+		message: null,
+		update: {
+			lastRequest: now,
+			requestCount: 1
+		},
+		tryAgainIn: null
+	};
+	if (requestCount >= rateLimitMax) return {
+		success: false,
+		message: ERROR_CODES.RATE_LIMIT_EXCEEDED,
+		update: null,
+		tryAgainIn: Math.ceil(rateLimitTimeWindow - timeSinceLastRequest)
+	};
+	requestCount++;
+	return {
+		success: true,
+		message: null,
+		tryAgainIn: null,
+		update: {
+			lastRequest: now,
+			requestCount
+		}
+	};
+}
+
+//#endregion
+//#region src/plugins/api-key/routes/verify-api-key.ts
+async function validateApiKey({ hashedKey, ctx, opts, schema: schema$1, permissions }) {
+	const apiKey$1 = await ctx.context.adapter.findOne({
+		model: API_KEY_TABLE_NAME,
+		where: [{
+			field: "key",
+			value: hashedKey
+		}]
+	});
+	if (!apiKey$1) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.INVALID_API_KEY });
+	if (apiKey$1.enabled === false) throw new APIError$1("UNAUTHORIZED", {
+		message: ERROR_CODES.KEY_DISABLED,
+		code: "KEY_DISABLED"
+	});
+	if (apiKey$1.expiresAt) {
+		if (Date.now() > new Date(apiKey$1.expiresAt).getTime()) {
+			try {
+				ctx.context.adapter.delete({
+					model: API_KEY_TABLE_NAME,
+					where: [{
+						field: "id",
+						value: apiKey$1.id
+					}]
+				});
+			} catch (error) {
+				ctx.context.logger.error(`Failed to delete expired API keys:`, error);
+			}
+			throw new APIError$1("UNAUTHORIZED", {
+				message: ERROR_CODES.KEY_EXPIRED,
+				code: "KEY_EXPIRED"
+			});
+		}
+	}
+	if (permissions) {
+		const apiKeyPermissions = apiKey$1.permissions ? safeJSONParse(apiKey$1.permissions) : null;
+		if (!apiKeyPermissions) throw new APIError$1("UNAUTHORIZED", {
+			message: ERROR_CODES.KEY_NOT_FOUND,
+			code: "KEY_NOT_FOUND"
+		});
+		if (!role(apiKeyPermissions).authorize(permissions).success) throw new APIError$1("UNAUTHORIZED", {
+			message: ERROR_CODES.KEY_NOT_FOUND,
+			code: "KEY_NOT_FOUND"
+		});
+	}
+	let remaining = apiKey$1.remaining;
+	let lastRefillAt = apiKey$1.lastRefillAt;
+	if (apiKey$1.remaining === 0 && apiKey$1.refillAmount === null) {
+		try {
+			ctx.context.adapter.delete({
+				model: API_KEY_TABLE_NAME,
+				where: [{
+					field: "id",
+					value: apiKey$1.id
+				}]
+			});
+		} catch (error) {
+			ctx.context.logger.error(`Failed to delete expired API keys:`, error);
+		}
+		throw new APIError$1("TOO_MANY_REQUESTS", {
+			message: ERROR_CODES.USAGE_EXCEEDED,
+			code: "USAGE_EXCEEDED"
+		});
+	} else if (remaining !== null) {
+		let now = Date.now();
+		const refillInterval = apiKey$1.refillInterval;
+		const refillAmount = apiKey$1.refillAmount;
+		let lastTime = new Date(lastRefillAt ?? apiKey$1.createdAt).getTime();
+		if (refillInterval && refillAmount) {
+			if (now - lastTime > refillInterval) {
+				remaining = refillAmount;
+				lastRefillAt = /* @__PURE__ */ new Date();
+			}
+		}
+		if (remaining === 0) throw new APIError$1("TOO_MANY_REQUESTS", {
+			message: ERROR_CODES.USAGE_EXCEEDED,
+			code: "USAGE_EXCEEDED"
+		});
+		else remaining--;
+	}
+	const { message, success, update, tryAgainIn } = isRateLimited(apiKey$1, opts);
+	const newApiKey = await ctx.context.adapter.update({
+		model: API_KEY_TABLE_NAME,
+		where: [{
+			field: "id",
+			value: apiKey$1.id
+		}],
+		update: {
+			...update,
+			remaining,
+			lastRefillAt
+		}
+	});
+	if (!newApiKey) throw new APIError$1("INTERNAL_SERVER_ERROR", {
+		message: ERROR_CODES.FAILED_TO_UPDATE_API_KEY,
+		code: "INTERNAL_SERVER_ERROR"
+	});
+	if (success === false) throw new APIError$1("UNAUTHORIZED", {
+		message: message ?? void 0,
+		code: "RATE_LIMITED",
+		details: { tryAgainIn }
+	});
+	return newApiKey;
+}
+function verifyApiKey({ opts, schema: schema$1, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys$1 }) {
+	return createAuthEndpoint("/api-key/verify", {
+		method: "POST",
+		body: z.object({
+			key: z.string().meta({ description: "The key to verify" }),
+			permissions: z.record(z.string(), z.array(z.string())).meta({ description: "The permissions to verify." }).optional()
+		}),
+		metadata: { SERVER_ONLY: true }
+	}, async (ctx) => {
+		const { key } = ctx.body;
+		if (key.length < opts.defaultKeyLength) return ctx.json({
+			valid: false,
+			error: {
+				message: ERROR_CODES.INVALID_API_KEY,
+				code: "KEY_NOT_FOUND"
+			},
+			key: null
+		});
+		if (opts.customAPIKeyValidator) {
+			if (!await opts.customAPIKeyValidator({
+				ctx,
+				key
+			})) return ctx.json({
+				valid: false,
+				error: {
+					message: ERROR_CODES.INVALID_API_KEY,
+					code: "KEY_NOT_FOUND"
+				},
+				key: null
+			});
+		}
+		const hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);
+		let apiKey$1 = null;
+		try {
+			apiKey$1 = await validateApiKey({
+				hashedKey: hashed,
+				permissions: ctx.body.permissions,
+				ctx,
+				opts,
+				schema: schema$1
+			});
+			await deleteAllExpiredApiKeys$1(ctx.context);
+		} catch (error) {
+			if (error instanceof APIError$1) return ctx.json({
+				valid: false,
+				error: {
+					message: error.body?.message,
+					code: error.body?.code
+				},
+				key: null
+			});
+			return ctx.json({
+				valid: false,
+				error: {
+					message: ERROR_CODES.INVALID_API_KEY,
+					code: "INVALID_API_KEY"
+				},
+				key: null
+			});
+		}
+		const { key: _,...returningApiKey } = apiKey$1 ?? {
+			key: 1,
+			permissions: void 0
+		};
+		if ("metadata" in returningApiKey) returningApiKey.metadata = schema$1.apikey.fields.metadata.transform.output(returningApiKey.metadata);
+		returningApiKey.permissions = returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null;
+		return ctx.json({
+			valid: true,
+			error: null,
+			key: apiKey$1 === null ? null : returningApiKey
+		});
+	});
+}
+
+//#endregion
+//#region src/plugins/api-key/routes/index.ts
+let lastChecked = null;
+async function deleteAllExpiredApiKeys(ctx, byPassLastCheckTime = false) {
+	if (lastChecked && !byPassLastCheckTime) {
+		if ((/* @__PURE__ */ new Date()).getTime() - lastChecked.getTime() < 1e4) return;
+	}
+	lastChecked = /* @__PURE__ */ new Date();
+	await ctx.adapter.deleteMany({
+		model: API_KEY_TABLE_NAME,
+		where: [{
+			field: "expiresAt",
+			operator: "lt",
+			value: /* @__PURE__ */ new Date()
+		}, {
+			field: "expiresAt",
+			operator: "ne",
+			value: null
+		}]
+	}).catch((error) => {
+		ctx.logger.error(`Failed to delete expired API keys:`, error);
+	});
+}
+function createApiKeyRoutes({ keyGenerator, opts, schema: schema$1 }) {
+	return {
+		createApiKey: createApiKey({
+			keyGenerator,
+			opts,
+			schema: schema$1,
+			deleteAllExpiredApiKeys
+		}),
+		verifyApiKey: verifyApiKey({
+			opts,
+			schema: schema$1,
+			deleteAllExpiredApiKeys
+		}),
+		getApiKey: getApiKey({
+			opts,
+			schema: schema$1,
+			deleteAllExpiredApiKeys
+		}),
+		updateApiKey: updateApiKey({
+			opts,
+			schema: schema$1,
+			deleteAllExpiredApiKeys
+		}),
+		deleteApiKey: deleteApiKey({
+			opts,
+			schema: schema$1,
+			deleteAllExpiredApiKeys
+		}),
+		listApiKeys: listApiKeys({
+			opts,
+			schema: schema$1,
+			deleteAllExpiredApiKeys
+		}),
+		deleteAllExpiredApiKeys: deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys })
+	};
+}
+
+//#endregion
+//#region src/plugins/api-key/index.ts
+const defaultKeyHasher = async (key) => {
+	const hash = await createHash("SHA-256").digest(new TextEncoder().encode(key));
+	return base64Url.encode(new Uint8Array(hash), { padding: false });
+};
+const ERROR_CODES = defineErrorCodes({
+	INVALID_METADATA_TYPE: "metadata must be an object or undefined",
+	REFILL_AMOUNT_AND_INTERVAL_REQUIRED: "refillAmount is required when refillInterval is provided",
+	REFILL_INTERVAL_AND_AMOUNT_REQUIRED: "refillInterval is required when refillAmount is provided",
+	USER_BANNED: "User is banned",
+	UNAUTHORIZED_SESSION: "Unauthorized or invalid session",
+	KEY_NOT_FOUND: "API Key not found",
+	KEY_DISABLED: "API Key is disabled",
+	KEY_EXPIRED: "API Key has expired",
+	USAGE_EXCEEDED: "API Key has reached its usage limit",
+	KEY_NOT_RECOVERABLE: "API Key is not recoverable",
+	EXPIRES_IN_IS_TOO_SMALL: "The expiresIn is smaller than the predefined minimum value.",
+	EXPIRES_IN_IS_TOO_LARGE: "The expiresIn is larger than the predefined maximum value.",
+	INVALID_REMAINING: "The remaining count is either too large or too small.",
+	INVALID_PREFIX_LENGTH: "The prefix length is either too large or too small.",
+	INVALID_NAME_LENGTH: "The name length is either too large or too small.",
+	METADATA_DISABLED: "Metadata is disabled.",
+	RATE_LIMIT_EXCEEDED: "Rate limit exceeded.",
+	NO_VALUES_TO_UPDATE: "No values to update.",
+	KEY_DISABLED_EXPIRATION: "Custom key expiration values are disabled.",
+	INVALID_API_KEY: "Invalid API key.",
+	INVALID_USER_ID_FROM_API_KEY: "The user id from the API key is invalid.",
+	INVALID_API_KEY_GETTER_RETURN_TYPE: "API Key getter returned an invalid key type. Expected string.",
+	SERVER_ONLY_PROPERTY: "The property you're trying to set can only be set from the server auth instance only.",
+	FAILED_TO_UPDATE_API_KEY: "Failed to update API key",
+	NAME_REQUIRED: "API Key name is required."
+});
+const API_KEY_TABLE_NAME = "apikey";
+const apiKey = (options) => {
+	const opts = {
+		...options,
+		apiKeyHeaders: options?.apiKeyHeaders ?? "x-api-key",
+		defaultKeyLength: options?.defaultKeyLength || 64,
+		maximumPrefixLength: options?.maximumPrefixLength ?? 32,
+		minimumPrefixLength: options?.minimumPrefixLength ?? 1,
+		maximumNameLength: options?.maximumNameLength ?? 32,
+		minimumNameLength: options?.minimumNameLength ?? 1,
+		enableMetadata: options?.enableMetadata ?? false,
+		disableKeyHashing: options?.disableKeyHashing ?? false,
+		requireName: options?.requireName ?? false,
+		rateLimit: {
+			enabled: options?.rateLimit?.enabled === void 0 ? true : options?.rateLimit?.enabled,
+			timeWindow: options?.rateLimit?.timeWindow ?? 1e3 * 60 * 60 * 24,
+			maxRequests: options?.rateLimit?.maxRequests ?? 10
+		},
+		keyExpiration: {
+			defaultExpiresIn: options?.keyExpiration?.defaultExpiresIn ?? null,
+			disableCustomExpiresTime: options?.keyExpiration?.disableCustomExpiresTime ?? false,
+			maxExpiresIn: options?.keyExpiration?.maxExpiresIn ?? 365,
+			minExpiresIn: options?.keyExpiration?.minExpiresIn ?? 1
+		},
+		startingCharactersConfig: {
+			shouldStore: options?.startingCharactersConfig?.shouldStore ?? true,
+			charactersLength: options?.startingCharactersConfig?.charactersLength ?? 6
+		},
+		enableSessionForAPIKeys: options?.enableSessionForAPIKeys ?? false
+	};
+	const schema$1 = mergeSchema(apiKeySchema({
+		rateLimitMax: opts.rateLimit.maxRequests,
+		timeWindow: opts.rateLimit.timeWindow
+	}), opts.schema);
+	const getter = opts.customAPIKeyGetter || ((ctx) => {
+		if (Array.isArray(opts.apiKeyHeaders)) for (const header of opts.apiKeyHeaders) {
+			const value = ctx.headers?.get(header);
+			if (value) return value;
+		}
+		else return ctx.headers?.get(opts.apiKeyHeaders);
+	});
+	const routes = createApiKeyRoutes({
+		keyGenerator: opts.customKeyGenerator || (async (options$1) => {
+			const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
+			let apiKey$1 = `${options$1.prefix || ""}`;
+			for (let i = 0; i < options$1.length; i++) {
+				const randomIndex = Math.floor(Math.random() * 52);
+				apiKey$1 += characters[randomIndex];
+			}
+			return apiKey$1;
+		}),
+		opts,
+		schema: schema$1
+	});
+	return {
+		id: "api-key",
+		$ERROR_CODES: ERROR_CODES,
+		hooks: { before: [{
+			matcher: (ctx) => !!getter(ctx) && opts.enableSessionForAPIKeys,
+			handler: createAuthMiddleware(async (ctx) => {
+				const key = getter(ctx);
+				if (typeof key !== "string") throw new APIError$1("BAD_REQUEST", { message: ERROR_CODES.INVALID_API_KEY_GETTER_RETURN_TYPE });
+				if (key.length < opts.defaultKeyLength) throw new APIError$1("FORBIDDEN", { message: ERROR_CODES.INVALID_API_KEY });
+				if (opts.customAPIKeyValidator) {
+					if (!await opts.customAPIKeyValidator({
+						ctx,
+						key
+					})) throw new APIError$1("FORBIDDEN", { message: ERROR_CODES.INVALID_API_KEY });
+				}
+				const apiKey$1 = await validateApiKey({
+					hashedKey: opts.disableKeyHashing ? key : await defaultKeyHasher(key),
+					ctx,
+					opts,
+					schema: schema$1
+				});
+				deleteAllExpiredApiKeys(ctx.context).catch((err) => {
+					ctx.context.logger.error("Failed to delete expired API keys:", err);
+				});
+				const user = await ctx.context.internalAdapter.findUserById(apiKey$1.userId);
+				if (!user) throw new APIError$1("UNAUTHORIZED", { message: ERROR_CODES.INVALID_USER_ID_FROM_API_KEY });
+				const session = {
+					user,
+					session: {
+						id: apiKey$1.id,
+						token: key,
+						userId: apiKey$1.userId,
+						userAgent: ctx.request?.headers.get("user-agent") ?? null,
+						ipAddress: ctx.request ? getIp(ctx.request, ctx.context.options) : null,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date(),
+						expiresAt: apiKey$1.expiresAt || getDate(ctx.context.options.session?.expiresIn || 3600 * 24 * 7, "ms")
+					}
+				};
+				ctx.context.session = session;
+				if (ctx.path === "/get-session") return session;
+				else return { context: ctx };
+			})
+		}] },
+		endpoints: {
+			createApiKey: routes.createApiKey,
+			verifyApiKey: routes.verifyApiKey,
+			getApiKey: routes.getApiKey,
+			updateApiKey: routes.updateApiKey,
+			deleteApiKey: routes.deleteApiKey,
+			listApiKeys: routes.listApiKeys,
+			deleteAllExpiredApiKeys: routes.deleteAllExpiredApiKeys
+		},
+		schema: schema$1
+	};
+};
+
+//#endregion
+//#region src/plugins/last-login-method/index.ts
+/**
+* Plugin to track the last used login method
+*/
+const lastLoginMethod = (userConfig) => {
+	const paths = [
+		"/callback/:id",
+		"/oauth2/callback/:providerId",
+		"/sign-in/email",
+		"/sign-up/email"
+	];
+	const defaultResolveMethod = (ctx) => {
+		if (paths.includes(ctx.path)) return ctx.params?.id || ctx.params?.providerId || ctx.path.split("/").pop();
+		if (ctx.path.includes("siwe")) return "siwe";
+		return null;
+	};
+	const config = {
+		cookieName: "better-auth.last_used_login_method",
+		maxAge: 3600 * 24 * 30,
+		...userConfig
+	};
+	return {
+		id: "last-login-method",
+		init(ctx) {
+			return { options: { databaseHooks: {
+				user: { create: { async before(user, context) {
+					if (!config.storeInDatabase) return;
+					if (!context) return;
+					const lastUsedLoginMethod = config.customResolveMethod?.(context) ?? defaultResolveMethod(context);
+					if (lastUsedLoginMethod) return { data: {
+						...user,
+						lastLoginMethod: lastUsedLoginMethod
+					} };
+				} } },
+				session: { create: { async after(session, context) {
+					if (!config.storeInDatabase) return;
+					if (!context) return;
+					const lastUsedLoginMethod = config.customResolveMethod?.(context) ?? defaultResolveMethod(context);
+					if (lastUsedLoginMethod && session?.userId) try {
+						await ctx.internalAdapter.updateUser(session.userId, { lastLoginMethod: lastUsedLoginMethod });
+					} catch (error) {
+						ctx.logger.error("Failed to update lastLoginMethod", error);
+					}
+				} } }
+			} } };
+		},
+		hooks: { after: [{
+			matcher() {
+				return true;
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const lastUsedLoginMethod = config.customResolveMethod?.(ctx) ?? defaultResolveMethod(ctx);
+				if (lastUsedLoginMethod) {
+					const setCookie = ctx.context.responseHeaders?.get("set-cookie");
+					const sessionTokenName = ctx.context.authCookies.sessionToken.name;
+					if (setCookie && setCookie.includes(sessionTokenName)) {
+						const cookieAttributes = {
+							...ctx.context.authCookies.sessionToken.options,
+							maxAge: config.maxAge,
+							httpOnly: false
+						};
+						ctx.setCookie(config.cookieName, lastUsedLoginMethod, cookieAttributes);
+					}
+				}
+			})
+		}] },
+		schema: config.storeInDatabase ? { user: { fields: { lastLoginMethod: {
+			type: "string",
+			input: false,
+			required: false,
+			fieldName: config.schema?.user?.lastLoginMethod || "lastLoginMethod"
+		} } } } : void 0
+	};
+};
+
+//#endregion
+//#region src/plugins/mcp/authorize.ts
+function redirectErrorURL(url, error, description) {
+	return `${url.includes("?") ? "&" : "?"}error=${error}&error_description=${description}`;
+}
+async function authorizeMCPOAuth(ctx, options) {
+	ctx.setHeader("Access-Control-Allow-Origin", "*");
+	ctx.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
+	ctx.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
+	ctx.setHeader("Access-Control-Max-Age", "86400");
+	const opts = {
+		codeExpiresIn: 600,
+		defaultScope: "openid",
+		...options,
+		scopes: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access",
+			...options?.scopes || []
+		]
+	};
+	if (!ctx.request) throw new APIError("UNAUTHORIZED", {
+		error_description: "request not found",
+		error: "invalid_request"
+	});
+	const session = await getSessionFromCtx(ctx);
+	if (!session) {
+		/**
+		* If the user is not logged in, we need to redirect them to the
+		* login page.
+		*/
+		await ctx.setSignedCookie("oidc_login_prompt", JSON.stringify(ctx.query), ctx.context.secret, {
+			maxAge: 600,
+			path: "/",
+			sameSite: "lax"
+		});
+		const queryFromURL = ctx.request.url?.split("?")[1];
+		throw ctx.redirect(`${options.loginPage}?${queryFromURL}`);
+	}
+	const query = ctx.query;
+	if (!query.client_id) throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_client`);
+	if (!query.response_type) throw ctx.redirect(redirectErrorURL(`${ctx.context.baseURL}/error`, "invalid_request", "response_type is required"));
+	const client = await ctx.context.adapter.findOne({
+		model: "oauthApplication",
+		where: [{
+			field: "clientId",
+			value: ctx.query.client_id
+		}]
+	}).then((res) => {
+		if (!res) return null;
+		return {
+			...res,
+			redirectUrls: res.redirectUrls.split(","),
+			metadata: res.metadata ? JSON.parse(res.metadata) : {}
+		};
+	});
+	if (!client) throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_client`);
+	const redirectURI = client.redirectUrls.find((url) => url === ctx.query.redirect_uri);
+	if (!redirectURI || !query.redirect_uri)
+ /**
+	* show UI error here warning the user that the redirect URI is invalid
+	*/
+	throw new APIError("BAD_REQUEST", { message: "Invalid redirect URI" });
+	if (client.disabled) throw ctx.redirect(`${ctx.context.baseURL}/error?error=client_disabled`);
+	if (query.response_type !== "code") throw ctx.redirect(`${ctx.context.baseURL}/error?error=unsupported_response_type`);
+	const requestScope = query.scope?.split(" ").filter((s) => s) || opts.defaultScope.split(" ");
+	const invalidScopes = requestScope.filter((scope) => {
+		return !opts.scopes.includes(scope);
+	});
+	if (invalidScopes.length) throw ctx.redirect(redirectErrorURL(query.redirect_uri, "invalid_scope", `The following scopes are invalid: ${invalidScopes.join(", ")}`));
+	if ((!query.code_challenge || !query.code_challenge_method) && options.requirePKCE) throw ctx.redirect(redirectErrorURL(query.redirect_uri, "invalid_request", "pkce is required"));
+	if (!query.code_challenge_method) query.code_challenge_method = "plain";
+	if (!["s256", options.allowPlainCodeChallengeMethod ? "plain" : "s256"].includes(query.code_challenge_method?.toLowerCase() || "")) throw ctx.redirect(redirectErrorURL(query.redirect_uri, "invalid_request", "invalid code_challenge method"));
+	const code = generateRandomString(32, "a-z", "A-Z", "0-9");
+	const codeExpiresInMs = opts.codeExpiresIn * 1e3;
+	const expiresAt = new Date(Date.now() + codeExpiresInMs);
+	try {
+		/**
+		* Save the code in the database
+		*/
+		await ctx.context.internalAdapter.createVerificationValue({
+			value: JSON.stringify({
+				clientId: client.clientId,
+				redirectURI: query.redirect_uri,
+				scope: requestScope,
+				userId: session.user.id,
+				authTime: new Date(session.session.createdAt).getTime(),
+				requireConsent: query.prompt === "consent",
+				state: query.prompt === "consent" ? query.state : null,
+				codeChallenge: query.code_challenge,
+				codeChallengeMethod: query.code_challenge_method,
+				nonce: query.nonce
+			}),
+			identifier: code,
+			expiresAt
+		});
+	} catch (e) {
+		throw ctx.redirect(redirectErrorURL(query.redirect_uri, "server_error", "An error occurred while processing the request"));
+	}
+	if (query.prompt !== "consent") {
+		const redirectURIWithCode$1 = new URL(redirectURI);
+		redirectURIWithCode$1.searchParams.set("code", code);
+		redirectURIWithCode$1.searchParams.set("state", ctx.query.state);
+		throw ctx.redirect(redirectURIWithCode$1.toString());
+	}
+	if (options?.consentPage) {
+		await ctx.setSignedCookie("oidc_consent_prompt", code, ctx.context.secret, {
+			maxAge: 600,
+			path: "/",
+			sameSite: "lax"
+		});
+		const urlParams = new URLSearchParams();
+		urlParams.set("consent_code", code);
+		urlParams.set("client_id", client.clientId);
+		urlParams.set("scope", requestScope.join(" "));
+		const consentURI = `${options.consentPage}?${urlParams.toString()}`;
+		throw ctx.redirect(consentURI);
+	}
+	const redirectURIWithCode = new URL(redirectURI);
+	redirectURIWithCode.searchParams.set("code", code);
+	redirectURIWithCode.searchParams.set("state", ctx.query.state);
+	throw ctx.redirect(redirectURIWithCode.toString());
+}
+
+//#endregion
+//#region src/plugins/mcp/index.ts
+const getMCPProviderMetadata = (ctx, options) => {
+	const issuer = ctx.context.options.baseURL;
+	const baseURL = ctx.context.baseURL;
+	if (!issuer || !baseURL) throw new APIError$1("INTERNAL_SERVER_ERROR", {
+		error: "invalid_issuer",
+		error_description: "issuer or baseURL is not set. If you're the app developer, please make sure to set the `baseURL` in your auth config."
+	});
+	return {
+		issuer,
+		authorization_endpoint: `${baseURL}/mcp/authorize`,
+		token_endpoint: `${baseURL}/mcp/token`,
+		userinfo_endpoint: `${baseURL}/mcp/userinfo`,
+		jwks_uri: `${baseURL}/mcp/jwks`,
+		registration_endpoint: `${baseURL}/mcp/register`,
+		scopes_supported: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access"
+		],
+		response_types_supported: ["code"],
+		response_modes_supported: ["query"],
+		grant_types_supported: ["authorization_code", "refresh_token"],
+		acr_values_supported: ["urn:mace:incommon:iap:silver", "urn:mace:incommon:iap:bronze"],
+		subject_types_supported: ["public"],
+		id_token_signing_alg_values_supported: ["RS256", "none"],
+		token_endpoint_auth_methods_supported: [
+			"client_secret_basic",
+			"client_secret_post",
+			"none"
+		],
+		code_challenge_methods_supported: ["S256"],
+		claims_supported: [
+			"sub",
+			"iss",
+			"aud",
+			"exp",
+			"nbf",
+			"iat",
+			"jti",
+			"email",
+			"email_verified",
+			"name"
+		],
+		...options?.metadata
+	};
+};
+const getMCPProtectedResourceMetadata = (ctx, options) => {
+	const baseURL = ctx.context.baseURL;
+	return {
+		resource: options?.resource ?? new URL(baseURL).origin,
+		authorization_servers: [baseURL],
+		jwks_uri: options?.oidcConfig?.metadata?.jwks_uri ?? `${baseURL}/mcp/jwks`,
+		scopes_supported: options?.oidcConfig?.metadata?.scopes_supported ?? [
+			"openid",
+			"profile",
+			"email",
+			"offline_access"
+		],
+		bearer_methods_supported: ["header"],
+		resource_signing_alg_values_supported: ["RS256", "none"]
+	};
+};
+const mcp = (options) => {
+	const opts = {
+		codeExpiresIn: 600,
+		defaultScope: "openid",
+		accessTokenExpiresIn: 3600,
+		refreshTokenExpiresIn: 604800,
+		allowPlainCodeChallengeMethod: true,
+		...options.oidcConfig,
+		loginPage: options.loginPage,
+		scopes: [
+			"openid",
+			"profile",
+			"email",
+			"offline_access",
+			...options.oidcConfig?.scopes || []
+		]
+	};
+	const modelName = {
+		oauthClient: "oauthApplication",
+		oauthAccessToken: "oauthAccessToken",
+		oauthConsent: "oauthConsent"
+	};
+	const provider = oidcProvider(opts);
+	return {
+		id: "mcp",
+		hooks: { after: [{
+			matcher() {
+				return true;
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const cookie = await ctx.getSignedCookie("oidc_login_prompt", ctx.context.secret);
+				const cookieName = ctx.context.authCookies.sessionToken.name;
+				const parsedSetCookieHeader = parseSetCookieHeader(ctx.context.responseHeaders?.get("set-cookie") || "");
+				const hasSessionToken = parsedSetCookieHeader.has(cookieName);
+				if (!cookie || !hasSessionToken) return;
+				ctx.setCookie("oidc_login_prompt", "", { maxAge: 0 });
+				const sessionToken = (parsedSetCookieHeader.get(cookieName)?.value)?.split(".")[0];
+				if (!sessionToken) return;
+				const session = await ctx.context.internalAdapter.findSession(sessionToken);
+				if (!session) return;
+				ctx.query = JSON.parse(cookie);
+				ctx.query.prompt = "consent";
+				ctx.context.session = session;
+				return await authorizeMCPOAuth(ctx, opts);
+			})
+		}] },
+		endpoints: {
+			oAuthConsent: provider.endpoints.oAuthConsent,
+			getMcpOAuthConfig: createAuthEndpoint("/.well-known/oauth-authorization-server", {
+				method: "GET",
+				metadata: { client: false }
+			}, async (c) => {
+				try {
+					const metadata = getMCPProviderMetadata(c, options);
+					return c.json(metadata);
+				} catch (e) {
+					console.log(e);
+					return c.json(null);
+				}
+			}),
+			getMCPProtectedResource: createAuthEndpoint("/.well-known/oauth-protected-resource", {
+				method: "GET",
+				metadata: { client: false }
+			}, async (c) => {
+				const metadata = getMCPProtectedResourceMetadata(c, options);
+				return c.json(metadata);
+			}),
+			mcpOAuthAuthorize: createAuthEndpoint("/mcp/authorize", {
+				method: "GET",
+				query: z.record(z.string(), z.any()),
+				metadata: { openapi: {
+					description: "Authorize an OAuth2 request using MCP",
+					responses: { "200": {
+						description: "Authorization response generated successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							additionalProperties: true,
+							description: "Authorization response, contents depend on the authorize function implementation"
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				return authorizeMCPOAuth(ctx, opts);
+			}),
+			mcpOAuthToken: createAuthEndpoint("/mcp/token", {
+				method: "POST",
+				body: z.record(z.any(), z.any()),
+				metadata: { isAction: false }
+			}, async (ctx) => {
+				ctx.setHeader("Access-Control-Allow-Origin", "*");
+				ctx.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
+				ctx.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
+				ctx.setHeader("Access-Control-Max-Age", "86400");
+				let { body } = ctx;
+				if (!body) throw ctx.error("BAD_REQUEST", {
+					error_description: "request body not found",
+					error: "invalid_request"
+				});
+				if (body instanceof FormData) body = Object.fromEntries(body.entries());
+				if (!(body instanceof Object)) throw new APIError$1("BAD_REQUEST", {
+					error_description: "request body is not an object",
+					error: "invalid_request"
+				});
+				let { client_id, client_secret } = body;
+				const authorization = ctx.request?.headers.get("authorization") || null;
+				if (authorization && !client_id && !client_secret && authorization.startsWith("Basic ")) try {
+					const encoded = authorization.replace("Basic ", "");
+					const decoded = new TextDecoder().decode(base64.decode(encoded));
+					if (!decoded.includes(":")) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+					const [id, secret] = decoded.split(":");
+					if (!id || !secret) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+					client_id = id;
+					client_secret = secret;
+				} catch (error) {
+					throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid authorization header format",
+						error: "invalid_client"
+					});
+				}
+				const { grant_type, code, redirect_uri, refresh_token, code_verifier } = body;
+				if (grant_type === "refresh_token") {
+					if (!refresh_token) throw new APIError$1("BAD_REQUEST", {
+						error_description: "refresh_token is required",
+						error: "invalid_request"
+					});
+					const token = await ctx.context.adapter.findOne({
+						model: "oauthAccessToken",
+						where: [{
+							field: "refreshToken",
+							value: refresh_token.toString()
+						}]
+					});
+					if (!token) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid refresh token",
+						error: "invalid_grant"
+					});
+					if (token.clientId !== client_id?.toString()) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid client_id",
+						error: "invalid_client"
+					});
+					if (token.refreshTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "refresh token expired",
+						error: "invalid_grant"
+					});
+					const accessToken$1 = generateRandomString(32, "a-z", "A-Z");
+					const newRefreshToken = generateRandomString(32, "a-z", "A-Z");
+					const accessTokenExpiresAt$1 = new Date(Date.now() + opts.accessTokenExpiresIn * 1e3);
+					const refreshTokenExpiresAt$1 = new Date(Date.now() + opts.refreshTokenExpiresIn * 1e3);
+					await ctx.context.adapter.create({
+						model: modelName.oauthAccessToken,
+						data: {
+							accessToken: accessToken$1,
+							refreshToken: newRefreshToken,
+							accessTokenExpiresAt: accessTokenExpiresAt$1,
+							refreshTokenExpiresAt: refreshTokenExpiresAt$1,
+							clientId: client_id.toString(),
+							userId: token.userId,
+							scopes: token.scopes,
+							createdAt: /* @__PURE__ */ new Date(),
+							updatedAt: /* @__PURE__ */ new Date()
+						}
+					});
+					return ctx.json({
+						access_token: accessToken$1,
+						token_type: "bearer",
+						expires_in: opts.accessTokenExpiresIn,
+						refresh_token: newRefreshToken,
+						scope: token.scopes
+					});
+				}
+				if (!code) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code is required",
+					error: "invalid_request"
+				});
+				if (opts.requirePKCE && !code_verifier) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code verifier is missing",
+					error: "invalid_request"
+				});
+				/**
+				* We need to check if the code is valid before we can proceed
+				* with the rest of the request.
+				*/
+				const verificationValue = await ctx.context.internalAdapter.findVerificationValue(code.toString());
+				if (!verificationValue) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid code",
+					error: "invalid_grant"
+				});
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "code expired",
+					error: "invalid_grant"
+				});
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				if (!client_id) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client_id is required",
+					error: "invalid_client"
+				});
+				if (!grant_type) throw new APIError$1("BAD_REQUEST", {
+					error_description: "grant_type is required",
+					error: "invalid_request"
+				});
+				if (grant_type !== "authorization_code") throw new APIError$1("BAD_REQUEST", {
+					error_description: "grant_type must be 'authorization_code'",
+					error: "unsupported_grant_type"
+				});
+				if (!redirect_uri) throw new APIError$1("BAD_REQUEST", {
+					error_description: "redirect_uri is required",
+					error: "invalid_request"
+				});
+				const client = await ctx.context.adapter.findOne({
+					model: modelName.oauthClient,
+					where: [{
+						field: "clientId",
+						value: client_id.toString()
+					}]
+				}).then((res) => {
+					if (!res) return null;
+					return {
+						...res,
+						redirectUrls: res.redirectUrls.split(","),
+						metadata: res.metadata ? JSON.parse(res.metadata) : {}
+					};
+				});
+				if (!client) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid client_id",
+					error: "invalid_client"
+				});
+				if (client.disabled) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "client is disabled",
+					error: "invalid_client"
+				});
+				if (client.type === "public") {
+					if (!code_verifier) throw new APIError$1("BAD_REQUEST", {
+						error_description: "code verifier is required for public clients",
+						error: "invalid_request"
+					});
+				} else {
+					if (!client_secret) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "client_secret is required for confidential clients",
+						error: "invalid_client"
+					});
+					if (!(client.clientSecret === client_secret.toString())) throw new APIError$1("UNAUTHORIZED", {
+						error_description: "invalid client_secret",
+						error: "invalid_client"
+					});
+				}
+				const value = JSON.parse(verificationValue.value);
+				if (value.clientId !== client_id.toString()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid client_id",
+					error: "invalid_client"
+				});
+				if (value.redirectURI !== redirect_uri.toString()) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "invalid redirect_uri",
+					error: "invalid_client"
+				});
+				if (value.codeChallenge && !code_verifier) throw new APIError$1("BAD_REQUEST", {
+					error_description: "code verifier is missing",
+					error: "invalid_request"
+				});
+				if ((value.codeChallengeMethod === "plain" ? code_verifier : await createHash("SHA-256", "base64urlnopad").digest(code_verifier)) !== value.codeChallenge) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "code verification failed",
+					error: "invalid_request"
+				});
+				const requestedScopes = value.scope;
+				await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				const accessToken = generateRandomString(32, "a-z", "A-Z");
+				const refreshToken = generateRandomString(32, "A-Z", "a-z");
+				const accessTokenExpiresAt = new Date(Date.now() + opts.accessTokenExpiresIn * 1e3);
+				const refreshTokenExpiresAt = new Date(Date.now() + opts.refreshTokenExpiresIn * 1e3);
+				await ctx.context.adapter.create({
+					model: modelName.oauthAccessToken,
+					data: {
+						accessToken,
+						refreshToken,
+						accessTokenExpiresAt,
+						refreshTokenExpiresAt,
+						clientId: client_id.toString(),
+						userId: value.userId,
+						scopes: requestedScopes.join(" "),
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}
+				});
+				const user = await ctx.context.internalAdapter.findUserById(value.userId);
+				if (!user) throw new APIError$1("UNAUTHORIZED", {
+					error_description: "user not found",
+					error: "invalid_grant"
+				});
+				let secretKey = {
+					alg: "HS256",
+					key: await getWebcryptoSubtle().generateKey({
+						name: "HMAC",
+						hash: "SHA-256"
+					}, true, ["sign", "verify"])
+				};
+				const profile = {
+					given_name: user.name.split(" ")[0],
+					family_name: user.name.split(" ")[1],
+					name: user.name,
+					profile: user.image,
+					updated_at: Math.floor(new Date(user.updatedAt).getTime() / 1e3)
+				};
+				const email = {
+					email: user.email,
+					email_verified: user.emailVerified
+				};
+				const userClaims = {
+					...requestedScopes.includes("profile") ? profile : {},
+					...requestedScopes.includes("email") ? email : {}
+				};
+				const additionalUserClaims = opts.getAdditionalUserInfoClaim ? await opts.getAdditionalUserInfoClaim(user, requestedScopes, client) : {};
+				const idToken = await new SignJWT({
+					sub: user.id,
+					aud: client_id.toString(),
+					iat: Date.now(),
+					auth_time: ctx.context.session ? new Date(ctx.context.session.session.createdAt).getTime() : void 0,
+					nonce: value.nonce,
+					acr: "urn:mace:incommon:iap:silver",
+					...userClaims,
+					...additionalUserClaims
+				}).setProtectedHeader({ alg: secretKey.alg }).setIssuedAt().setExpirationTime(Math.floor(Date.now() / 1e3) + opts.accessTokenExpiresIn).sign(secretKey.key);
+				return ctx.json({
+					access_token: accessToken,
+					token_type: "Bearer",
+					expires_in: opts.accessTokenExpiresIn,
+					refresh_token: requestedScopes.includes("offline_access") ? refreshToken : void 0,
+					scope: requestedScopes.join(" "),
+					id_token: requestedScopes.includes("openid") ? idToken : void 0
+				}, { headers: {
+					"Cache-Control": "no-store",
+					Pragma: "no-cache"
+				} });
+			}),
+			registerMcpClient: createAuthEndpoint("/mcp/register", {
+				method: "POST",
+				body: z.object({
+					redirect_uris: z.array(z.string()),
+					token_endpoint_auth_method: z.enum([
+						"none",
+						"client_secret_basic",
+						"client_secret_post"
+					]).default("client_secret_basic").optional(),
+					grant_types: z.array(z.enum([
+						"authorization_code",
+						"implicit",
+						"password",
+						"client_credentials",
+						"refresh_token",
+						"urn:ietf:params:oauth:grant-type:jwt-bearer",
+						"urn:ietf:params:oauth:grant-type:saml2-bearer"
+					])).default(["authorization_code"]).optional(),
+					response_types: z.array(z.enum(["code", "token"])).default(["code"]).optional(),
+					client_name: z.string().optional(),
+					client_uri: z.string().optional(),
+					logo_uri: z.string().optional(),
+					scope: z.string().optional(),
+					contacts: z.array(z.string()).optional(),
+					tos_uri: z.string().optional(),
+					policy_uri: z.string().optional(),
+					jwks_uri: z.string().optional(),
+					jwks: z.record(z.string(), z.any()).optional(),
+					metadata: z.record(z.any(), z.any()).optional(),
+					software_id: z.string().optional(),
+					software_version: z.string().optional(),
+					software_statement: z.string().optional()
+				}),
+				metadata: { openapi: {
+					description: "Register an OAuth2 application",
+					responses: { "200": {
+						description: "OAuth2 application registered successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								name: {
+									type: "string",
+									description: "Name of the OAuth2 application"
+								},
+								icon: {
+									type: "string",
+									nullable: true,
+									description: "Icon URL for the application"
+								},
+								metadata: {
+									type: "object",
+									additionalProperties: true,
+									nullable: true,
+									description: "Additional metadata for the application"
+								},
+								clientId: {
+									type: "string",
+									description: "Unique identifier for the client"
+								},
+								clientSecret: {
+									type: "string",
+									description: "Secret key for the client. Not included for public clients."
+								},
+								redirectUrls: {
+									type: "array",
+									items: {
+										type: "string",
+										format: "uri"
+									},
+									description: "List of allowed redirect URLs"
+								},
+								type: {
+									type: "string",
+									description: "Type of the client",
+									enum: ["web", "public"]
+								},
+								authenticationScheme: {
+									type: "string",
+									description: "Authentication scheme used by the client",
+									enum: ["client_secret", "none"]
+								},
+								disabled: {
+									type: "boolean",
+									description: "Whether the client is disabled",
+									enum: [false]
+								},
+								userId: {
+									type: "string",
+									nullable: true,
+									description: "ID of the user who registered the client, null if registered anonymously"
+								},
+								createdAt: {
+									type: "string",
+									format: "date-time",
+									description: "Creation timestamp"
+								},
+								updatedAt: {
+									type: "string",
+									format: "date-time",
+									description: "Last update timestamp"
+								}
+							},
+							required: [
+								"name",
+								"clientId",
+								"redirectUrls",
+								"type",
+								"authenticationScheme",
+								"disabled",
+								"createdAt",
+								"updatedAt"
+							]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const body = ctx.body;
+				const session = await getSessionFromCtx(ctx);
+				ctx.setHeader("Access-Control-Allow-Origin", "*");
+				ctx.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
+				ctx.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
+				ctx.setHeader("Access-Control-Max-Age", "86400");
+				ctx.headers?.set("Access-Control-Max-Age", "86400");
+				if ((!body.grant_types || body.grant_types.includes("authorization_code") || body.grant_types.includes("implicit")) && (!body.redirect_uris || body.redirect_uris.length === 0)) throw new APIError$1("BAD_REQUEST", {
+					error: "invalid_redirect_uri",
+					error_description: "Redirect URIs are required for authorization_code and implicit grant types"
+				});
+				if (body.grant_types && body.response_types) {
+					if (body.grant_types.includes("authorization_code") && !body.response_types.includes("code")) throw new APIError$1("BAD_REQUEST", {
+						error: "invalid_client_metadata",
+						error_description: "When 'authorization_code' grant type is used, 'code' response type must be included"
+					});
+					if (body.grant_types.includes("implicit") && !body.response_types.includes("token")) throw new APIError$1("BAD_REQUEST", {
+						error: "invalid_client_metadata",
+						error_description: "When 'implicit' grant type is used, 'token' response type must be included"
+					});
+				}
+				const clientId = opts.generateClientId?.() || generateRandomString(32, "a-z", "A-Z");
+				const clientSecret = opts.generateClientSecret?.() || generateRandomString(32, "a-z", "A-Z");
+				const clientType = body.token_endpoint_auth_method === "none" ? "public" : "web";
+				const finalClientSecret = clientType === "public" ? "" : clientSecret;
+				await ctx.context.adapter.create({
+					model: modelName.oauthClient,
+					data: {
+						name: body.client_name,
+						icon: body.logo_uri,
+						metadata: body.metadata ? JSON.stringify(body.metadata) : null,
+						clientId,
+						clientSecret: finalClientSecret,
+						redirectUrls: body.redirect_uris.join(","),
+						type: clientType,
+						authenticationScheme: body.token_endpoint_auth_method || "client_secret_basic",
+						disabled: false,
+						userId: session?.session.userId,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					}
+				});
+				const responseData = {
+					client_id: clientId,
+					client_id_issued_at: Math.floor(Date.now() / 1e3),
+					redirect_uris: body.redirect_uris,
+					token_endpoint_auth_method: body.token_endpoint_auth_method || "client_secret_basic",
+					grant_types: body.grant_types || ["authorization_code"],
+					response_types: body.response_types || ["code"],
+					client_name: body.client_name,
+					client_uri: body.client_uri,
+					logo_uri: body.logo_uri,
+					scope: body.scope,
+					contacts: body.contacts,
+					tos_uri: body.tos_uri,
+					policy_uri: body.policy_uri,
+					jwks_uri: body.jwks_uri,
+					jwks: body.jwks,
+					software_id: body.software_id,
+					software_version: body.software_version,
+					software_statement: body.software_statement,
+					metadata: body.metadata,
+					...clientType !== "public" ? {
+						client_secret: finalClientSecret,
+						client_secret_expires_at: 0
+					} : {}
+				};
+				return new Response(JSON.stringify(responseData), {
+					status: 201,
+					headers: {
+						"Content-Type": "application/json",
+						"Cache-Control": "no-store",
+						Pragma: "no-cache"
+					}
+				});
+			}),
+			getMcpSession: createAuthEndpoint("/mcp/get-session", {
+				method: "GET",
+				requireHeaders: true
+			}, async (c) => {
+				const accessToken = c.headers?.get("Authorization")?.replace("Bearer ", "");
+				if (!accessToken) {
+					c.headers?.set("WWW-Authenticate", "Bearer");
+					return c.json(null);
+				}
+				const accessTokenData = await c.context.adapter.findOne({
+					model: modelName.oauthAccessToken,
+					where: [{
+						field: "accessToken",
+						value: accessToken
+					}]
+				});
+				if (!accessTokenData) return c.json(null);
+				return c.json(accessTokenData);
+			})
+		},
+		schema
+	};
+};
+const withMcpAuth = (auth, handler) => {
+	return async (req) => {
+		const baseURL = getBaseURL(auth.options.baseURL, auth.options.basePath);
+		if (!baseURL && !isProduction) logger.warn("Unable to get the baseURL, please check your config!");
+		const session = await auth.api.getMcpSession({ headers: req.headers });
+		const wwwAuthenticateValue = `Bearer resource_metadata="${baseURL}/.well-known/oauth-protected-resource"`;
+		if (!session) return Response.json({
+			jsonrpc: "2.0",
+			error: {
+				code: -32e3,
+				message: "Unauthorized: Authentication required",
+				"www-authenticate": wwwAuthenticateValue
+			},
+			id: null
+		}, {
+			status: 401,
+			headers: {
+				"WWW-Authenticate": wwwAuthenticateValue,
+				"Access-Control-Expose-Headers": "WWW-Authenticate"
+			}
+		});
+		return handler(req, session);
+	};
+};
+const oAuthDiscoveryMetadata = (auth) => {
+	return async (request) => {
+		const res = await auth.api.getMcpOAuthConfig();
+		return new Response(JSON.stringify(res), {
+			status: 200,
+			headers: {
+				"Content-Type": "application/json",
+				"Access-Control-Allow-Origin": "*",
+				"Access-Control-Allow-Methods": "POST, OPTIONS",
+				"Access-Control-Allow-Headers": "Content-Type, Authorization",
+				"Access-Control-Max-Age": "86400"
+			}
+		});
+	};
+};
+const oAuthProtectedResourceMetadata = (auth) => {
+	return async (request) => {
+		const res = await auth.api.getMCPProtectedResource();
+		return new Response(JSON.stringify(res), {
+			status: 200,
+			headers: {
+				"Content-Type": "application/json",
+				"Access-Control-Allow-Origin": "*",
+				"Access-Control-Allow-Methods": "POST, OPTIONS",
+				"Access-Control-Allow-Headers": "Content-Type, Authorization",
+				"Access-Control-Max-Age": "86400"
+			}
+		});
+	};
+};
+
+//#endregion
+//#region src/plugins/one-time-token/index.ts
+const oneTimeToken = (options) => {
+	const opts = {
+		storeToken: "plain",
+		...options
+	};
+	async function storeToken(ctx, token) {
+		if (opts.storeToken === "hashed") return await defaultKeyHasher(token);
+		if (typeof opts.storeToken === "object" && "type" in opts.storeToken && opts.storeToken.type === "custom-hasher") return await opts.storeToken.hash(token);
+		return token;
+	}
+	return {
+		id: "one-time-token",
+		endpoints: {
+			generateOneTimeToken: createAuthEndpoint("/one-time-token/generate", {
+				method: "GET",
+				use: [sessionMiddleware]
+			}, async (c) => {
+				if (opts?.disableClientRequest && c.request) throw c.error("BAD_REQUEST", { message: "Client requests are disabled" });
+				const session = c.context.session;
+				const token = opts?.generateToken ? await opts.generateToken(session, c) : generateRandomString(32);
+				const expiresAt = new Date(Date.now() + (opts?.expiresIn ?? 3) * 60 * 1e3);
+				const storedToken = await storeToken(c, token);
+				await c.context.internalAdapter.createVerificationValue({
+					value: session.session.token,
+					identifier: `one-time-token:${storedToken}`,
+					expiresAt
+				});
+				return c.json({ token });
+			}),
+			verifyOneTimeToken: createAuthEndpoint("/one-time-token/verify", {
+				method: "POST",
+				body: z.object({ token: z.string().meta({ description: "The token to verify. Eg: \"some-token\"" }) })
+			}, async (c) => {
+				const { token } = c.body;
+				const storedToken = await storeToken(c, token);
+				const verificationValue = await c.context.internalAdapter.findVerificationValue(`one-time-token:${storedToken}`);
+				if (!verificationValue) throw c.error("BAD_REQUEST", { message: "Invalid token" });
+				await c.context.internalAdapter.deleteVerificationValue(verificationValue.id);
+				if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw c.error("BAD_REQUEST", { message: "Token expired" });
+				const session = await c.context.internalAdapter.findSession(verificationValue.value);
+				if (!session) throw c.error("BAD_REQUEST", { message: "Session not found" });
+				return c.json(session);
+			})
+		}
+	};
+};
+
+//#endregion
+export { getMCPProtectedResourceMetadata as a, oAuthDiscoveryMetadata as c, lastLoginMethod as d, API_KEY_TABLE_NAME as f, defaultKeyHasher as h, oneTimeToken as i, oAuthProtectedResourceMetadata as l, apiKey as m, createAuthMiddleware$1 as n, getMCPProviderMetadata as o, ERROR_CODES as p, optionsMiddleware as r, mcp as s, createAuthEndpoint$1 as t, withMcpAuth as u };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/access/index.mjs.bak b/node_modules/better-auth/dist/plugins/access/index.mjs.bak
new file mode 100644
index 0000000..9477e3d
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/access/index.mjs.bak
@@ -0,0 +1,3 @@
+import { n as role, t as createAccessControl } from "../../access-6c2-Np4U.mjs";
+
+export { createAccessControl, role };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/admin/access/index.mjs.bak b/node_modules/better-auth/dist/plugins/admin/access/index.mjs.bak
new file mode 100644
index 0000000..1a1b639
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/admin/access/index.mjs.bak
@@ -0,0 +1,4 @@
+import "../../../access-6c2-Np4U.mjs";
+import { a as userAc, i as defaultStatements, n as defaultAc, r as defaultRoles, t as adminAc } from "../../../access-BYnrn7CR.mjs";
+
+export { adminAc, defaultAc, defaultRoles, defaultStatements, userAc };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/admin/index.mjs.bak b/node_modules/better-auth/dist/plugins/admin/index.mjs.bak
new file mode 100644
index 0000000..69fc34d
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/admin/index.mjs.bak
@@ -0,0 +1,22 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../access-6c2-Np4U.mjs";
+import "../../plugin-helper-RJJBTOba.mjs";
+import "../../access-BYnrn7CR.mjs";
+import { t as admin } from "../../admin-CJ3jncSX.mjs";
+import "../../has-permission-DhpFBOUO.mjs";
+
+export { admin };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/anonymous/index.mjs.bak b/node_modules/better-auth/dist/plugins/anonymous/index.mjs.bak
new file mode 100644
index 0000000..c777f3c
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/anonymous/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as anonymous } from "../../anonymous-DCfvRfoL.mjs";
+
+export { anonymous };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/bearer/index.mjs.bak b/node_modules/better-auth/dist/plugins/bearer/index.mjs.bak
new file mode 100644
index 0000000..c98d1d3
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/bearer/index.mjs.bak
@@ -0,0 +1,8 @@
+import "../../jwt-CmxZAGe2.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import { t as bearer } from "../../bearer-DRqPkgUx.mjs";
+
+export { bearer };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/captcha/index.mjs.bak b/node_modules/better-auth/dist/plugins/captcha/index.mjs.bak
new file mode 100644
index 0000000..0e78fd8
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/captcha/index.mjs.bak
@@ -0,0 +1,4 @@
+import "../../get-request-ip-kbu825ez.mjs";
+import { t as captcha } from "../../captcha-CU0p6qrj.mjs";
+
+export { captcha };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/custom-session/index.mjs.bak b/node_modules/better-auth/dist/plugins/custom-session/index.mjs.bak
new file mode 100644
index 0000000..9c452ae
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/custom-session/index.mjs.bak
@@ -0,0 +1,19 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../plugin-helper-RJJBTOba.mjs";
+import { t as customSession } from "../../custom-session-BDpuPRbk.mjs";
+
+export { customSession };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/device-authorization/index.mjs.bak b/node_modules/better-auth/dist/plugins/device-authorization/index.mjs.bak
new file mode 100644
index 0000000..c4670b5
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/device-authorization/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { n as deviceAuthorization, t as $deviceAuthorizationOptionsSchema } from "../../device-authorization-CIxU2CCU.mjs";
+import { t as deviceAuthorizationClient } from "../../client-WiN43tAS.mjs";
+
+export { $deviceAuthorizationOptionsSchema, deviceAuthorization, deviceAuthorizationClient };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/email-otp/index.mjs.bak b/node_modules/better-auth/dist/plugins/email-otp/index.mjs.bak
new file mode 100644
index 0000000..e806481
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/email-otp/index.mjs.bak
@@ -0,0 +1,19 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../plugin-helper-RJJBTOba.mjs";
+import { t as emailOTP } from "../../email-otp-C08WNTNC.mjs";
+
+export { emailOTP };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/generic-oauth/index.mjs.bak b/node_modules/better-auth/dist/plugins/generic-oauth/index.mjs.bak
new file mode 100644
index 0000000..90c199f
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/generic-oauth/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as genericOAuth } from "../../generic-oauth-BI8Iz1pK.mjs";
+
+export { genericOAuth };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/haveibeenpwned/index.mjs.bak b/node_modules/better-auth/dist/plugins/haveibeenpwned/index.mjs.bak
new file mode 100644
index 0000000..e083284
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/haveibeenpwned/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as haveIBeenPwned } from "../../haveibeenpwned-lb4pgDiK.mjs";
+
+export { haveIBeenPwned };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/index.mjs.bak b/node_modules/better-auth/dist/plugins/index.mjs.bak
new file mode 100644
index 0000000..65ac0eb
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/index.mjs.bak
@@ -0,0 +1,50 @@
+import "../dialect-BhkkSrrx.mjs";
+import "../get-model-name-nJd9iPTo.mjs";
+import "../get-migration-C1tgKlQ6.mjs";
+import "../types-BReKsBV6.mjs";
+import { n as HIDE_METADATA } from "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import "../schema-BevzneML.mjs";
+import "../get-request-ip-kbu825ez.mjs";
+import "../json-BS-nL3f-.mjs";
+import "../url-SXU3XD3W.mjs";
+import "../api-C0IsrmGz.mjs";
+import "../cookies-Cl2L38B1.mjs";
+import "../session-Efap-vxj.mjs";
+import "../password-DWi8yN3A.mjs";
+import "../parser-DcrIEuXE.mjs";
+import { n as role, t as createAccessControl } from "../access-6c2-Np4U.mjs";
+import "../plugin-helper-RJJBTOba.mjs";
+import "../access-BYnrn7CR.mjs";
+import { t as admin } from "../admin-CJ3jncSX.mjs";
+import "../has-permission-DhpFBOUO.mjs";
+import { t as anonymous } from "../anonymous-DCfvRfoL.mjs";
+import { a as getMCPProtectedResourceMetadata, c as oAuthDiscoveryMetadata, d as lastLoginMethod, f as API_KEY_TABLE_NAME, h as defaultKeyHasher, i as oneTimeToken, l as oAuthProtectedResourceMetadata, m as apiKey, n as createAuthMiddleware, o as getMCPProviderMetadata, p as ERROR_CODES, r as optionsMiddleware, s as mcp, t as createAuthEndpoint, u as withMcpAuth } from "../plugins-D9JjA_z3.mjs";
+import { t as bearer } from "../bearer-DRqPkgUx.mjs";
+import { t as captcha } from "../captcha-CU0p6qrj.mjs";
+import { t as customSession } from "../custom-session-BDpuPRbk.mjs";
+import { n as deviceAuthorization, t as $deviceAuthorizationOptionsSchema } from "../device-authorization-CIxU2CCU.mjs";
+import { t as deviceAuthorizationClient } from "../client-WiN43tAS.mjs";
+import { t as emailOTP } from "../email-otp-C08WNTNC.mjs";
+import { t as genericOAuth } from "../generic-oauth-BI8Iz1pK.mjs";
+import { t as haveIBeenPwned } from "../haveibeenpwned-lb4pgDiK.mjs";
+import { i as generateExportedKeyPair, r as createJwk, t as getJwtToken } from "../sign-wCNCtKGh.mjs";
+import { t as jwt } from "../jwt-CLg_nnrd.mjs";
+import { t as magicLink } from "../magic-link-DCBndC0L.mjs";
+import { n as getMetadata, r as oidcProvider, t as getClient } from "../oidc-provider-ComEKSEi.mjs";
+import { t as multiSession } from "../multi-session-CxgwAYRM.mjs";
+import { t as oAuthProxy } from "../oauth-proxy-Dsp9ntvU.mjs";
+import { t as oneTap } from "../one-tap-thuUsT_P.mjs";
+import { t as openAPI } from "../open-api-Cb5nhhNu.mjs";
+import { n as parseRoles, t as organization } from "../organization-D-mvr_hy.mjs";
+import "../access-HdxSBEa0.mjs";
+import "../permission-CDDWgA_O.mjs";
+import { t as phoneNumber } from "../phone-number-WeAgIbHL.mjs";
+import { t as siwe } from "../siwe-__fBpXPo.mjs";
+import { n as TWO_FACTOR_ERROR_CODES, t as twoFactor } from "../two-factor-2QtPvfKI.mjs";
+import { t as twoFactorClient } from "../client-CuoyvYUC.mjs";
+import { n as USERNAME_ERROR_CODES, t as username } from "../username-DI2v-O3q.mjs";
+
+export { $deviceAuthorizationOptionsSchema, API_KEY_TABLE_NAME, ERROR_CODES, HIDE_METADATA, TWO_FACTOR_ERROR_CODES, USERNAME_ERROR_CODES, admin, anonymous, apiKey, bearer, captcha, createAccessControl, createAuthEndpoint, createAuthMiddleware, createJwk, customSession, defaultKeyHasher, deviceAuthorization, deviceAuthorizationClient, emailOTP, generateExportedKeyPair, genericOAuth, getClient, getJwtToken, getMCPProtectedResourceMetadata, getMCPProviderMetadata, getMetadata, haveIBeenPwned, jwt, lastLoginMethod, magicLink, mcp, multiSession, oAuthDiscoveryMetadata, oAuthProtectedResourceMetadata, oAuthProxy, oidcProvider, oneTap, oneTimeToken, openAPI, optionsMiddleware, organization, parseRoles, phoneNumber, role, siwe, twoFactor, twoFactorClient, username, withMcpAuth };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/jwt/index.mjs.bak b/node_modules/better-auth/dist/plugins/jwt/index.mjs.bak
new file mode 100644
index 0000000..d4cf474
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/jwt/index.mjs.bak
@@ -0,0 +1,19 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { i as generateExportedKeyPair, r as createJwk, t as getJwtToken } from "../../sign-wCNCtKGh.mjs";
+import { t as jwt } from "../../jwt-CLg_nnrd.mjs";
+
+export { createJwk, generateExportedKeyPair, getJwtToken, jwt };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/magic-link/index.mjs.bak b/node_modules/better-auth/dist/plugins/magic-link/index.mjs.bak
new file mode 100644
index 0000000..44c36b6
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/magic-link/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as magicLink } from "../../magic-link-DCBndC0L.mjs";
+
+export { magicLink };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/multi-session/index.mjs.bak b/node_modules/better-auth/dist/plugins/multi-session/index.mjs.bak
new file mode 100644
index 0000000..95e6190
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/multi-session/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as multiSession } from "../../multi-session-CxgwAYRM.mjs";
+
+export { multiSession };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/oauth-proxy/index.mjs.bak b/node_modules/better-auth/dist/plugins/oauth-proxy/index.mjs.bak
new file mode 100644
index 0000000..18e763b
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/oauth-proxy/index.mjs.bak
@@ -0,0 +1,19 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import { t as oAuthProxy } from "../../oauth-proxy-Dsp9ntvU.mjs";
+
+export { oAuthProxy };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/oidc-provider/index.mjs.bak b/node_modules/better-auth/dist/plugins/oidc-provider/index.mjs.bak
new file mode 100644
index 0000000..d6805cd
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/oidc-provider/index.mjs.bak
@@ -0,0 +1,19 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../sign-wCNCtKGh.mjs";
+import { n as getMetadata, r as oidcProvider, t as getClient } from "../../oidc-provider-ComEKSEi.mjs";
+
+export { getClient, getMetadata, oidcProvider };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/one-tap/index.mjs.bak b/node_modules/better-auth/dist/plugins/one-tap/index.mjs.bak
new file mode 100644
index 0000000..064301c
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/one-tap/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as oneTap } from "../../one-tap-thuUsT_P.mjs";
+
+export { oneTap };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/one-time-token/index.mjs.bak b/node_modules/better-auth/dist/plugins/one-time-token/index.mjs.bak
new file mode 100644
index 0000000..e1808d3
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/one-time-token/index.mjs.bak
@@ -0,0 +1,50 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../password-DWi8yN3A.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import "../../access-6c2-Np4U.mjs";
+import "../../plugin-helper-RJJBTOba.mjs";
+import "../../access-BYnrn7CR.mjs";
+import "../../admin-CJ3jncSX.mjs";
+import "../../has-permission-DhpFBOUO.mjs";
+import "../../anonymous-DCfvRfoL.mjs";
+import { i as oneTimeToken } from "../../plugins-D9JjA_z3.mjs";
+import "../../bearer-DRqPkgUx.mjs";
+import "../../captcha-CU0p6qrj.mjs";
+import "../../custom-session-BDpuPRbk.mjs";
+import "../../device-authorization-CIxU2CCU.mjs";
+import "../../client-WiN43tAS.mjs";
+import "../../email-otp-C08WNTNC.mjs";
+import "../../generic-oauth-BI8Iz1pK.mjs";
+import "../../haveibeenpwned-lb4pgDiK.mjs";
+import "../../sign-wCNCtKGh.mjs";
+import "../../jwt-CLg_nnrd.mjs";
+import "../../magic-link-DCBndC0L.mjs";
+import "../../oidc-provider-ComEKSEi.mjs";
+import "../../multi-session-CxgwAYRM.mjs";
+import "../../oauth-proxy-Dsp9ntvU.mjs";
+import "../../one-tap-thuUsT_P.mjs";
+import "../../open-api-Cb5nhhNu.mjs";
+import "../../organization-D-mvr_hy.mjs";
+import "../../access-HdxSBEa0.mjs";
+import "../../permission-CDDWgA_O.mjs";
+import "../../phone-number-WeAgIbHL.mjs";
+import "../../siwe-__fBpXPo.mjs";
+import "../../two-factor-2QtPvfKI.mjs";
+import "../../client-CuoyvYUC.mjs";
+import "../../username-DI2v-O3q.mjs";
+
+export { oneTimeToken };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/open-api/index.mjs.bak b/node_modules/better-auth/dist/plugins/open-api/index.mjs.bak
new file mode 100644
index 0000000..c3a8e07
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/open-api/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as openAPI } from "../../open-api-Cb5nhhNu.mjs";
+
+export { openAPI };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/organization/access/index.mjs.bak b/node_modules/better-auth/dist/plugins/organization/access/index.mjs.bak
new file mode 100644
index 0000000..40c1a7e
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/organization/access/index.mjs.bak
@@ -0,0 +1,4 @@
+import "../../../access-6c2-Np4U.mjs";
+import { a as memberAc, i as defaultStatements, n as defaultAc, o as ownerAc, r as defaultRoles, t as adminAc } from "../../../access-HdxSBEa0.mjs";
+
+export { adminAc, defaultAc, defaultRoles, defaultStatements, memberAc, ownerAc };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/organization/index.mjs.bak b/node_modules/better-auth/dist/plugins/organization/index.mjs.bak
new file mode 100644
index 0000000..0d06a03
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/organization/index.mjs.bak
@@ -0,0 +1,22 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../parser-DcrIEuXE.mjs";
+import "../../access-6c2-Np4U.mjs";
+import { n as parseRoles, t as organization } from "../../organization-D-mvr_hy.mjs";
+import "../../access-HdxSBEa0.mjs";
+import "../../permission-CDDWgA_O.mjs";
+
+export { organization, parseRoles };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/phone-number/index.mjs.bak b/node_modules/better-auth/dist/plugins/phone-number/index.mjs.bak
new file mode 100644
index 0000000..0eea9d4
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/phone-number/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as phoneNumber } from "../../phone-number-WeAgIbHL.mjs";
+
+export { phoneNumber };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/siwe/index.mjs.bak b/node_modules/better-auth/dist/plugins/siwe/index.mjs.bak
new file mode 100644
index 0000000..c99247e
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/siwe/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { t as siwe } from "../../siwe-__fBpXPo.mjs";
+
+export { siwe };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/two-factor/index.mjs.bak b/node_modules/better-auth/dist/plugins/two-factor/index.mjs.bak
new file mode 100644
index 0000000..3731fbe
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/two-factor/index.mjs.bak
@@ -0,0 +1,20 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import "../../password-DWi8yN3A.mjs";
+import { n as TWO_FACTOR_ERROR_CODES, t as twoFactor } from "../../two-factor-2QtPvfKI.mjs";
+import { t as twoFactorClient } from "../../client-CuoyvYUC.mjs";
+
+export { TWO_FACTOR_ERROR_CODES, twoFactor, twoFactorClient };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/plugins/username/index.mjs.bak b/node_modules/better-auth/dist/plugins/username/index.mjs.bak
new file mode 100644
index 0000000..865f2e6
--- /dev/null
+++ b/node_modules/better-auth/dist/plugins/username/index.mjs.bak
@@ -0,0 +1,18 @@
+import "../../dialect-BhkkSrrx.mjs";
+import "../../get-model-name-nJd9iPTo.mjs";
+import "../../get-migration-C1tgKlQ6.mjs";
+import "../../types-BReKsBV6.mjs";
+import "../../utils-F62c-ieM.mjs";
+import "../../crypto-DZW3hrq1.mjs";
+import "../../jwt-CmxZAGe2.mjs";
+import "../../misc-CADLxPeM.mjs";
+import "../../schema-BevzneML.mjs";
+import "../../get-request-ip-kbu825ez.mjs";
+import "../../json-BS-nL3f-.mjs";
+import "../../url-SXU3XD3W.mjs";
+import "../../api-C0IsrmGz.mjs";
+import "../../cookies-Cl2L38B1.mjs";
+import "../../session-Efap-vxj.mjs";
+import { n as USERNAME_ERROR_CODES, t as username } from "../../username-DI2v-O3q.mjs";
+
+export { USERNAME_ERROR_CODES, username };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/promise-BvQ0gTog.mjs.bak b/node_modules/better-auth/dist/promise-BvQ0gTog.mjs.bak
new file mode 100644
index 0000000..94402e0
--- /dev/null
+++ b/node_modules/better-auth/dist/promise-BvQ0gTog.mjs.bak
@@ -0,0 +1,23144 @@
+import { i as __require, t as __commonJS } from "./chunk-BK_LfMhE.mjs";
+
+//#region ../../node_modules/.pnpm/sqlstring@2.3.3/node_modules/sqlstring/lib/SqlString.js
+var require_SqlString = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/sqlstring@2.3.3/node_modules/sqlstring/lib/SqlString.js": ((exports) => {
+	var SqlString$3 = exports;
+	var ID_GLOBAL_REGEXP = /`/g;
+	var QUAL_GLOBAL_REGEXP = /\./g;
+	var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g;
+	var CHARS_ESCAPE_MAP = {
+		"\0": "\\0",
+		"\b": "\\b",
+		"	": "\\t",
+		"\n": "\\n",
+		"\r": "\\r",
+		"": "\\Z",
+		"\"": "\\\"",
+		"'": "\\'",
+		"\\": "\\\\"
+	};
+	SqlString$3.escapeId = function escapeId(val, forbidQualified) {
+		if (Array.isArray(val)) {
+			var sql = "";
+			for (var i$4 = 0; i$4 < val.length; i$4++) sql += (i$4 === 0 ? "" : ", ") + SqlString$3.escapeId(val[i$4], forbidQualified);
+			return sql;
+		} else if (forbidQualified) return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``") + "`";
+		else return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``").replace(QUAL_GLOBAL_REGEXP, "`.`") + "`";
+	};
+	SqlString$3.escape = function escape(val, stringifyObjects, timeZone) {
+		if (val === void 0 || val === null) return "NULL";
+		switch (typeof val) {
+			case "boolean": return val ? "true" : "false";
+			case "number": return val + "";
+			case "object": if (Object.prototype.toString.call(val) === "[object Date]") return SqlString$3.dateToString(val, timeZone || "local");
+			else if (Array.isArray(val)) return SqlString$3.arrayToList(val, timeZone);
+			else if (Buffer.isBuffer(val)) return SqlString$3.bufferToString(val);
+			else if (typeof val.toSqlString === "function") return String(val.toSqlString());
+			else if (stringifyObjects) return escapeString(val.toString());
+			else return SqlString$3.objectToValues(val, timeZone);
+			default: return escapeString(val);
+		}
+	};
+	SqlString$3.arrayToList = function arrayToList(array, timeZone) {
+		var sql = "";
+		for (var i$4 = 0; i$4 < array.length; i$4++) {
+			var val = array[i$4];
+			if (Array.isArray(val)) sql += (i$4 === 0 ? "" : ", ") + "(" + SqlString$3.arrayToList(val, timeZone) + ")";
+			else sql += (i$4 === 0 ? "" : ", ") + SqlString$3.escape(val, true, timeZone);
+		}
+		return sql;
+	};
+	SqlString$3.format = function format(sql, values, stringifyObjects, timeZone) {
+		if (values == null) return sql;
+		if (!Array.isArray(values)) values = [values];
+		var chunkIndex = 0;
+		var placeholdersRegex = /\?+/g;
+		var result = "";
+		var valuesIndex = 0;
+		var match;
+		while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
+			var len = match[0].length;
+			if (len > 2) continue;
+			var value = len === 2 ? SqlString$3.escapeId(values[valuesIndex]) : SqlString$3.escape(values[valuesIndex], stringifyObjects, timeZone);
+			result += sql.slice(chunkIndex, match.index) + value;
+			chunkIndex = placeholdersRegex.lastIndex;
+			valuesIndex++;
+		}
+		if (chunkIndex === 0) return sql;
+		if (chunkIndex < sql.length) return result + sql.slice(chunkIndex);
+		return result;
+	};
+	SqlString$3.dateToString = function dateToString(date, timeZone) {
+		var dt = new Date(date);
+		if (isNaN(dt.getTime())) return "NULL";
+		var year;
+		var month;
+		var day;
+		var hour;
+		var minute;
+		var second;
+		var millisecond;
+		if (timeZone === "local") {
+			year = dt.getFullYear();
+			month = dt.getMonth() + 1;
+			day = dt.getDate();
+			hour = dt.getHours();
+			minute = dt.getMinutes();
+			second = dt.getSeconds();
+			millisecond = dt.getMilliseconds();
+		} else {
+			var tz = convertTimezone(timeZone);
+			if (tz !== false && tz !== 0) dt.setTime(dt.getTime() + tz * 6e4);
+			year = dt.getUTCFullYear();
+			month = dt.getUTCMonth() + 1;
+			day = dt.getUTCDate();
+			hour = dt.getUTCHours();
+			minute = dt.getUTCMinutes();
+			second = dt.getUTCSeconds();
+			millisecond = dt.getUTCMilliseconds();
+		}
+		return escapeString(zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3));
+	};
+	SqlString$3.bufferToString = function bufferToString(buffer$1) {
+		return "X" + escapeString(buffer$1.toString("hex"));
+	};
+	SqlString$3.objectToValues = function objectToValues(object, timeZone) {
+		var sql = "";
+		for (var key$1 in object) {
+			var val = object[key$1];
+			if (typeof val === "function") continue;
+			sql += (sql.length === 0 ? "" : ", ") + SqlString$3.escapeId(key$1) + " = " + SqlString$3.escape(val, true, timeZone);
+		}
+		return sql;
+	};
+	SqlString$3.raw = function raw(sql) {
+		if (typeof sql !== "string") throw new TypeError("argument sql must be a string");
+		return { toSqlString: function toSqlString() {
+			return sql;
+		} };
+	};
+	function escapeString(val) {
+		var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
+		var escapedVal = "";
+		var match;
+		while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
+			escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
+			chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
+		}
+		if (chunkIndex === 0) return "'" + val + "'";
+		if (chunkIndex < val.length) return "'" + escapedVal + val.slice(chunkIndex) + "'";
+		return "'" + escapedVal + "'";
+	}
+	function zeroPad(number, length) {
+		number = number.toString();
+		while (number.length < length) number = "0" + number;
+		return number;
+	}
+	function convertTimezone(tz) {
+		if (tz === "Z") return 0;
+		var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
+		if (m) return (m[1] === "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
+		return false;
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/sqlstring@2.3.3/node_modules/sqlstring/index.js
+var require_sqlstring = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/sqlstring@2.3.3/node_modules/sqlstring/index.js": ((exports, module) => {
+	module.exports = require_SqlString();
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/lru.min@1.1.2/node_modules/lru.min/lib/index.js
+var require_lib$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/lru.min@1.1.2/node_modules/lru.min/lib/index.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.createLRU = void 0;
+	const createLRU$3 = (options) => {
+		let { max } = options;
+		if (!(Number.isInteger(max) && max > 0)) throw new TypeError("`max` must be a positive integer");
+		let size = 0;
+		let head = 0;
+		let tail = 0;
+		let free = [];
+		const { onEviction } = options;
+		const keyMap = /* @__PURE__ */ new Map();
+		const keyList = new Array(max).fill(void 0);
+		const valList = new Array(max).fill(void 0);
+		const next = new Array(max).fill(0);
+		const prev = new Array(max).fill(0);
+		const setTail = (index, type) => {
+			if (index === tail) return;
+			const nextIndex = next[index];
+			const prevIndex = prev[index];
+			if (index === head) head = nextIndex;
+			else if (type === "get" || prevIndex !== 0) next[prevIndex] = nextIndex;
+			if (nextIndex !== 0) prev[nextIndex] = prevIndex;
+			next[tail] = index;
+			prev[index] = tail;
+			next[index] = 0;
+			tail = index;
+		};
+		const _evict = () => {
+			const evictHead = head;
+			const key$1 = keyList[evictHead];
+			onEviction === null || onEviction === void 0 || onEviction(key$1, valList[evictHead]);
+			keyMap.delete(key$1);
+			keyList[evictHead] = void 0;
+			valList[evictHead] = void 0;
+			head = next[evictHead];
+			if (head !== 0) prev[head] = 0;
+			size--;
+			if (size === 0) head = tail = 0;
+			free.push(evictHead);
+			return evictHead;
+		};
+		return {
+			set(key$1, value) {
+				if (key$1 === void 0) return;
+				let index = keyMap.get(key$1);
+				if (index === void 0) {
+					index = size === max ? _evict() : free.length > 0 ? free.pop() : size;
+					keyMap.set(key$1, index);
+					keyList[index] = key$1;
+					size++;
+				} else onEviction === null || onEviction === void 0 || onEviction(key$1, valList[index]);
+				valList[index] = value;
+				if (size === 1) head = tail = index;
+				else setTail(index, "set");
+			},
+			get(key$1) {
+				const index = keyMap.get(key$1);
+				if (index === void 0) return;
+				if (index !== tail) setTail(index, "get");
+				return valList[index];
+			},
+			peek: (key$1) => {
+				const index = keyMap.get(key$1);
+				return index !== void 0 ? valList[index] : void 0;
+			},
+			has: (key$1) => keyMap.has(key$1),
+			*keys() {
+				let current = tail;
+				for (let i$4 = 0; i$4 < size; i$4++) {
+					yield keyList[current];
+					current = prev[current];
+				}
+			},
+			*values() {
+				let current = tail;
+				for (let i$4 = 0; i$4 < size; i$4++) {
+					yield valList[current];
+					current = prev[current];
+				}
+			},
+			*entries() {
+				let current = tail;
+				for (let i$4 = 0; i$4 < size; i$4++) {
+					yield [keyList[current], valList[current]];
+					current = prev[current];
+				}
+			},
+			forEach: (callback) => {
+				let current = tail;
+				for (let i$4 = 0; i$4 < size; i$4++) {
+					const key$1 = keyList[current];
+					const value = valList[current];
+					callback(value, key$1);
+					current = prev[current];
+				}
+			},
+			delete(key$1) {
+				const index = keyMap.get(key$1);
+				if (index === void 0) return false;
+				onEviction === null || onEviction === void 0 || onEviction(key$1, valList[index]);
+				keyMap.delete(key$1);
+				free.push(index);
+				keyList[index] = void 0;
+				valList[index] = void 0;
+				const prevIndex = prev[index];
+				const nextIndex = next[index];
+				if (prevIndex !== 0) next[prevIndex] = nextIndex;
+				if (nextIndex !== 0) prev[nextIndex] = prevIndex;
+				if (index === head) head = nextIndex;
+				if (index === tail) tail = prevIndex;
+				size--;
+				return true;
+			},
+			evict: (number) => {
+				let toPrune = Math.min(number, size);
+				while (toPrune > 0) {
+					_evict();
+					toPrune--;
+				}
+			},
+			clear() {
+				if (typeof onEviction === "function") {
+					const iterator = keyMap.values();
+					for (let result = iterator.next(); !result.done; result = iterator.next()) onEviction(keyList[result.value], valList[result.value]);
+				}
+				keyMap.clear();
+				keyList.fill(void 0);
+				valList.fill(void 0);
+				free = [];
+				size = 0;
+				head = tail = 0;
+			},
+			resize: (newMax) => {
+				if (!(Number.isInteger(newMax) && newMax > 0)) throw new TypeError("`max` must be a positive integer");
+				if (newMax === max) return;
+				if (newMax < max) {
+					let current = tail;
+					const preserve = Math.min(size, newMax);
+					const remove = size - preserve;
+					const newKeyList = new Array(newMax);
+					const newValList = new Array(newMax);
+					const newNext = new Array(newMax);
+					const newPrev = new Array(newMax);
+					for (let i$4 = 1; i$4 <= remove; i$4++) onEviction === null || onEviction === void 0 || onEviction(keyList[i$4], valList[i$4]);
+					for (let i$4 = preserve - 1; i$4 >= 0; i$4--) {
+						newKeyList[i$4] = keyList[current];
+						newValList[i$4] = valList[current];
+						newNext[i$4] = i$4 + 1;
+						newPrev[i$4] = i$4 - 1;
+						keyMap.set(newKeyList[i$4], i$4);
+						current = prev[current];
+					}
+					head = 0;
+					tail = preserve - 1;
+					size = preserve;
+					keyList.length = newMax;
+					valList.length = newMax;
+					next.length = newMax;
+					prev.length = newMax;
+					for (let i$4 = 0; i$4 < preserve; i$4++) {
+						keyList[i$4] = newKeyList[i$4];
+						valList[i$4] = newValList[i$4];
+						next[i$4] = newNext[i$4];
+						prev[i$4] = newPrev[i$4];
+					}
+					free = [];
+					for (let i$4 = preserve; i$4 < newMax; i$4++) free.push(i$4);
+				} else {
+					const fill = newMax - max;
+					keyList.push(...new Array(fill).fill(void 0));
+					valList.push(...new Array(fill).fill(void 0));
+					next.push(...new Array(fill).fill(0));
+					prev.push(...new Array(fill).fill(0));
+				}
+				max = newMax;
+			},
+			get max() {
+				return max;
+			},
+			get size() {
+				return size;
+			},
+			get available() {
+				return max - size;
+			}
+		};
+	};
+	exports.createLRU = createLRU$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/parser_cache.js
+var require_parser_cache = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/parser_cache.js": ((exports, module) => {
+	const { createLRU: createLRU$2 } = require_lib$2();
+	const parserCache$3 = createLRU$2({ max: 15e3 });
+	function keyFromFields(type, fields$1, options, config) {
+		const res = [
+			type,
+			typeof options.nestTables,
+			options.nestTables,
+			Boolean(options.rowsAsArray),
+			Boolean(options.supportBigNumbers || config.supportBigNumbers),
+			Boolean(options.bigNumberStrings || config.bigNumberStrings),
+			typeof options.typeCast === "boolean" ? options.typeCast : typeof options.typeCast,
+			options.timezone || config.timezone,
+			Boolean(options.decimalNumbers),
+			options.dateStrings
+		];
+		for (let i$4 = 0; i$4 < fields$1.length; ++i$4) {
+			const field = fields$1[i$4];
+			res.push([
+				field.name,
+				field.columnType,
+				field.length,
+				field.schema,
+				field.table,
+				field.flags,
+				field.characterSet
+			]);
+		}
+		return JSON.stringify(res, null, 0);
+	}
+	function getParser(type, fields$1, options, config, compiler) {
+		const key$1 = keyFromFields(type, fields$1, options, config);
+		let parser = parserCache$3.get(key$1);
+		if (parser) return parser;
+		parser = compiler(fields$1, options, config);
+		parserCache$3.set(key$1, parser);
+		return parser;
+	}
+	function setMaxCache(max) {
+		parserCache$3.resize(max);
+	}
+	function clearCache() {
+		parserCache$3.clear();
+	}
+	module.exports = {
+		getParser,
+		setMaxCache,
+		clearCache,
+		_keyFromFields: keyFromFields
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/denque@2.1.0/node_modules/denque/index.js
+var require_denque = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/denque@2.1.0/node_modules/denque/index.js": ((exports, module) => {
+	/**
+	* Custom implementation of a double ended queue.
+	*/
+	function Denque(array, options) {
+		var options = options || {};
+		this._capacity = options.capacity;
+		this._head = 0;
+		this._tail = 0;
+		if (Array.isArray(array)) this._fromArray(array);
+		else {
+			this._capacityMask = 3;
+			this._list = new Array(4);
+		}
+	}
+	/**
+	* --------------
+	*  PUBLIC API
+	* -------------
+	*/
+	/**
+	* Returns the item at the specified index from the list.
+	* 0 is the first element, 1 is the second, and so on...
+	* Elements at negative values are that many from the end: -1 is one before the end
+	* (the last element), -2 is two before the end (one before last), etc.
+	* @param index
+	* @returns {*}
+	*/
+	Denque.prototype.peekAt = function peekAt(index) {
+		var i$4 = index;
+		if (i$4 !== (i$4 | 0)) return;
+		var len = this.size();
+		if (i$4 >= len || i$4 < -len) return void 0;
+		if (i$4 < 0) i$4 += len;
+		i$4 = this._head + i$4 & this._capacityMask;
+		return this._list[i$4];
+	};
+	/**
+	* Alias for peekAt()
+	* @param i
+	* @returns {*}
+	*/
+	Denque.prototype.get = function get(i$4) {
+		return this.peekAt(i$4);
+	};
+	/**
+	* Returns the first item in the list without removing it.
+	* @returns {*}
+	*/
+	Denque.prototype.peek = function peek() {
+		if (this._head === this._tail) return void 0;
+		return this._list[this._head];
+	};
+	/**
+	* Alias for peek()
+	* @returns {*}
+	*/
+	Denque.prototype.peekFront = function peekFront() {
+		return this.peek();
+	};
+	/**
+	* Returns the item that is at the back of the queue without removing it.
+	* Uses peekAt(-1)
+	*/
+	Denque.prototype.peekBack = function peekBack() {
+		return this.peekAt(-1);
+	};
+	/**
+	* Returns the current length of the queue
+	* @return {Number}
+	*/
+	Object.defineProperty(Denque.prototype, "length", { get: function length() {
+		return this.size();
+	} });
+	/**
+	* Return the number of items on the list, or 0 if empty.
+	* @returns {number}
+	*/
+	Denque.prototype.size = function size() {
+		if (this._head === this._tail) return 0;
+		if (this._head < this._tail) return this._tail - this._head;
+		else return this._capacityMask + 1 - (this._head - this._tail);
+	};
+	/**
+	* Add an item at the beginning of the list.
+	* @param item
+	*/
+	Denque.prototype.unshift = function unshift(item) {
+		if (arguments.length === 0) return this.size();
+		var len = this._list.length;
+		this._head = this._head - 1 + len & this._capacityMask;
+		this._list[this._head] = item;
+		if (this._tail === this._head) this._growArray();
+		if (this._capacity && this.size() > this._capacity) this.pop();
+		if (this._head < this._tail) return this._tail - this._head;
+		else return this._capacityMask + 1 - (this._head - this._tail);
+	};
+	/**
+	* Remove and return the first item on the list,
+	* Returns undefined if the list is empty.
+	* @returns {*}
+	*/
+	Denque.prototype.shift = function shift() {
+		var head = this._head;
+		if (head === this._tail) return void 0;
+		var item = this._list[head];
+		this._list[head] = void 0;
+		this._head = head + 1 & this._capacityMask;
+		if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
+		return item;
+	};
+	/**
+	* Add an item to the bottom of the list.
+	* @param item
+	*/
+	Denque.prototype.push = function push(item) {
+		if (arguments.length === 0) return this.size();
+		var tail = this._tail;
+		this._list[tail] = item;
+		this._tail = tail + 1 & this._capacityMask;
+		if (this._tail === this._head) this._growArray();
+		if (this._capacity && this.size() > this._capacity) this.shift();
+		if (this._head < this._tail) return this._tail - this._head;
+		else return this._capacityMask + 1 - (this._head - this._tail);
+	};
+	/**
+	* Remove and return the last item on the list.
+	* Returns undefined if the list is empty.
+	* @returns {*}
+	*/
+	Denque.prototype.pop = function pop() {
+		var tail = this._tail;
+		if (tail === this._head) return void 0;
+		var len = this._list.length;
+		this._tail = tail - 1 + len & this._capacityMask;
+		var item = this._list[this._tail];
+		this._list[this._tail] = void 0;
+		if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
+		return item;
+	};
+	/**
+	* Remove and return the item at the specified index from the list.
+	* Returns undefined if the list is empty.
+	* @param index
+	* @returns {*}
+	*/
+	Denque.prototype.removeOne = function removeOne(index) {
+		var i$4 = index;
+		if (i$4 !== (i$4 | 0)) return;
+		if (this._head === this._tail) return void 0;
+		var size = this.size();
+		var len = this._list.length;
+		if (i$4 >= size || i$4 < -size) return void 0;
+		if (i$4 < 0) i$4 += size;
+		i$4 = this._head + i$4 & this._capacityMask;
+		var item = this._list[i$4];
+		var k;
+		if (index < size / 2) {
+			for (k = index; k > 0; k--) this._list[i$4] = this._list[i$4 = i$4 - 1 + len & this._capacityMask];
+			this._list[i$4] = void 0;
+			this._head = this._head + 1 + len & this._capacityMask;
+		} else {
+			for (k = size - 1 - index; k > 0; k--) this._list[i$4] = this._list[i$4 = i$4 + 1 + len & this._capacityMask];
+			this._list[i$4] = void 0;
+			this._tail = this._tail - 1 + len & this._capacityMask;
+		}
+		return item;
+	};
+	/**
+	* Remove number of items from the specified index from the list.
+	* Returns array of removed items.
+	* Returns undefined if the list is empty.
+	* @param index
+	* @param count
+	* @returns {array}
+	*/
+	Denque.prototype.remove = function remove(index, count) {
+		var i$4 = index;
+		var removed;
+		var del_count = count;
+		if (i$4 !== (i$4 | 0)) return;
+		if (this._head === this._tail) return void 0;
+		var size = this.size();
+		var len = this._list.length;
+		if (i$4 >= size || i$4 < -size || count < 1) return void 0;
+		if (i$4 < 0) i$4 += size;
+		if (count === 1 || !count) {
+			removed = new Array(1);
+			removed[0] = this.removeOne(i$4);
+			return removed;
+		}
+		if (i$4 === 0 && i$4 + count >= size) {
+			removed = this.toArray();
+			this.clear();
+			return removed;
+		}
+		if (i$4 + count > size) count = size - i$4;
+		var k;
+		removed = new Array(count);
+		for (k = 0; k < count; k++) removed[k] = this._list[this._head + i$4 + k & this._capacityMask];
+		i$4 = this._head + i$4 & this._capacityMask;
+		if (index + count === size) {
+			this._tail = this._tail - count + len & this._capacityMask;
+			for (k = count; k > 0; k--) this._list[i$4 = i$4 + 1 + len & this._capacityMask] = void 0;
+			return removed;
+		}
+		if (index === 0) {
+			this._head = this._head + count + len & this._capacityMask;
+			for (k = count - 1; k > 0; k--) this._list[i$4 = i$4 + 1 + len & this._capacityMask] = void 0;
+			return removed;
+		}
+		if (i$4 < size / 2) {
+			this._head = this._head + index + count + len & this._capacityMask;
+			for (k = index; k > 0; k--) this.unshift(this._list[i$4 = i$4 - 1 + len & this._capacityMask]);
+			i$4 = this._head - 1 + len & this._capacityMask;
+			while (del_count > 0) {
+				this._list[i$4 = i$4 - 1 + len & this._capacityMask] = void 0;
+				del_count--;
+			}
+			if (index < 0) this._tail = i$4;
+		} else {
+			this._tail = i$4;
+			i$4 = i$4 + count + len & this._capacityMask;
+			for (k = size - (count + index); k > 0; k--) this.push(this._list[i$4++]);
+			i$4 = this._tail;
+			while (del_count > 0) {
+				this._list[i$4 = i$4 + 1 + len & this._capacityMask] = void 0;
+				del_count--;
+			}
+		}
+		if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
+		return removed;
+	};
+	/**
+	* Native splice implementation.
+	* Remove number of items from the specified index from the list and/or add new elements.
+	* Returns array of removed items or empty array if count == 0.
+	* Returns undefined if the list is empty.
+	*
+	* @param index
+	* @param count
+	* @param {...*} [elements]
+	* @returns {array}
+	*/
+	Denque.prototype.splice = function splice(index, count) {
+		var i$4 = index;
+		if (i$4 !== (i$4 | 0)) return;
+		var size = this.size();
+		if (i$4 < 0) i$4 += size;
+		if (i$4 > size) return void 0;
+		if (arguments.length > 2) {
+			var k;
+			var temp;
+			var removed;
+			var arg_len = arguments.length;
+			var len = this._list.length;
+			var arguments_index = 2;
+			if (!size || i$4 < size / 2) {
+				temp = new Array(i$4);
+				for (k = 0; k < i$4; k++) temp[k] = this._list[this._head + k & this._capacityMask];
+				if (count === 0) {
+					removed = [];
+					if (i$4 > 0) this._head = this._head + i$4 + len & this._capacityMask;
+				} else {
+					removed = this.remove(i$4, count);
+					this._head = this._head + i$4 + len & this._capacityMask;
+				}
+				while (arg_len > arguments_index) this.unshift(arguments[--arg_len]);
+				for (k = i$4; k > 0; k--) this.unshift(temp[k - 1]);
+			} else {
+				temp = new Array(size - (i$4 + count));
+				var leng = temp.length;
+				for (k = 0; k < leng; k++) temp[k] = this._list[this._head + i$4 + count + k & this._capacityMask];
+				if (count === 0) {
+					removed = [];
+					if (i$4 != size) this._tail = this._head + i$4 + len & this._capacityMask;
+				} else {
+					removed = this.remove(i$4, count);
+					this._tail = this._tail - leng + len & this._capacityMask;
+				}
+				while (arguments_index < arg_len) this.push(arguments[arguments_index++]);
+				for (k = 0; k < leng; k++) this.push(temp[k]);
+			}
+			return removed;
+		} else return this.remove(i$4, count);
+	};
+	/**
+	* Soft clear - does not reset capacity.
+	*/
+	Denque.prototype.clear = function clear() {
+		this._list = new Array(this._list.length);
+		this._head = 0;
+		this._tail = 0;
+	};
+	/**
+	* Returns true or false whether the list is empty.
+	* @returns {boolean}
+	*/
+	Denque.prototype.isEmpty = function isEmpty() {
+		return this._head === this._tail;
+	};
+	/**
+	* Returns an array of all queue items.
+	* @returns {Array}
+	*/
+	Denque.prototype.toArray = function toArray() {
+		return this._copyArray(false);
+	};
+	/**
+	* -------------
+	*   INTERNALS
+	* -------------
+	*/
+	/**
+	* Fills the queue with items from an array
+	* For use in the constructor
+	* @param array
+	* @private
+	*/
+	Denque.prototype._fromArray = function _fromArray(array) {
+		var length = array.length;
+		var capacity = this._nextPowerOf2(length);
+		this._list = new Array(capacity);
+		this._capacityMask = capacity - 1;
+		this._tail = length;
+		for (var i$4 = 0; i$4 < length; i$4++) this._list[i$4] = array[i$4];
+	};
+	/**
+	*
+	* @param fullCopy
+	* @param size Initialize the array with a specific size. Will default to the current list size
+	* @returns {Array}
+	* @private
+	*/
+	Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
+		var src = this._list;
+		var capacity = src.length;
+		var length = this.length;
+		size = size | length;
+		if (size == length && this._head < this._tail) return this._list.slice(this._head, this._tail);
+		var dest = new Array(size);
+		var k = 0;
+		var i$4;
+		if (fullCopy || this._head > this._tail) {
+			for (i$4 = this._head; i$4 < capacity; i$4++) dest[k++] = src[i$4];
+			for (i$4 = 0; i$4 < this._tail; i$4++) dest[k++] = src[i$4];
+		} else for (i$4 = this._head; i$4 < this._tail; i$4++) dest[k++] = src[i$4];
+		return dest;
+	};
+	/**
+	* Grows the internal list array.
+	* @private
+	*/
+	Denque.prototype._growArray = function _growArray() {
+		if (this._head != 0) {
+			var newList = this._copyArray(true, this._list.length << 1);
+			this._tail = this._list.length;
+			this._head = 0;
+			this._list = newList;
+		} else {
+			this._tail = this._list.length;
+			this._list.length <<= 1;
+		}
+		this._capacityMask = this._capacityMask << 1 | 1;
+	};
+	/**
+	* Shrinks the internal list array.
+	* @private
+	*/
+	Denque.prototype._shrinkArray = function _shrinkArray() {
+		this._list.length >>>= 1;
+		this._capacityMask >>>= 1;
+	};
+	/**
+	* Find the next power of 2, at least 4
+	* @private
+	* @param {number} num 
+	* @returns {number}
+	*/
+	Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
+		var nextPow2 = 1 << Math.log(num) / Math.log(2) + 1;
+		return Math.max(nextPow2, 4);
+	};
+	module.exports = Denque;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/errors.js
+var require_errors = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/errors.js": ((exports) => {
+	/**
+	* MySQL error constants
+	*
+	* Extracted from version 8.0.33
+	*
+	* !! Generated by generate-error-constants.js, do not modify by hand !!
+	*/
+	exports.EE_CANTCREATEFILE = 1;
+	exports.EE_READ = 2;
+	exports.EE_WRITE = 3;
+	exports.EE_BADCLOSE = 4;
+	exports.EE_OUTOFMEMORY = 5;
+	exports.EE_DELETE = 6;
+	exports.EE_LINK = 7;
+	exports.EE_EOFERR = 9;
+	exports.EE_CANTLOCK = 10;
+	exports.EE_CANTUNLOCK = 11;
+	exports.EE_DIR = 12;
+	exports.EE_STAT = 13;
+	exports.EE_CANT_CHSIZE = 14;
+	exports.EE_CANT_OPEN_STREAM = 15;
+	exports.EE_GETWD = 16;
+	exports.EE_SETWD = 17;
+	exports.EE_LINK_WARNING = 18;
+	exports.EE_OPEN_WARNING = 19;
+	exports.EE_DISK_FULL = 20;
+	exports.EE_CANT_MKDIR = 21;
+	exports.EE_UNKNOWN_CHARSET = 22;
+	exports.EE_OUT_OF_FILERESOURCES = 23;
+	exports.EE_CANT_READLINK = 24;
+	exports.EE_CANT_SYMLINK = 25;
+	exports.EE_REALPATH = 26;
+	exports.EE_SYNC = 27;
+	exports.EE_UNKNOWN_COLLATION = 28;
+	exports.EE_FILENOTFOUND = 29;
+	exports.EE_FILE_NOT_CLOSED = 30;
+	exports.EE_CHANGE_OWNERSHIP = 31;
+	exports.EE_CHANGE_PERMISSIONS = 32;
+	exports.EE_CANT_SEEK = 33;
+	exports.EE_CAPACITY_EXCEEDED = 34;
+	exports.EE_DISK_FULL_WITH_RETRY_MSG = 35;
+	exports.EE_FAILED_TO_CREATE_TIMER = 36;
+	exports.EE_FAILED_TO_DELETE_TIMER = 37;
+	exports.EE_FAILED_TO_CREATE_TIMER_QUEUE = 38;
+	exports.EE_FAILED_TO_START_TIMER_NOTIFY_THREAD = 39;
+	exports.EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT = 40;
+	exports.EE_EXITING_TIMER_NOTIFY_THREAD = 41;
+	exports.EE_WIN_LIBRARY_LOAD_FAILED = 42;
+	exports.EE_WIN_RUN_TIME_ERROR_CHECK = 43;
+	exports.EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE = 44;
+	exports.EE_FAILED_TO_KILL_ALL_THREADS = 45;
+	exports.EE_FAILED_TO_CREATE_IO_COMPLETION_PORT = 46;
+	exports.EE_FAILED_TO_OPEN_DEFAULTS_FILE = 47;
+	exports.EE_FAILED_TO_HANDLE_DEFAULTS_FILE = 48;
+	exports.EE_WRONG_DIRECTIVE_IN_CONFIG_FILE = 49;
+	exports.EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION = 50;
+	exports.EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE = 51;
+	exports.EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE = 52;
+	exports.EE_CONFIG_FILE_PERMISSION_ERROR = 53;
+	exports.EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE = 54;
+	exports.EE_USING_DISABLED_OPTION = 55;
+	exports.EE_USING_DISABLED_SHORT_OPTION = 56;
+	exports.EE_USING_PASSWORD_ON_CLI_IS_INSECURE = 57;
+	exports.EE_UNKNOWN_SUFFIX_FOR_VARIABLE = 58;
+	exports.EE_SSL_ERROR_FROM_FILE = 59;
+	exports.EE_SSL_ERROR = 60;
+	exports.EE_NET_SEND_ERROR_IN_BOOTSTRAP = 61;
+	exports.EE_PACKETS_OUT_OF_ORDER = 62;
+	exports.EE_UNKNOWN_PROTOCOL_OPTION = 63;
+	exports.EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY = 64;
+	exports.EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT = 65;
+	exports.EE_DEBUG_INFO = 66;
+	exports.EE_UNKNOWN_VARIABLE = 67;
+	exports.EE_UNKNOWN_OPTION = 68;
+	exports.EE_UNKNOWN_SHORT_OPTION = 69;
+	exports.EE_OPTION_WITHOUT_ARGUMENT = 70;
+	exports.EE_OPTION_REQUIRES_ARGUMENT = 71;
+	exports.EE_SHORT_OPTION_REQUIRES_ARGUMENT = 72;
+	exports.EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE = 73;
+	exports.EE_OPTION_WITH_EMPTY_VALUE = 74;
+	exports.EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION = 75;
+	exports.EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION = 76;
+	exports.EE_FAILED_TO_SET_OPTION_VALUE = 77;
+	exports.EE_INCORRECT_INT_VALUE_FOR_OPTION = 78;
+	exports.EE_INCORRECT_UINT_VALUE_FOR_OPTION = 79;
+	exports.EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION = 80;
+	exports.EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION = 81;
+	exports.EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION = 82;
+	exports.EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION = 83;
+	exports.EE_INVALID_DECIMAL_VALUE_FOR_OPTION = 84;
+	exports.EE_COLLATION_PARSER_ERROR = 85;
+	exports.EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR = 86;
+	exports.EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR = 87;
+	exports.EE_SHIFT_CHAR_OUT_OF_RANGE = 88;
+	exports.EE_RESET_CHAR_OUT_OF_RANGE = 89;
+	exports.EE_UNKNOWN_LDML_TAG = 90;
+	exports.EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR = 91;
+	exports.EE_FAILED_PROCESSING_DIRECTIVE = 92;
+	exports.EE_PTHREAD_KILL_FAILED = 93;
+	exports.HA_ERR_KEY_NOT_FOUND = 120;
+	exports.HA_ERR_FOUND_DUPP_KEY = 121;
+	exports.HA_ERR_INTERNAL_ERROR = 122;
+	exports.HA_ERR_RECORD_CHANGED = 123;
+	exports.HA_ERR_WRONG_INDEX = 124;
+	exports.HA_ERR_ROLLED_BACK = 125;
+	exports.HA_ERR_CRASHED = 126;
+	exports.HA_ERR_WRONG_IN_RECORD = 127;
+	exports.HA_ERR_OUT_OF_MEM = 128;
+	exports.HA_ERR_NOT_A_TABLE = 130;
+	exports.HA_ERR_WRONG_COMMAND = 131;
+	exports.HA_ERR_OLD_FILE = 132;
+	exports.HA_ERR_NO_ACTIVE_RECORD = 133;
+	exports.HA_ERR_RECORD_DELETED = 134;
+	exports.HA_ERR_RECORD_FILE_FULL = 135;
+	exports.HA_ERR_INDEX_FILE_FULL = 136;
+	exports.HA_ERR_END_OF_FILE = 137;
+	exports.HA_ERR_UNSUPPORTED = 138;
+	exports.HA_ERR_TOO_BIG_ROW = 139;
+	exports.HA_WRONG_CREATE_OPTION = 140;
+	exports.HA_ERR_FOUND_DUPP_UNIQUE = 141;
+	exports.HA_ERR_UNKNOWN_CHARSET = 142;
+	exports.HA_ERR_WRONG_MRG_TABLE_DEF = 143;
+	exports.HA_ERR_CRASHED_ON_REPAIR = 144;
+	exports.HA_ERR_CRASHED_ON_USAGE = 145;
+	exports.HA_ERR_LOCK_WAIT_TIMEOUT = 146;
+	exports.HA_ERR_LOCK_TABLE_FULL = 147;
+	exports.HA_ERR_READ_ONLY_TRANSACTION = 148;
+	exports.HA_ERR_LOCK_DEADLOCK = 149;
+	exports.HA_ERR_CANNOT_ADD_FOREIGN = 150;
+	exports.HA_ERR_NO_REFERENCED_ROW = 151;
+	exports.HA_ERR_ROW_IS_REFERENCED = 152;
+	exports.HA_ERR_NO_SAVEPOINT = 153;
+	exports.HA_ERR_NON_UNIQUE_BLOCK_SIZE = 154;
+	exports.HA_ERR_NO_SUCH_TABLE = 155;
+	exports.HA_ERR_TABLE_EXIST = 156;
+	exports.HA_ERR_NO_CONNECTION = 157;
+	exports.HA_ERR_NULL_IN_SPATIAL = 158;
+	exports.HA_ERR_TABLE_DEF_CHANGED = 159;
+	exports.HA_ERR_NO_PARTITION_FOUND = 160;
+	exports.HA_ERR_RBR_LOGGING_FAILED = 161;
+	exports.HA_ERR_DROP_INDEX_FK = 162;
+	exports.HA_ERR_FOREIGN_DUPLICATE_KEY = 163;
+	exports.HA_ERR_TABLE_NEEDS_UPGRADE = 164;
+	exports.HA_ERR_TABLE_READONLY = 165;
+	exports.HA_ERR_AUTOINC_READ_FAILED = 166;
+	exports.HA_ERR_AUTOINC_ERANGE = 167;
+	exports.HA_ERR_GENERIC = 168;
+	exports.HA_ERR_RECORD_IS_THE_SAME = 169;
+	exports.HA_ERR_LOGGING_IMPOSSIBLE = 170;
+	exports.HA_ERR_CORRUPT_EVENT = 171;
+	exports.HA_ERR_NEW_FILE = 172;
+	exports.HA_ERR_ROWS_EVENT_APPLY = 173;
+	exports.HA_ERR_INITIALIZATION = 174;
+	exports.HA_ERR_FILE_TOO_SHORT = 175;
+	exports.HA_ERR_WRONG_CRC = 176;
+	exports.HA_ERR_TOO_MANY_CONCURRENT_TRXS = 177;
+	exports.HA_ERR_NOT_IN_LOCK_PARTITIONS = 178;
+	exports.HA_ERR_INDEX_COL_TOO_LONG = 179;
+	exports.HA_ERR_INDEX_CORRUPT = 180;
+	exports.HA_ERR_UNDO_REC_TOO_BIG = 181;
+	exports.HA_FTS_INVALID_DOCID = 182;
+	exports.HA_ERR_TABLE_IN_FK_CHECK = 183;
+	exports.HA_ERR_TABLESPACE_EXISTS = 184;
+	exports.HA_ERR_TOO_MANY_FIELDS = 185;
+	exports.HA_ERR_ROW_IN_WRONG_PARTITION = 186;
+	exports.HA_ERR_INNODB_READ_ONLY = 187;
+	exports.HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT = 188;
+	exports.HA_ERR_TEMP_FILE_WRITE_FAILURE = 189;
+	exports.HA_ERR_INNODB_FORCED_RECOVERY = 190;
+	exports.HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE = 191;
+	exports.HA_ERR_FK_DEPTH_EXCEEDED = 192;
+	exports.HA_MISSING_CREATE_OPTION = 193;
+	exports.HA_ERR_SE_OUT_OF_MEMORY = 194;
+	exports.HA_ERR_TABLE_CORRUPT = 195;
+	exports.HA_ERR_QUERY_INTERRUPTED = 196;
+	exports.HA_ERR_TABLESPACE_MISSING = 197;
+	exports.HA_ERR_TABLESPACE_IS_NOT_EMPTY = 198;
+	exports.HA_ERR_WRONG_FILE_NAME = 199;
+	exports.HA_ERR_NOT_ALLOWED_COMMAND = 200;
+	exports.HA_ERR_COMPUTE_FAILED = 201;
+	exports.HA_ERR_ROW_FORMAT_CHANGED = 202;
+	exports.HA_ERR_NO_WAIT_LOCK = 203;
+	exports.HA_ERR_DISK_FULL_NOWAIT = 204;
+	exports.HA_ERR_NO_SESSION_TEMP = 205;
+	exports.HA_ERR_WRONG_TABLE_NAME = 206;
+	exports.HA_ERR_TOO_LONG_PATH = 207;
+	exports.HA_ERR_SAMPLING_INIT_FAILED = 208;
+	exports.HA_ERR_FTS_TOO_MANY_NESTED_EXP = 209;
+	exports.ER_HASHCHK = 1e3;
+	exports.ER_NISAMCHK = 1001;
+	exports.ER_NO = 1002;
+	exports.ER_YES = 1003;
+	exports.ER_CANT_CREATE_FILE = 1004;
+	exports.ER_CANT_CREATE_TABLE = 1005;
+	exports.ER_CANT_CREATE_DB = 1006;
+	exports.ER_DB_CREATE_EXISTS = 1007;
+	exports.ER_DB_DROP_EXISTS = 1008;
+	exports.ER_DB_DROP_DELETE = 1009;
+	exports.ER_DB_DROP_RMDIR = 1010;
+	exports.ER_CANT_DELETE_FILE = 1011;
+	exports.ER_CANT_FIND_SYSTEM_REC = 1012;
+	exports.ER_CANT_GET_STAT = 1013;
+	exports.ER_CANT_GET_WD = 1014;
+	exports.ER_CANT_LOCK = 1015;
+	exports.ER_CANT_OPEN_FILE = 1016;
+	exports.ER_FILE_NOT_FOUND = 1017;
+	exports.ER_CANT_READ_DIR = 1018;
+	exports.ER_CANT_SET_WD = 1019;
+	exports.ER_CHECKREAD = 1020;
+	exports.ER_DISK_FULL = 1021;
+	exports.ER_DUP_KEY = 1022;
+	exports.ER_ERROR_ON_CLOSE = 1023;
+	exports.ER_ERROR_ON_READ = 1024;
+	exports.ER_ERROR_ON_RENAME = 1025;
+	exports.ER_ERROR_ON_WRITE = 1026;
+	exports.ER_FILE_USED = 1027;
+	exports.ER_FILSORT_ABORT = 1028;
+	exports.ER_FORM_NOT_FOUND = 1029;
+	exports.ER_GET_ERRNO = 1030;
+	exports.ER_ILLEGAL_HA = 1031;
+	exports.ER_KEY_NOT_FOUND = 1032;
+	exports.ER_NOT_FORM_FILE = 1033;
+	exports.ER_NOT_KEYFILE = 1034;
+	exports.ER_OLD_KEYFILE = 1035;
+	exports.ER_OPEN_AS_READONLY = 1036;
+	exports.ER_OUTOFMEMORY = 1037;
+	exports.ER_OUT_OF_SORTMEMORY = 1038;
+	exports.ER_UNEXPECTED_EOF = 1039;
+	exports.ER_CON_COUNT_ERROR = 1040;
+	exports.ER_OUT_OF_RESOURCES = 1041;
+	exports.ER_BAD_HOST_ERROR = 1042;
+	exports.ER_HANDSHAKE_ERROR = 1043;
+	exports.ER_DBACCESS_DENIED_ERROR = 1044;
+	exports.ER_ACCESS_DENIED_ERROR = 1045;
+	exports.ER_NO_DB_ERROR = 1046;
+	exports.ER_UNKNOWN_COM_ERROR = 1047;
+	exports.ER_BAD_NULL_ERROR = 1048;
+	exports.ER_BAD_DB_ERROR = 1049;
+	exports.ER_TABLE_EXISTS_ERROR = 1050;
+	exports.ER_BAD_TABLE_ERROR = 1051;
+	exports.ER_NON_UNIQ_ERROR = 1052;
+	exports.ER_SERVER_SHUTDOWN = 1053;
+	exports.ER_BAD_FIELD_ERROR = 1054;
+	exports.ER_WRONG_FIELD_WITH_GROUP = 1055;
+	exports.ER_WRONG_GROUP_FIELD = 1056;
+	exports.ER_WRONG_SUM_SELECT = 1057;
+	exports.ER_WRONG_VALUE_COUNT = 1058;
+	exports.ER_TOO_LONG_IDENT = 1059;
+	exports.ER_DUP_FIELDNAME = 1060;
+	exports.ER_DUP_KEYNAME = 1061;
+	exports.ER_DUP_ENTRY = 1062;
+	exports.ER_WRONG_FIELD_SPEC = 1063;
+	exports.ER_PARSE_ERROR = 1064;
+	exports.ER_EMPTY_QUERY = 1065;
+	exports.ER_NONUNIQ_TABLE = 1066;
+	exports.ER_INVALID_DEFAULT = 1067;
+	exports.ER_MULTIPLE_PRI_KEY = 1068;
+	exports.ER_TOO_MANY_KEYS = 1069;
+	exports.ER_TOO_MANY_KEY_PARTS = 1070;
+	exports.ER_TOO_LONG_KEY = 1071;
+	exports.ER_KEY_COLUMN_DOES_NOT_EXITS = 1072;
+	exports.ER_BLOB_USED_AS_KEY = 1073;
+	exports.ER_TOO_BIG_FIELDLENGTH = 1074;
+	exports.ER_WRONG_AUTO_KEY = 1075;
+	exports.ER_READY = 1076;
+	exports.ER_NORMAL_SHUTDOWN = 1077;
+	exports.ER_GOT_SIGNAL = 1078;
+	exports.ER_SHUTDOWN_COMPLETE = 1079;
+	exports.ER_FORCING_CLOSE = 1080;
+	exports.ER_IPSOCK_ERROR = 1081;
+	exports.ER_NO_SUCH_INDEX = 1082;
+	exports.ER_WRONG_FIELD_TERMINATORS = 1083;
+	exports.ER_BLOBS_AND_NO_TERMINATED = 1084;
+	exports.ER_TEXTFILE_NOT_READABLE = 1085;
+	exports.ER_FILE_EXISTS_ERROR = 1086;
+	exports.ER_LOAD_INFO = 1087;
+	exports.ER_ALTER_INFO = 1088;
+	exports.ER_WRONG_SUB_KEY = 1089;
+	exports.ER_CANT_REMOVE_ALL_FIELDS = 1090;
+	exports.ER_CANT_DROP_FIELD_OR_KEY = 1091;
+	exports.ER_INSERT_INFO = 1092;
+	exports.ER_UPDATE_TABLE_USED = 1093;
+	exports.ER_NO_SUCH_THREAD = 1094;
+	exports.ER_KILL_DENIED_ERROR = 1095;
+	exports.ER_NO_TABLES_USED = 1096;
+	exports.ER_TOO_BIG_SET = 1097;
+	exports.ER_NO_UNIQUE_LOGFILE = 1098;
+	exports.ER_TABLE_NOT_LOCKED_FOR_WRITE = 1099;
+	exports.ER_TABLE_NOT_LOCKED = 1100;
+	exports.ER_BLOB_CANT_HAVE_DEFAULT = 1101;
+	exports.ER_WRONG_DB_NAME = 1102;
+	exports.ER_WRONG_TABLE_NAME = 1103;
+	exports.ER_TOO_BIG_SELECT = 1104;
+	exports.ER_UNKNOWN_ERROR = 1105;
+	exports.ER_UNKNOWN_PROCEDURE = 1106;
+	exports.ER_WRONG_PARAMCOUNT_TO_PROCEDURE = 1107;
+	exports.ER_WRONG_PARAMETERS_TO_PROCEDURE = 1108;
+	exports.ER_UNKNOWN_TABLE = 1109;
+	exports.ER_FIELD_SPECIFIED_TWICE = 1110;
+	exports.ER_INVALID_GROUP_FUNC_USE = 1111;
+	exports.ER_UNSUPPORTED_EXTENSION = 1112;
+	exports.ER_TABLE_MUST_HAVE_COLUMNS = 1113;
+	exports.ER_RECORD_FILE_FULL = 1114;
+	exports.ER_UNKNOWN_CHARACTER_SET = 1115;
+	exports.ER_TOO_MANY_TABLES = 1116;
+	exports.ER_TOO_MANY_FIELDS = 1117;
+	exports.ER_TOO_BIG_ROWSIZE = 1118;
+	exports.ER_STACK_OVERRUN = 1119;
+	exports.ER_WRONG_OUTER_JOIN = 1120;
+	exports.ER_NULL_COLUMN_IN_INDEX = 1121;
+	exports.ER_CANT_FIND_UDF = 1122;
+	exports.ER_CANT_INITIALIZE_UDF = 1123;
+	exports.ER_UDF_NO_PATHS = 1124;
+	exports.ER_UDF_EXISTS = 1125;
+	exports.ER_CANT_OPEN_LIBRARY = 1126;
+	exports.ER_CANT_FIND_DL_ENTRY = 1127;
+	exports.ER_FUNCTION_NOT_DEFINED = 1128;
+	exports.ER_HOST_IS_BLOCKED = 1129;
+	exports.ER_HOST_NOT_PRIVILEGED = 1130;
+	exports.ER_PASSWORD_ANONYMOUS_USER = 1131;
+	exports.ER_PASSWORD_NOT_ALLOWED = 1132;
+	exports.ER_PASSWORD_NO_MATCH = 1133;
+	exports.ER_UPDATE_INFO = 1134;
+	exports.ER_CANT_CREATE_THREAD = 1135;
+	exports.ER_WRONG_VALUE_COUNT_ON_ROW = 1136;
+	exports.ER_CANT_REOPEN_TABLE = 1137;
+	exports.ER_INVALID_USE_OF_NULL = 1138;
+	exports.ER_REGEXP_ERROR = 1139;
+	exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS = 1140;
+	exports.ER_NONEXISTING_GRANT = 1141;
+	exports.ER_TABLEACCESS_DENIED_ERROR = 1142;
+	exports.ER_COLUMNACCESS_DENIED_ERROR = 1143;
+	exports.ER_ILLEGAL_GRANT_FOR_TABLE = 1144;
+	exports.ER_GRANT_WRONG_HOST_OR_USER = 1145;
+	exports.ER_NO_SUCH_TABLE = 1146;
+	exports.ER_NONEXISTING_TABLE_GRANT = 1147;
+	exports.ER_NOT_ALLOWED_COMMAND = 1148;
+	exports.ER_SYNTAX_ERROR = 1149;
+	exports.ER_UNUSED1 = 1150;
+	exports.ER_UNUSED2 = 1151;
+	exports.ER_ABORTING_CONNECTION = 1152;
+	exports.ER_NET_PACKET_TOO_LARGE = 1153;
+	exports.ER_NET_READ_ERROR_FROM_PIPE = 1154;
+	exports.ER_NET_FCNTL_ERROR = 1155;
+	exports.ER_NET_PACKETS_OUT_OF_ORDER = 1156;
+	exports.ER_NET_UNCOMPRESS_ERROR = 1157;
+	exports.ER_NET_READ_ERROR = 1158;
+	exports.ER_NET_READ_INTERRUPTED = 1159;
+	exports.ER_NET_ERROR_ON_WRITE = 1160;
+	exports.ER_NET_WRITE_INTERRUPTED = 1161;
+	exports.ER_TOO_LONG_STRING = 1162;
+	exports.ER_TABLE_CANT_HANDLE_BLOB = 1163;
+	exports.ER_TABLE_CANT_HANDLE_AUTO_INCREMENT = 1164;
+	exports.ER_UNUSED3 = 1165;
+	exports.ER_WRONG_COLUMN_NAME = 1166;
+	exports.ER_WRONG_KEY_COLUMN = 1167;
+	exports.ER_WRONG_MRG_TABLE = 1168;
+	exports.ER_DUP_UNIQUE = 1169;
+	exports.ER_BLOB_KEY_WITHOUT_LENGTH = 1170;
+	exports.ER_PRIMARY_CANT_HAVE_NULL = 1171;
+	exports.ER_TOO_MANY_ROWS = 1172;
+	exports.ER_REQUIRES_PRIMARY_KEY = 1173;
+	exports.ER_NO_RAID_COMPILED = 1174;
+	exports.ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE = 1175;
+	exports.ER_KEY_DOES_NOT_EXITS = 1176;
+	exports.ER_CHECK_NO_SUCH_TABLE = 1177;
+	exports.ER_CHECK_NOT_IMPLEMENTED = 1178;
+	exports.ER_CANT_DO_THIS_DURING_AN_TRANSACTION = 1179;
+	exports.ER_ERROR_DURING_COMMIT = 1180;
+	exports.ER_ERROR_DURING_ROLLBACK = 1181;
+	exports.ER_ERROR_DURING_FLUSH_LOGS = 1182;
+	exports.ER_ERROR_DURING_CHECKPOINT = 1183;
+	exports.ER_NEW_ABORTING_CONNECTION = 1184;
+	exports.ER_DUMP_NOT_IMPLEMENTED = 1185;
+	exports.ER_FLUSH_MASTER_BINLOG_CLOSED = 1186;
+	exports.ER_INDEX_REBUILD = 1187;
+	exports.ER_SOURCE = 1188;
+	exports.ER_SOURCE_NET_READ = 1189;
+	exports.ER_SOURCE_NET_WRITE = 1190;
+	exports.ER_FT_MATCHING_KEY_NOT_FOUND = 1191;
+	exports.ER_LOCK_OR_ACTIVE_TRANSACTION = 1192;
+	exports.ER_UNKNOWN_SYSTEM_VARIABLE = 1193;
+	exports.ER_CRASHED_ON_USAGE = 1194;
+	exports.ER_CRASHED_ON_REPAIR = 1195;
+	exports.ER_WARNING_NOT_COMPLETE_ROLLBACK = 1196;
+	exports.ER_TRANS_CACHE_FULL = 1197;
+	exports.ER_SLAVE_MUST_STOP = 1198;
+	exports.ER_REPLICA_NOT_RUNNING = 1199;
+	exports.ER_BAD_REPLICA = 1200;
+	exports.ER_CONNECTION_METADATA = 1201;
+	exports.ER_REPLICA_THREAD = 1202;
+	exports.ER_TOO_MANY_USER_CONNECTIONS = 1203;
+	exports.ER_SET_CONSTANTS_ONLY = 1204;
+	exports.ER_LOCK_WAIT_TIMEOUT = 1205;
+	exports.ER_LOCK_TABLE_FULL = 1206;
+	exports.ER_READ_ONLY_TRANSACTION = 1207;
+	exports.ER_DROP_DB_WITH_READ_LOCK = 1208;
+	exports.ER_CREATE_DB_WITH_READ_LOCK = 1209;
+	exports.ER_WRONG_ARGUMENTS = 1210;
+	exports.ER_NO_PERMISSION_TO_CREATE_USER = 1211;
+	exports.ER_UNION_TABLES_IN_DIFFERENT_DIR = 1212;
+	exports.ER_LOCK_DEADLOCK = 1213;
+	exports.ER_TABLE_CANT_HANDLE_FT = 1214;
+	exports.ER_CANNOT_ADD_FOREIGN = 1215;
+	exports.ER_NO_REFERENCED_ROW = 1216;
+	exports.ER_ROW_IS_REFERENCED = 1217;
+	exports.ER_CONNECT_TO_SOURCE = 1218;
+	exports.ER_QUERY_ON_MASTER = 1219;
+	exports.ER_ERROR_WHEN_EXECUTING_COMMAND = 1220;
+	exports.ER_WRONG_USAGE = 1221;
+	exports.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT = 1222;
+	exports.ER_CANT_UPDATE_WITH_READLOCK = 1223;
+	exports.ER_MIXING_NOT_ALLOWED = 1224;
+	exports.ER_DUP_ARGUMENT = 1225;
+	exports.ER_USER_LIMIT_REACHED = 1226;
+	exports.ER_SPECIFIC_ACCESS_DENIED_ERROR = 1227;
+	exports.ER_LOCAL_VARIABLE = 1228;
+	exports.ER_GLOBAL_VARIABLE = 1229;
+	exports.ER_NO_DEFAULT = 1230;
+	exports.ER_WRONG_VALUE_FOR_VAR = 1231;
+	exports.ER_WRONG_TYPE_FOR_VAR = 1232;
+	exports.ER_VAR_CANT_BE_READ = 1233;
+	exports.ER_CANT_USE_OPTION_HERE = 1234;
+	exports.ER_NOT_SUPPORTED_YET = 1235;
+	exports.ER_SOURCE_FATAL_ERROR_READING_BINLOG = 1236;
+	exports.ER_REPLICA_IGNORED_TABLE = 1237;
+	exports.ER_INCORRECT_GLOBAL_LOCAL_VAR = 1238;
+	exports.ER_WRONG_FK_DEF = 1239;
+	exports.ER_KEY_REF_DO_NOT_MATCH_TABLE_REF = 1240;
+	exports.ER_OPERAND_COLUMNS = 1241;
+	exports.ER_SUBQUERY_NO_1_ROW = 1242;
+	exports.ER_UNKNOWN_STMT_HANDLER = 1243;
+	exports.ER_CORRUPT_HELP_DB = 1244;
+	exports.ER_CYCLIC_REFERENCE = 1245;
+	exports.ER_AUTO_CONVERT = 1246;
+	exports.ER_ILLEGAL_REFERENCE = 1247;
+	exports.ER_DERIVED_MUST_HAVE_ALIAS = 1248;
+	exports.ER_SELECT_REDUCED = 1249;
+	exports.ER_TABLENAME_NOT_ALLOWED_HERE = 1250;
+	exports.ER_NOT_SUPPORTED_AUTH_MODE = 1251;
+	exports.ER_SPATIAL_CANT_HAVE_NULL = 1252;
+	exports.ER_COLLATION_CHARSET_MISMATCH = 1253;
+	exports.ER_SLAVE_WAS_RUNNING = 1254;
+	exports.ER_SLAVE_WAS_NOT_RUNNING = 1255;
+	exports.ER_TOO_BIG_FOR_UNCOMPRESS = 1256;
+	exports.ER_ZLIB_Z_MEM_ERROR = 1257;
+	exports.ER_ZLIB_Z_BUF_ERROR = 1258;
+	exports.ER_ZLIB_Z_DATA_ERROR = 1259;
+	exports.ER_CUT_VALUE_GROUP_CONCAT = 1260;
+	exports.ER_WARN_TOO_FEW_RECORDS = 1261;
+	exports.ER_WARN_TOO_MANY_RECORDS = 1262;
+	exports.ER_WARN_NULL_TO_NOTNULL = 1263;
+	exports.ER_WARN_DATA_OUT_OF_RANGE = 1264;
+	exports.WARN_DATA_TRUNCATED = 1265;
+	exports.ER_WARN_USING_OTHER_HANDLER = 1266;
+	exports.ER_CANT_AGGREGATE_2COLLATIONS = 1267;
+	exports.ER_DROP_USER = 1268;
+	exports.ER_REVOKE_GRANTS = 1269;
+	exports.ER_CANT_AGGREGATE_3COLLATIONS = 1270;
+	exports.ER_CANT_AGGREGATE_NCOLLATIONS = 1271;
+	exports.ER_VARIABLE_IS_NOT_STRUCT = 1272;
+	exports.ER_UNKNOWN_COLLATION = 1273;
+	exports.ER_REPLICA_IGNORED_SSL_PARAMS = 1274;
+	exports.ER_SERVER_IS_IN_SECURE_AUTH_MODE = 1275;
+	exports.ER_WARN_FIELD_RESOLVED = 1276;
+	exports.ER_BAD_REPLICA_UNTIL_COND = 1277;
+	exports.ER_MISSING_SKIP_REPLICA = 1278;
+	exports.ER_UNTIL_COND_IGNORED = 1279;
+	exports.ER_WRONG_NAME_FOR_INDEX = 1280;
+	exports.ER_WRONG_NAME_FOR_CATALOG = 1281;
+	exports.ER_WARN_QC_RESIZE = 1282;
+	exports.ER_BAD_FT_COLUMN = 1283;
+	exports.ER_UNKNOWN_KEY_CACHE = 1284;
+	exports.ER_WARN_HOSTNAME_WONT_WORK = 1285;
+	exports.ER_UNKNOWN_STORAGE_ENGINE = 1286;
+	exports.ER_WARN_DEPRECATED_SYNTAX = 1287;
+	exports.ER_NON_UPDATABLE_TABLE = 1288;
+	exports.ER_FEATURE_DISABLED = 1289;
+	exports.ER_OPTION_PREVENTS_STATEMENT = 1290;
+	exports.ER_DUPLICATED_VALUE_IN_TYPE = 1291;
+	exports.ER_TRUNCATED_WRONG_VALUE = 1292;
+	exports.ER_TOO_MUCH_AUTO_TIMESTAMP_COLS = 1293;
+	exports.ER_INVALID_ON_UPDATE = 1294;
+	exports.ER_UNSUPPORTED_PS = 1295;
+	exports.ER_GET_ERRMSG = 1296;
+	exports.ER_GET_TEMPORARY_ERRMSG = 1297;
+	exports.ER_UNKNOWN_TIME_ZONE = 1298;
+	exports.ER_WARN_INVALID_TIMESTAMP = 1299;
+	exports.ER_INVALID_CHARACTER_STRING = 1300;
+	exports.ER_WARN_ALLOWED_PACKET_OVERFLOWED = 1301;
+	exports.ER_CONFLICTING_DECLARATIONS = 1302;
+	exports.ER_SP_NO_RECURSIVE_CREATE = 1303;
+	exports.ER_SP_ALREADY_EXISTS = 1304;
+	exports.ER_SP_DOES_NOT_EXIST = 1305;
+	exports.ER_SP_DROP_FAILED = 1306;
+	exports.ER_SP_STORE_FAILED = 1307;
+	exports.ER_SP_LILABEL_MISMATCH = 1308;
+	exports.ER_SP_LABEL_REDEFINE = 1309;
+	exports.ER_SP_LABEL_MISMATCH = 1310;
+	exports.ER_SP_UNINIT_VAR = 1311;
+	exports.ER_SP_BADSELECT = 1312;
+	exports.ER_SP_BADRETURN = 1313;
+	exports.ER_SP_BADSTATEMENT = 1314;
+	exports.ER_UPDATE_LOG_DEPRECATED_IGNORED = 1315;
+	exports.ER_UPDATE_LOG_DEPRECATED_TRANSLATED = 1316;
+	exports.ER_QUERY_INTERRUPTED = 1317;
+	exports.ER_SP_WRONG_NO_OF_ARGS = 1318;
+	exports.ER_SP_COND_MISMATCH = 1319;
+	exports.ER_SP_NORETURN = 1320;
+	exports.ER_SP_NORETURNEND = 1321;
+	exports.ER_SP_BAD_CURSOR_QUERY = 1322;
+	exports.ER_SP_BAD_CURSOR_SELECT = 1323;
+	exports.ER_SP_CURSOR_MISMATCH = 1324;
+	exports.ER_SP_CURSOR_ALREADY_OPEN = 1325;
+	exports.ER_SP_CURSOR_NOT_OPEN = 1326;
+	exports.ER_SP_UNDECLARED_VAR = 1327;
+	exports.ER_SP_WRONG_NO_OF_FETCH_ARGS = 1328;
+	exports.ER_SP_FETCH_NO_DATA = 1329;
+	exports.ER_SP_DUP_PARAM = 1330;
+	exports.ER_SP_DUP_VAR = 1331;
+	exports.ER_SP_DUP_COND = 1332;
+	exports.ER_SP_DUP_CURS = 1333;
+	exports.ER_SP_CANT_ALTER = 1334;
+	exports.ER_SP_SUBSELECT_NYI = 1335;
+	exports.ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG = 1336;
+	exports.ER_SP_VARCOND_AFTER_CURSHNDLR = 1337;
+	exports.ER_SP_CURSOR_AFTER_HANDLER = 1338;
+	exports.ER_SP_CASE_NOT_FOUND = 1339;
+	exports.ER_FPARSER_TOO_BIG_FILE = 1340;
+	exports.ER_FPARSER_BAD_HEADER = 1341;
+	exports.ER_FPARSER_EOF_IN_COMMENT = 1342;
+	exports.ER_FPARSER_ERROR_IN_PARAMETER = 1343;
+	exports.ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER = 1344;
+	exports.ER_VIEW_NO_EXPLAIN = 1345;
+	exports.ER_FRM_UNKNOWN_TYPE = 1346;
+	exports.ER_WRONG_OBJECT = 1347;
+	exports.ER_NONUPDATEABLE_COLUMN = 1348;
+	exports.ER_VIEW_SELECT_DERIVED = 1349;
+	exports.ER_VIEW_SELECT_CLAUSE = 1350;
+	exports.ER_VIEW_SELECT_VARIABLE = 1351;
+	exports.ER_VIEW_SELECT_TMPTABLE = 1352;
+	exports.ER_VIEW_WRONG_LIST = 1353;
+	exports.ER_WARN_VIEW_MERGE = 1354;
+	exports.ER_WARN_VIEW_WITHOUT_KEY = 1355;
+	exports.ER_VIEW_INVALID = 1356;
+	exports.ER_SP_NO_DROP_SP = 1357;
+	exports.ER_SP_GOTO_IN_HNDLR = 1358;
+	exports.ER_TRG_ALREADY_EXISTS = 1359;
+	exports.ER_TRG_DOES_NOT_EXIST = 1360;
+	exports.ER_TRG_ON_VIEW_OR_TEMP_TABLE = 1361;
+	exports.ER_TRG_CANT_CHANGE_ROW = 1362;
+	exports.ER_TRG_NO_SUCH_ROW_IN_TRG = 1363;
+	exports.ER_NO_DEFAULT_FOR_FIELD = 1364;
+	exports.ER_DIVISION_BY_ZERO = 1365;
+	exports.ER_TRUNCATED_WRONG_VALUE_FOR_FIELD = 1366;
+	exports.ER_ILLEGAL_VALUE_FOR_TYPE = 1367;
+	exports.ER_VIEW_NONUPD_CHECK = 1368;
+	exports.ER_VIEW_CHECK_FAILED = 1369;
+	exports.ER_PROCACCESS_DENIED_ERROR = 1370;
+	exports.ER_RELAY_LOG_FAIL = 1371;
+	exports.ER_PASSWD_LENGTH = 1372;
+	exports.ER_UNKNOWN_TARGET_BINLOG = 1373;
+	exports.ER_IO_ERR_LOG_INDEX_READ = 1374;
+	exports.ER_BINLOG_PURGE_PROHIBITED = 1375;
+	exports.ER_FSEEK_FAIL = 1376;
+	exports.ER_BINLOG_PURGE_FATAL_ERR = 1377;
+	exports.ER_LOG_IN_USE = 1378;
+	exports.ER_LOG_PURGE_UNKNOWN_ERR = 1379;
+	exports.ER_RELAY_LOG_INIT = 1380;
+	exports.ER_NO_BINARY_LOGGING = 1381;
+	exports.ER_RESERVED_SYNTAX = 1382;
+	exports.ER_WSAS_FAILED = 1383;
+	exports.ER_DIFF_GROUPS_PROC = 1384;
+	exports.ER_NO_GROUP_FOR_PROC = 1385;
+	exports.ER_ORDER_WITH_PROC = 1386;
+	exports.ER_LOGGING_PROHIBIT_CHANGING_OF = 1387;
+	exports.ER_NO_FILE_MAPPING = 1388;
+	exports.ER_WRONG_MAGIC = 1389;
+	exports.ER_PS_MANY_PARAM = 1390;
+	exports.ER_KEY_PART_0 = 1391;
+	exports.ER_VIEW_CHECKSUM = 1392;
+	exports.ER_VIEW_MULTIUPDATE = 1393;
+	exports.ER_VIEW_NO_INSERT_FIELD_LIST = 1394;
+	exports.ER_VIEW_DELETE_MERGE_VIEW = 1395;
+	exports.ER_CANNOT_USER = 1396;
+	exports.ER_XAER_NOTA = 1397;
+	exports.ER_XAER_INVAL = 1398;
+	exports.ER_XAER_RMFAIL = 1399;
+	exports.ER_XAER_OUTSIDE = 1400;
+	exports.ER_XAER_RMERR = 1401;
+	exports.ER_XA_RBROLLBACK = 1402;
+	exports.ER_NONEXISTING_PROC_GRANT = 1403;
+	exports.ER_PROC_AUTO_GRANT_FAIL = 1404;
+	exports.ER_PROC_AUTO_REVOKE_FAIL = 1405;
+	exports.ER_DATA_TOO_LONG = 1406;
+	exports.ER_SP_BAD_SQLSTATE = 1407;
+	exports.ER_STARTUP = 1408;
+	exports.ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR = 1409;
+	exports.ER_CANT_CREATE_USER_WITH_GRANT = 1410;
+	exports.ER_WRONG_VALUE_FOR_TYPE = 1411;
+	exports.ER_TABLE_DEF_CHANGED = 1412;
+	exports.ER_SP_DUP_HANDLER = 1413;
+	exports.ER_SP_NOT_VAR_ARG = 1414;
+	exports.ER_SP_NO_RETSET = 1415;
+	exports.ER_CANT_CREATE_GEOMETRY_OBJECT = 1416;
+	exports.ER_FAILED_ROUTINE_BREAK_BINLOG = 1417;
+	exports.ER_BINLOG_UNSAFE_ROUTINE = 1418;
+	exports.ER_BINLOG_CREATE_ROUTINE_NEED_SUPER = 1419;
+	exports.ER_EXEC_STMT_WITH_OPEN_CURSOR = 1420;
+	exports.ER_STMT_HAS_NO_OPEN_CURSOR = 1421;
+	exports.ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG = 1422;
+	exports.ER_NO_DEFAULT_FOR_VIEW_FIELD = 1423;
+	exports.ER_SP_NO_RECURSION = 1424;
+	exports.ER_TOO_BIG_SCALE = 1425;
+	exports.ER_TOO_BIG_PRECISION = 1426;
+	exports.ER_M_BIGGER_THAN_D = 1427;
+	exports.ER_WRONG_LOCK_OF_SYSTEM_TABLE = 1428;
+	exports.ER_CONNECT_TO_FOREIGN_DATA_SOURCE = 1429;
+	exports.ER_QUERY_ON_FOREIGN_DATA_SOURCE = 1430;
+	exports.ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST = 1431;
+	exports.ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE = 1432;
+	exports.ER_FOREIGN_DATA_STRING_INVALID = 1433;
+	exports.ER_CANT_CREATE_FEDERATED_TABLE = 1434;
+	exports.ER_TRG_IN_WRONG_SCHEMA = 1435;
+	exports.ER_STACK_OVERRUN_NEED_MORE = 1436;
+	exports.ER_TOO_LONG_BODY = 1437;
+	exports.ER_WARN_CANT_DROP_DEFAULT_KEYCACHE = 1438;
+	exports.ER_TOO_BIG_DISPLAYWIDTH = 1439;
+	exports.ER_XAER_DUPID = 1440;
+	exports.ER_DATETIME_FUNCTION_OVERFLOW = 1441;
+	exports.ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG = 1442;
+	exports.ER_VIEW_PREVENT_UPDATE = 1443;
+	exports.ER_PS_NO_RECURSION = 1444;
+	exports.ER_SP_CANT_SET_AUTOCOMMIT = 1445;
+	exports.ER_MALFORMED_DEFINER = 1446;
+	exports.ER_VIEW_FRM_NO_USER = 1447;
+	exports.ER_VIEW_OTHER_USER = 1448;
+	exports.ER_NO_SUCH_USER = 1449;
+	exports.ER_FORBID_SCHEMA_CHANGE = 1450;
+	exports.ER_ROW_IS_REFERENCED_2 = 1451;
+	exports.ER_NO_REFERENCED_ROW_2 = 1452;
+	exports.ER_SP_BAD_VAR_SHADOW = 1453;
+	exports.ER_TRG_NO_DEFINER = 1454;
+	exports.ER_OLD_FILE_FORMAT = 1455;
+	exports.ER_SP_RECURSION_LIMIT = 1456;
+	exports.ER_SP_PROC_TABLE_CORRUPT = 1457;
+	exports.ER_SP_WRONG_NAME = 1458;
+	exports.ER_TABLE_NEEDS_UPGRADE = 1459;
+	exports.ER_SP_NO_AGGREGATE = 1460;
+	exports.ER_MAX_PREPARED_STMT_COUNT_REACHED = 1461;
+	exports.ER_VIEW_RECURSIVE = 1462;
+	exports.ER_NON_GROUPING_FIELD_USED = 1463;
+	exports.ER_TABLE_CANT_HANDLE_SPKEYS = 1464;
+	exports.ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA = 1465;
+	exports.ER_REMOVED_SPACES = 1466;
+	exports.ER_AUTOINC_READ_FAILED = 1467;
+	exports.ER_USERNAME = 1468;
+	exports.ER_HOSTNAME = 1469;
+	exports.ER_WRONG_STRING_LENGTH = 1470;
+	exports.ER_NON_INSERTABLE_TABLE = 1471;
+	exports.ER_ADMIN_WRONG_MRG_TABLE = 1472;
+	exports.ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT = 1473;
+	exports.ER_NAME_BECOMES_EMPTY = 1474;
+	exports.ER_AMBIGUOUS_FIELD_TERM = 1475;
+	exports.ER_FOREIGN_SERVER_EXISTS = 1476;
+	exports.ER_FOREIGN_SERVER_DOESNT_EXIST = 1477;
+	exports.ER_ILLEGAL_HA_CREATE_OPTION = 1478;
+	exports.ER_PARTITION_REQUIRES_VALUES_ERROR = 1479;
+	exports.ER_PARTITION_WRONG_VALUES_ERROR = 1480;
+	exports.ER_PARTITION_MAXVALUE_ERROR = 1481;
+	exports.ER_PARTITION_SUBPARTITION_ERROR = 1482;
+	exports.ER_PARTITION_SUBPART_MIX_ERROR = 1483;
+	exports.ER_PARTITION_WRONG_NO_PART_ERROR = 1484;
+	exports.ER_PARTITION_WRONG_NO_SUBPART_ERROR = 1485;
+	exports.ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR = 1486;
+	exports.ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR = 1487;
+	exports.ER_FIELD_NOT_FOUND_PART_ERROR = 1488;
+	exports.ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR = 1489;
+	exports.ER_INCONSISTENT_PARTITION_INFO_ERROR = 1490;
+	exports.ER_PARTITION_FUNC_NOT_ALLOWED_ERROR = 1491;
+	exports.ER_PARTITIONS_MUST_BE_DEFINED_ERROR = 1492;
+	exports.ER_RANGE_NOT_INCREASING_ERROR = 1493;
+	exports.ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR = 1494;
+	exports.ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR = 1495;
+	exports.ER_PARTITION_ENTRY_ERROR = 1496;
+	exports.ER_MIX_HANDLER_ERROR = 1497;
+	exports.ER_PARTITION_NOT_DEFINED_ERROR = 1498;
+	exports.ER_TOO_MANY_PARTITIONS_ERROR = 1499;
+	exports.ER_SUBPARTITION_ERROR = 1500;
+	exports.ER_CANT_CREATE_HANDLER_FILE = 1501;
+	exports.ER_BLOB_FIELD_IN_PART_FUNC_ERROR = 1502;
+	exports.ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF = 1503;
+	exports.ER_NO_PARTS_ERROR = 1504;
+	exports.ER_PARTITION_MGMT_ON_NONPARTITIONED = 1505;
+	exports.ER_FOREIGN_KEY_ON_PARTITIONED = 1506;
+	exports.ER_DROP_PARTITION_NON_EXISTENT = 1507;
+	exports.ER_DROP_LAST_PARTITION = 1508;
+	exports.ER_COALESCE_ONLY_ON_HASH_PARTITION = 1509;
+	exports.ER_REORG_HASH_ONLY_ON_SAME_NO = 1510;
+	exports.ER_REORG_NO_PARAM_ERROR = 1511;
+	exports.ER_ONLY_ON_RANGE_LIST_PARTITION = 1512;
+	exports.ER_ADD_PARTITION_SUBPART_ERROR = 1513;
+	exports.ER_ADD_PARTITION_NO_NEW_PARTITION = 1514;
+	exports.ER_COALESCE_PARTITION_NO_PARTITION = 1515;
+	exports.ER_REORG_PARTITION_NOT_EXIST = 1516;
+	exports.ER_SAME_NAME_PARTITION = 1517;
+	exports.ER_NO_BINLOG_ERROR = 1518;
+	exports.ER_CONSECUTIVE_REORG_PARTITIONS = 1519;
+	exports.ER_REORG_OUTSIDE_RANGE = 1520;
+	exports.ER_PARTITION_FUNCTION_FAILURE = 1521;
+	exports.ER_PART_STATE_ERROR = 1522;
+	exports.ER_LIMITED_PART_RANGE = 1523;
+	exports.ER_PLUGIN_IS_NOT_LOADED = 1524;
+	exports.ER_WRONG_VALUE = 1525;
+	exports.ER_NO_PARTITION_FOR_GIVEN_VALUE = 1526;
+	exports.ER_FILEGROUP_OPTION_ONLY_ONCE = 1527;
+	exports.ER_CREATE_FILEGROUP_FAILED = 1528;
+	exports.ER_DROP_FILEGROUP_FAILED = 1529;
+	exports.ER_TABLESPACE_AUTO_EXTEND_ERROR = 1530;
+	exports.ER_WRONG_SIZE_NUMBER = 1531;
+	exports.ER_SIZE_OVERFLOW_ERROR = 1532;
+	exports.ER_ALTER_FILEGROUP_FAILED = 1533;
+	exports.ER_BINLOG_ROW_LOGGING_FAILED = 1534;
+	exports.ER_BINLOG_ROW_WRONG_TABLE_DEF = 1535;
+	exports.ER_BINLOG_ROW_RBR_TO_SBR = 1536;
+	exports.ER_EVENT_ALREADY_EXISTS = 1537;
+	exports.ER_EVENT_STORE_FAILED = 1538;
+	exports.ER_EVENT_DOES_NOT_EXIST = 1539;
+	exports.ER_EVENT_CANT_ALTER = 1540;
+	exports.ER_EVENT_DROP_FAILED = 1541;
+	exports.ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG = 1542;
+	exports.ER_EVENT_ENDS_BEFORE_STARTS = 1543;
+	exports.ER_EVENT_EXEC_TIME_IN_THE_PAST = 1544;
+	exports.ER_EVENT_OPEN_TABLE_FAILED = 1545;
+	exports.ER_EVENT_NEITHER_M_EXPR_NOR_M_AT = 1546;
+	exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED = 1547;
+	exports.ER_CANNOT_LOAD_FROM_TABLE = 1548;
+	exports.ER_EVENT_CANNOT_DELETE = 1549;
+	exports.ER_EVENT_COMPILE_ERROR = 1550;
+	exports.ER_EVENT_SAME_NAME = 1551;
+	exports.ER_EVENT_DATA_TOO_LONG = 1552;
+	exports.ER_DROP_INDEX_FK = 1553;
+	exports.ER_WARN_DEPRECATED_SYNTAX_WITH_VER = 1554;
+	exports.ER_CANT_WRITE_LOCK_LOG_TABLE = 1555;
+	exports.ER_CANT_LOCK_LOG_TABLE = 1556;
+	exports.ER_FOREIGN_DUPLICATE_KEY = 1557;
+	exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE = 1558;
+	exports.ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR = 1559;
+	exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1560;
+	exports.ER_NDB_CANT_SWITCH_BINLOG_FORMAT = 1561;
+	exports.ER_PARTITION_NO_TEMPORARY = 1562;
+	exports.ER_PARTITION_CONST_DOMAIN_ERROR = 1563;
+	exports.ER_PARTITION_FUNCTION_IS_NOT_ALLOWED = 1564;
+	exports.ER_DDL_LOG_ERROR = 1565;
+	exports.ER_NULL_IN_VALUES_LESS_THAN = 1566;
+	exports.ER_WRONG_PARTITION_NAME = 1567;
+	exports.ER_CANT_CHANGE_TX_CHARACTERISTICS = 1568;
+	exports.ER_DUP_ENTRY_AUTOINCREMENT_CASE = 1569;
+	exports.ER_EVENT_MODIFY_QUEUE_ERROR = 1570;
+	exports.ER_EVENT_SET_VAR_ERROR = 1571;
+	exports.ER_PARTITION_MERGE_ERROR = 1572;
+	exports.ER_CANT_ACTIVATE_LOG = 1573;
+	exports.ER_RBR_NOT_AVAILABLE = 1574;
+	exports.ER_BASE64_DECODE_ERROR = 1575;
+	exports.ER_EVENT_RECURSION_FORBIDDEN = 1576;
+	exports.ER_EVENTS_DB_ERROR = 1577;
+	exports.ER_ONLY_INTEGERS_ALLOWED = 1578;
+	exports.ER_UNSUPORTED_LOG_ENGINE = 1579;
+	exports.ER_BAD_LOG_STATEMENT = 1580;
+	exports.ER_CANT_RENAME_LOG_TABLE = 1581;
+	exports.ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT = 1582;
+	exports.ER_WRONG_PARAMETERS_TO_NATIVE_FCT = 1583;
+	exports.ER_WRONG_PARAMETERS_TO_STORED_FCT = 1584;
+	exports.ER_NATIVE_FCT_NAME_COLLISION = 1585;
+	exports.ER_DUP_ENTRY_WITH_KEY_NAME = 1586;
+	exports.ER_BINLOG_PURGE_EMFILE = 1587;
+	exports.ER_EVENT_CANNOT_CREATE_IN_THE_PAST = 1588;
+	exports.ER_EVENT_CANNOT_ALTER_IN_THE_PAST = 1589;
+	exports.ER_SLAVE_INCIDENT = 1590;
+	exports.ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT = 1591;
+	exports.ER_BINLOG_UNSAFE_STATEMENT = 1592;
+	exports.ER_BINLOG_FATAL_ERROR = 1593;
+	exports.ER_SLAVE_RELAY_LOG_READ_FAILURE = 1594;
+	exports.ER_SLAVE_RELAY_LOG_WRITE_FAILURE = 1595;
+	exports.ER_SLAVE_CREATE_EVENT_FAILURE = 1596;
+	exports.ER_SLAVE_MASTER_COM_FAILURE = 1597;
+	exports.ER_BINLOG_LOGGING_IMPOSSIBLE = 1598;
+	exports.ER_VIEW_NO_CREATION_CTX = 1599;
+	exports.ER_VIEW_INVALID_CREATION_CTX = 1600;
+	exports.ER_SR_INVALID_CREATION_CTX = 1601;
+	exports.ER_TRG_CORRUPTED_FILE = 1602;
+	exports.ER_TRG_NO_CREATION_CTX = 1603;
+	exports.ER_TRG_INVALID_CREATION_CTX = 1604;
+	exports.ER_EVENT_INVALID_CREATION_CTX = 1605;
+	exports.ER_TRG_CANT_OPEN_TABLE = 1606;
+	exports.ER_CANT_CREATE_SROUTINE = 1607;
+	exports.ER_NEVER_USED = 1608;
+	exports.ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT = 1609;
+	exports.ER_REPLICA_CORRUPT_EVENT = 1610;
+	exports.ER_LOAD_DATA_INVALID_COLUMN = 1611;
+	exports.ER_LOG_PURGE_NO_FILE = 1612;
+	exports.ER_XA_RBTIMEOUT = 1613;
+	exports.ER_XA_RBDEADLOCK = 1614;
+	exports.ER_NEED_REPREPARE = 1615;
+	exports.ER_DELAYED_NOT_SUPPORTED = 1616;
+	exports.WARN_NO_CONNECTION_METADATA = 1617;
+	exports.WARN_OPTION_IGNORED = 1618;
+	exports.ER_PLUGIN_DELETE_BUILTIN = 1619;
+	exports.WARN_PLUGIN_BUSY = 1620;
+	exports.ER_VARIABLE_IS_READONLY = 1621;
+	exports.ER_WARN_ENGINE_TRANSACTION_ROLLBACK = 1622;
+	exports.ER_SLAVE_HEARTBEAT_FAILURE = 1623;
+	exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE = 1624;
+	exports.ER_NDB_REPLICATION_SCHEMA_ERROR = 1625;
+	exports.ER_CONFLICT_FN_PARSE_ERROR = 1626;
+	exports.ER_EXCEPTIONS_WRITE_ERROR = 1627;
+	exports.ER_TOO_LONG_TABLE_COMMENT = 1628;
+	exports.ER_TOO_LONG_FIELD_COMMENT = 1629;
+	exports.ER_FUNC_INEXISTENT_NAME_COLLISION = 1630;
+	exports.ER_DATABASE_NAME = 1631;
+	exports.ER_TABLE_NAME = 1632;
+	exports.ER_PARTITION_NAME = 1633;
+	exports.ER_SUBPARTITION_NAME = 1634;
+	exports.ER_TEMPORARY_NAME = 1635;
+	exports.ER_RENAMED_NAME = 1636;
+	exports.ER_TOO_MANY_CONCURRENT_TRXS = 1637;
+	exports.WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED = 1638;
+	exports.ER_DEBUG_SYNC_TIMEOUT = 1639;
+	exports.ER_DEBUG_SYNC_HIT_LIMIT = 1640;
+	exports.ER_DUP_SIGNAL_SET = 1641;
+	exports.ER_SIGNAL_WARN = 1642;
+	exports.ER_SIGNAL_NOT_FOUND = 1643;
+	exports.ER_SIGNAL_EXCEPTION = 1644;
+	exports.ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER = 1645;
+	exports.ER_SIGNAL_BAD_CONDITION_TYPE = 1646;
+	exports.WARN_COND_ITEM_TRUNCATED = 1647;
+	exports.ER_COND_ITEM_TOO_LONG = 1648;
+	exports.ER_UNKNOWN_LOCALE = 1649;
+	exports.ER_REPLICA_IGNORE_SERVER_IDS = 1650;
+	exports.ER_QUERY_CACHE_DISABLED = 1651;
+	exports.ER_SAME_NAME_PARTITION_FIELD = 1652;
+	exports.ER_PARTITION_COLUMN_LIST_ERROR = 1653;
+	exports.ER_WRONG_TYPE_COLUMN_VALUE_ERROR = 1654;
+	exports.ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR = 1655;
+	exports.ER_MAXVALUE_IN_VALUES_IN = 1656;
+	exports.ER_TOO_MANY_VALUES_ERROR = 1657;
+	exports.ER_ROW_SINGLE_PARTITION_FIELD_ERROR = 1658;
+	exports.ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD = 1659;
+	exports.ER_PARTITION_FIELDS_TOO_LONG = 1660;
+	exports.ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE = 1661;
+	exports.ER_BINLOG_ROW_MODE_AND_STMT_ENGINE = 1662;
+	exports.ER_BINLOG_UNSAFE_AND_STMT_ENGINE = 1663;
+	exports.ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE = 1664;
+	exports.ER_BINLOG_STMT_MODE_AND_ROW_ENGINE = 1665;
+	exports.ER_BINLOG_ROW_INJECTION_AND_STMT_MODE = 1666;
+	exports.ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1667;
+	exports.ER_BINLOG_UNSAFE_LIMIT = 1668;
+	exports.ER_UNUSED4 = 1669;
+	exports.ER_BINLOG_UNSAFE_SYSTEM_TABLE = 1670;
+	exports.ER_BINLOG_UNSAFE_AUTOINC_COLUMNS = 1671;
+	exports.ER_BINLOG_UNSAFE_UDF = 1672;
+	exports.ER_BINLOG_UNSAFE_SYSTEM_VARIABLE = 1673;
+	exports.ER_BINLOG_UNSAFE_SYSTEM_FUNCTION = 1674;
+	exports.ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS = 1675;
+	exports.ER_MESSAGE_AND_STATEMENT = 1676;
+	exports.ER_SLAVE_CONVERSION_FAILED = 1677;
+	exports.ER_REPLICA_CANT_CREATE_CONVERSION = 1678;
+	exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT = 1679;
+	exports.ER_PATH_LENGTH = 1680;
+	exports.ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT = 1681;
+	exports.ER_WRONG_NATIVE_TABLE_STRUCTURE = 1682;
+	exports.ER_WRONG_PERFSCHEMA_USAGE = 1683;
+	exports.ER_WARN_I_S_SKIPPED_TABLE = 1684;
+	exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1685;
+	exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT = 1686;
+	exports.ER_SPATIAL_MUST_HAVE_GEOM_COL = 1687;
+	exports.ER_TOO_LONG_INDEX_COMMENT = 1688;
+	exports.ER_LOCK_ABORTED = 1689;
+	exports.ER_DATA_OUT_OF_RANGE = 1690;
+	exports.ER_WRONG_SPVAR_TYPE_IN_LIMIT = 1691;
+	exports.ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE = 1692;
+	exports.ER_BINLOG_UNSAFE_MIXED_STATEMENT = 1693;
+	exports.ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1694;
+	exports.ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN = 1695;
+	exports.ER_FAILED_READ_FROM_PAR_FILE = 1696;
+	exports.ER_VALUES_IS_NOT_INT_TYPE_ERROR = 1697;
+	exports.ER_ACCESS_DENIED_NO_PASSWORD_ERROR = 1698;
+	exports.ER_SET_PASSWORD_AUTH_PLUGIN = 1699;
+	exports.ER_GRANT_PLUGIN_USER_EXISTS = 1700;
+	exports.ER_TRUNCATE_ILLEGAL_FK = 1701;
+	exports.ER_PLUGIN_IS_PERMANENT = 1702;
+	exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN = 1703;
+	exports.ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX = 1704;
+	exports.ER_STMT_CACHE_FULL = 1705;
+	exports.ER_MULTI_UPDATE_KEY_CONFLICT = 1706;
+	exports.ER_TABLE_NEEDS_REBUILD = 1707;
+	exports.WARN_OPTION_BELOW_LIMIT = 1708;
+	exports.ER_INDEX_COLUMN_TOO_LONG = 1709;
+	exports.ER_ERROR_IN_TRIGGER_BODY = 1710;
+	exports.ER_ERROR_IN_UNKNOWN_TRIGGER_BODY = 1711;
+	exports.ER_INDEX_CORRUPT = 1712;
+	exports.ER_UNDO_RECORD_TOO_BIG = 1713;
+	exports.ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT = 1714;
+	exports.ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE = 1715;
+	exports.ER_BINLOG_UNSAFE_REPLACE_SELECT = 1716;
+	exports.ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT = 1717;
+	exports.ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT = 1718;
+	exports.ER_BINLOG_UNSAFE_UPDATE_IGNORE = 1719;
+	exports.ER_PLUGIN_NO_UNINSTALL = 1720;
+	exports.ER_PLUGIN_NO_INSTALL = 1721;
+	exports.ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT = 1722;
+	exports.ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC = 1723;
+	exports.ER_BINLOG_UNSAFE_INSERT_TWO_KEYS = 1724;
+	exports.ER_TABLE_IN_FK_CHECK = 1725;
+	exports.ER_UNSUPPORTED_ENGINE = 1726;
+	exports.ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST = 1727;
+	exports.ER_CANNOT_LOAD_FROM_TABLE_V2 = 1728;
+	exports.ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE = 1729;
+	exports.ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT = 1730;
+	exports.ER_PARTITION_EXCHANGE_DIFFERENT_OPTION = 1731;
+	exports.ER_PARTITION_EXCHANGE_PART_TABLE = 1732;
+	exports.ER_PARTITION_EXCHANGE_TEMP_TABLE = 1733;
+	exports.ER_PARTITION_INSTEAD_OF_SUBPARTITION = 1734;
+	exports.ER_UNKNOWN_PARTITION = 1735;
+	exports.ER_TABLES_DIFFERENT_METADATA = 1736;
+	exports.ER_ROW_DOES_NOT_MATCH_PARTITION = 1737;
+	exports.ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX = 1738;
+	exports.ER_WARN_INDEX_NOT_APPLICABLE = 1739;
+	exports.ER_PARTITION_EXCHANGE_FOREIGN_KEY = 1740;
+	exports.ER_NO_SUCH_KEY_VALUE = 1741;
+	exports.ER_RPL_INFO_DATA_TOO_LONG = 1742;
+	exports.ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE = 1743;
+	exports.ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE = 1744;
+	exports.ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX = 1745;
+	exports.ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT = 1746;
+	exports.ER_PARTITION_CLAUSE_ON_NONPARTITIONED = 1747;
+	exports.ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET = 1748;
+	exports.ER_NO_SUCH_PARTITION = 1749;
+	exports.ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE = 1750;
+	exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE = 1751;
+	exports.ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE = 1752;
+	exports.ER_MTA_FEATURE_IS_NOT_SUPPORTED = 1753;
+	exports.ER_MTA_UPDATED_DBS_GREATER_MAX = 1754;
+	exports.ER_MTA_CANT_PARALLEL = 1755;
+	exports.ER_MTA_INCONSISTENT_DATA = 1756;
+	exports.ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING = 1757;
+	exports.ER_DA_INVALID_CONDITION_NUMBER = 1758;
+	exports.ER_INSECURE_PLAIN_TEXT = 1759;
+	exports.ER_INSECURE_CHANGE_SOURCE = 1760;
+	exports.ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO = 1761;
+	exports.ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO = 1762;
+	exports.ER_SQLTHREAD_WITH_SECURE_REPLICA = 1763;
+	exports.ER_TABLE_HAS_NO_FT = 1764;
+	exports.ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER = 1765;
+	exports.ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION = 1766;
+	exports.ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST = 1767;
+	exports.ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION = 1768;
+	exports.ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION = 1769;
+	exports.ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL = 1770;
+	exports.ER_SKIPPING_LOGGED_TRANSACTION = 1771;
+	exports.ER_MALFORMED_GTID_SET_SPECIFICATION = 1772;
+	exports.ER_MALFORMED_GTID_SET_ENCODING = 1773;
+	exports.ER_MALFORMED_GTID_SPECIFICATION = 1774;
+	exports.ER_GNO_EXHAUSTED = 1775;
+	exports.ER_BAD_REPLICA_AUTO_POSITION = 1776;
+	exports.ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF = 1777;
+	exports.ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET = 1778;
+	exports.ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON = 1779;
+	exports.ER_GTID_MODE_REQUIRES_BINLOG = 1780;
+	exports.ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF = 1781;
+	exports.ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON = 1782;
+	exports.ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF = 1783;
+	exports.ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF = 1784;
+	exports.ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE = 1785;
+	exports.ER_GTID_UNSAFE_CREATE_SELECT = 1786;
+	exports.ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION = 1787;
+	exports.ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME = 1788;
+	exports.ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS = 1789;
+	exports.ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID = 1790;
+	exports.ER_UNKNOWN_EXPLAIN_FORMAT = 1791;
+	exports.ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION = 1792;
+	exports.ER_TOO_LONG_TABLE_PARTITION_COMMENT = 1793;
+	exports.ER_REPLICA_CONFIGURATION = 1794;
+	exports.ER_INNODB_FT_LIMIT = 1795;
+	exports.ER_INNODB_NO_FT_TEMP_TABLE = 1796;
+	exports.ER_INNODB_FT_WRONG_DOCID_COLUMN = 1797;
+	exports.ER_INNODB_FT_WRONG_DOCID_INDEX = 1798;
+	exports.ER_INNODB_ONLINE_LOG_TOO_BIG = 1799;
+	exports.ER_UNKNOWN_ALTER_ALGORITHM = 1800;
+	exports.ER_UNKNOWN_ALTER_LOCK = 1801;
+	exports.ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS = 1802;
+	exports.ER_MTA_RECOVERY_FAILURE = 1803;
+	exports.ER_MTA_RESET_WORKERS = 1804;
+	exports.ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2 = 1805;
+	exports.ER_REPLICA_SILENT_RETRY_TRANSACTION = 1806;
+	exports.ER_DISCARD_FK_CHECKS_RUNNING = 1807;
+	exports.ER_TABLE_SCHEMA_MISMATCH = 1808;
+	exports.ER_TABLE_IN_SYSTEM_TABLESPACE = 1809;
+	exports.ER_IO_READ_ERROR = 1810;
+	exports.ER_IO_WRITE_ERROR = 1811;
+	exports.ER_TABLESPACE_MISSING = 1812;
+	exports.ER_TABLESPACE_EXISTS = 1813;
+	exports.ER_TABLESPACE_DISCARDED = 1814;
+	exports.ER_INTERNAL_ERROR = 1815;
+	exports.ER_INNODB_IMPORT_ERROR = 1816;
+	exports.ER_INNODB_INDEX_CORRUPT = 1817;
+	exports.ER_INVALID_YEAR_COLUMN_LENGTH = 1818;
+	exports.ER_NOT_VALID_PASSWORD = 1819;
+	exports.ER_MUST_CHANGE_PASSWORD = 1820;
+	exports.ER_FK_NO_INDEX_CHILD = 1821;
+	exports.ER_FK_NO_INDEX_PARENT = 1822;
+	exports.ER_FK_FAIL_ADD_SYSTEM = 1823;
+	exports.ER_FK_CANNOT_OPEN_PARENT = 1824;
+	exports.ER_FK_INCORRECT_OPTION = 1825;
+	exports.ER_FK_DUP_NAME = 1826;
+	exports.ER_PASSWORD_FORMAT = 1827;
+	exports.ER_FK_COLUMN_CANNOT_DROP = 1828;
+	exports.ER_FK_COLUMN_CANNOT_DROP_CHILD = 1829;
+	exports.ER_FK_COLUMN_NOT_NULL = 1830;
+	exports.ER_DUP_INDEX = 1831;
+	exports.ER_FK_COLUMN_CANNOT_CHANGE = 1832;
+	exports.ER_FK_COLUMN_CANNOT_CHANGE_CHILD = 1833;
+	exports.ER_UNUSED5 = 1834;
+	exports.ER_MALFORMED_PACKET = 1835;
+	exports.ER_READ_ONLY_MODE = 1836;
+	exports.ER_GTID_NEXT_TYPE_UNDEFINED_GTID = 1837;
+	exports.ER_VARIABLE_NOT_SETTABLE_IN_SP = 1838;
+	exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF = 1839;
+	exports.ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY = 1840;
+	exports.ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY = 1841;
+	exports.ER_GTID_PURGED_WAS_CHANGED = 1842;
+	exports.ER_GTID_EXECUTED_WAS_CHANGED = 1843;
+	exports.ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES = 1844;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED = 1845;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON = 1846;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY = 1847;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION = 1848;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME = 1849;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE = 1850;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK = 1851;
+	exports.ER_UNUSED6 = 1852;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK = 1853;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC = 1854;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS = 1855;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS = 1856;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS = 1857;
+	exports.ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE = 1858;
+	exports.ER_DUP_UNKNOWN_IN_INDEX = 1859;
+	exports.ER_IDENT_CAUSES_TOO_LONG_PATH = 1860;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL = 1861;
+	exports.ER_MUST_CHANGE_PASSWORD_LOGIN = 1862;
+	exports.ER_ROW_IN_WRONG_PARTITION = 1863;
+	exports.ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX = 1864;
+	exports.ER_INNODB_NO_FT_USES_PARSER = 1865;
+	exports.ER_BINLOG_LOGICAL_CORRUPTION = 1866;
+	exports.ER_WARN_PURGE_LOG_IN_USE = 1867;
+	exports.ER_WARN_PURGE_LOG_IS_ACTIVE = 1868;
+	exports.ER_AUTO_INCREMENT_CONFLICT = 1869;
+	exports.WARN_ON_BLOCKHOLE_IN_RBR = 1870;
+	exports.ER_REPLICA_CM_INIT_REPOSITORY = 1871;
+	exports.ER_REPLICA_AM_INIT_REPOSITORY = 1872;
+	exports.ER_ACCESS_DENIED_CHANGE_USER_ERROR = 1873;
+	exports.ER_INNODB_READ_ONLY = 1874;
+	exports.ER_STOP_REPLICA_SQL_THREAD_TIMEOUT = 1875;
+	exports.ER_STOP_REPLICA_IO_THREAD_TIMEOUT = 1876;
+	exports.ER_TABLE_CORRUPT = 1877;
+	exports.ER_TEMP_FILE_WRITE_FAILURE = 1878;
+	exports.ER_INNODB_FT_AUX_NOT_HEX_ID = 1879;
+	exports.ER_OLD_TEMPORALS_UPGRADED = 1880;
+	exports.ER_INNODB_FORCED_RECOVERY = 1881;
+	exports.ER_AES_INVALID_IV = 1882;
+	exports.ER_PLUGIN_CANNOT_BE_UNINSTALLED = 1883;
+	exports.ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID = 1884;
+	exports.ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE = 1885;
+	exports.ER_MISSING_KEY = 1886;
+	exports.WARN_NAMED_PIPE_ACCESS_EVERYONE = 1887;
+	exports.ER_FILE_CORRUPT = 3e3;
+	exports.ER_ERROR_ON_SOURCE = 3001;
+	exports.ER_INCONSISTENT_ERROR = 3002;
+	exports.ER_STORAGE_ENGINE_NOT_LOADED = 3003;
+	exports.ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER = 3004;
+	exports.ER_WARN_LEGACY_SYNTAX_CONVERTED = 3005;
+	exports.ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN = 3006;
+	exports.ER_CANNOT_DISCARD_TEMPORARY_TABLE = 3007;
+	exports.ER_FK_DEPTH_EXCEEDED = 3008;
+	exports.ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2 = 3009;
+	exports.ER_WARN_TRIGGER_DOESNT_HAVE_CREATED = 3010;
+	exports.ER_REFERENCED_TRG_DOES_NOT_EXIST = 3011;
+	exports.ER_EXPLAIN_NOT_SUPPORTED = 3012;
+	exports.ER_INVALID_FIELD_SIZE = 3013;
+	exports.ER_MISSING_HA_CREATE_OPTION = 3014;
+	exports.ER_ENGINE_OUT_OF_MEMORY = 3015;
+	exports.ER_PASSWORD_EXPIRE_ANONYMOUS_USER = 3016;
+	exports.ER_REPLICA_SQL_THREAD_MUST_STOP = 3017;
+	exports.ER_NO_FT_MATERIALIZED_SUBQUERY = 3018;
+	exports.ER_INNODB_UNDO_LOG_FULL = 3019;
+	exports.ER_INVALID_ARGUMENT_FOR_LOGARITHM = 3020;
+	exports.ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP = 3021;
+	exports.ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO = 3022;
+	exports.ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS = 3023;
+	exports.ER_QUERY_TIMEOUT = 3024;
+	exports.ER_NON_RO_SELECT_DISABLE_TIMER = 3025;
+	exports.ER_DUP_LIST_ENTRY = 3026;
+	exports.ER_SQL_MODE_NO_EFFECT = 3027;
+	exports.ER_AGGREGATE_ORDER_FOR_UNION = 3028;
+	exports.ER_AGGREGATE_ORDER_NON_AGG_QUERY = 3029;
+	exports.ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR = 3030;
+	exports.ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER = 3031;
+	exports.ER_SERVER_OFFLINE_MODE = 3032;
+	exports.ER_GIS_DIFFERENT_SRIDS = 3033;
+	exports.ER_GIS_UNSUPPORTED_ARGUMENT = 3034;
+	exports.ER_GIS_UNKNOWN_ERROR = 3035;
+	exports.ER_GIS_UNKNOWN_EXCEPTION = 3036;
+	exports.ER_GIS_INVALID_DATA = 3037;
+	exports.ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION = 3038;
+	exports.ER_BOOST_GEOMETRY_CENTROID_EXCEPTION = 3039;
+	exports.ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION = 3040;
+	exports.ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION = 3041;
+	exports.ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION = 3042;
+	exports.ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION = 3043;
+	exports.ER_STD_BAD_ALLOC_ERROR = 3044;
+	exports.ER_STD_DOMAIN_ERROR = 3045;
+	exports.ER_STD_LENGTH_ERROR = 3046;
+	exports.ER_STD_INVALID_ARGUMENT = 3047;
+	exports.ER_STD_OUT_OF_RANGE_ERROR = 3048;
+	exports.ER_STD_OVERFLOW_ERROR = 3049;
+	exports.ER_STD_RANGE_ERROR = 3050;
+	exports.ER_STD_UNDERFLOW_ERROR = 3051;
+	exports.ER_STD_LOGIC_ERROR = 3052;
+	exports.ER_STD_RUNTIME_ERROR = 3053;
+	exports.ER_STD_UNKNOWN_EXCEPTION = 3054;
+	exports.ER_GIS_DATA_WRONG_ENDIANESS = 3055;
+	exports.ER_CHANGE_SOURCE_PASSWORD_LENGTH = 3056;
+	exports.ER_USER_LOCK_WRONG_NAME = 3057;
+	exports.ER_USER_LOCK_DEADLOCK = 3058;
+	exports.ER_REPLACE_INACCESSIBLE_ROWS = 3059;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS = 3060;
+	exports.ER_ILLEGAL_USER_VAR = 3061;
+	exports.ER_GTID_MODE_OFF = 3062;
+	exports.ER_UNSUPPORTED_BY_REPLICATION_THREAD = 3063;
+	exports.ER_INCORRECT_TYPE = 3064;
+	exports.ER_FIELD_IN_ORDER_NOT_SELECT = 3065;
+	exports.ER_AGGREGATE_IN_ORDER_NOT_SELECT = 3066;
+	exports.ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN = 3067;
+	exports.ER_NET_OK_PACKET_TOO_LARGE = 3068;
+	exports.ER_INVALID_JSON_DATA = 3069;
+	exports.ER_INVALID_GEOJSON_MISSING_MEMBER = 3070;
+	exports.ER_INVALID_GEOJSON_WRONG_TYPE = 3071;
+	exports.ER_INVALID_GEOJSON_UNSPECIFIED = 3072;
+	exports.ER_DIMENSION_UNSUPPORTED = 3073;
+	exports.ER_REPLICA_CHANNEL_DOES_NOT_EXIST = 3074;
+	exports.ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT = 3075;
+	exports.ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG = 3076;
+	exports.ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY = 3077;
+	exports.ER_SLAVE_CHANNEL_DELETE = 3078;
+	exports.ER_REPLICA_MULTIPLE_CHANNELS_CMD = 3079;
+	exports.ER_REPLICA_MAX_CHANNELS_EXCEEDED = 3080;
+	exports.ER_REPLICA_CHANNEL_MUST_STOP = 3081;
+	exports.ER_REPLICA_CHANNEL_NOT_RUNNING = 3082;
+	exports.ER_REPLICA_CHANNEL_WAS_RUNNING = 3083;
+	exports.ER_REPLICA_CHANNEL_WAS_NOT_RUNNING = 3084;
+	exports.ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP = 3085;
+	exports.ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER = 3086;
+	exports.ER_WRONG_FIELD_WITH_GROUP_V2 = 3087;
+	exports.ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2 = 3088;
+	exports.ER_WARN_DEPRECATED_SYSVAR_UPDATE = 3089;
+	exports.ER_WARN_DEPRECATED_SQLMODE = 3090;
+	exports.ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID = 3091;
+	exports.ER_GROUP_REPLICATION_CONFIGURATION = 3092;
+	exports.ER_GROUP_REPLICATION_RUNNING = 3093;
+	exports.ER_GROUP_REPLICATION_APPLIER_INIT_ERROR = 3094;
+	exports.ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT = 3095;
+	exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR = 3096;
+	exports.ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR = 3097;
+	exports.ER_BEFORE_DML_VALIDATION_ERROR = 3098;
+	exports.ER_PREVENTS_VARIABLE_WITHOUT_RBR = 3099;
+	exports.ER_RUN_HOOK_ERROR = 3100;
+	exports.ER_TRANSACTION_ROLLBACK_DURING_COMMIT = 3101;
+	exports.ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED = 3102;
+	exports.ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN = 3103;
+	exports.ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN = 3104;
+	exports.ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN = 3105;
+	exports.ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN = 3106;
+	exports.ER_GENERATED_COLUMN_NON_PRIOR = 3107;
+	exports.ER_DEPENDENT_BY_GENERATED_COLUMN = 3108;
+	exports.ER_GENERATED_COLUMN_REF_AUTO_INC = 3109;
+	exports.ER_FEATURE_NOT_AVAILABLE = 3110;
+	exports.ER_CANT_SET_GTID_MODE = 3111;
+	exports.ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF = 3112;
+	exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION = 3113;
+	exports.ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON = 3114;
+	exports.ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF = 3115;
+	exports.ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX = 3116;
+	exports.ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX = 3117;
+	exports.ER_ACCOUNT_HAS_BEEN_LOCKED = 3118;
+	exports.ER_WRONG_TABLESPACE_NAME = 3119;
+	exports.ER_TABLESPACE_IS_NOT_EMPTY = 3120;
+	exports.ER_WRONG_FILE_NAME = 3121;
+	exports.ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION = 3122;
+	exports.ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR = 3123;
+	exports.ER_WARN_BAD_MAX_EXECUTION_TIME = 3124;
+	exports.ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME = 3125;
+	exports.ER_WARN_CONFLICTING_HINT = 3126;
+	exports.ER_WARN_UNKNOWN_QB_NAME = 3127;
+	exports.ER_UNRESOLVED_HINT_NAME = 3128;
+	exports.ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE = 3129;
+	exports.ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED = 3130;
+	exports.ER_LOCKING_SERVICE_WRONG_NAME = 3131;
+	exports.ER_LOCKING_SERVICE_DEADLOCK = 3132;
+	exports.ER_LOCKING_SERVICE_TIMEOUT = 3133;
+	exports.ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED = 3134;
+	exports.ER_SQL_MODE_MERGED = 3135;
+	exports.ER_VTOKEN_PLUGIN_TOKEN_MISMATCH = 3136;
+	exports.ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND = 3137;
+	exports.ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID = 3138;
+	exports.ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED = 3139;
+	exports.ER_INVALID_JSON_TEXT = 3140;
+	exports.ER_INVALID_JSON_TEXT_IN_PARAM = 3141;
+	exports.ER_INVALID_JSON_BINARY_DATA = 3142;
+	exports.ER_INVALID_JSON_PATH = 3143;
+	exports.ER_INVALID_JSON_CHARSET = 3144;
+	exports.ER_INVALID_JSON_CHARSET_IN_FUNCTION = 3145;
+	exports.ER_INVALID_TYPE_FOR_JSON = 3146;
+	exports.ER_INVALID_CAST_TO_JSON = 3147;
+	exports.ER_INVALID_JSON_PATH_CHARSET = 3148;
+	exports.ER_INVALID_JSON_PATH_WILDCARD = 3149;
+	exports.ER_JSON_VALUE_TOO_BIG = 3150;
+	exports.ER_JSON_KEY_TOO_BIG = 3151;
+	exports.ER_JSON_USED_AS_KEY = 3152;
+	exports.ER_JSON_VACUOUS_PATH = 3153;
+	exports.ER_JSON_BAD_ONE_OR_ALL_ARG = 3154;
+	exports.ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE = 3155;
+	exports.ER_INVALID_JSON_VALUE_FOR_CAST = 3156;
+	exports.ER_JSON_DOCUMENT_TOO_DEEP = 3157;
+	exports.ER_JSON_DOCUMENT_NULL_KEY = 3158;
+	exports.ER_SECURE_TRANSPORT_REQUIRED = 3159;
+	exports.ER_NO_SECURE_TRANSPORTS_CONFIGURED = 3160;
+	exports.ER_DISABLED_STORAGE_ENGINE = 3161;
+	exports.ER_USER_DOES_NOT_EXIST = 3162;
+	exports.ER_USER_ALREADY_EXISTS = 3163;
+	exports.ER_AUDIT_API_ABORT = 3164;
+	exports.ER_INVALID_JSON_PATH_ARRAY_CELL = 3165;
+	exports.ER_BUFPOOL_RESIZE_INPROGRESS = 3166;
+	exports.ER_FEATURE_DISABLED_SEE_DOC = 3167;
+	exports.ER_SERVER_ISNT_AVAILABLE = 3168;
+	exports.ER_SESSION_WAS_KILLED = 3169;
+	exports.ER_CAPACITY_EXCEEDED = 3170;
+	exports.ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER = 3171;
+	exports.ER_TABLE_NEEDS_UPG_PART = 3172;
+	exports.ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID = 3173;
+	exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL = 3174;
+	exports.ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT = 3175;
+	exports.ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE = 3176;
+	exports.ER_LOCK_REFUSED_BY_ENGINE = 3177;
+	exports.ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN = 3178;
+	exports.ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE = 3179;
+	exports.ER_MASTER_KEY_ROTATION_ERROR_BY_SE = 3180;
+	exports.ER_MASTER_KEY_ROTATION_BINLOG_FAILED = 3181;
+	exports.ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE = 3182;
+	exports.ER_TABLESPACE_CANNOT_ENCRYPT = 3183;
+	exports.ER_INVALID_ENCRYPTION_OPTION = 3184;
+	exports.ER_CANNOT_FIND_KEY_IN_KEYRING = 3185;
+	exports.ER_CAPACITY_EXCEEDED_IN_PARSER = 3186;
+	exports.ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE = 3187;
+	exports.ER_KEYRING_UDF_KEYRING_SERVICE_ERROR = 3188;
+	exports.ER_USER_COLUMN_OLD_LENGTH = 3189;
+	exports.ER_CANT_RESET_SOURCE = 3190;
+	exports.ER_GROUP_REPLICATION_MAX_GROUP_SIZE = 3191;
+	exports.ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED = 3192;
+	exports.ER_TABLE_REFERENCED = 3193;
+	exports.ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE = 3194;
+	exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO = 3195;
+	exports.ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID = 3196;
+	exports.ER_XA_RETRY = 3197;
+	exports.ER_KEYRING_AWS_UDF_AWS_KMS_ERROR = 3198;
+	exports.ER_BINLOG_UNSAFE_XA = 3199;
+	exports.ER_UDF_ERROR = 3200;
+	exports.ER_KEYRING_MIGRATION_FAILURE = 3201;
+	exports.ER_KEYRING_ACCESS_DENIED_ERROR = 3202;
+	exports.ER_KEYRING_MIGRATION_STATUS = 3203;
+	exports.ER_PLUGIN_FAILED_TO_OPEN_TABLES = 3204;
+	exports.ER_PLUGIN_FAILED_TO_OPEN_TABLE = 3205;
+	exports.ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED = 3206;
+	exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET = 3207;
+	exports.ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY = 3208;
+	exports.ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED = 3209;
+	exports.ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED = 3210;
+	exports.ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE = 3211;
+	exports.ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED = 3212;
+	exports.ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS = 3213;
+	exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE = 3214;
+	exports.ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT = 3215;
+	exports.ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED = 3216;
+	exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE = 3217;
+	exports.ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE = 3218;
+	exports.ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR = 3219;
+	exports.ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY = 3220;
+	exports.ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY = 3221;
+	exports.ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS = 3222;
+	exports.ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC = 3223;
+	exports.ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER = 3224;
+	exports.ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER = 3225;
+	exports.WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP = 3226;
+	exports.ER_XA_REPLICATION_FILTERS = 3227;
+	exports.ER_CANT_OPEN_ERROR_LOG = 3228;
+	exports.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3229;
+	exports.ER_CANT_START_SERVER_NAMED_PIPE = 3230;
+	exports.ER_WRITE_SET_EXCEEDS_LIMIT = 3231;
+	exports.ER_DEPRECATED_TLS_VERSION_SESSION_57 = 3232;
+	exports.ER_WARN_DEPRECATED_TLS_VERSION_57 = 3233;
+	exports.ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE = 3234;
+	exports.ER_AES_INVALID_KDF_NAME = 3235;
+	exports.ER_AES_INVALID_KDF_ITERATIONS = 3236;
+	exports.WARN_AES_KEY_SIZE = 3237;
+	exports.ER_AES_INVALID_KDF_OPTION_SIZE = 3238;
+	exports.ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE = 3500;
+	exports.ER_ACL_OPERATION_FAILED = 3501;
+	exports.ER_UNSUPPORTED_INDEX_ALGORITHM = 3502;
+	exports.ER_NO_SUCH_DB = 3503;
+	exports.ER_TOO_BIG_ENUM = 3504;
+	exports.ER_TOO_LONG_SET_ENUM_VALUE = 3505;
+	exports.ER_INVALID_DD_OBJECT = 3506;
+	exports.ER_UPDATING_DD_TABLE = 3507;
+	exports.ER_INVALID_DD_OBJECT_ID = 3508;
+	exports.ER_INVALID_DD_OBJECT_NAME = 3509;
+	exports.ER_TABLESPACE_MISSING_WITH_NAME = 3510;
+	exports.ER_TOO_LONG_ROUTINE_COMMENT = 3511;
+	exports.ER_SP_LOAD_FAILED = 3512;
+	exports.ER_INVALID_BITWISE_OPERANDS_SIZE = 3513;
+	exports.ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE = 3514;
+	exports.ER_WARN_UNSUPPORTED_HINT = 3515;
+	exports.ER_UNEXPECTED_GEOMETRY_TYPE = 3516;
+	exports.ER_SRS_PARSE_ERROR = 3517;
+	exports.ER_SRS_PROJ_PARAMETER_MISSING = 3518;
+	exports.ER_WARN_SRS_NOT_FOUND = 3519;
+	exports.ER_SRS_NOT_CARTESIAN = 3520;
+	exports.ER_SRS_NOT_CARTESIAN_UNDEFINED = 3521;
+	exports.ER_PK_INDEX_CANT_BE_INVISIBLE = 3522;
+	exports.ER_UNKNOWN_AUTHID = 3523;
+	exports.ER_FAILED_ROLE_GRANT = 3524;
+	exports.ER_OPEN_ROLE_TABLES = 3525;
+	exports.ER_FAILED_DEFAULT_ROLES = 3526;
+	exports.ER_COMPONENTS_NO_SCHEME = 3527;
+	exports.ER_COMPONENTS_NO_SCHEME_SERVICE = 3528;
+	exports.ER_COMPONENTS_CANT_LOAD = 3529;
+	exports.ER_ROLE_NOT_GRANTED = 3530;
+	exports.ER_FAILED_REVOKE_ROLE = 3531;
+	exports.ER_RENAME_ROLE = 3532;
+	exports.ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION = 3533;
+	exports.ER_COMPONENTS_CANT_SATISFY_DEPENDENCY = 3534;
+	exports.ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION = 3535;
+	exports.ER_COMPONENTS_LOAD_CANT_INITIALIZE = 3536;
+	exports.ER_COMPONENTS_UNLOAD_NOT_LOADED = 3537;
+	exports.ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE = 3538;
+	exports.ER_COMPONENTS_CANT_RELEASE_SERVICE = 3539;
+	exports.ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE = 3540;
+	exports.ER_COMPONENTS_CANT_UNLOAD = 3541;
+	exports.ER_WARN_UNLOAD_THE_NOT_PERSISTED = 3542;
+	exports.ER_COMPONENT_TABLE_INCORRECT = 3543;
+	exports.ER_COMPONENT_MANIPULATE_ROW_FAILED = 3544;
+	exports.ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP = 3545;
+	exports.ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS = 3546;
+	exports.ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES = 3547;
+	exports.ER_SRS_NOT_FOUND = 3548;
+	exports.ER_VARIABLE_NOT_PERSISTED = 3549;
+	exports.ER_IS_QUERY_INVALID_CLAUSE = 3550;
+	exports.ER_UNABLE_TO_STORE_STATISTICS = 3551;
+	exports.ER_NO_SYSTEM_SCHEMA_ACCESS = 3552;
+	exports.ER_NO_SYSTEM_TABLESPACE_ACCESS = 3553;
+	exports.ER_NO_SYSTEM_TABLE_ACCESS = 3554;
+	exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE = 3555;
+	exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE = 3556;
+	exports.ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE = 3557;
+	exports.ER_INVALID_OPTION_KEY = 3558;
+	exports.ER_INVALID_OPTION_VALUE = 3559;
+	exports.ER_INVALID_OPTION_KEY_VALUE_PAIR = 3560;
+	exports.ER_INVALID_OPTION_START_CHARACTER = 3561;
+	exports.ER_INVALID_OPTION_END_CHARACTER = 3562;
+	exports.ER_INVALID_OPTION_CHARACTERS = 3563;
+	exports.ER_DUPLICATE_OPTION_KEY = 3564;
+	exports.ER_WARN_SRS_NOT_FOUND_AXIS_ORDER = 3565;
+	exports.ER_NO_ACCESS_TO_NATIVE_FCT = 3566;
+	exports.ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE = 3567;
+	exports.ER_UNRESOLVED_TABLE_LOCK = 3568;
+	exports.ER_DUPLICATE_TABLE_LOCK = 3569;
+	exports.ER_BINLOG_UNSAFE_SKIP_LOCKED = 3570;
+	exports.ER_BINLOG_UNSAFE_NOWAIT = 3571;
+	exports.ER_LOCK_NOWAIT = 3572;
+	exports.ER_CTE_RECURSIVE_REQUIRES_UNION = 3573;
+	exports.ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST = 3574;
+	exports.ER_CTE_RECURSIVE_FORBIDS_AGGREGATION = 3575;
+	exports.ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER = 3576;
+	exports.ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE = 3577;
+	exports.ER_SWITCH_TMP_ENGINE = 3578;
+	exports.ER_WINDOW_NO_SUCH_WINDOW = 3579;
+	exports.ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH = 3580;
+	exports.ER_WINDOW_NO_CHILD_PARTITIONING = 3581;
+	exports.ER_WINDOW_NO_INHERIT_FRAME = 3582;
+	exports.ER_WINDOW_NO_REDEFINE_ORDER_BY = 3583;
+	exports.ER_WINDOW_FRAME_START_ILLEGAL = 3584;
+	exports.ER_WINDOW_FRAME_END_ILLEGAL = 3585;
+	exports.ER_WINDOW_FRAME_ILLEGAL = 3586;
+	exports.ER_WINDOW_RANGE_FRAME_ORDER_TYPE = 3587;
+	exports.ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE = 3588;
+	exports.ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE = 3589;
+	exports.ER_WINDOW_RANGE_BOUND_NOT_CONSTANT = 3590;
+	exports.ER_WINDOW_DUPLICATE_NAME = 3591;
+	exports.ER_WINDOW_ILLEGAL_ORDER_BY = 3592;
+	exports.ER_WINDOW_INVALID_WINDOW_FUNC_USE = 3593;
+	exports.ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE = 3594;
+	exports.ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC = 3595;
+	exports.ER_WINDOW_ROWS_INTERVAL_USE = 3596;
+	exports.ER_WINDOW_NO_GROUP_ORDER = 3597;
+	exports.ER_WINDOW_EXPLAIN_JSON = 3598;
+	exports.ER_WINDOW_FUNCTION_IGNORES_FRAME = 3599;
+	exports.ER_WL9236_NOW = 3600;
+	exports.ER_INVALID_NO_OF_ARGS = 3601;
+	exports.ER_FIELD_IN_GROUPING_NOT_GROUP_BY = 3602;
+	exports.ER_TOO_LONG_TABLESPACE_COMMENT = 3603;
+	exports.ER_ENGINE_CANT_DROP_TABLE = 3604;
+	exports.ER_ENGINE_CANT_DROP_MISSING_TABLE = 3605;
+	exports.ER_TABLESPACE_DUP_FILENAME = 3606;
+	exports.ER_DB_DROP_RMDIR2 = 3607;
+	exports.ER_IMP_NO_FILES_MATCHED = 3608;
+	exports.ER_IMP_SCHEMA_DOES_NOT_EXIST = 3609;
+	exports.ER_IMP_TABLE_ALREADY_EXISTS = 3610;
+	exports.ER_IMP_INCOMPATIBLE_MYSQLD_VERSION = 3611;
+	exports.ER_IMP_INCOMPATIBLE_DD_VERSION = 3612;
+	exports.ER_IMP_INCOMPATIBLE_SDI_VERSION = 3613;
+	exports.ER_WARN_INVALID_HINT = 3614;
+	exports.ER_VAR_DOES_NOT_EXIST = 3615;
+	exports.ER_LONGITUDE_OUT_OF_RANGE = 3616;
+	exports.ER_LATITUDE_OUT_OF_RANGE = 3617;
+	exports.ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS = 3618;
+	exports.ER_ILLEGAL_PRIVILEGE_LEVEL = 3619;
+	exports.ER_NO_SYSTEM_VIEW_ACCESS = 3620;
+	exports.ER_COMPONENT_FILTER_FLABBERGASTED = 3621;
+	exports.ER_PART_EXPR_TOO_LONG = 3622;
+	exports.ER_UDF_DROP_DYNAMICALLY_REGISTERED = 3623;
+	exports.ER_UNABLE_TO_STORE_COLUMN_STATISTICS = 3624;
+	exports.ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS = 3625;
+	exports.ER_UNABLE_TO_DROP_COLUMN_STATISTICS = 3626;
+	exports.ER_UNABLE_TO_BUILD_HISTOGRAM = 3627;
+	exports.ER_MANDATORY_ROLE = 3628;
+	exports.ER_MISSING_TABLESPACE_FILE = 3629;
+	exports.ER_PERSIST_ONLY_ACCESS_DENIED_ERROR = 3630;
+	exports.ER_CMD_NEED_SUPER = 3631;
+	exports.ER_PATH_IN_DATADIR = 3632;
+	exports.ER_CLONE_DDL_IN_PROGRESS = 3633;
+	exports.ER_CLONE_TOO_MANY_CONCURRENT_CLONES = 3634;
+	exports.ER_APPLIER_LOG_EVENT_VALIDATION_ERROR = 3635;
+	exports.ER_CTE_MAX_RECURSION_DEPTH = 3636;
+	exports.ER_NOT_HINT_UPDATABLE_VARIABLE = 3637;
+	exports.ER_CREDENTIALS_CONTRADICT_TO_HISTORY = 3638;
+	exports.ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID = 3639;
+	exports.ER_CLIENT_DOES_NOT_SUPPORT = 3640;
+	exports.ER_I_S_SKIPPED_TABLESPACE = 3641;
+	exports.ER_TABLESPACE_ENGINE_MISMATCH = 3642;
+	exports.ER_WRONG_SRID_FOR_COLUMN = 3643;
+	exports.ER_CANNOT_ALTER_SRID_DUE_TO_INDEX = 3644;
+	exports.ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED = 3645;
+	exports.ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED = 3646;
+	exports.ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES = 3647;
+	exports.ER_COULD_NOT_APPLY_JSON_DIFF = 3648;
+	exports.ER_CORRUPTED_JSON_DIFF = 3649;
+	exports.ER_RESOURCE_GROUP_EXISTS = 3650;
+	exports.ER_RESOURCE_GROUP_NOT_EXISTS = 3651;
+	exports.ER_INVALID_VCPU_ID = 3652;
+	exports.ER_INVALID_VCPU_RANGE = 3653;
+	exports.ER_INVALID_THREAD_PRIORITY = 3654;
+	exports.ER_DISALLOWED_OPERATION = 3655;
+	exports.ER_RESOURCE_GROUP_BUSY = 3656;
+	exports.ER_RESOURCE_GROUP_DISABLED = 3657;
+	exports.ER_FEATURE_UNSUPPORTED = 3658;
+	exports.ER_ATTRIBUTE_IGNORED = 3659;
+	exports.ER_INVALID_THREAD_ID = 3660;
+	exports.ER_RESOURCE_GROUP_BIND_FAILED = 3661;
+	exports.ER_INVALID_USE_OF_FORCE_OPTION = 3662;
+	exports.ER_GROUP_REPLICATION_COMMAND_FAILURE = 3663;
+	exports.ER_SDI_OPERATION_FAILED = 3664;
+	exports.ER_MISSING_JSON_TABLE_VALUE = 3665;
+	exports.ER_WRONG_JSON_TABLE_VALUE = 3666;
+	exports.ER_TF_MUST_HAVE_ALIAS = 3667;
+	exports.ER_TF_FORBIDDEN_JOIN_TYPE = 3668;
+	exports.ER_JT_VALUE_OUT_OF_RANGE = 3669;
+	exports.ER_JT_MAX_NESTED_PATH = 3670;
+	exports.ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD = 3671;
+	exports.ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL = 3672;
+	exports.ER_BAD_NULL_ERROR_NOT_IGNORED = 3673;
+	exports.WARN_USELESS_SPATIAL_INDEX = 3674;
+	exports.ER_DISK_FULL_NOWAIT = 3675;
+	exports.ER_PARSE_ERROR_IN_DIGEST_FN = 3676;
+	exports.ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN = 3677;
+	exports.ER_SCHEMA_DIR_EXISTS = 3678;
+	exports.ER_SCHEMA_DIR_MISSING = 3679;
+	exports.ER_SCHEMA_DIR_CREATE_FAILED = 3680;
+	exports.ER_SCHEMA_DIR_UNKNOWN = 3681;
+	exports.ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326 = 3682;
+	exports.ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER = 3683;
+	exports.ER_REGEXP_BUFFER_OVERFLOW = 3684;
+	exports.ER_REGEXP_ILLEGAL_ARGUMENT = 3685;
+	exports.ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR = 3686;
+	exports.ER_REGEXP_INTERNAL_ERROR = 3687;
+	exports.ER_REGEXP_RULE_SYNTAX = 3688;
+	exports.ER_REGEXP_BAD_ESCAPE_SEQUENCE = 3689;
+	exports.ER_REGEXP_UNIMPLEMENTED = 3690;
+	exports.ER_REGEXP_MISMATCHED_PAREN = 3691;
+	exports.ER_REGEXP_BAD_INTERVAL = 3692;
+	exports.ER_REGEXP_MAX_LT_MIN = 3693;
+	exports.ER_REGEXP_INVALID_BACK_REF = 3694;
+	exports.ER_REGEXP_LOOK_BEHIND_LIMIT = 3695;
+	exports.ER_REGEXP_MISSING_CLOSE_BRACKET = 3696;
+	exports.ER_REGEXP_INVALID_RANGE = 3697;
+	exports.ER_REGEXP_STACK_OVERFLOW = 3698;
+	exports.ER_REGEXP_TIME_OUT = 3699;
+	exports.ER_REGEXP_PATTERN_TOO_BIG = 3700;
+	exports.ER_CANT_SET_ERROR_LOG_SERVICE = 3701;
+	exports.ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE = 3702;
+	exports.ER_COMPONENT_FILTER_DIAGNOSTICS = 3703;
+	exports.ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS = 3704;
+	exports.ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS = 3705;
+	exports.ER_NONPOSITIVE_RADIUS = 3706;
+	exports.ER_RESTART_SERVER_FAILED = 3707;
+	exports.ER_SRS_MISSING_MANDATORY_ATTRIBUTE = 3708;
+	exports.ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS = 3709;
+	exports.ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE = 3710;
+	exports.ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE = 3711;
+	exports.ER_SRS_ID_ALREADY_EXISTS = 3712;
+	exports.ER_WARN_SRS_ID_ALREADY_EXISTS = 3713;
+	exports.ER_CANT_MODIFY_SRID_0 = 3714;
+	exports.ER_WARN_RESERVED_SRID_RANGE = 3715;
+	exports.ER_CANT_MODIFY_SRS_USED_BY_COLUMN = 3716;
+	exports.ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE = 3717;
+	exports.ER_SRS_ATTRIBUTE_STRING_TOO_LONG = 3718;
+	exports.ER_DEPRECATED_UTF8_ALIAS = 3719;
+	exports.ER_DEPRECATED_NATIONAL = 3720;
+	exports.ER_INVALID_DEFAULT_UTF8MB4_COLLATION = 3721;
+	exports.ER_UNABLE_TO_COLLECT_LOG_STATUS = 3722;
+	exports.ER_RESERVED_TABLESPACE_NAME = 3723;
+	exports.ER_UNABLE_TO_SET_OPTION = 3724;
+	exports.ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL = 3725;
+	exports.ER_SRS_NOT_GEOGRAPHIC = 3726;
+	exports.ER_POLYGON_TOO_LARGE = 3727;
+	exports.ER_SPATIAL_UNIQUE_INDEX = 3728;
+	exports.ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX = 3729;
+	exports.ER_FK_CANNOT_DROP_PARENT = 3730;
+	exports.ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE = 3731;
+	exports.ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE = 3732;
+	exports.ER_FK_CANNOT_USE_VIRTUAL_COLUMN = 3733;
+	exports.ER_FK_NO_COLUMN_PARENT = 3734;
+	exports.ER_CANT_SET_ERROR_SUPPRESSION_LIST = 3735;
+	exports.ER_SRS_GEOGCS_INVALID_AXES = 3736;
+	exports.ER_SRS_INVALID_SEMI_MAJOR_AXIS = 3737;
+	exports.ER_SRS_INVALID_INVERSE_FLATTENING = 3738;
+	exports.ER_SRS_INVALID_ANGULAR_UNIT = 3739;
+	exports.ER_SRS_INVALID_PRIME_MERIDIAN = 3740;
+	exports.ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED = 3741;
+	exports.ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED = 3742;
+	exports.ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84 = 3743;
+	exports.ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84 = 3744;
+	exports.ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT = 3745;
+	exports.ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3746;
+	exports.ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT = 3747;
+	exports.ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR = 3748;
+	exports.ER_XA_CANT_CREATE_MDL_BACKUP = 3749;
+	exports.ER_TABLE_WITHOUT_PK = 3750;
+	exports.ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX = 3751;
+	exports.ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX = 3752;
+	exports.ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION = 3753;
+	exports.ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT = 3754;
+	exports.ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX = 3755;
+	exports.ER_FUNCTIONAL_INDEX_PRIMARY_KEY = 3756;
+	exports.ER_FUNCTIONAL_INDEX_ON_LOB = 3757;
+	exports.ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED = 3758;
+	exports.ER_FULLTEXT_FUNCTIONAL_INDEX = 3759;
+	exports.ER_SPATIAL_FUNCTIONAL_INDEX = 3760;
+	exports.ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX = 3761;
+	exports.ER_FUNCTIONAL_INDEX_ON_FIELD = 3762;
+	exports.ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED = 3763;
+	exports.ER_GENERATED_COLUMN_ROW_VALUE = 3764;
+	exports.ER_GENERATED_COLUMN_VARIABLES = 3765;
+	exports.ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE = 3766;
+	exports.ER_DEFAULT_VAL_GENERATED_NON_PRIOR = 3767;
+	exports.ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC = 3768;
+	exports.ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED = 3769;
+	exports.ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED = 3770;
+	exports.ER_DEFAULT_VAL_GENERATED_ROW_VALUE = 3771;
+	exports.ER_DEFAULT_VAL_GENERATED_VARIABLES = 3772;
+	exports.ER_DEFAULT_AS_VAL_GENERATED = 3773;
+	exports.ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED = 3774;
+	exports.ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION = 3775;
+	exports.ER_FK_CANNOT_CHANGE_ENGINE = 3776;
+	exports.ER_WARN_DEPRECATED_USER_SET_EXPR = 3777;
+	exports.ER_WARN_DEPRECATED_UTF8MB3_COLLATION = 3778;
+	exports.ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX = 3779;
+	exports.ER_FK_INCOMPATIBLE_COLUMNS = 3780;
+	exports.ER_GR_HOLD_WAIT_TIMEOUT = 3781;
+	exports.ER_GR_HOLD_KILLED = 3782;
+	exports.ER_GR_HOLD_MEMBER_STATUS_ERROR = 3783;
+	exports.ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY = 3784;
+	exports.ER_RPL_ENCRYPTION_KEY_NOT_FOUND = 3785;
+	exports.ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY = 3786;
+	exports.ER_RPL_ENCRYPTION_HEADER_ERROR = 3787;
+	exports.ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS = 3788;
+	exports.ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED = 3789;
+	exports.ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY = 3790;
+	exports.ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY = 3791;
+	exports.ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY = 3792;
+	exports.ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION = 3793;
+	exports.ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED = 3794;
+	exports.ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE = 3795;
+	exports.ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED = 3796;
+	exports.ER_GRP_TRX_CONSISTENCY_BEFORE = 3797;
+	exports.ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN = 3798;
+	exports.ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED = 3799;
+	exports.ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED = 3800;
+	exports.ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT = 3801;
+	exports.ER_PAGE_TRACKING_NOT_STARTED = 3802;
+	exports.ER_PAGE_TRACKING_RANGE_NOT_TRACKED = 3803;
+	exports.ER_PAGE_TRACKING_CANNOT_PURGE = 3804;
+	exports.ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY = 3805;
+	exports.ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION = 3806;
+	exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY = 3807;
+	exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS = 3808;
+	exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG = 3809;
+	exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS = 3810;
+	exports.ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY = 3811;
+	exports.ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT = 3812;
+	exports.ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN = 3813;
+	exports.ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED = 3814;
+	exports.ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED = 3815;
+	exports.ER_CHECK_CONSTRAINT_VARIABLES = 3816;
+	exports.ER_CHECK_CONSTRAINT_ROW_VALUE = 3817;
+	exports.ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN = 3818;
+	exports.ER_CHECK_CONSTRAINT_VIOLATED = 3819;
+	exports.ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN = 3820;
+	exports.ER_CHECK_CONSTRAINT_NOT_FOUND = 3821;
+	exports.ER_CHECK_CONSTRAINT_DUP_NAME = 3822;
+	exports.ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN = 3823;
+	exports.WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB = 3824;
+	exports.ER_INVALID_ENCRYPTION_REQUEST = 3825;
+	exports.ER_CANNOT_SET_TABLE_ENCRYPTION = 3826;
+	exports.ER_CANNOT_SET_DATABASE_ENCRYPTION = 3827;
+	exports.ER_CANNOT_SET_TABLESPACE_ENCRYPTION = 3828;
+	exports.ER_TABLESPACE_CANNOT_BE_ENCRYPTED = 3829;
+	exports.ER_TABLESPACE_CANNOT_BE_DECRYPTED = 3830;
+	exports.ER_TABLESPACE_TYPE_UNKNOWN = 3831;
+	exports.ER_TARGET_TABLESPACE_UNENCRYPTED = 3832;
+	exports.ER_CANNOT_USE_ENCRYPTION_CLAUSE = 3833;
+	exports.ER_INVALID_MULTIPLE_CLAUSES = 3834;
+	exports.ER_UNSUPPORTED_USE_OF_GRANT_AS = 3835;
+	exports.ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS = 3836;
+	exports.ER_DEPENDENT_BY_FUNCTIONAL_INDEX = 3837;
+	exports.ER_PLUGIN_NOT_EARLY = 3838;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH = 3839;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT = 3840;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID = 3841;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND = 3842;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY = 3843;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR = 3844;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH = 3845;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS = 3846;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE = 3847;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE = 3848;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE = 3849;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_FAILED = 3850;
+	exports.ER_INNODB_REDO_LOG_ARCHIVE_SESSION = 3851;
+	exports.ER_STD_REGEX_ERROR = 3852;
+	exports.ER_INVALID_JSON_TYPE = 3853;
+	exports.ER_CANNOT_CONVERT_STRING = 3854;
+	exports.ER_DEPENDENT_BY_PARTITION_FUNC = 3855;
+	exports.ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT = 3856;
+	exports.ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP = 3857;
+	exports.ER_WARN_DEPRECATED_FLOAT_DIGITS = 3858;
+	exports.ER_WARN_DEPRECATED_FLOAT_UNSIGNED = 3859;
+	exports.ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH = 3860;
+	exports.ER_WARN_DEPRECATED_ZEROFILL = 3861;
+	exports.ER_CLONE_DONOR = 3862;
+	exports.ER_CLONE_PROTOCOL = 3863;
+	exports.ER_CLONE_DONOR_VERSION = 3864;
+	exports.ER_CLONE_OS = 3865;
+	exports.ER_CLONE_PLATFORM = 3866;
+	exports.ER_CLONE_CHARSET = 3867;
+	exports.ER_CLONE_CONFIG = 3868;
+	exports.ER_CLONE_SYS_CONFIG = 3869;
+	exports.ER_CLONE_PLUGIN_MATCH = 3870;
+	exports.ER_CLONE_LOOPBACK = 3871;
+	exports.ER_CLONE_ENCRYPTION = 3872;
+	exports.ER_CLONE_DISK_SPACE = 3873;
+	exports.ER_CLONE_IN_PROGRESS = 3874;
+	exports.ER_CLONE_DISALLOWED = 3875;
+	exports.ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER = 3876;
+	exports.ER_SECONDARY_ENGINE_PLUGIN = 3877;
+	exports.ER_SECOND_PASSWORD_CANNOT_BE_EMPTY = 3878;
+	exports.ER_DB_ACCESS_DENIED = 3879;
+	exports.ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES = 3880;
+	exports.ER_DA_RPL_GTID_TABLE_CANNOT_OPEN = 3881;
+	exports.ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT = 3882;
+	exports.ER_DA_PLUGIN_INSTALL_ERROR = 3883;
+	exports.ER_NO_SESSION_TEMP = 3884;
+	exports.ER_DA_UNKNOWN_ERROR_NUMBER = 3885;
+	exports.ER_COLUMN_CHANGE_SIZE = 3886;
+	exports.ER_REGEXP_INVALID_CAPTURE_GROUP_NAME = 3887;
+	exports.ER_DA_SSL_LIBRARY_ERROR = 3888;
+	exports.ER_SECONDARY_ENGINE = 3889;
+	exports.ER_SECONDARY_ENGINE_DDL = 3890;
+	exports.ER_INCORRECT_CURRENT_PASSWORD = 3891;
+	exports.ER_MISSING_CURRENT_PASSWORD = 3892;
+	exports.ER_CURRENT_PASSWORD_NOT_REQUIRED = 3893;
+	exports.ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE = 3894;
+	exports.ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED = 3895;
+	exports.ER_PARTIAL_REVOKES_EXIST = 3896;
+	exports.ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE = 3897;
+	exports.ER_XA_REPLICATION_FILTERS = 3898;
+	exports.ER_UNSUPPORTED_SQL_MODE = 3899;
+	exports.ER_REGEXP_INVALID_FLAG = 3900;
+	exports.ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS = 3901;
+	exports.ER_UNIT_NOT_FOUND = 3902;
+	exports.ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX = 3903;
+	exports.ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX = 3904;
+	exports.ER_EXCEEDED_MV_KEYS_NUM = 3905;
+	exports.ER_EXCEEDED_MV_KEYS_SPACE = 3906;
+	exports.ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG = 3907;
+	exports.ER_WRONG_MVI_VALUE = 3908;
+	exports.ER_WARN_FUNC_INDEX_NOT_APPLICABLE = 3909;
+	exports.ER_GRP_RPL_UDF_ERROR = 3910;
+	exports.ER_UPDATE_GTID_PURGED_WITH_GR = 3911;
+	exports.ER_GROUPING_ON_TIMESTAMP_IN_DST = 3912;
+	exports.ER_TABLE_NAME_CAUSES_TOO_LONG_PATH = 3913;
+	exports.ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE = 3914;
+	exports.ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED = 3915;
+	exports.ER_DA_GRP_RPL_STARTED_AUTO_REJOIN = 3916;
+	exports.ER_SYSVAR_CHANGE_DURING_QUERY = 3917;
+	exports.ER_GLOBSTAT_CHANGE_DURING_QUERY = 3918;
+	exports.ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE = 3919;
+	exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3920;
+	exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT = 3921;
+	exports.ER_WRONG_COMPRESSION_ALGORITHM_CLIENT = 3922;
+	exports.ER_WRONG_COMPRESSION_LEVEL_CLIENT = 3923;
+	exports.ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT = 3924;
+	exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS = 3925;
+	exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST = 3926;
+	exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT = 3927;
+	exports.ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV = 3928;
+	exports.ER_WARN_DA_PRIVILEGE_NOT_REGISTERED = 3929;
+	exports.ER_CLIENT_KEYRING_UDF_KEY_INVALID = 3930;
+	exports.ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID = 3931;
+	exports.ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG = 3932;
+	exports.ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG = 3933;
+	exports.ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT = 3934;
+	exports.ER_DA_UDF_INVALID_CHARSET_SPECIFIED = 3935;
+	exports.ER_DA_UDF_INVALID_CHARSET = 3936;
+	exports.ER_DA_UDF_INVALID_COLLATION = 3937;
+	exports.ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE = 3938;
+	exports.ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME = 3939;
+	exports.ER_CONSTRAINT_NOT_FOUND = 3940;
+	exports.ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED = 3941;
+	exports.ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS = 3942;
+	exports.ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT = 3943;
+	exports.ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT = 3944;
+	exports.ER_REQUIRE_ROW_FORMAT_INVALID_VALUE = 3945;
+	exports.ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY = 3946;
+	exports.ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST = 3947;
+	exports.ER_CLIENT_LOCAL_FILES_DISABLED = 3948;
+	exports.ER_IMP_INCOMPATIBLE_CFG_VERSION = 3949;
+	exports.ER_DA_OOM = 3950;
+	exports.ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET = 3951;
+	exports.ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET = 3952;
+	exports.ER_MULTIPLE_INTO_CLAUSES = 3953;
+	exports.ER_MISPLACED_INTO = 3954;
+	exports.ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK = 3955;
+	exports.ER_WARN_DEPRECATED_YEAR_UNSIGNED = 3956;
+	exports.ER_CLONE_NETWORK_PACKET = 3957;
+	exports.ER_SDI_OPERATION_FAILED_MISSING_RECORD = 3958;
+	exports.ER_DEPENDENT_BY_CHECK_CONSTRAINT = 3959;
+	exports.ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP = 3960;
+	exports.ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY = 3961;
+	exports.ER_WARN_DEPRECATED_INNER_INTO = 3962;
+	exports.ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL = 3963;
+	exports.ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS = 3964;
+	exports.ER_WARN_DEPRECATED_FOUND_ROWS = 3965;
+	exports.ER_MISSING_JSON_VALUE = 3966;
+	exports.ER_MULTIPLE_JSON_VALUES = 3967;
+	exports.ER_HOSTNAME_TOO_LONG = 3968;
+	exports.ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY = 3969;
+	exports.ER_GROUP_REPLICATION_USER_EMPTY_MSG = 3970;
+	exports.ER_GROUP_REPLICATION_USER_MANDATORY_MSG = 3971;
+	exports.ER_GROUP_REPLICATION_PASSWORD_LENGTH = 3972;
+	exports.ER_SUBQUERY_TRANSFORM_REJECTED = 3973;
+	exports.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT = 3974;
+	exports.ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID = 3975;
+	exports.ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART = 3976;
+	exports.ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION = 3977;
+	exports.ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT = 3978;
+	exports.ER_NOT_ALLOWED_WITH_START_TRANSACTION = 3979;
+	exports.ER_INVALID_JSON_ATTRIBUTE = 3980;
+	exports.ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED = 3981;
+	exports.ER_INVALID_USER_ATTRIBUTE_JSON = 3982;
+	exports.ER_INNODB_REDO_DISABLED = 3983;
+	exports.ER_INNODB_REDO_ARCHIVING_ENABLED = 3984;
+	exports.ER_MDL_OUT_OF_RESOURCES = 3985;
+	exports.ER_IMPLICIT_COMPARISON_FOR_JSON = 3986;
+	exports.ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET = 3987;
+	exports.ER_IMPOSSIBLE_STRING_CONVERSION = 3988;
+	exports.ER_SCHEMA_READ_ONLY = 3989;
+	exports.ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF = 3990;
+	exports.ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF = 3991;
+	exports.ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF = 3992;
+	exports.ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF = 3993;
+	exports.ER_INVALID_PARAMETER_USE = 3994;
+	exports.ER_CHARACTER_SET_MISMATCH = 3995;
+	exports.ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED = 3996;
+	exports.ER_INVALID_TIME_ZONE_INTERVAL = 3997;
+	exports.ER_INVALID_CAST = 3998;
+	exports.ER_HYPERGRAPH_NOT_SUPPORTED_YET = 3999;
+	exports.ER_WARN_HYPERGRAPH_EXPERIMENTAL = 4e3;
+	exports.ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED = 4001;
+	exports.ER_DA_ERROR_LOG_TABLE_DISABLED = 4002;
+	exports.ER_DA_ERROR_LOG_MULTIPLE_FILTERS = 4003;
+	exports.ER_DA_CANT_OPEN_ERROR_LOG = 4004;
+	exports.ER_USER_REFERENCED_AS_DEFINER = 4005;
+	exports.ER_CANNOT_USER_REFERENCED_AS_DEFINER = 4006;
+	exports.ER_REGEX_NUMBER_TOO_BIG = 4007;
+	exports.ER_SPVAR_NONINTEGER_TYPE = 4008;
+	exports.WARN_UNSUPPORTED_ACL_TABLES_READ = 4009;
+	exports.ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL = 4010;
+	exports.ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT = 4011;
+	exports.ER_STARTING_REPLICA_MONITOR_IO_THREAD = 4012;
+	exports.ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON = 4013;
+	exports.ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION = 4014;
+	exports.ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON = 4015;
+	exports.ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON = 4016;
+	exports.ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID = 4017;
+	exports.ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS = 4018;
+	exports.ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID = 4019;
+	exports.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME = 4020;
+	exports.ER_CANT_USE_SAME_UUID_AS_GROUP_NAME = 4021;
+	exports.ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING = 4022;
+	exports.ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE = 4023;
+	exports.ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE = 4024;
+	exports.ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE = 4025;
+	exports.ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE = 4026;
+	exports.ER_ROLE_GRANTED_TO_ITSELF = 4027;
+	exports.ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN = 4028;
+	exports.ER_INNODB_COMPRESSION_FAILURE = 4029;
+	exports.ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE = 4030;
+	exports.ER_CLIENT_INTERACTION_TIMEOUT = 4031;
+	exports.ER_INVALID_CAST_TO_GEOMETRY = 4032;
+	exports.ER_INVALID_CAST_POLYGON_RING_DIRECTION = 4033;
+	exports.ER_GIS_DIFFERENT_SRIDS_AGGREGATION = 4034;
+	exports.ER_RELOAD_KEYRING_FAILURE = 4035;
+	exports.ER_SDI_GET_KEYS_INVALID_TABLESPACE = 4036;
+	exports.ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE = 4037;
+	exports.ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI = 4038;
+	exports.ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID = 4039;
+	exports.ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID = 4040;
+	exports.ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE = 4041;
+	exports.ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS = 4042;
+	exports.ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE = 4043;
+	exports.ER_KERBEROS_CREATE_USER = 4044;
+	exports.ER_INSTALL_PLUGIN_CONFLICT_CLIENT = 4045;
+	exports.ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED = 4046;
+	exports.ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED = 4047;
+	exports.ER_INVALID_ASSIGNMENT_TARGET = 4048;
+	exports.ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY = 4049;
+	exports.ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION = 4050;
+	exports.ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON = 4051;
+	exports.ER_INVALID_MFA_PLUGIN_SPECIFIED = 4052;
+	exports.ER_IDENTIFIED_BY_UNSUPPORTED = 4053;
+	exports.ER_INVALID_PLUGIN_FOR_REGISTRATION = 4054;
+	exports.ER_PLUGIN_REQUIRES_REGISTRATION = 4055;
+	exports.ER_MFA_METHOD_EXISTS = 4056;
+	exports.ER_MFA_METHOD_NOT_EXISTS = 4057;
+	exports.ER_AUTHENTICATION_POLICY_MISMATCH = 4058;
+	exports.ER_PLUGIN_REGISTRATION_DONE = 4059;
+	exports.ER_INVALID_USER_FOR_REGISTRATION = 4060;
+	exports.ER_USER_REGISTRATION_FAILED = 4061;
+	exports.ER_MFA_METHODS_INVALID_ORDER = 4062;
+	exports.ER_MFA_METHODS_IDENTICAL = 4063;
+	exports.ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER = 4064;
+	exports.ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY = 4065;
+	exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY = 4066;
+	exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY = 4067;
+	exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS = 4068;
+	exports.ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS = 4069;
+	exports.ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON = 4070;
+	exports.ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON = 4071;
+	exports.ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS = 4072;
+	exports.ER_DA_SSL_FIPS_MODE_ERROR = 4073;
+	exports.ER_VALUE_OUT_OF_RANGE = 4074;
+	exports.ER_FULLTEXT_WITH_ROLLUP = 4075;
+	exports.ER_REGEXP_MISSING_RESOURCE = 4076;
+	exports.ER_WARN_REGEXP_USING_DEFAULT = 4077;
+	exports.ER_REGEXP_MISSING_FILE = 4078;
+	exports.ER_WARN_DEPRECATED_COLLATION = 4079;
+	exports.ER_CONCURRENT_PROCEDURE_USAGE = 4080;
+	exports.ER_DA_GLOBAL_CONN_LIMIT = 4081;
+	exports.ER_DA_CONN_LIMIT = 4082;
+	exports.ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT = 4083;
+	exports.ER_WARN_SF_UDF_NAME_COLLISION = 4084;
+	exports.ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK = 4085;
+	exports.ER_TOO_MANY_WINDOWS = 4086;
+	exports.ER_MYSQLBACKUP_CLIENT_MSG = 4087;
+	exports.ER_COMMENT_CONTAINS_INVALID_STRING = 4088;
+	exports.ER_DEFINITION_CONTAINS_INVALID_STRING = 4089;
+	exports.ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT = 4090;
+	exports.ER_XA_TEMP_TABLE = 4091;
+	exports.ER_INNODB_MAX_ROW_VERSION = 4092;
+	exports.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE = 4093;
+	exports.ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING = 4094;
+	exports.ER_WARN_DEPRECATED_DATETIME_DELIMITER = 4095;
+	exports.ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER = 4096;
+	exports.ER_CANNOT_PERSIST_SENSITIVE_VARIABLES = 4097;
+	exports.ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES = 4098;
+	exports.ER_WARN_TRG_ALREADY_EXISTS = 4099;
+	exports.ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE = 4100;
+	exports.ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION = 4101;
+	exports.ER_SET_PASSWORD_AUTH_PLUGIN_ERROR = 4102;
+	exports.ER_REDUCED_DBLWR_FILE_CORRUPTED = 4103;
+	exports.ER_REDUCED_DBLWR_PAGE_FOUND = 4104;
+	exports.ER_SRS_INVALID_LATITUDE_OF_ORIGIN = 4105;
+	exports.ER_SRS_INVALID_LONGITUDE_OF_ORIGIN = 4106;
+	exports.ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT = 4107;
+	exports.ER_GIPK_COLUMN_EXISTS = 4108;
+	exports.ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS = 4109;
+	exports.ER_GIPK_COLUMN_ALTER_NOT_ALLOWED = 4110;
+	exports.ER_DROP_PK_COLUMN_TO_DROP_GIPK = 4111;
+	exports.ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR = 4112;
+	exports.ER_DA_EXPIRE_LOGS_DAYS_IGNORED = 4113;
+	exports.ER_CTE_RECURSIVE_NOT_UNION = 4114;
+	exports.ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX = 4115;
+	exports.ER_COMMAND_SERVICE_BACKEND_FAILED = 4116;
+	exports.ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS = 4117;
+	exports.ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE = 4118;
+	exports.ER_WARN_DEPRECATED_IDENT = 4119;
+	exports.ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED = 4120;
+	exports.ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT = 4121;
+	exports.ER_BAD_TIMESTAMP_FORMAT = 4122;
+	exports.ER_SHAPE_PRIDICTION_UDF = 4123;
+	exports.ER_SRS_INVALID_HEIGHT = 4124;
+	exports.ER_SRS_INVALID_SCALING = 4125;
+	exports.ER_SRS_INVALID_ZONE_WIDTH = 4126;
+	exports.ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A = 4127;
+	exports.ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION = 4128;
+	exports.ER_TABLE_NOT_EMPTY = 4129;
+	exports.ER_TABLE_NO_PRIMARY_KEY = 4130;
+	exports.ER_TABLE_IN_SHARED_TABLESPACE = 4131;
+	exports.ER_INDEX_OTHER_THAN_PK = 4132;
+	exports.ER_LOAD_BULK_DATA_UNSORTED = 4133;
+	exports.ER_BULK_EXECUTOR_ERROR = 4134;
+	exports.ER_BULK_READER_LIBCURL_INIT_FAILED = 4135;
+	exports.ER_BULK_READER_LIBCURL_ERROR = 4136;
+	exports.ER_BULK_READER_SERVER_ERROR = 4137;
+	exports.ER_BULK_READER_COMMUNICATION_ERROR = 4138;
+	exports.ER_BULK_LOAD_DATA_FAILED = 4139;
+	exports.ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER = 4140;
+	exports.ER_BULK_LOADER_COMPONENT_ERROR = 4141;
+	exports.ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE = 4142;
+	exports.ER_BULK_PARSER_MISSING_ENCLOSED_BY = 4143;
+	exports.ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED = 4144;
+	exports.ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED = 4145;
+	exports.ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT = 4146;
+	exports.ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR = 4147;
+	exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY = 4148;
+	exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE = 4149;
+	exports.ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR = 4150;
+	exports.ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE = 4151;
+	exports.ER_LOAD_BULK_DATA_FAILED = 4152;
+	exports.ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD = 4153;
+	exports.ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL = 4154;
+	exports.ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR = 4155;
+	exports.ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE = 4156;
+	exports.ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE = 4157;
+	exports.ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS = 4158;
+	exports.ER_CANT_SET_PERSISTED = 4159;
+	exports.ER_INSTALL_COMPONENT_SET_NULL_VALUE = 4160;
+	exports.ER_INSTALL_COMPONENT_SET_UNUSED_VALUE = 4161;
+	exports.ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS = 4162;
+	exports[1] = "EE_CANTCREATEFILE";
+	exports[2] = "EE_READ";
+	exports[3] = "EE_WRITE";
+	exports[4] = "EE_BADCLOSE";
+	exports[5] = "EE_OUTOFMEMORY";
+	exports[6] = "EE_DELETE";
+	exports[7] = "EE_LINK";
+	exports[9] = "EE_EOFERR";
+	exports[10] = "EE_CANTLOCK";
+	exports[11] = "EE_CANTUNLOCK";
+	exports[12] = "EE_DIR";
+	exports[13] = "EE_STAT";
+	exports[14] = "EE_CANT_CHSIZE";
+	exports[15] = "EE_CANT_OPEN_STREAM";
+	exports[16] = "EE_GETWD";
+	exports[17] = "EE_SETWD";
+	exports[18] = "EE_LINK_WARNING";
+	exports[19] = "EE_OPEN_WARNING";
+	exports[20] = "EE_DISK_FULL";
+	exports[21] = "EE_CANT_MKDIR";
+	exports[22] = "EE_UNKNOWN_CHARSET";
+	exports[23] = "EE_OUT_OF_FILERESOURCES";
+	exports[24] = "EE_CANT_READLINK";
+	exports[25] = "EE_CANT_SYMLINK";
+	exports[26] = "EE_REALPATH";
+	exports[27] = "EE_SYNC";
+	exports[28] = "EE_UNKNOWN_COLLATION";
+	exports[29] = "EE_FILENOTFOUND";
+	exports[30] = "EE_FILE_NOT_CLOSED";
+	exports[31] = "EE_CHANGE_OWNERSHIP";
+	exports[32] = "EE_CHANGE_PERMISSIONS";
+	exports[33] = "EE_CANT_SEEK";
+	exports[34] = "EE_CAPACITY_EXCEEDED";
+	exports[35] = "EE_DISK_FULL_WITH_RETRY_MSG";
+	exports[36] = "EE_FAILED_TO_CREATE_TIMER";
+	exports[37] = "EE_FAILED_TO_DELETE_TIMER";
+	exports[38] = "EE_FAILED_TO_CREATE_TIMER_QUEUE";
+	exports[39] = "EE_FAILED_TO_START_TIMER_NOTIFY_THREAD";
+	exports[40] = "EE_FAILED_TO_CREATE_TIMER_NOTIFY_THREAD_INTERRUPT_EVENT";
+	exports[41] = "EE_EXITING_TIMER_NOTIFY_THREAD";
+	exports[42] = "EE_WIN_LIBRARY_LOAD_FAILED";
+	exports[43] = "EE_WIN_RUN_TIME_ERROR_CHECK";
+	exports[44] = "EE_FAILED_TO_DETERMINE_LARGE_PAGE_SIZE";
+	exports[45] = "EE_FAILED_TO_KILL_ALL_THREADS";
+	exports[46] = "EE_FAILED_TO_CREATE_IO_COMPLETION_PORT";
+	exports[47] = "EE_FAILED_TO_OPEN_DEFAULTS_FILE";
+	exports[48] = "EE_FAILED_TO_HANDLE_DEFAULTS_FILE";
+	exports[49] = "EE_WRONG_DIRECTIVE_IN_CONFIG_FILE";
+	exports[50] = "EE_SKIPPING_DIRECTIVE_DUE_TO_MAX_INCLUDE_RECURSION";
+	exports[51] = "EE_INCORRECT_GRP_DEFINITION_IN_CONFIG_FILE";
+	exports[52] = "EE_OPTION_WITHOUT_GRP_IN_CONFIG_FILE";
+	exports[53] = "EE_CONFIG_FILE_PERMISSION_ERROR";
+	exports[54] = "EE_IGNORE_WORLD_WRITABLE_CONFIG_FILE";
+	exports[55] = "EE_USING_DISABLED_OPTION";
+	exports[56] = "EE_USING_DISABLED_SHORT_OPTION";
+	exports[57] = "EE_USING_PASSWORD_ON_CLI_IS_INSECURE";
+	exports[58] = "EE_UNKNOWN_SUFFIX_FOR_VARIABLE";
+	exports[59] = "EE_SSL_ERROR_FROM_FILE";
+	exports[60] = "EE_SSL_ERROR";
+	exports[61] = "EE_NET_SEND_ERROR_IN_BOOTSTRAP";
+	exports[62] = "EE_PACKETS_OUT_OF_ORDER";
+	exports[63] = "EE_UNKNOWN_PROTOCOL_OPTION";
+	exports[64] = "EE_FAILED_TO_LOCATE_SERVER_PUBLIC_KEY";
+	exports[65] = "EE_PUBLIC_KEY_NOT_IN_PEM_FORMAT";
+	exports[66] = "EE_DEBUG_INFO";
+	exports[67] = "EE_UNKNOWN_VARIABLE";
+	exports[68] = "EE_UNKNOWN_OPTION";
+	exports[69] = "EE_UNKNOWN_SHORT_OPTION";
+	exports[70] = "EE_OPTION_WITHOUT_ARGUMENT";
+	exports[71] = "EE_OPTION_REQUIRES_ARGUMENT";
+	exports[72] = "EE_SHORT_OPTION_REQUIRES_ARGUMENT";
+	exports[73] = "EE_OPTION_IGNORED_DUE_TO_INVALID_VALUE";
+	exports[74] = "EE_OPTION_WITH_EMPTY_VALUE";
+	exports[75] = "EE_FAILED_TO_ASSIGN_MAX_VALUE_TO_OPTION";
+	exports[76] = "EE_INCORRECT_BOOLEAN_VALUE_FOR_OPTION";
+	exports[77] = "EE_FAILED_TO_SET_OPTION_VALUE";
+	exports[78] = "EE_INCORRECT_INT_VALUE_FOR_OPTION";
+	exports[79] = "EE_INCORRECT_UINT_VALUE_FOR_OPTION";
+	exports[80] = "EE_ADJUSTED_SIGNED_VALUE_FOR_OPTION";
+	exports[81] = "EE_ADJUSTED_UNSIGNED_VALUE_FOR_OPTION";
+	exports[82] = "EE_ADJUSTED_ULONGLONG_VALUE_FOR_OPTION";
+	exports[83] = "EE_ADJUSTED_DOUBLE_VALUE_FOR_OPTION";
+	exports[84] = "EE_INVALID_DECIMAL_VALUE_FOR_OPTION";
+	exports[85] = "EE_COLLATION_PARSER_ERROR";
+	exports[86] = "EE_FAILED_TO_RESET_BEFORE_PRIMARY_IGNORABLE_CHAR";
+	exports[87] = "EE_FAILED_TO_RESET_BEFORE_TERTIARY_IGNORABLE_CHAR";
+	exports[88] = "EE_SHIFT_CHAR_OUT_OF_RANGE";
+	exports[89] = "EE_RESET_CHAR_OUT_OF_RANGE";
+	exports[90] = "EE_UNKNOWN_LDML_TAG";
+	exports[91] = "EE_FAILED_TO_RESET_BEFORE_SECONDARY_IGNORABLE_CHAR";
+	exports[92] = "EE_FAILED_PROCESSING_DIRECTIVE";
+	exports[93] = "EE_PTHREAD_KILL_FAILED";
+	exports[120] = "HA_ERR_KEY_NOT_FOUND";
+	exports[121] = "HA_ERR_FOUND_DUPP_KEY";
+	exports[122] = "HA_ERR_INTERNAL_ERROR";
+	exports[123] = "HA_ERR_RECORD_CHANGED";
+	exports[124] = "HA_ERR_WRONG_INDEX";
+	exports[125] = "HA_ERR_ROLLED_BACK";
+	exports[126] = "HA_ERR_CRASHED";
+	exports[127] = "HA_ERR_WRONG_IN_RECORD";
+	exports[128] = "HA_ERR_OUT_OF_MEM";
+	exports[130] = "HA_ERR_NOT_A_TABLE";
+	exports[131] = "HA_ERR_WRONG_COMMAND";
+	exports[132] = "HA_ERR_OLD_FILE";
+	exports[133] = "HA_ERR_NO_ACTIVE_RECORD";
+	exports[134] = "HA_ERR_RECORD_DELETED";
+	exports[135] = "HA_ERR_RECORD_FILE_FULL";
+	exports[136] = "HA_ERR_INDEX_FILE_FULL";
+	exports[137] = "HA_ERR_END_OF_FILE";
+	exports[138] = "HA_ERR_UNSUPPORTED";
+	exports[139] = "HA_ERR_TOO_BIG_ROW";
+	exports[140] = "HA_WRONG_CREATE_OPTION";
+	exports[141] = "HA_ERR_FOUND_DUPP_UNIQUE";
+	exports[142] = "HA_ERR_UNKNOWN_CHARSET";
+	exports[143] = "HA_ERR_WRONG_MRG_TABLE_DEF";
+	exports[144] = "HA_ERR_CRASHED_ON_REPAIR";
+	exports[145] = "HA_ERR_CRASHED_ON_USAGE";
+	exports[146] = "HA_ERR_LOCK_WAIT_TIMEOUT";
+	exports[147] = "HA_ERR_LOCK_TABLE_FULL";
+	exports[148] = "HA_ERR_READ_ONLY_TRANSACTION";
+	exports[149] = "HA_ERR_LOCK_DEADLOCK";
+	exports[150] = "HA_ERR_CANNOT_ADD_FOREIGN";
+	exports[151] = "HA_ERR_NO_REFERENCED_ROW";
+	exports[152] = "HA_ERR_ROW_IS_REFERENCED";
+	exports[153] = "HA_ERR_NO_SAVEPOINT";
+	exports[154] = "HA_ERR_NON_UNIQUE_BLOCK_SIZE";
+	exports[155] = "HA_ERR_NO_SUCH_TABLE";
+	exports[156] = "HA_ERR_TABLE_EXIST";
+	exports[157] = "HA_ERR_NO_CONNECTION";
+	exports[158] = "HA_ERR_NULL_IN_SPATIAL";
+	exports[159] = "HA_ERR_TABLE_DEF_CHANGED";
+	exports[160] = "HA_ERR_NO_PARTITION_FOUND";
+	exports[161] = "HA_ERR_RBR_LOGGING_FAILED";
+	exports[162] = "HA_ERR_DROP_INDEX_FK";
+	exports[163] = "HA_ERR_FOREIGN_DUPLICATE_KEY";
+	exports[164] = "HA_ERR_TABLE_NEEDS_UPGRADE";
+	exports[165] = "HA_ERR_TABLE_READONLY";
+	exports[166] = "HA_ERR_AUTOINC_READ_FAILED";
+	exports[167] = "HA_ERR_AUTOINC_ERANGE";
+	exports[168] = "HA_ERR_GENERIC";
+	exports[169] = "HA_ERR_RECORD_IS_THE_SAME";
+	exports[170] = "HA_ERR_LOGGING_IMPOSSIBLE";
+	exports[171] = "HA_ERR_CORRUPT_EVENT";
+	exports[172] = "HA_ERR_NEW_FILE";
+	exports[173] = "HA_ERR_ROWS_EVENT_APPLY";
+	exports[174] = "HA_ERR_INITIALIZATION";
+	exports[175] = "HA_ERR_FILE_TOO_SHORT";
+	exports[176] = "HA_ERR_WRONG_CRC";
+	exports[177] = "HA_ERR_TOO_MANY_CONCURRENT_TRXS";
+	exports[178] = "HA_ERR_NOT_IN_LOCK_PARTITIONS";
+	exports[179] = "HA_ERR_INDEX_COL_TOO_LONG";
+	exports[180] = "HA_ERR_INDEX_CORRUPT";
+	exports[181] = "HA_ERR_UNDO_REC_TOO_BIG";
+	exports[182] = "HA_FTS_INVALID_DOCID";
+	exports[183] = "HA_ERR_TABLE_IN_FK_CHECK";
+	exports[184] = "HA_ERR_TABLESPACE_EXISTS";
+	exports[185] = "HA_ERR_TOO_MANY_FIELDS";
+	exports[186] = "HA_ERR_ROW_IN_WRONG_PARTITION";
+	exports[187] = "HA_ERR_INNODB_READ_ONLY";
+	exports[188] = "HA_ERR_FTS_EXCEED_RESULT_CACHE_LIMIT";
+	exports[189] = "HA_ERR_TEMP_FILE_WRITE_FAILURE";
+	exports[190] = "HA_ERR_INNODB_FORCED_RECOVERY";
+	exports[191] = "HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE";
+	exports[192] = "HA_ERR_FK_DEPTH_EXCEEDED";
+	exports[193] = "HA_MISSING_CREATE_OPTION";
+	exports[194] = "HA_ERR_SE_OUT_OF_MEMORY";
+	exports[195] = "HA_ERR_TABLE_CORRUPT";
+	exports[196] = "HA_ERR_QUERY_INTERRUPTED";
+	exports[197] = "HA_ERR_TABLESPACE_MISSING";
+	exports[198] = "HA_ERR_TABLESPACE_IS_NOT_EMPTY";
+	exports[199] = "HA_ERR_WRONG_FILE_NAME";
+	exports[200] = "HA_ERR_NOT_ALLOWED_COMMAND";
+	exports[201] = "HA_ERR_COMPUTE_FAILED";
+	exports[202] = "HA_ERR_ROW_FORMAT_CHANGED";
+	exports[203] = "HA_ERR_NO_WAIT_LOCK";
+	exports[204] = "HA_ERR_DISK_FULL_NOWAIT";
+	exports[205] = "HA_ERR_NO_SESSION_TEMP";
+	exports[206] = "HA_ERR_WRONG_TABLE_NAME";
+	exports[207] = "HA_ERR_TOO_LONG_PATH";
+	exports[208] = "HA_ERR_SAMPLING_INIT_FAILED";
+	exports[209] = "HA_ERR_FTS_TOO_MANY_NESTED_EXP";
+	exports[1e3] = "ER_HASHCHK";
+	exports[1001] = "ER_NISAMCHK";
+	exports[1002] = "ER_NO";
+	exports[1003] = "ER_YES";
+	exports[1004] = "ER_CANT_CREATE_FILE";
+	exports[1005] = "ER_CANT_CREATE_TABLE";
+	exports[1006] = "ER_CANT_CREATE_DB";
+	exports[1007] = "ER_DB_CREATE_EXISTS";
+	exports[1008] = "ER_DB_DROP_EXISTS";
+	exports[1009] = "ER_DB_DROP_DELETE";
+	exports[1010] = "ER_DB_DROP_RMDIR";
+	exports[1011] = "ER_CANT_DELETE_FILE";
+	exports[1012] = "ER_CANT_FIND_SYSTEM_REC";
+	exports[1013] = "ER_CANT_GET_STAT";
+	exports[1014] = "ER_CANT_GET_WD";
+	exports[1015] = "ER_CANT_LOCK";
+	exports[1016] = "ER_CANT_OPEN_FILE";
+	exports[1017] = "ER_FILE_NOT_FOUND";
+	exports[1018] = "ER_CANT_READ_DIR";
+	exports[1019] = "ER_CANT_SET_WD";
+	exports[1020] = "ER_CHECKREAD";
+	exports[1021] = "ER_DISK_FULL";
+	exports[1022] = "ER_DUP_KEY";
+	exports[1023] = "ER_ERROR_ON_CLOSE";
+	exports[1024] = "ER_ERROR_ON_READ";
+	exports[1025] = "ER_ERROR_ON_RENAME";
+	exports[1026] = "ER_ERROR_ON_WRITE";
+	exports[1027] = "ER_FILE_USED";
+	exports[1028] = "ER_FILSORT_ABORT";
+	exports[1029] = "ER_FORM_NOT_FOUND";
+	exports[1030] = "ER_GET_ERRNO";
+	exports[1031] = "ER_ILLEGAL_HA";
+	exports[1032] = "ER_KEY_NOT_FOUND";
+	exports[1033] = "ER_NOT_FORM_FILE";
+	exports[1034] = "ER_NOT_KEYFILE";
+	exports[1035] = "ER_OLD_KEYFILE";
+	exports[1036] = "ER_OPEN_AS_READONLY";
+	exports[1037] = "ER_OUTOFMEMORY";
+	exports[1038] = "ER_OUT_OF_SORTMEMORY";
+	exports[1039] = "ER_UNEXPECTED_EOF";
+	exports[1040] = "ER_CON_COUNT_ERROR";
+	exports[1041] = "ER_OUT_OF_RESOURCES";
+	exports[1042] = "ER_BAD_HOST_ERROR";
+	exports[1043] = "ER_HANDSHAKE_ERROR";
+	exports[1044] = "ER_DBACCESS_DENIED_ERROR";
+	exports[1045] = "ER_ACCESS_DENIED_ERROR";
+	exports[1046] = "ER_NO_DB_ERROR";
+	exports[1047] = "ER_UNKNOWN_COM_ERROR";
+	exports[1048] = "ER_BAD_NULL_ERROR";
+	exports[1049] = "ER_BAD_DB_ERROR";
+	exports[1050] = "ER_TABLE_EXISTS_ERROR";
+	exports[1051] = "ER_BAD_TABLE_ERROR";
+	exports[1052] = "ER_NON_UNIQ_ERROR";
+	exports[1053] = "ER_SERVER_SHUTDOWN";
+	exports[1054] = "ER_BAD_FIELD_ERROR";
+	exports[1055] = "ER_WRONG_FIELD_WITH_GROUP";
+	exports[1056] = "ER_WRONG_GROUP_FIELD";
+	exports[1057] = "ER_WRONG_SUM_SELECT";
+	exports[1058] = "ER_WRONG_VALUE_COUNT";
+	exports[1059] = "ER_TOO_LONG_IDENT";
+	exports[1060] = "ER_DUP_FIELDNAME";
+	exports[1061] = "ER_DUP_KEYNAME";
+	exports[1062] = "ER_DUP_ENTRY";
+	exports[1063] = "ER_WRONG_FIELD_SPEC";
+	exports[1064] = "ER_PARSE_ERROR";
+	exports[1065] = "ER_EMPTY_QUERY";
+	exports[1066] = "ER_NONUNIQ_TABLE";
+	exports[1067] = "ER_INVALID_DEFAULT";
+	exports[1068] = "ER_MULTIPLE_PRI_KEY";
+	exports[1069] = "ER_TOO_MANY_KEYS";
+	exports[1070] = "ER_TOO_MANY_KEY_PARTS";
+	exports[1071] = "ER_TOO_LONG_KEY";
+	exports[1072] = "ER_KEY_COLUMN_DOES_NOT_EXITS";
+	exports[1073] = "ER_BLOB_USED_AS_KEY";
+	exports[1074] = "ER_TOO_BIG_FIELDLENGTH";
+	exports[1075] = "ER_WRONG_AUTO_KEY";
+	exports[1076] = "ER_READY";
+	exports[1077] = "ER_NORMAL_SHUTDOWN";
+	exports[1078] = "ER_GOT_SIGNAL";
+	exports[1079] = "ER_SHUTDOWN_COMPLETE";
+	exports[1080] = "ER_FORCING_CLOSE";
+	exports[1081] = "ER_IPSOCK_ERROR";
+	exports[1082] = "ER_NO_SUCH_INDEX";
+	exports[1083] = "ER_WRONG_FIELD_TERMINATORS";
+	exports[1084] = "ER_BLOBS_AND_NO_TERMINATED";
+	exports[1085] = "ER_TEXTFILE_NOT_READABLE";
+	exports[1086] = "ER_FILE_EXISTS_ERROR";
+	exports[1087] = "ER_LOAD_INFO";
+	exports[1088] = "ER_ALTER_INFO";
+	exports[1089] = "ER_WRONG_SUB_KEY";
+	exports[1090] = "ER_CANT_REMOVE_ALL_FIELDS";
+	exports[1091] = "ER_CANT_DROP_FIELD_OR_KEY";
+	exports[1092] = "ER_INSERT_INFO";
+	exports[1093] = "ER_UPDATE_TABLE_USED";
+	exports[1094] = "ER_NO_SUCH_THREAD";
+	exports[1095] = "ER_KILL_DENIED_ERROR";
+	exports[1096] = "ER_NO_TABLES_USED";
+	exports[1097] = "ER_TOO_BIG_SET";
+	exports[1098] = "ER_NO_UNIQUE_LOGFILE";
+	exports[1099] = "ER_TABLE_NOT_LOCKED_FOR_WRITE";
+	exports[1100] = "ER_TABLE_NOT_LOCKED";
+	exports[1101] = "ER_BLOB_CANT_HAVE_DEFAULT";
+	exports[1102] = "ER_WRONG_DB_NAME";
+	exports[1103] = "ER_WRONG_TABLE_NAME";
+	exports[1104] = "ER_TOO_BIG_SELECT";
+	exports[1105] = "ER_UNKNOWN_ERROR";
+	exports[1106] = "ER_UNKNOWN_PROCEDURE";
+	exports[1107] = "ER_WRONG_PARAMCOUNT_TO_PROCEDURE";
+	exports[1108] = "ER_WRONG_PARAMETERS_TO_PROCEDURE";
+	exports[1109] = "ER_UNKNOWN_TABLE";
+	exports[1110] = "ER_FIELD_SPECIFIED_TWICE";
+	exports[1111] = "ER_INVALID_GROUP_FUNC_USE";
+	exports[1112] = "ER_UNSUPPORTED_EXTENSION";
+	exports[1113] = "ER_TABLE_MUST_HAVE_COLUMNS";
+	exports[1114] = "ER_RECORD_FILE_FULL";
+	exports[1115] = "ER_UNKNOWN_CHARACTER_SET";
+	exports[1116] = "ER_TOO_MANY_TABLES";
+	exports[1117] = "ER_TOO_MANY_FIELDS";
+	exports[1118] = "ER_TOO_BIG_ROWSIZE";
+	exports[1119] = "ER_STACK_OVERRUN";
+	exports[1120] = "ER_WRONG_OUTER_JOIN";
+	exports[1121] = "ER_NULL_COLUMN_IN_INDEX";
+	exports[1122] = "ER_CANT_FIND_UDF";
+	exports[1123] = "ER_CANT_INITIALIZE_UDF";
+	exports[1124] = "ER_UDF_NO_PATHS";
+	exports[1125] = "ER_UDF_EXISTS";
+	exports[1126] = "ER_CANT_OPEN_LIBRARY";
+	exports[1127] = "ER_CANT_FIND_DL_ENTRY";
+	exports[1128] = "ER_FUNCTION_NOT_DEFINED";
+	exports[1129] = "ER_HOST_IS_BLOCKED";
+	exports[1130] = "ER_HOST_NOT_PRIVILEGED";
+	exports[1131] = "ER_PASSWORD_ANONYMOUS_USER";
+	exports[1132] = "ER_PASSWORD_NOT_ALLOWED";
+	exports[1133] = "ER_PASSWORD_NO_MATCH";
+	exports[1134] = "ER_UPDATE_INFO";
+	exports[1135] = "ER_CANT_CREATE_THREAD";
+	exports[1136] = "ER_WRONG_VALUE_COUNT_ON_ROW";
+	exports[1137] = "ER_CANT_REOPEN_TABLE";
+	exports[1138] = "ER_INVALID_USE_OF_NULL";
+	exports[1139] = "ER_REGEXP_ERROR";
+	exports[1140] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS";
+	exports[1141] = "ER_NONEXISTING_GRANT";
+	exports[1142] = "ER_TABLEACCESS_DENIED_ERROR";
+	exports[1143] = "ER_COLUMNACCESS_DENIED_ERROR";
+	exports[1144] = "ER_ILLEGAL_GRANT_FOR_TABLE";
+	exports[1145] = "ER_GRANT_WRONG_HOST_OR_USER";
+	exports[1146] = "ER_NO_SUCH_TABLE";
+	exports[1147] = "ER_NONEXISTING_TABLE_GRANT";
+	exports[1148] = "ER_NOT_ALLOWED_COMMAND";
+	exports[1149] = "ER_SYNTAX_ERROR";
+	exports[1150] = "ER_UNUSED1";
+	exports[1151] = "ER_UNUSED2";
+	exports[1152] = "ER_ABORTING_CONNECTION";
+	exports[1153] = "ER_NET_PACKET_TOO_LARGE";
+	exports[1154] = "ER_NET_READ_ERROR_FROM_PIPE";
+	exports[1155] = "ER_NET_FCNTL_ERROR";
+	exports[1156] = "ER_NET_PACKETS_OUT_OF_ORDER";
+	exports[1157] = "ER_NET_UNCOMPRESS_ERROR";
+	exports[1158] = "ER_NET_READ_ERROR";
+	exports[1159] = "ER_NET_READ_INTERRUPTED";
+	exports[1160] = "ER_NET_ERROR_ON_WRITE";
+	exports[1161] = "ER_NET_WRITE_INTERRUPTED";
+	exports[1162] = "ER_TOO_LONG_STRING";
+	exports[1163] = "ER_TABLE_CANT_HANDLE_BLOB";
+	exports[1164] = "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT";
+	exports[1165] = "ER_UNUSED3";
+	exports[1166] = "ER_WRONG_COLUMN_NAME";
+	exports[1167] = "ER_WRONG_KEY_COLUMN";
+	exports[1168] = "ER_WRONG_MRG_TABLE";
+	exports[1169] = "ER_DUP_UNIQUE";
+	exports[1170] = "ER_BLOB_KEY_WITHOUT_LENGTH";
+	exports[1171] = "ER_PRIMARY_CANT_HAVE_NULL";
+	exports[1172] = "ER_TOO_MANY_ROWS";
+	exports[1173] = "ER_REQUIRES_PRIMARY_KEY";
+	exports[1174] = "ER_NO_RAID_COMPILED";
+	exports[1175] = "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE";
+	exports[1176] = "ER_KEY_DOES_NOT_EXITS";
+	exports[1177] = "ER_CHECK_NO_SUCH_TABLE";
+	exports[1178] = "ER_CHECK_NOT_IMPLEMENTED";
+	exports[1179] = "ER_CANT_DO_THIS_DURING_AN_TRANSACTION";
+	exports[1180] = "ER_ERROR_DURING_COMMIT";
+	exports[1181] = "ER_ERROR_DURING_ROLLBACK";
+	exports[1182] = "ER_ERROR_DURING_FLUSH_LOGS";
+	exports[1183] = "ER_ERROR_DURING_CHECKPOINT";
+	exports[1184] = "ER_NEW_ABORTING_CONNECTION";
+	exports[1185] = "ER_DUMP_NOT_IMPLEMENTED";
+	exports[1186] = "ER_FLUSH_MASTER_BINLOG_CLOSED";
+	exports[1187] = "ER_INDEX_REBUILD";
+	exports[1188] = "ER_SOURCE";
+	exports[1189] = "ER_SOURCE_NET_READ";
+	exports[1190] = "ER_SOURCE_NET_WRITE";
+	exports[1191] = "ER_FT_MATCHING_KEY_NOT_FOUND";
+	exports[1192] = "ER_LOCK_OR_ACTIVE_TRANSACTION";
+	exports[1193] = "ER_UNKNOWN_SYSTEM_VARIABLE";
+	exports[1194] = "ER_CRASHED_ON_USAGE";
+	exports[1195] = "ER_CRASHED_ON_REPAIR";
+	exports[1196] = "ER_WARNING_NOT_COMPLETE_ROLLBACK";
+	exports[1197] = "ER_TRANS_CACHE_FULL";
+	exports[1198] = "ER_SLAVE_MUST_STOP";
+	exports[1199] = "ER_REPLICA_NOT_RUNNING";
+	exports[1200] = "ER_BAD_REPLICA";
+	exports[1201] = "ER_CONNECTION_METADATA";
+	exports[1202] = "ER_REPLICA_THREAD";
+	exports[1203] = "ER_TOO_MANY_USER_CONNECTIONS";
+	exports[1204] = "ER_SET_CONSTANTS_ONLY";
+	exports[1205] = "ER_LOCK_WAIT_TIMEOUT";
+	exports[1206] = "ER_LOCK_TABLE_FULL";
+	exports[1207] = "ER_READ_ONLY_TRANSACTION";
+	exports[1208] = "ER_DROP_DB_WITH_READ_LOCK";
+	exports[1209] = "ER_CREATE_DB_WITH_READ_LOCK";
+	exports[1210] = "ER_WRONG_ARGUMENTS";
+	exports[1211] = "ER_NO_PERMISSION_TO_CREATE_USER";
+	exports[1212] = "ER_UNION_TABLES_IN_DIFFERENT_DIR";
+	exports[1213] = "ER_LOCK_DEADLOCK";
+	exports[1214] = "ER_TABLE_CANT_HANDLE_FT";
+	exports[1215] = "ER_CANNOT_ADD_FOREIGN";
+	exports[1216] = "ER_NO_REFERENCED_ROW";
+	exports[1217] = "ER_ROW_IS_REFERENCED";
+	exports[1218] = "ER_CONNECT_TO_SOURCE";
+	exports[1219] = "ER_QUERY_ON_MASTER";
+	exports[1220] = "ER_ERROR_WHEN_EXECUTING_COMMAND";
+	exports[1221] = "ER_WRONG_USAGE";
+	exports[1222] = "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT";
+	exports[1223] = "ER_CANT_UPDATE_WITH_READLOCK";
+	exports[1224] = "ER_MIXING_NOT_ALLOWED";
+	exports[1225] = "ER_DUP_ARGUMENT";
+	exports[1226] = "ER_USER_LIMIT_REACHED";
+	exports[1227] = "ER_SPECIFIC_ACCESS_DENIED_ERROR";
+	exports[1228] = "ER_LOCAL_VARIABLE";
+	exports[1229] = "ER_GLOBAL_VARIABLE";
+	exports[1230] = "ER_NO_DEFAULT";
+	exports[1231] = "ER_WRONG_VALUE_FOR_VAR";
+	exports[1232] = "ER_WRONG_TYPE_FOR_VAR";
+	exports[1233] = "ER_VAR_CANT_BE_READ";
+	exports[1234] = "ER_CANT_USE_OPTION_HERE";
+	exports[1235] = "ER_NOT_SUPPORTED_YET";
+	exports[1236] = "ER_SOURCE_FATAL_ERROR_READING_BINLOG";
+	exports[1237] = "ER_REPLICA_IGNORED_TABLE";
+	exports[1238] = "ER_INCORRECT_GLOBAL_LOCAL_VAR";
+	exports[1239] = "ER_WRONG_FK_DEF";
+	exports[1240] = "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF";
+	exports[1241] = "ER_OPERAND_COLUMNS";
+	exports[1242] = "ER_SUBQUERY_NO_1_ROW";
+	exports[1243] = "ER_UNKNOWN_STMT_HANDLER";
+	exports[1244] = "ER_CORRUPT_HELP_DB";
+	exports[1245] = "ER_CYCLIC_REFERENCE";
+	exports[1246] = "ER_AUTO_CONVERT";
+	exports[1247] = "ER_ILLEGAL_REFERENCE";
+	exports[1248] = "ER_DERIVED_MUST_HAVE_ALIAS";
+	exports[1249] = "ER_SELECT_REDUCED";
+	exports[1250] = "ER_TABLENAME_NOT_ALLOWED_HERE";
+	exports[1251] = "ER_NOT_SUPPORTED_AUTH_MODE";
+	exports[1252] = "ER_SPATIAL_CANT_HAVE_NULL";
+	exports[1253] = "ER_COLLATION_CHARSET_MISMATCH";
+	exports[1254] = "ER_SLAVE_WAS_RUNNING";
+	exports[1255] = "ER_SLAVE_WAS_NOT_RUNNING";
+	exports[1256] = "ER_TOO_BIG_FOR_UNCOMPRESS";
+	exports[1257] = "ER_ZLIB_Z_MEM_ERROR";
+	exports[1258] = "ER_ZLIB_Z_BUF_ERROR";
+	exports[1259] = "ER_ZLIB_Z_DATA_ERROR";
+	exports[1260] = "ER_CUT_VALUE_GROUP_CONCAT";
+	exports[1261] = "ER_WARN_TOO_FEW_RECORDS";
+	exports[1262] = "ER_WARN_TOO_MANY_RECORDS";
+	exports[1263] = "ER_WARN_NULL_TO_NOTNULL";
+	exports[1264] = "ER_WARN_DATA_OUT_OF_RANGE";
+	exports[1265] = "WARN_DATA_TRUNCATED";
+	exports[1266] = "ER_WARN_USING_OTHER_HANDLER";
+	exports[1267] = "ER_CANT_AGGREGATE_2COLLATIONS";
+	exports[1268] = "ER_DROP_USER";
+	exports[1269] = "ER_REVOKE_GRANTS";
+	exports[1270] = "ER_CANT_AGGREGATE_3COLLATIONS";
+	exports[1271] = "ER_CANT_AGGREGATE_NCOLLATIONS";
+	exports[1272] = "ER_VARIABLE_IS_NOT_STRUCT";
+	exports[1273] = "ER_UNKNOWN_COLLATION";
+	exports[1274] = "ER_REPLICA_IGNORED_SSL_PARAMS";
+	exports[1275] = "ER_SERVER_IS_IN_SECURE_AUTH_MODE";
+	exports[1276] = "ER_WARN_FIELD_RESOLVED";
+	exports[1277] = "ER_BAD_REPLICA_UNTIL_COND";
+	exports[1278] = "ER_MISSING_SKIP_REPLICA";
+	exports[1279] = "ER_UNTIL_COND_IGNORED";
+	exports[1280] = "ER_WRONG_NAME_FOR_INDEX";
+	exports[1281] = "ER_WRONG_NAME_FOR_CATALOG";
+	exports[1282] = "ER_WARN_QC_RESIZE";
+	exports[1283] = "ER_BAD_FT_COLUMN";
+	exports[1284] = "ER_UNKNOWN_KEY_CACHE";
+	exports[1285] = "ER_WARN_HOSTNAME_WONT_WORK";
+	exports[1286] = "ER_UNKNOWN_STORAGE_ENGINE";
+	exports[1287] = "ER_WARN_DEPRECATED_SYNTAX";
+	exports[1288] = "ER_NON_UPDATABLE_TABLE";
+	exports[1289] = "ER_FEATURE_DISABLED";
+	exports[1290] = "ER_OPTION_PREVENTS_STATEMENT";
+	exports[1291] = "ER_DUPLICATED_VALUE_IN_TYPE";
+	exports[1292] = "ER_TRUNCATED_WRONG_VALUE";
+	exports[1293] = "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS";
+	exports[1294] = "ER_INVALID_ON_UPDATE";
+	exports[1295] = "ER_UNSUPPORTED_PS";
+	exports[1296] = "ER_GET_ERRMSG";
+	exports[1297] = "ER_GET_TEMPORARY_ERRMSG";
+	exports[1298] = "ER_UNKNOWN_TIME_ZONE";
+	exports[1299] = "ER_WARN_INVALID_TIMESTAMP";
+	exports[1300] = "ER_INVALID_CHARACTER_STRING";
+	exports[1301] = "ER_WARN_ALLOWED_PACKET_OVERFLOWED";
+	exports[1302] = "ER_CONFLICTING_DECLARATIONS";
+	exports[1303] = "ER_SP_NO_RECURSIVE_CREATE";
+	exports[1304] = "ER_SP_ALREADY_EXISTS";
+	exports[1305] = "ER_SP_DOES_NOT_EXIST";
+	exports[1306] = "ER_SP_DROP_FAILED";
+	exports[1307] = "ER_SP_STORE_FAILED";
+	exports[1308] = "ER_SP_LILABEL_MISMATCH";
+	exports[1309] = "ER_SP_LABEL_REDEFINE";
+	exports[1310] = "ER_SP_LABEL_MISMATCH";
+	exports[1311] = "ER_SP_UNINIT_VAR";
+	exports[1312] = "ER_SP_BADSELECT";
+	exports[1313] = "ER_SP_BADRETURN";
+	exports[1314] = "ER_SP_BADSTATEMENT";
+	exports[1315] = "ER_UPDATE_LOG_DEPRECATED_IGNORED";
+	exports[1316] = "ER_UPDATE_LOG_DEPRECATED_TRANSLATED";
+	exports[1317] = "ER_QUERY_INTERRUPTED";
+	exports[1318] = "ER_SP_WRONG_NO_OF_ARGS";
+	exports[1319] = "ER_SP_COND_MISMATCH";
+	exports[1320] = "ER_SP_NORETURN";
+	exports[1321] = "ER_SP_NORETURNEND";
+	exports[1322] = "ER_SP_BAD_CURSOR_QUERY";
+	exports[1323] = "ER_SP_BAD_CURSOR_SELECT";
+	exports[1324] = "ER_SP_CURSOR_MISMATCH";
+	exports[1325] = "ER_SP_CURSOR_ALREADY_OPEN";
+	exports[1326] = "ER_SP_CURSOR_NOT_OPEN";
+	exports[1327] = "ER_SP_UNDECLARED_VAR";
+	exports[1328] = "ER_SP_WRONG_NO_OF_FETCH_ARGS";
+	exports[1329] = "ER_SP_FETCH_NO_DATA";
+	exports[1330] = "ER_SP_DUP_PARAM";
+	exports[1331] = "ER_SP_DUP_VAR";
+	exports[1332] = "ER_SP_DUP_COND";
+	exports[1333] = "ER_SP_DUP_CURS";
+	exports[1334] = "ER_SP_CANT_ALTER";
+	exports[1335] = "ER_SP_SUBSELECT_NYI";
+	exports[1336] = "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG";
+	exports[1337] = "ER_SP_VARCOND_AFTER_CURSHNDLR";
+	exports[1338] = "ER_SP_CURSOR_AFTER_HANDLER";
+	exports[1339] = "ER_SP_CASE_NOT_FOUND";
+	exports[1340] = "ER_FPARSER_TOO_BIG_FILE";
+	exports[1341] = "ER_FPARSER_BAD_HEADER";
+	exports[1342] = "ER_FPARSER_EOF_IN_COMMENT";
+	exports[1343] = "ER_FPARSER_ERROR_IN_PARAMETER";
+	exports[1344] = "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER";
+	exports[1345] = "ER_VIEW_NO_EXPLAIN";
+	exports[1346] = "ER_FRM_UNKNOWN_TYPE";
+	exports[1347] = "ER_WRONG_OBJECT";
+	exports[1348] = "ER_NONUPDATEABLE_COLUMN";
+	exports[1349] = "ER_VIEW_SELECT_DERIVED";
+	exports[1350] = "ER_VIEW_SELECT_CLAUSE";
+	exports[1351] = "ER_VIEW_SELECT_VARIABLE";
+	exports[1352] = "ER_VIEW_SELECT_TMPTABLE";
+	exports[1353] = "ER_VIEW_WRONG_LIST";
+	exports[1354] = "ER_WARN_VIEW_MERGE";
+	exports[1355] = "ER_WARN_VIEW_WITHOUT_KEY";
+	exports[1356] = "ER_VIEW_INVALID";
+	exports[1357] = "ER_SP_NO_DROP_SP";
+	exports[1358] = "ER_SP_GOTO_IN_HNDLR";
+	exports[1359] = "ER_TRG_ALREADY_EXISTS";
+	exports[1360] = "ER_TRG_DOES_NOT_EXIST";
+	exports[1361] = "ER_TRG_ON_VIEW_OR_TEMP_TABLE";
+	exports[1362] = "ER_TRG_CANT_CHANGE_ROW";
+	exports[1363] = "ER_TRG_NO_SUCH_ROW_IN_TRG";
+	exports[1364] = "ER_NO_DEFAULT_FOR_FIELD";
+	exports[1365] = "ER_DIVISION_BY_ZERO";
+	exports[1366] = "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD";
+	exports[1367] = "ER_ILLEGAL_VALUE_FOR_TYPE";
+	exports[1368] = "ER_VIEW_NONUPD_CHECK";
+	exports[1369] = "ER_VIEW_CHECK_FAILED";
+	exports[1370] = "ER_PROCACCESS_DENIED_ERROR";
+	exports[1371] = "ER_RELAY_LOG_FAIL";
+	exports[1372] = "ER_PASSWD_LENGTH";
+	exports[1373] = "ER_UNKNOWN_TARGET_BINLOG";
+	exports[1374] = "ER_IO_ERR_LOG_INDEX_READ";
+	exports[1375] = "ER_BINLOG_PURGE_PROHIBITED";
+	exports[1376] = "ER_FSEEK_FAIL";
+	exports[1377] = "ER_BINLOG_PURGE_FATAL_ERR";
+	exports[1378] = "ER_LOG_IN_USE";
+	exports[1379] = "ER_LOG_PURGE_UNKNOWN_ERR";
+	exports[1380] = "ER_RELAY_LOG_INIT";
+	exports[1381] = "ER_NO_BINARY_LOGGING";
+	exports[1382] = "ER_RESERVED_SYNTAX";
+	exports[1383] = "ER_WSAS_FAILED";
+	exports[1384] = "ER_DIFF_GROUPS_PROC";
+	exports[1385] = "ER_NO_GROUP_FOR_PROC";
+	exports[1386] = "ER_ORDER_WITH_PROC";
+	exports[1387] = "ER_LOGGING_PROHIBIT_CHANGING_OF";
+	exports[1388] = "ER_NO_FILE_MAPPING";
+	exports[1389] = "ER_WRONG_MAGIC";
+	exports[1390] = "ER_PS_MANY_PARAM";
+	exports[1391] = "ER_KEY_PART_0";
+	exports[1392] = "ER_VIEW_CHECKSUM";
+	exports[1393] = "ER_VIEW_MULTIUPDATE";
+	exports[1394] = "ER_VIEW_NO_INSERT_FIELD_LIST";
+	exports[1395] = "ER_VIEW_DELETE_MERGE_VIEW";
+	exports[1396] = "ER_CANNOT_USER";
+	exports[1397] = "ER_XAER_NOTA";
+	exports[1398] = "ER_XAER_INVAL";
+	exports[1399] = "ER_XAER_RMFAIL";
+	exports[1400] = "ER_XAER_OUTSIDE";
+	exports[1401] = "ER_XAER_RMERR";
+	exports[1402] = "ER_XA_RBROLLBACK";
+	exports[1403] = "ER_NONEXISTING_PROC_GRANT";
+	exports[1404] = "ER_PROC_AUTO_GRANT_FAIL";
+	exports[1405] = "ER_PROC_AUTO_REVOKE_FAIL";
+	exports[1406] = "ER_DATA_TOO_LONG";
+	exports[1407] = "ER_SP_BAD_SQLSTATE";
+	exports[1408] = "ER_STARTUP";
+	exports[1409] = "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR";
+	exports[1410] = "ER_CANT_CREATE_USER_WITH_GRANT";
+	exports[1411] = "ER_WRONG_VALUE_FOR_TYPE";
+	exports[1412] = "ER_TABLE_DEF_CHANGED";
+	exports[1413] = "ER_SP_DUP_HANDLER";
+	exports[1414] = "ER_SP_NOT_VAR_ARG";
+	exports[1415] = "ER_SP_NO_RETSET";
+	exports[1416] = "ER_CANT_CREATE_GEOMETRY_OBJECT";
+	exports[1417] = "ER_FAILED_ROUTINE_BREAK_BINLOG";
+	exports[1418] = "ER_BINLOG_UNSAFE_ROUTINE";
+	exports[1419] = "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER";
+	exports[1420] = "ER_EXEC_STMT_WITH_OPEN_CURSOR";
+	exports[1421] = "ER_STMT_HAS_NO_OPEN_CURSOR";
+	exports[1422] = "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG";
+	exports[1423] = "ER_NO_DEFAULT_FOR_VIEW_FIELD";
+	exports[1424] = "ER_SP_NO_RECURSION";
+	exports[1425] = "ER_TOO_BIG_SCALE";
+	exports[1426] = "ER_TOO_BIG_PRECISION";
+	exports[1427] = "ER_M_BIGGER_THAN_D";
+	exports[1428] = "ER_WRONG_LOCK_OF_SYSTEM_TABLE";
+	exports[1429] = "ER_CONNECT_TO_FOREIGN_DATA_SOURCE";
+	exports[1430] = "ER_QUERY_ON_FOREIGN_DATA_SOURCE";
+	exports[1431] = "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST";
+	exports[1432] = "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE";
+	exports[1433] = "ER_FOREIGN_DATA_STRING_INVALID";
+	exports[1434] = "ER_CANT_CREATE_FEDERATED_TABLE";
+	exports[1435] = "ER_TRG_IN_WRONG_SCHEMA";
+	exports[1436] = "ER_STACK_OVERRUN_NEED_MORE";
+	exports[1437] = "ER_TOO_LONG_BODY";
+	exports[1438] = "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE";
+	exports[1439] = "ER_TOO_BIG_DISPLAYWIDTH";
+	exports[1440] = "ER_XAER_DUPID";
+	exports[1441] = "ER_DATETIME_FUNCTION_OVERFLOW";
+	exports[1442] = "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG";
+	exports[1443] = "ER_VIEW_PREVENT_UPDATE";
+	exports[1444] = "ER_PS_NO_RECURSION";
+	exports[1445] = "ER_SP_CANT_SET_AUTOCOMMIT";
+	exports[1446] = "ER_MALFORMED_DEFINER";
+	exports[1447] = "ER_VIEW_FRM_NO_USER";
+	exports[1448] = "ER_VIEW_OTHER_USER";
+	exports[1449] = "ER_NO_SUCH_USER";
+	exports[1450] = "ER_FORBID_SCHEMA_CHANGE";
+	exports[1451] = "ER_ROW_IS_REFERENCED_2";
+	exports[1452] = "ER_NO_REFERENCED_ROW_2";
+	exports[1453] = "ER_SP_BAD_VAR_SHADOW";
+	exports[1454] = "ER_TRG_NO_DEFINER";
+	exports[1455] = "ER_OLD_FILE_FORMAT";
+	exports[1456] = "ER_SP_RECURSION_LIMIT";
+	exports[1457] = "ER_SP_PROC_TABLE_CORRUPT";
+	exports[1458] = "ER_SP_WRONG_NAME";
+	exports[1459] = "ER_TABLE_NEEDS_UPGRADE";
+	exports[1460] = "ER_SP_NO_AGGREGATE";
+	exports[1461] = "ER_MAX_PREPARED_STMT_COUNT_REACHED";
+	exports[1462] = "ER_VIEW_RECURSIVE";
+	exports[1463] = "ER_NON_GROUPING_FIELD_USED";
+	exports[1464] = "ER_TABLE_CANT_HANDLE_SPKEYS";
+	exports[1465] = "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA";
+	exports[1466] = "ER_REMOVED_SPACES";
+	exports[1467] = "ER_AUTOINC_READ_FAILED";
+	exports[1468] = "ER_USERNAME";
+	exports[1469] = "ER_HOSTNAME";
+	exports[1470] = "ER_WRONG_STRING_LENGTH";
+	exports[1471] = "ER_NON_INSERTABLE_TABLE";
+	exports[1472] = "ER_ADMIN_WRONG_MRG_TABLE";
+	exports[1473] = "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT";
+	exports[1474] = "ER_NAME_BECOMES_EMPTY";
+	exports[1475] = "ER_AMBIGUOUS_FIELD_TERM";
+	exports[1476] = "ER_FOREIGN_SERVER_EXISTS";
+	exports[1477] = "ER_FOREIGN_SERVER_DOESNT_EXIST";
+	exports[1478] = "ER_ILLEGAL_HA_CREATE_OPTION";
+	exports[1479] = "ER_PARTITION_REQUIRES_VALUES_ERROR";
+	exports[1480] = "ER_PARTITION_WRONG_VALUES_ERROR";
+	exports[1481] = "ER_PARTITION_MAXVALUE_ERROR";
+	exports[1482] = "ER_PARTITION_SUBPARTITION_ERROR";
+	exports[1483] = "ER_PARTITION_SUBPART_MIX_ERROR";
+	exports[1484] = "ER_PARTITION_WRONG_NO_PART_ERROR";
+	exports[1485] = "ER_PARTITION_WRONG_NO_SUBPART_ERROR";
+	exports[1486] = "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR";
+	exports[1487] = "ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR";
+	exports[1488] = "ER_FIELD_NOT_FOUND_PART_ERROR";
+	exports[1489] = "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR";
+	exports[1490] = "ER_INCONSISTENT_PARTITION_INFO_ERROR";
+	exports[1491] = "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR";
+	exports[1492] = "ER_PARTITIONS_MUST_BE_DEFINED_ERROR";
+	exports[1493] = "ER_RANGE_NOT_INCREASING_ERROR";
+	exports[1494] = "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR";
+	exports[1495] = "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR";
+	exports[1496] = "ER_PARTITION_ENTRY_ERROR";
+	exports[1497] = "ER_MIX_HANDLER_ERROR";
+	exports[1498] = "ER_PARTITION_NOT_DEFINED_ERROR";
+	exports[1499] = "ER_TOO_MANY_PARTITIONS_ERROR";
+	exports[1500] = "ER_SUBPARTITION_ERROR";
+	exports[1501] = "ER_CANT_CREATE_HANDLER_FILE";
+	exports[1502] = "ER_BLOB_FIELD_IN_PART_FUNC_ERROR";
+	exports[1503] = "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF";
+	exports[1504] = "ER_NO_PARTS_ERROR";
+	exports[1505] = "ER_PARTITION_MGMT_ON_NONPARTITIONED";
+	exports[1506] = "ER_FOREIGN_KEY_ON_PARTITIONED";
+	exports[1507] = "ER_DROP_PARTITION_NON_EXISTENT";
+	exports[1508] = "ER_DROP_LAST_PARTITION";
+	exports[1509] = "ER_COALESCE_ONLY_ON_HASH_PARTITION";
+	exports[1510] = "ER_REORG_HASH_ONLY_ON_SAME_NO";
+	exports[1511] = "ER_REORG_NO_PARAM_ERROR";
+	exports[1512] = "ER_ONLY_ON_RANGE_LIST_PARTITION";
+	exports[1513] = "ER_ADD_PARTITION_SUBPART_ERROR";
+	exports[1514] = "ER_ADD_PARTITION_NO_NEW_PARTITION";
+	exports[1515] = "ER_COALESCE_PARTITION_NO_PARTITION";
+	exports[1516] = "ER_REORG_PARTITION_NOT_EXIST";
+	exports[1517] = "ER_SAME_NAME_PARTITION";
+	exports[1518] = "ER_NO_BINLOG_ERROR";
+	exports[1519] = "ER_CONSECUTIVE_REORG_PARTITIONS";
+	exports[1520] = "ER_REORG_OUTSIDE_RANGE";
+	exports[1521] = "ER_PARTITION_FUNCTION_FAILURE";
+	exports[1522] = "ER_PART_STATE_ERROR";
+	exports[1523] = "ER_LIMITED_PART_RANGE";
+	exports[1524] = "ER_PLUGIN_IS_NOT_LOADED";
+	exports[1525] = "ER_WRONG_VALUE";
+	exports[1526] = "ER_NO_PARTITION_FOR_GIVEN_VALUE";
+	exports[1527] = "ER_FILEGROUP_OPTION_ONLY_ONCE";
+	exports[1528] = "ER_CREATE_FILEGROUP_FAILED";
+	exports[1529] = "ER_DROP_FILEGROUP_FAILED";
+	exports[1530] = "ER_TABLESPACE_AUTO_EXTEND_ERROR";
+	exports[1531] = "ER_WRONG_SIZE_NUMBER";
+	exports[1532] = "ER_SIZE_OVERFLOW_ERROR";
+	exports[1533] = "ER_ALTER_FILEGROUP_FAILED";
+	exports[1534] = "ER_BINLOG_ROW_LOGGING_FAILED";
+	exports[1535] = "ER_BINLOG_ROW_WRONG_TABLE_DEF";
+	exports[1536] = "ER_BINLOG_ROW_RBR_TO_SBR";
+	exports[1537] = "ER_EVENT_ALREADY_EXISTS";
+	exports[1538] = "ER_EVENT_STORE_FAILED";
+	exports[1539] = "ER_EVENT_DOES_NOT_EXIST";
+	exports[1540] = "ER_EVENT_CANT_ALTER";
+	exports[1541] = "ER_EVENT_DROP_FAILED";
+	exports[1542] = "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG";
+	exports[1543] = "ER_EVENT_ENDS_BEFORE_STARTS";
+	exports[1544] = "ER_EVENT_EXEC_TIME_IN_THE_PAST";
+	exports[1545] = "ER_EVENT_OPEN_TABLE_FAILED";
+	exports[1546] = "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT";
+	exports[1547] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED";
+	exports[1548] = "ER_CANNOT_LOAD_FROM_TABLE";
+	exports[1549] = "ER_EVENT_CANNOT_DELETE";
+	exports[1550] = "ER_EVENT_COMPILE_ERROR";
+	exports[1551] = "ER_EVENT_SAME_NAME";
+	exports[1552] = "ER_EVENT_DATA_TOO_LONG";
+	exports[1553] = "ER_DROP_INDEX_FK";
+	exports[1554] = "ER_WARN_DEPRECATED_SYNTAX_WITH_VER";
+	exports[1555] = "ER_CANT_WRITE_LOCK_LOG_TABLE";
+	exports[1556] = "ER_CANT_LOCK_LOG_TABLE";
+	exports[1557] = "ER_FOREIGN_DUPLICATE_KEY";
+	exports[1558] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE";
+	exports[1559] = "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR";
+	exports[1560] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT";
+	exports[1561] = "ER_NDB_CANT_SWITCH_BINLOG_FORMAT";
+	exports[1562] = "ER_PARTITION_NO_TEMPORARY";
+	exports[1563] = "ER_PARTITION_CONST_DOMAIN_ERROR";
+	exports[1564] = "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED";
+	exports[1565] = "ER_DDL_LOG_ERROR";
+	exports[1566] = "ER_NULL_IN_VALUES_LESS_THAN";
+	exports[1567] = "ER_WRONG_PARTITION_NAME";
+	exports[1568] = "ER_CANT_CHANGE_TX_CHARACTERISTICS";
+	exports[1569] = "ER_DUP_ENTRY_AUTOINCREMENT_CASE";
+	exports[1570] = "ER_EVENT_MODIFY_QUEUE_ERROR";
+	exports[1571] = "ER_EVENT_SET_VAR_ERROR";
+	exports[1572] = "ER_PARTITION_MERGE_ERROR";
+	exports[1573] = "ER_CANT_ACTIVATE_LOG";
+	exports[1574] = "ER_RBR_NOT_AVAILABLE";
+	exports[1575] = "ER_BASE64_DECODE_ERROR";
+	exports[1576] = "ER_EVENT_RECURSION_FORBIDDEN";
+	exports[1577] = "ER_EVENTS_DB_ERROR";
+	exports[1578] = "ER_ONLY_INTEGERS_ALLOWED";
+	exports[1579] = "ER_UNSUPORTED_LOG_ENGINE";
+	exports[1580] = "ER_BAD_LOG_STATEMENT";
+	exports[1581] = "ER_CANT_RENAME_LOG_TABLE";
+	exports[1582] = "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT";
+	exports[1583] = "ER_WRONG_PARAMETERS_TO_NATIVE_FCT";
+	exports[1584] = "ER_WRONG_PARAMETERS_TO_STORED_FCT";
+	exports[1585] = "ER_NATIVE_FCT_NAME_COLLISION";
+	exports[1586] = "ER_DUP_ENTRY_WITH_KEY_NAME";
+	exports[1587] = "ER_BINLOG_PURGE_EMFILE";
+	exports[1588] = "ER_EVENT_CANNOT_CREATE_IN_THE_PAST";
+	exports[1589] = "ER_EVENT_CANNOT_ALTER_IN_THE_PAST";
+	exports[1590] = "ER_SLAVE_INCIDENT";
+	exports[1591] = "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT";
+	exports[1592] = "ER_BINLOG_UNSAFE_STATEMENT";
+	exports[1593] = "ER_BINLOG_FATAL_ERROR";
+	exports[1594] = "ER_SLAVE_RELAY_LOG_READ_FAILURE";
+	exports[1595] = "ER_SLAVE_RELAY_LOG_WRITE_FAILURE";
+	exports[1596] = "ER_SLAVE_CREATE_EVENT_FAILURE";
+	exports[1597] = "ER_SLAVE_MASTER_COM_FAILURE";
+	exports[1598] = "ER_BINLOG_LOGGING_IMPOSSIBLE";
+	exports[1599] = "ER_VIEW_NO_CREATION_CTX";
+	exports[1600] = "ER_VIEW_INVALID_CREATION_CTX";
+	exports[1601] = "ER_SR_INVALID_CREATION_CTX";
+	exports[1602] = "ER_TRG_CORRUPTED_FILE";
+	exports[1603] = "ER_TRG_NO_CREATION_CTX";
+	exports[1604] = "ER_TRG_INVALID_CREATION_CTX";
+	exports[1605] = "ER_EVENT_INVALID_CREATION_CTX";
+	exports[1606] = "ER_TRG_CANT_OPEN_TABLE";
+	exports[1607] = "ER_CANT_CREATE_SROUTINE";
+	exports[1608] = "ER_NEVER_USED";
+	exports[1609] = "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT";
+	exports[1610] = "ER_REPLICA_CORRUPT_EVENT";
+	exports[1611] = "ER_LOAD_DATA_INVALID_COLUMN";
+	exports[1612] = "ER_LOG_PURGE_NO_FILE";
+	exports[1613] = "ER_XA_RBTIMEOUT";
+	exports[1614] = "ER_XA_RBDEADLOCK";
+	exports[1615] = "ER_NEED_REPREPARE";
+	exports[1616] = "ER_DELAYED_NOT_SUPPORTED";
+	exports[1617] = "WARN_NO_CONNECTION_METADATA";
+	exports[1618] = "WARN_OPTION_IGNORED";
+	exports[1619] = "ER_PLUGIN_DELETE_BUILTIN";
+	exports[1620] = "WARN_PLUGIN_BUSY";
+	exports[1621] = "ER_VARIABLE_IS_READONLY";
+	exports[1622] = "ER_WARN_ENGINE_TRANSACTION_ROLLBACK";
+	exports[1623] = "ER_SLAVE_HEARTBEAT_FAILURE";
+	exports[1624] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE";
+	exports[1625] = "ER_NDB_REPLICATION_SCHEMA_ERROR";
+	exports[1626] = "ER_CONFLICT_FN_PARSE_ERROR";
+	exports[1627] = "ER_EXCEPTIONS_WRITE_ERROR";
+	exports[1628] = "ER_TOO_LONG_TABLE_COMMENT";
+	exports[1629] = "ER_TOO_LONG_FIELD_COMMENT";
+	exports[1630] = "ER_FUNC_INEXISTENT_NAME_COLLISION";
+	exports[1631] = "ER_DATABASE_NAME";
+	exports[1632] = "ER_TABLE_NAME";
+	exports[1633] = "ER_PARTITION_NAME";
+	exports[1634] = "ER_SUBPARTITION_NAME";
+	exports[1635] = "ER_TEMPORARY_NAME";
+	exports[1636] = "ER_RENAMED_NAME";
+	exports[1637] = "ER_TOO_MANY_CONCURRENT_TRXS";
+	exports[1638] = "WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED";
+	exports[1639] = "ER_DEBUG_SYNC_TIMEOUT";
+	exports[1640] = "ER_DEBUG_SYNC_HIT_LIMIT";
+	exports[1641] = "ER_DUP_SIGNAL_SET";
+	exports[1642] = "ER_SIGNAL_WARN";
+	exports[1643] = "ER_SIGNAL_NOT_FOUND";
+	exports[1644] = "ER_SIGNAL_EXCEPTION";
+	exports[1645] = "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER";
+	exports[1646] = "ER_SIGNAL_BAD_CONDITION_TYPE";
+	exports[1647] = "WARN_COND_ITEM_TRUNCATED";
+	exports[1648] = "ER_COND_ITEM_TOO_LONG";
+	exports[1649] = "ER_UNKNOWN_LOCALE";
+	exports[1650] = "ER_REPLICA_IGNORE_SERVER_IDS";
+	exports[1651] = "ER_QUERY_CACHE_DISABLED";
+	exports[1652] = "ER_SAME_NAME_PARTITION_FIELD";
+	exports[1653] = "ER_PARTITION_COLUMN_LIST_ERROR";
+	exports[1654] = "ER_WRONG_TYPE_COLUMN_VALUE_ERROR";
+	exports[1655] = "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR";
+	exports[1656] = "ER_MAXVALUE_IN_VALUES_IN";
+	exports[1657] = "ER_TOO_MANY_VALUES_ERROR";
+	exports[1658] = "ER_ROW_SINGLE_PARTITION_FIELD_ERROR";
+	exports[1659] = "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD";
+	exports[1660] = "ER_PARTITION_FIELDS_TOO_LONG";
+	exports[1661] = "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE";
+	exports[1662] = "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE";
+	exports[1663] = "ER_BINLOG_UNSAFE_AND_STMT_ENGINE";
+	exports[1664] = "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE";
+	exports[1665] = "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE";
+	exports[1666] = "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE";
+	exports[1667] = "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
+	exports[1668] = "ER_BINLOG_UNSAFE_LIMIT";
+	exports[1669] = "ER_UNUSED4";
+	exports[1670] = "ER_BINLOG_UNSAFE_SYSTEM_TABLE";
+	exports[1671] = "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS";
+	exports[1672] = "ER_BINLOG_UNSAFE_UDF";
+	exports[1673] = "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE";
+	exports[1674] = "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION";
+	exports[1675] = "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS";
+	exports[1676] = "ER_MESSAGE_AND_STATEMENT";
+	exports[1677] = "ER_SLAVE_CONVERSION_FAILED";
+	exports[1678] = "ER_REPLICA_CANT_CREATE_CONVERSION";
+	exports[1679] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT";
+	exports[1680] = "ER_PATH_LENGTH";
+	exports[1681] = "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT";
+	exports[1682] = "ER_WRONG_NATIVE_TABLE_STRUCTURE";
+	exports[1683] = "ER_WRONG_PERFSCHEMA_USAGE";
+	exports[1684] = "ER_WARN_I_S_SKIPPED_TABLE";
+	exports[1685] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT";
+	exports[1686] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT";
+	exports[1687] = "ER_SPATIAL_MUST_HAVE_GEOM_COL";
+	exports[1688] = "ER_TOO_LONG_INDEX_COMMENT";
+	exports[1689] = "ER_LOCK_ABORTED";
+	exports[1690] = "ER_DATA_OUT_OF_RANGE";
+	exports[1691] = "ER_WRONG_SPVAR_TYPE_IN_LIMIT";
+	exports[1692] = "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
+	exports[1693] = "ER_BINLOG_UNSAFE_MIXED_STATEMENT";
+	exports[1694] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN";
+	exports[1695] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN";
+	exports[1696] = "ER_FAILED_READ_FROM_PAR_FILE";
+	exports[1697] = "ER_VALUES_IS_NOT_INT_TYPE_ERROR";
+	exports[1698] = "ER_ACCESS_DENIED_NO_PASSWORD_ERROR";
+	exports[1699] = "ER_SET_PASSWORD_AUTH_PLUGIN";
+	exports[1700] = "ER_GRANT_PLUGIN_USER_EXISTS";
+	exports[1701] = "ER_TRUNCATE_ILLEGAL_FK";
+	exports[1702] = "ER_PLUGIN_IS_PERMANENT";
+	exports[1703] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN";
+	exports[1704] = "ER_REPLICA_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX";
+	exports[1705] = "ER_STMT_CACHE_FULL";
+	exports[1706] = "ER_MULTI_UPDATE_KEY_CONFLICT";
+	exports[1707] = "ER_TABLE_NEEDS_REBUILD";
+	exports[1708] = "WARN_OPTION_BELOW_LIMIT";
+	exports[1709] = "ER_INDEX_COLUMN_TOO_LONG";
+	exports[1710] = "ER_ERROR_IN_TRIGGER_BODY";
+	exports[1711] = "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY";
+	exports[1712] = "ER_INDEX_CORRUPT";
+	exports[1713] = "ER_UNDO_RECORD_TOO_BIG";
+	exports[1714] = "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT";
+	exports[1715] = "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE";
+	exports[1716] = "ER_BINLOG_UNSAFE_REPLACE_SELECT";
+	exports[1717] = "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT";
+	exports[1718] = "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT";
+	exports[1719] = "ER_BINLOG_UNSAFE_UPDATE_IGNORE";
+	exports[1720] = "ER_PLUGIN_NO_UNINSTALL";
+	exports[1721] = "ER_PLUGIN_NO_INSTALL";
+	exports[1722] = "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT";
+	exports[1723] = "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC";
+	exports[1724] = "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS";
+	exports[1725] = "ER_TABLE_IN_FK_CHECK";
+	exports[1726] = "ER_UNSUPPORTED_ENGINE";
+	exports[1727] = "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST";
+	exports[1728] = "ER_CANNOT_LOAD_FROM_TABLE_V2";
+	exports[1729] = "ER_SOURCE_DELAY_VALUE_OUT_OF_RANGE";
+	exports[1730] = "ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT";
+	exports[1731] = "ER_PARTITION_EXCHANGE_DIFFERENT_OPTION";
+	exports[1732] = "ER_PARTITION_EXCHANGE_PART_TABLE";
+	exports[1733] = "ER_PARTITION_EXCHANGE_TEMP_TABLE";
+	exports[1734] = "ER_PARTITION_INSTEAD_OF_SUBPARTITION";
+	exports[1735] = "ER_UNKNOWN_PARTITION";
+	exports[1736] = "ER_TABLES_DIFFERENT_METADATA";
+	exports[1737] = "ER_ROW_DOES_NOT_MATCH_PARTITION";
+	exports[1738] = "ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX";
+	exports[1739] = "ER_WARN_INDEX_NOT_APPLICABLE";
+	exports[1740] = "ER_PARTITION_EXCHANGE_FOREIGN_KEY";
+	exports[1741] = "ER_NO_SUCH_KEY_VALUE";
+	exports[1742] = "ER_RPL_INFO_DATA_TOO_LONG";
+	exports[1743] = "ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE";
+	exports[1744] = "ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE";
+	exports[1745] = "ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX";
+	exports[1746] = "ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT";
+	exports[1747] = "ER_PARTITION_CLAUSE_ON_NONPARTITIONED";
+	exports[1748] = "ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET";
+	exports[1749] = "ER_NO_SUCH_PARTITION";
+	exports[1750] = "ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE";
+	exports[1751] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE";
+	exports[1752] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE";
+	exports[1753] = "ER_MTA_FEATURE_IS_NOT_SUPPORTED";
+	exports[1754] = "ER_MTA_UPDATED_DBS_GREATER_MAX";
+	exports[1755] = "ER_MTA_CANT_PARALLEL";
+	exports[1756] = "ER_MTA_INCONSISTENT_DATA";
+	exports[1757] = "ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING";
+	exports[1758] = "ER_DA_INVALID_CONDITION_NUMBER";
+	exports[1759] = "ER_INSECURE_PLAIN_TEXT";
+	exports[1760] = "ER_INSECURE_CHANGE_SOURCE";
+	exports[1761] = "ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO";
+	exports[1762] = "ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO";
+	exports[1763] = "ER_SQLTHREAD_WITH_SECURE_REPLICA";
+	exports[1764] = "ER_TABLE_HAS_NO_FT";
+	exports[1765] = "ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER";
+	exports[1766] = "ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION";
+	exports[1767] = "ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST";
+	exports[1768] = "ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION";
+	exports[1769] = "ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION";
+	exports[1770] = "ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL";
+	exports[1771] = "ER_SKIPPING_LOGGED_TRANSACTION";
+	exports[1772] = "ER_MALFORMED_GTID_SET_SPECIFICATION";
+	exports[1773] = "ER_MALFORMED_GTID_SET_ENCODING";
+	exports[1774] = "ER_MALFORMED_GTID_SPECIFICATION";
+	exports[1775] = "ER_GNO_EXHAUSTED";
+	exports[1776] = "ER_BAD_REPLICA_AUTO_POSITION";
+	exports[1777] = "ER_AUTO_POSITION_REQUIRES_GTID_MODE_NOT_OFF";
+	exports[1778] = "ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET";
+	exports[1779] = "ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON";
+	exports[1780] = "ER_GTID_MODE_REQUIRES_BINLOG";
+	exports[1781] = "ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF";
+	exports[1782] = "ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON";
+	exports[1783] = "ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF";
+	exports[1784] = "ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF";
+	exports[1785] = "ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE";
+	exports[1786] = "ER_GTID_UNSAFE_CREATE_SELECT";
+	exports[1787] = "ER_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRANSACTION";
+	exports[1788] = "ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME";
+	exports[1789] = "ER_SOURCE_HAS_PURGED_REQUIRED_GTIDS";
+	exports[1790] = "ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID";
+	exports[1791] = "ER_UNKNOWN_EXPLAIN_FORMAT";
+	exports[1792] = "ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION";
+	exports[1793] = "ER_TOO_LONG_TABLE_PARTITION_COMMENT";
+	exports[1794] = "ER_REPLICA_CONFIGURATION";
+	exports[1795] = "ER_INNODB_FT_LIMIT";
+	exports[1796] = "ER_INNODB_NO_FT_TEMP_TABLE";
+	exports[1797] = "ER_INNODB_FT_WRONG_DOCID_COLUMN";
+	exports[1798] = "ER_INNODB_FT_WRONG_DOCID_INDEX";
+	exports[1799] = "ER_INNODB_ONLINE_LOG_TOO_BIG";
+	exports[1800] = "ER_UNKNOWN_ALTER_ALGORITHM";
+	exports[1801] = "ER_UNKNOWN_ALTER_LOCK";
+	exports[1802] = "ER_MTA_CHANGE_SOURCE_CANT_RUN_WITH_GAPS";
+	exports[1803] = "ER_MTA_RECOVERY_FAILURE";
+	exports[1804] = "ER_MTA_RESET_WORKERS";
+	exports[1805] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2";
+	exports[1806] = "ER_REPLICA_SILENT_RETRY_TRANSACTION";
+	exports[1807] = "ER_DISCARD_FK_CHECKS_RUNNING";
+	exports[1808] = "ER_TABLE_SCHEMA_MISMATCH";
+	exports[1809] = "ER_TABLE_IN_SYSTEM_TABLESPACE";
+	exports[1810] = "ER_IO_READ_ERROR";
+	exports[1811] = "ER_IO_WRITE_ERROR";
+	exports[1812] = "ER_TABLESPACE_MISSING";
+	exports[1813] = "ER_TABLESPACE_EXISTS";
+	exports[1814] = "ER_TABLESPACE_DISCARDED";
+	exports[1815] = "ER_INTERNAL_ERROR";
+	exports[1816] = "ER_INNODB_IMPORT_ERROR";
+	exports[1817] = "ER_INNODB_INDEX_CORRUPT";
+	exports[1818] = "ER_INVALID_YEAR_COLUMN_LENGTH";
+	exports[1819] = "ER_NOT_VALID_PASSWORD";
+	exports[1820] = "ER_MUST_CHANGE_PASSWORD";
+	exports[1821] = "ER_FK_NO_INDEX_CHILD";
+	exports[1822] = "ER_FK_NO_INDEX_PARENT";
+	exports[1823] = "ER_FK_FAIL_ADD_SYSTEM";
+	exports[1824] = "ER_FK_CANNOT_OPEN_PARENT";
+	exports[1825] = "ER_FK_INCORRECT_OPTION";
+	exports[1826] = "ER_FK_DUP_NAME";
+	exports[1827] = "ER_PASSWORD_FORMAT";
+	exports[1828] = "ER_FK_COLUMN_CANNOT_DROP";
+	exports[1829] = "ER_FK_COLUMN_CANNOT_DROP_CHILD";
+	exports[1830] = "ER_FK_COLUMN_NOT_NULL";
+	exports[1831] = "ER_DUP_INDEX";
+	exports[1832] = "ER_FK_COLUMN_CANNOT_CHANGE";
+	exports[1833] = "ER_FK_COLUMN_CANNOT_CHANGE_CHILD";
+	exports[1834] = "ER_UNUSED5";
+	exports[1835] = "ER_MALFORMED_PACKET";
+	exports[1836] = "ER_READ_ONLY_MODE";
+	exports[1837] = "ER_GTID_NEXT_TYPE_UNDEFINED_GTID";
+	exports[1838] = "ER_VARIABLE_NOT_SETTABLE_IN_SP";
+	exports[1839] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF";
+	exports[1840] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY";
+	exports[1841] = "ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY";
+	exports[1842] = "ER_GTID_PURGED_WAS_CHANGED";
+	exports[1843] = "ER_GTID_EXECUTED_WAS_CHANGED";
+	exports[1844] = "ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES";
+	exports[1845] = "ER_ALTER_OPERATION_NOT_SUPPORTED";
+	exports[1846] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON";
+	exports[1847] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY";
+	exports[1848] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION";
+	exports[1849] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME";
+	exports[1850] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE";
+	exports[1851] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK";
+	exports[1852] = "ER_UNUSED6";
+	exports[1853] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK";
+	exports[1854] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC";
+	exports[1855] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS";
+	exports[1856] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS";
+	exports[1857] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS";
+	exports[1858] = "ER_SQL_REPLICA_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE";
+	exports[1859] = "ER_DUP_UNKNOWN_IN_INDEX";
+	exports[1860] = "ER_IDENT_CAUSES_TOO_LONG_PATH";
+	exports[1861] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL";
+	exports[1862] = "ER_MUST_CHANGE_PASSWORD_LOGIN";
+	exports[1863] = "ER_ROW_IN_WRONG_PARTITION";
+	exports[1864] = "ER_MTA_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX";
+	exports[1865] = "ER_INNODB_NO_FT_USES_PARSER";
+	exports[1866] = "ER_BINLOG_LOGICAL_CORRUPTION";
+	exports[1867] = "ER_WARN_PURGE_LOG_IN_USE";
+	exports[1868] = "ER_WARN_PURGE_LOG_IS_ACTIVE";
+	exports[1869] = "ER_AUTO_INCREMENT_CONFLICT";
+	exports[1870] = "WARN_ON_BLOCKHOLE_IN_RBR";
+	exports[1871] = "ER_REPLICA_CM_INIT_REPOSITORY";
+	exports[1872] = "ER_REPLICA_AM_INIT_REPOSITORY";
+	exports[1873] = "ER_ACCESS_DENIED_CHANGE_USER_ERROR";
+	exports[1874] = "ER_INNODB_READ_ONLY";
+	exports[1875] = "ER_STOP_REPLICA_SQL_THREAD_TIMEOUT";
+	exports[1876] = "ER_STOP_REPLICA_IO_THREAD_TIMEOUT";
+	exports[1877] = "ER_TABLE_CORRUPT";
+	exports[1878] = "ER_TEMP_FILE_WRITE_FAILURE";
+	exports[1879] = "ER_INNODB_FT_AUX_NOT_HEX_ID";
+	exports[1880] = "ER_OLD_TEMPORALS_UPGRADED";
+	exports[1881] = "ER_INNODB_FORCED_RECOVERY";
+	exports[1882] = "ER_AES_INVALID_IV";
+	exports[1883] = "ER_PLUGIN_CANNOT_BE_UNINSTALLED";
+	exports[1884] = "ER_GTID_UNSAFE_BINLOG_SPLITTABLE_STATEMENT_AND_ASSIGNED_GTID";
+	exports[1885] = "ER_REPLICA_HAS_MORE_GTIDS_THAN_SOURCE";
+	exports[1886] = "ER_MISSING_KEY";
+	exports[1887] = "WARN_NAMED_PIPE_ACCESS_EVERYONE";
+	exports[3e3] = "ER_FILE_CORRUPT";
+	exports[3001] = "ER_ERROR_ON_SOURCE";
+	exports[3002] = "ER_INCONSISTENT_ERROR";
+	exports[3003] = "ER_STORAGE_ENGINE_NOT_LOADED";
+	exports[3004] = "ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER";
+	exports[3005] = "ER_WARN_LEGACY_SYNTAX_CONVERTED";
+	exports[3006] = "ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN";
+	exports[3007] = "ER_CANNOT_DISCARD_TEMPORARY_TABLE";
+	exports[3008] = "ER_FK_DEPTH_EXCEEDED";
+	exports[3009] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2";
+	exports[3010] = "ER_WARN_TRIGGER_DOESNT_HAVE_CREATED";
+	exports[3011] = "ER_REFERENCED_TRG_DOES_NOT_EXIST";
+	exports[3012] = "ER_EXPLAIN_NOT_SUPPORTED";
+	exports[3013] = "ER_INVALID_FIELD_SIZE";
+	exports[3014] = "ER_MISSING_HA_CREATE_OPTION";
+	exports[3015] = "ER_ENGINE_OUT_OF_MEMORY";
+	exports[3016] = "ER_PASSWORD_EXPIRE_ANONYMOUS_USER";
+	exports[3017] = "ER_REPLICA_SQL_THREAD_MUST_STOP";
+	exports[3018] = "ER_NO_FT_MATERIALIZED_SUBQUERY";
+	exports[3019] = "ER_INNODB_UNDO_LOG_FULL";
+	exports[3020] = "ER_INVALID_ARGUMENT_FOR_LOGARITHM";
+	exports[3021] = "ER_REPLICA_CHANNEL_IO_THREAD_MUST_STOP";
+	exports[3022] = "ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO";
+	exports[3023] = "ER_WARN_ONLY_SOURCE_LOG_FILE_NO_POS";
+	exports[3024] = "ER_QUERY_TIMEOUT";
+	exports[3025] = "ER_NON_RO_SELECT_DISABLE_TIMER";
+	exports[3026] = "ER_DUP_LIST_ENTRY";
+	exports[3027] = "ER_SQL_MODE_NO_EFFECT";
+	exports[3028] = "ER_AGGREGATE_ORDER_FOR_UNION";
+	exports[3029] = "ER_AGGREGATE_ORDER_NON_AGG_QUERY";
+	exports[3030] = "ER_REPLICA_WORKER_STOPPED_PREVIOUS_THD_ERROR";
+	exports[3031] = "ER_DONT_SUPPORT_REPLICA_PRESERVE_COMMIT_ORDER";
+	exports[3032] = "ER_SERVER_OFFLINE_MODE";
+	exports[3033] = "ER_GIS_DIFFERENT_SRIDS";
+	exports[3034] = "ER_GIS_UNSUPPORTED_ARGUMENT";
+	exports[3035] = "ER_GIS_UNKNOWN_ERROR";
+	exports[3036] = "ER_GIS_UNKNOWN_EXCEPTION";
+	exports[3037] = "ER_GIS_INVALID_DATA";
+	exports[3038] = "ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION";
+	exports[3039] = "ER_BOOST_GEOMETRY_CENTROID_EXCEPTION";
+	exports[3040] = "ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION";
+	exports[3041] = "ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION";
+	exports[3042] = "ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION";
+	exports[3043] = "ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION";
+	exports[3044] = "ER_STD_BAD_ALLOC_ERROR";
+	exports[3045] = "ER_STD_DOMAIN_ERROR";
+	exports[3046] = "ER_STD_LENGTH_ERROR";
+	exports[3047] = "ER_STD_INVALID_ARGUMENT";
+	exports[3048] = "ER_STD_OUT_OF_RANGE_ERROR";
+	exports[3049] = "ER_STD_OVERFLOW_ERROR";
+	exports[3050] = "ER_STD_RANGE_ERROR";
+	exports[3051] = "ER_STD_UNDERFLOW_ERROR";
+	exports[3052] = "ER_STD_LOGIC_ERROR";
+	exports[3053] = "ER_STD_RUNTIME_ERROR";
+	exports[3054] = "ER_STD_UNKNOWN_EXCEPTION";
+	exports[3055] = "ER_GIS_DATA_WRONG_ENDIANESS";
+	exports[3056] = "ER_CHANGE_SOURCE_PASSWORD_LENGTH";
+	exports[3057] = "ER_USER_LOCK_WRONG_NAME";
+	exports[3058] = "ER_USER_LOCK_DEADLOCK";
+	exports[3059] = "ER_REPLACE_INACCESSIBLE_ROWS";
+	exports[3060] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS";
+	exports[3061] = "ER_ILLEGAL_USER_VAR";
+	exports[3062] = "ER_GTID_MODE_OFF";
+	exports[3063] = "ER_UNSUPPORTED_BY_REPLICATION_THREAD";
+	exports[3064] = "ER_INCORRECT_TYPE";
+	exports[3065] = "ER_FIELD_IN_ORDER_NOT_SELECT";
+	exports[3066] = "ER_AGGREGATE_IN_ORDER_NOT_SELECT";
+	exports[3067] = "ER_INVALID_RPL_WILD_TABLE_FILTER_PATTERN";
+	exports[3068] = "ER_NET_OK_PACKET_TOO_LARGE";
+	exports[3069] = "ER_INVALID_JSON_DATA";
+	exports[3070] = "ER_INVALID_GEOJSON_MISSING_MEMBER";
+	exports[3071] = "ER_INVALID_GEOJSON_WRONG_TYPE";
+	exports[3072] = "ER_INVALID_GEOJSON_UNSPECIFIED";
+	exports[3073] = "ER_DIMENSION_UNSUPPORTED";
+	exports[3074] = "ER_REPLICA_CHANNEL_DOES_NOT_EXIST";
+	exports[3075] = "ER_SLAVE_MULTIPLE_CHANNELS_HOST_PORT";
+	exports[3076] = "ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG";
+	exports[3077] = "ER_REPLICA_NEW_CHANNEL_WRONG_REPOSITORY";
+	exports[3078] = "ER_SLAVE_CHANNEL_DELETE";
+	exports[3079] = "ER_REPLICA_MULTIPLE_CHANNELS_CMD";
+	exports[3080] = "ER_REPLICA_MAX_CHANNELS_EXCEEDED";
+	exports[3081] = "ER_REPLICA_CHANNEL_MUST_STOP";
+	exports[3082] = "ER_REPLICA_CHANNEL_NOT_RUNNING";
+	exports[3083] = "ER_REPLICA_CHANNEL_WAS_RUNNING";
+	exports[3084] = "ER_REPLICA_CHANNEL_WAS_NOT_RUNNING";
+	exports[3085] = "ER_REPLICA_CHANNEL_SQL_THREAD_MUST_STOP";
+	exports[3086] = "ER_REPLICA_CHANNEL_SQL_SKIP_COUNTER";
+	exports[3087] = "ER_WRONG_FIELD_WITH_GROUP_V2";
+	exports[3088] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS_V2";
+	exports[3089] = "ER_WARN_DEPRECATED_SYSVAR_UPDATE";
+	exports[3090] = "ER_WARN_DEPRECATED_SQLMODE";
+	exports[3091] = "ER_CANNOT_LOG_PARTIAL_DROP_DATABASE_WITH_GTID";
+	exports[3092] = "ER_GROUP_REPLICATION_CONFIGURATION";
+	exports[3093] = "ER_GROUP_REPLICATION_RUNNING";
+	exports[3094] = "ER_GROUP_REPLICATION_APPLIER_INIT_ERROR";
+	exports[3095] = "ER_GROUP_REPLICATION_STOP_APPLIER_THREAD_TIMEOUT";
+	exports[3096] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_SESSION_ERROR";
+	exports[3097] = "ER_GROUP_REPLICATION_COMMUNICATION_LAYER_JOIN_ERROR";
+	exports[3098] = "ER_BEFORE_DML_VALIDATION_ERROR";
+	exports[3099] = "ER_PREVENTS_VARIABLE_WITHOUT_RBR";
+	exports[3100] = "ER_RUN_HOOK_ERROR";
+	exports[3101] = "ER_TRANSACTION_ROLLBACK_DURING_COMMIT";
+	exports[3102] = "ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED";
+	exports[3103] = "ER_UNSUPPORTED_ALTER_INPLACE_ON_VIRTUAL_COLUMN";
+	exports[3104] = "ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN";
+	exports[3105] = "ER_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN";
+	exports[3106] = "ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN";
+	exports[3107] = "ER_GENERATED_COLUMN_NON_PRIOR";
+	exports[3108] = "ER_DEPENDENT_BY_GENERATED_COLUMN";
+	exports[3109] = "ER_GENERATED_COLUMN_REF_AUTO_INC";
+	exports[3110] = "ER_FEATURE_NOT_AVAILABLE";
+	exports[3111] = "ER_CANT_SET_GTID_MODE";
+	exports[3112] = "ER_CANT_USE_AUTO_POSITION_WITH_GTID_MODE_OFF";
+	exports[3113] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_AUTO_POSITION";
+	exports[3114] = "ER_CANT_REPLICATE_ANONYMOUS_WITH_GTID_MODE_ON";
+	exports[3115] = "ER_CANT_REPLICATE_GTID_WITH_GTID_MODE_OFF";
+	exports[3116] = "ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX";
+	exports[3117] = "ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX";
+	exports[3118] = "ER_ACCOUNT_HAS_BEEN_LOCKED";
+	exports[3119] = "ER_WRONG_TABLESPACE_NAME";
+	exports[3120] = "ER_TABLESPACE_IS_NOT_EMPTY";
+	exports[3121] = "ER_WRONG_FILE_NAME";
+	exports[3122] = "ER_BOOST_GEOMETRY_INCONSISTENT_TURNS_EXCEPTION";
+	exports[3123] = "ER_WARN_OPTIMIZER_HINT_SYNTAX_ERROR";
+	exports[3124] = "ER_WARN_BAD_MAX_EXECUTION_TIME";
+	exports[3125] = "ER_WARN_UNSUPPORTED_MAX_EXECUTION_TIME";
+	exports[3126] = "ER_WARN_CONFLICTING_HINT";
+	exports[3127] = "ER_WARN_UNKNOWN_QB_NAME";
+	exports[3128] = "ER_UNRESOLVED_HINT_NAME";
+	exports[3129] = "ER_WARN_ON_MODIFYING_GTID_EXECUTED_TABLE";
+	exports[3130] = "ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED";
+	exports[3131] = "ER_LOCKING_SERVICE_WRONG_NAME";
+	exports[3132] = "ER_LOCKING_SERVICE_DEADLOCK";
+	exports[3133] = "ER_LOCKING_SERVICE_TIMEOUT";
+	exports[3134] = "ER_GIS_MAX_POINTS_IN_GEOMETRY_OVERFLOWED";
+	exports[3135] = "ER_SQL_MODE_MERGED";
+	exports[3136] = "ER_VTOKEN_PLUGIN_TOKEN_MISMATCH";
+	exports[3137] = "ER_VTOKEN_PLUGIN_TOKEN_NOT_FOUND";
+	exports[3138] = "ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID";
+	exports[3139] = "ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED";
+	exports[3140] = "ER_INVALID_JSON_TEXT";
+	exports[3141] = "ER_INVALID_JSON_TEXT_IN_PARAM";
+	exports[3142] = "ER_INVALID_JSON_BINARY_DATA";
+	exports[3143] = "ER_INVALID_JSON_PATH";
+	exports[3144] = "ER_INVALID_JSON_CHARSET";
+	exports[3145] = "ER_INVALID_JSON_CHARSET_IN_FUNCTION";
+	exports[3146] = "ER_INVALID_TYPE_FOR_JSON";
+	exports[3147] = "ER_INVALID_CAST_TO_JSON";
+	exports[3148] = "ER_INVALID_JSON_PATH_CHARSET";
+	exports[3149] = "ER_INVALID_JSON_PATH_WILDCARD";
+	exports[3150] = "ER_JSON_VALUE_TOO_BIG";
+	exports[3151] = "ER_JSON_KEY_TOO_BIG";
+	exports[3152] = "ER_JSON_USED_AS_KEY";
+	exports[3153] = "ER_JSON_VACUOUS_PATH";
+	exports[3154] = "ER_JSON_BAD_ONE_OR_ALL_ARG";
+	exports[3155] = "ER_NUMERIC_JSON_VALUE_OUT_OF_RANGE";
+	exports[3156] = "ER_INVALID_JSON_VALUE_FOR_CAST";
+	exports[3157] = "ER_JSON_DOCUMENT_TOO_DEEP";
+	exports[3158] = "ER_JSON_DOCUMENT_NULL_KEY";
+	exports[3159] = "ER_SECURE_TRANSPORT_REQUIRED";
+	exports[3160] = "ER_NO_SECURE_TRANSPORTS_CONFIGURED";
+	exports[3161] = "ER_DISABLED_STORAGE_ENGINE";
+	exports[3162] = "ER_USER_DOES_NOT_EXIST";
+	exports[3163] = "ER_USER_ALREADY_EXISTS";
+	exports[3164] = "ER_AUDIT_API_ABORT";
+	exports[3165] = "ER_INVALID_JSON_PATH_ARRAY_CELL";
+	exports[3166] = "ER_BUFPOOL_RESIZE_INPROGRESS";
+	exports[3167] = "ER_FEATURE_DISABLED_SEE_DOC";
+	exports[3168] = "ER_SERVER_ISNT_AVAILABLE";
+	exports[3169] = "ER_SESSION_WAS_KILLED";
+	exports[3170] = "ER_CAPACITY_EXCEEDED";
+	exports[3171] = "ER_CAPACITY_EXCEEDED_IN_RANGE_OPTIMIZER";
+	exports[3172] = "ER_TABLE_NEEDS_UPG_PART";
+	exports[3173] = "ER_CANT_WAIT_FOR_EXECUTED_GTID_SET_WHILE_OWNING_A_GTID";
+	exports[3174] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_VIRTUAL";
+	exports[3175] = "ER_CANNOT_CREATE_VIRTUAL_INDEX_CONSTRAINT";
+	exports[3176] = "ER_ERROR_ON_MODIFYING_GTID_EXECUTED_TABLE";
+	exports[3177] = "ER_LOCK_REFUSED_BY_ENGINE";
+	exports[3178] = "ER_UNSUPPORTED_ALTER_ONLINE_ON_VIRTUAL_COLUMN";
+	exports[3179] = "ER_MASTER_KEY_ROTATION_NOT_SUPPORTED_BY_SE";
+	exports[3180] = "ER_MASTER_KEY_ROTATION_ERROR_BY_SE";
+	exports[3181] = "ER_MASTER_KEY_ROTATION_BINLOG_FAILED";
+	exports[3182] = "ER_MASTER_KEY_ROTATION_SE_UNAVAILABLE";
+	exports[3183] = "ER_TABLESPACE_CANNOT_ENCRYPT";
+	exports[3184] = "ER_INVALID_ENCRYPTION_OPTION";
+	exports[3185] = "ER_CANNOT_FIND_KEY_IN_KEYRING";
+	exports[3186] = "ER_CAPACITY_EXCEEDED_IN_PARSER";
+	exports[3187] = "ER_UNSUPPORTED_ALTER_ENCRYPTION_INPLACE";
+	exports[3188] = "ER_KEYRING_UDF_KEYRING_SERVICE_ERROR";
+	exports[3189] = "ER_USER_COLUMN_OLD_LENGTH";
+	exports[3190] = "ER_CANT_RESET_SOURCE";
+	exports[3191] = "ER_GROUP_REPLICATION_MAX_GROUP_SIZE";
+	exports[3192] = "ER_CANNOT_ADD_FOREIGN_BASE_COL_STORED";
+	exports[3193] = "ER_TABLE_REFERENCED";
+	exports[3194] = "ER_PARTITION_ENGINE_DEPRECATED_FOR_TABLE";
+	exports[3195] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID_ZERO";
+	exports[3196] = "ER_WARN_USING_GEOMFROMWKB_TO_SET_SRID";
+	exports[3197] = "ER_XA_RETRY";
+	exports[3198] = "ER_KEYRING_AWS_UDF_AWS_KMS_ERROR";
+	exports[3199] = "ER_BINLOG_UNSAFE_XA";
+	exports[3200] = "ER_UDF_ERROR";
+	exports[3201] = "ER_KEYRING_MIGRATION_FAILURE";
+	exports[3202] = "ER_KEYRING_ACCESS_DENIED_ERROR";
+	exports[3203] = "ER_KEYRING_MIGRATION_STATUS";
+	exports[3204] = "ER_PLUGIN_FAILED_TO_OPEN_TABLES";
+	exports[3205] = "ER_PLUGIN_FAILED_TO_OPEN_TABLE";
+	exports[3206] = "ER_AUDIT_LOG_NO_KEYRING_PLUGIN_INSTALLED";
+	exports[3207] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_HAS_NOT_BEEN_SET";
+	exports[3208] = "ER_AUDIT_LOG_COULD_NOT_CREATE_AES_KEY";
+	exports[3209] = "ER_AUDIT_LOG_ENCRYPTION_PASSWORD_CANNOT_BE_FETCHED";
+	exports[3210] = "ER_AUDIT_LOG_JSON_FILTERING_NOT_ENABLED";
+	exports[3211] = "ER_AUDIT_LOG_UDF_INSUFFICIENT_PRIVILEGE";
+	exports[3212] = "ER_AUDIT_LOG_SUPER_PRIVILEGE_REQUIRED";
+	exports[3213] = "ER_COULD_NOT_REINITIALIZE_AUDIT_LOG_FILTERS";
+	exports[3214] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_TYPE";
+	exports[3215] = "ER_AUDIT_LOG_UDF_INVALID_ARGUMENT_COUNT";
+	exports[3216] = "ER_AUDIT_LOG_HAS_NOT_BEEN_INSTALLED";
+	exports[3217] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_TYPE";
+	exports[3218] = "ER_AUDIT_LOG_UDF_READ_INVALID_MAX_ARRAY_LENGTH_ARG_VALUE";
+	exports[3219] = "ER_AUDIT_LOG_JSON_FILTER_PARSING_ERROR";
+	exports[3220] = "ER_AUDIT_LOG_JSON_FILTER_NAME_CANNOT_BE_EMPTY";
+	exports[3221] = "ER_AUDIT_LOG_JSON_USER_NAME_CANNOT_BE_EMPTY";
+	exports[3222] = "ER_AUDIT_LOG_JSON_FILTER_DOES_NOT_EXISTS";
+	exports[3223] = "ER_AUDIT_LOG_USER_FIRST_CHARACTER_MUST_BE_ALPHANUMERIC";
+	exports[3224] = "ER_AUDIT_LOG_USER_NAME_INVALID_CHARACTER";
+	exports[3225] = "ER_AUDIT_LOG_HOST_NAME_INVALID_CHARACTER";
+	exports[3226] = "WARN_DEPRECATED_MAXDB_SQL_MODE_FOR_TIMESTAMP";
+	exports[3227] = "ER_XA_REPLICATION_FILTERS";
+	exports[3228] = "ER_CANT_OPEN_ERROR_LOG";
+	exports[3229] = "ER_GROUPING_ON_TIMESTAMP_IN_DST";
+	exports[3230] = "ER_CANT_START_SERVER_NAMED_PIPE";
+	exports[3231] = "ER_WRITE_SET_EXCEEDS_LIMIT";
+	exports[3232] = "ER_DEPRECATED_TLS_VERSION_SESSION_57";
+	exports[3233] = "ER_WARN_DEPRECATED_TLS_VERSION_57";
+	exports[3234] = "ER_WARN_WRONG_NATIVE_TABLE_STRUCTURE";
+	exports[3235] = "ER_AES_INVALID_KDF_NAME";
+	exports[3236] = "ER_AES_INVALID_KDF_ITERATIONS";
+	exports[3237] = "WARN_AES_KEY_SIZE";
+	exports[3238] = "ER_AES_INVALID_KDF_OPTION_SIZE";
+	exports[3500] = "ER_UNSUPPORT_COMPRESSED_TEMPORARY_TABLE";
+	exports[3501] = "ER_ACL_OPERATION_FAILED";
+	exports[3502] = "ER_UNSUPPORTED_INDEX_ALGORITHM";
+	exports[3503] = "ER_NO_SUCH_DB";
+	exports[3504] = "ER_TOO_BIG_ENUM";
+	exports[3505] = "ER_TOO_LONG_SET_ENUM_VALUE";
+	exports[3506] = "ER_INVALID_DD_OBJECT";
+	exports[3507] = "ER_UPDATING_DD_TABLE";
+	exports[3508] = "ER_INVALID_DD_OBJECT_ID";
+	exports[3509] = "ER_INVALID_DD_OBJECT_NAME";
+	exports[3510] = "ER_TABLESPACE_MISSING_WITH_NAME";
+	exports[3511] = "ER_TOO_LONG_ROUTINE_COMMENT";
+	exports[3512] = "ER_SP_LOAD_FAILED";
+	exports[3513] = "ER_INVALID_BITWISE_OPERANDS_SIZE";
+	exports[3514] = "ER_INVALID_BITWISE_AGGREGATE_OPERANDS_SIZE";
+	exports[3515] = "ER_WARN_UNSUPPORTED_HINT";
+	exports[3516] = "ER_UNEXPECTED_GEOMETRY_TYPE";
+	exports[3517] = "ER_SRS_PARSE_ERROR";
+	exports[3518] = "ER_SRS_PROJ_PARAMETER_MISSING";
+	exports[3519] = "ER_WARN_SRS_NOT_FOUND";
+	exports[3520] = "ER_SRS_NOT_CARTESIAN";
+	exports[3521] = "ER_SRS_NOT_CARTESIAN_UNDEFINED";
+	exports[3522] = "ER_PK_INDEX_CANT_BE_INVISIBLE";
+	exports[3523] = "ER_UNKNOWN_AUTHID";
+	exports[3524] = "ER_FAILED_ROLE_GRANT";
+	exports[3525] = "ER_OPEN_ROLE_TABLES";
+	exports[3526] = "ER_FAILED_DEFAULT_ROLES";
+	exports[3527] = "ER_COMPONENTS_NO_SCHEME";
+	exports[3528] = "ER_COMPONENTS_NO_SCHEME_SERVICE";
+	exports[3529] = "ER_COMPONENTS_CANT_LOAD";
+	exports[3530] = "ER_ROLE_NOT_GRANTED";
+	exports[3531] = "ER_FAILED_REVOKE_ROLE";
+	exports[3532] = "ER_RENAME_ROLE";
+	exports[3533] = "ER_COMPONENTS_CANT_ACQUIRE_SERVICE_IMPLEMENTATION";
+	exports[3534] = "ER_COMPONENTS_CANT_SATISFY_DEPENDENCY";
+	exports[3535] = "ER_COMPONENTS_LOAD_CANT_REGISTER_SERVICE_IMPLEMENTATION";
+	exports[3536] = "ER_COMPONENTS_LOAD_CANT_INITIALIZE";
+	exports[3537] = "ER_COMPONENTS_UNLOAD_NOT_LOADED";
+	exports[3538] = "ER_COMPONENTS_UNLOAD_CANT_DEINITIALIZE";
+	exports[3539] = "ER_COMPONENTS_CANT_RELEASE_SERVICE";
+	exports[3540] = "ER_COMPONENTS_UNLOAD_CANT_UNREGISTER_SERVICE";
+	exports[3541] = "ER_COMPONENTS_CANT_UNLOAD";
+	exports[3542] = "ER_WARN_UNLOAD_THE_NOT_PERSISTED";
+	exports[3543] = "ER_COMPONENT_TABLE_INCORRECT";
+	exports[3544] = "ER_COMPONENT_MANIPULATE_ROW_FAILED";
+	exports[3545] = "ER_COMPONENTS_UNLOAD_DUPLICATE_IN_GROUP";
+	exports[3546] = "ER_CANT_SET_GTID_PURGED_DUE_SETS_CONSTRAINTS";
+	exports[3547] = "ER_CANNOT_LOCK_USER_MANAGEMENT_CACHES";
+	exports[3548] = "ER_SRS_NOT_FOUND";
+	exports[3549] = "ER_VARIABLE_NOT_PERSISTED";
+	exports[3550] = "ER_IS_QUERY_INVALID_CLAUSE";
+	exports[3551] = "ER_UNABLE_TO_STORE_STATISTICS";
+	exports[3552] = "ER_NO_SYSTEM_SCHEMA_ACCESS";
+	exports[3553] = "ER_NO_SYSTEM_TABLESPACE_ACCESS";
+	exports[3554] = "ER_NO_SYSTEM_TABLE_ACCESS";
+	exports[3555] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_DICTIONARY_TABLE";
+	exports[3556] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_SYSTEM_TABLE";
+	exports[3557] = "ER_NO_SYSTEM_TABLE_ACCESS_FOR_TABLE";
+	exports[3558] = "ER_INVALID_OPTION_KEY";
+	exports[3559] = "ER_INVALID_OPTION_VALUE";
+	exports[3560] = "ER_INVALID_OPTION_KEY_VALUE_PAIR";
+	exports[3561] = "ER_INVALID_OPTION_START_CHARACTER";
+	exports[3562] = "ER_INVALID_OPTION_END_CHARACTER";
+	exports[3563] = "ER_INVALID_OPTION_CHARACTERS";
+	exports[3564] = "ER_DUPLICATE_OPTION_KEY";
+	exports[3565] = "ER_WARN_SRS_NOT_FOUND_AXIS_ORDER";
+	exports[3566] = "ER_NO_ACCESS_TO_NATIVE_FCT";
+	exports[3567] = "ER_RESET_SOURCE_TO_VALUE_OUT_OF_RANGE";
+	exports[3568] = "ER_UNRESOLVED_TABLE_LOCK";
+	exports[3569] = "ER_DUPLICATE_TABLE_LOCK";
+	exports[3570] = "ER_BINLOG_UNSAFE_SKIP_LOCKED";
+	exports[3571] = "ER_BINLOG_UNSAFE_NOWAIT";
+	exports[3572] = "ER_LOCK_NOWAIT";
+	exports[3573] = "ER_CTE_RECURSIVE_REQUIRES_UNION";
+	exports[3574] = "ER_CTE_RECURSIVE_REQUIRES_NONRECURSIVE_FIRST";
+	exports[3575] = "ER_CTE_RECURSIVE_FORBIDS_AGGREGATION";
+	exports[3576] = "ER_CTE_RECURSIVE_FORBIDDEN_JOIN_ORDER";
+	exports[3577] = "ER_CTE_RECURSIVE_REQUIRES_SINGLE_REFERENCE";
+	exports[3578] = "ER_SWITCH_TMP_ENGINE";
+	exports[3579] = "ER_WINDOW_NO_SUCH_WINDOW";
+	exports[3580] = "ER_WINDOW_CIRCULARITY_IN_WINDOW_GRAPH";
+	exports[3581] = "ER_WINDOW_NO_CHILD_PARTITIONING";
+	exports[3582] = "ER_WINDOW_NO_INHERIT_FRAME";
+	exports[3583] = "ER_WINDOW_NO_REDEFINE_ORDER_BY";
+	exports[3584] = "ER_WINDOW_FRAME_START_ILLEGAL";
+	exports[3585] = "ER_WINDOW_FRAME_END_ILLEGAL";
+	exports[3586] = "ER_WINDOW_FRAME_ILLEGAL";
+	exports[3587] = "ER_WINDOW_RANGE_FRAME_ORDER_TYPE";
+	exports[3588] = "ER_WINDOW_RANGE_FRAME_TEMPORAL_TYPE";
+	exports[3589] = "ER_WINDOW_RANGE_FRAME_NUMERIC_TYPE";
+	exports[3590] = "ER_WINDOW_RANGE_BOUND_NOT_CONSTANT";
+	exports[3591] = "ER_WINDOW_DUPLICATE_NAME";
+	exports[3592] = "ER_WINDOW_ILLEGAL_ORDER_BY";
+	exports[3593] = "ER_WINDOW_INVALID_WINDOW_FUNC_USE";
+	exports[3594] = "ER_WINDOW_INVALID_WINDOW_FUNC_ALIAS_USE";
+	exports[3595] = "ER_WINDOW_NESTED_WINDOW_FUNC_USE_IN_WINDOW_SPEC";
+	exports[3596] = "ER_WINDOW_ROWS_INTERVAL_USE";
+	exports[3597] = "ER_WINDOW_NO_GROUP_ORDER";
+	exports[3598] = "ER_WINDOW_EXPLAIN_JSON";
+	exports[3599] = "ER_WINDOW_FUNCTION_IGNORES_FRAME";
+	exports[3600] = "ER_WL9236_NOW";
+	exports[3601] = "ER_INVALID_NO_OF_ARGS";
+	exports[3602] = "ER_FIELD_IN_GROUPING_NOT_GROUP_BY";
+	exports[3603] = "ER_TOO_LONG_TABLESPACE_COMMENT";
+	exports[3604] = "ER_ENGINE_CANT_DROP_TABLE";
+	exports[3605] = "ER_ENGINE_CANT_DROP_MISSING_TABLE";
+	exports[3606] = "ER_TABLESPACE_DUP_FILENAME";
+	exports[3607] = "ER_DB_DROP_RMDIR2";
+	exports[3608] = "ER_IMP_NO_FILES_MATCHED";
+	exports[3609] = "ER_IMP_SCHEMA_DOES_NOT_EXIST";
+	exports[3610] = "ER_IMP_TABLE_ALREADY_EXISTS";
+	exports[3611] = "ER_IMP_INCOMPATIBLE_MYSQLD_VERSION";
+	exports[3612] = "ER_IMP_INCOMPATIBLE_DD_VERSION";
+	exports[3613] = "ER_IMP_INCOMPATIBLE_SDI_VERSION";
+	exports[3614] = "ER_WARN_INVALID_HINT";
+	exports[3615] = "ER_VAR_DOES_NOT_EXIST";
+	exports[3616] = "ER_LONGITUDE_OUT_OF_RANGE";
+	exports[3617] = "ER_LATITUDE_OUT_OF_RANGE";
+	exports[3618] = "ER_NOT_IMPLEMENTED_FOR_GEOGRAPHIC_SRS";
+	exports[3619] = "ER_ILLEGAL_PRIVILEGE_LEVEL";
+	exports[3620] = "ER_NO_SYSTEM_VIEW_ACCESS";
+	exports[3621] = "ER_COMPONENT_FILTER_FLABBERGASTED";
+	exports[3622] = "ER_PART_EXPR_TOO_LONG";
+	exports[3623] = "ER_UDF_DROP_DYNAMICALLY_REGISTERED";
+	exports[3624] = "ER_UNABLE_TO_STORE_COLUMN_STATISTICS";
+	exports[3625] = "ER_UNABLE_TO_UPDATE_COLUMN_STATISTICS";
+	exports[3626] = "ER_UNABLE_TO_DROP_COLUMN_STATISTICS";
+	exports[3627] = "ER_UNABLE_TO_BUILD_HISTOGRAM";
+	exports[3628] = "ER_MANDATORY_ROLE";
+	exports[3629] = "ER_MISSING_TABLESPACE_FILE";
+	exports[3630] = "ER_PERSIST_ONLY_ACCESS_DENIED_ERROR";
+	exports[3631] = "ER_CMD_NEED_SUPER";
+	exports[3632] = "ER_PATH_IN_DATADIR";
+	exports[3633] = "ER_CLONE_DDL_IN_PROGRESS";
+	exports[3634] = "ER_CLONE_TOO_MANY_CONCURRENT_CLONES";
+	exports[3635] = "ER_APPLIER_LOG_EVENT_VALIDATION_ERROR";
+	exports[3636] = "ER_CTE_MAX_RECURSION_DEPTH";
+	exports[3637] = "ER_NOT_HINT_UPDATABLE_VARIABLE";
+	exports[3638] = "ER_CREDENTIALS_CONTRADICT_TO_HISTORY";
+	exports[3639] = "ER_WARNING_PASSWORD_HISTORY_CLAUSES_VOID";
+	exports[3640] = "ER_CLIENT_DOES_NOT_SUPPORT";
+	exports[3641] = "ER_I_S_SKIPPED_TABLESPACE";
+	exports[3642] = "ER_TABLESPACE_ENGINE_MISMATCH";
+	exports[3643] = "ER_WRONG_SRID_FOR_COLUMN";
+	exports[3644] = "ER_CANNOT_ALTER_SRID_DUE_TO_INDEX";
+	exports[3645] = "ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED";
+	exports[3646] = "ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED";
+	exports[3647] = "ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES";
+	exports[3648] = "ER_COULD_NOT_APPLY_JSON_DIFF";
+	exports[3649] = "ER_CORRUPTED_JSON_DIFF";
+	exports[3650] = "ER_RESOURCE_GROUP_EXISTS";
+	exports[3651] = "ER_RESOURCE_GROUP_NOT_EXISTS";
+	exports[3652] = "ER_INVALID_VCPU_ID";
+	exports[3653] = "ER_INVALID_VCPU_RANGE";
+	exports[3654] = "ER_INVALID_THREAD_PRIORITY";
+	exports[3655] = "ER_DISALLOWED_OPERATION";
+	exports[3656] = "ER_RESOURCE_GROUP_BUSY";
+	exports[3657] = "ER_RESOURCE_GROUP_DISABLED";
+	exports[3658] = "ER_FEATURE_UNSUPPORTED";
+	exports[3659] = "ER_ATTRIBUTE_IGNORED";
+	exports[3660] = "ER_INVALID_THREAD_ID";
+	exports[3661] = "ER_RESOURCE_GROUP_BIND_FAILED";
+	exports[3662] = "ER_INVALID_USE_OF_FORCE_OPTION";
+	exports[3663] = "ER_GROUP_REPLICATION_COMMAND_FAILURE";
+	exports[3664] = "ER_SDI_OPERATION_FAILED";
+	exports[3665] = "ER_MISSING_JSON_TABLE_VALUE";
+	exports[3666] = "ER_WRONG_JSON_TABLE_VALUE";
+	exports[3667] = "ER_TF_MUST_HAVE_ALIAS";
+	exports[3668] = "ER_TF_FORBIDDEN_JOIN_TYPE";
+	exports[3669] = "ER_JT_VALUE_OUT_OF_RANGE";
+	exports[3670] = "ER_JT_MAX_NESTED_PATH";
+	exports[3671] = "ER_PASSWORD_EXPIRATION_NOT_SUPPORTED_BY_AUTH_METHOD";
+	exports[3672] = "ER_INVALID_GEOJSON_CRS_NOT_TOP_LEVEL";
+	exports[3673] = "ER_BAD_NULL_ERROR_NOT_IGNORED";
+	exports[3674] = "WARN_USELESS_SPATIAL_INDEX";
+	exports[3675] = "ER_DISK_FULL_NOWAIT";
+	exports[3676] = "ER_PARSE_ERROR_IN_DIGEST_FN";
+	exports[3677] = "ER_UNDISCLOSED_PARSE_ERROR_IN_DIGEST_FN";
+	exports[3678] = "ER_SCHEMA_DIR_EXISTS";
+	exports[3679] = "ER_SCHEMA_DIR_MISSING";
+	exports[3680] = "ER_SCHEMA_DIR_CREATE_FAILED";
+	exports[3681] = "ER_SCHEMA_DIR_UNKNOWN";
+	exports[3682] = "ER_ONLY_IMPLEMENTED_FOR_SRID_0_AND_4326";
+	exports[3683] = "ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER";
+	exports[3684] = "ER_REGEXP_BUFFER_OVERFLOW";
+	exports[3685] = "ER_REGEXP_ILLEGAL_ARGUMENT";
+	exports[3686] = "ER_REGEXP_INDEX_OUTOFBOUNDS_ERROR";
+	exports[3687] = "ER_REGEXP_INTERNAL_ERROR";
+	exports[3688] = "ER_REGEXP_RULE_SYNTAX";
+	exports[3689] = "ER_REGEXP_BAD_ESCAPE_SEQUENCE";
+	exports[3690] = "ER_REGEXP_UNIMPLEMENTED";
+	exports[3691] = "ER_REGEXP_MISMATCHED_PAREN";
+	exports[3692] = "ER_REGEXP_BAD_INTERVAL";
+	exports[3693] = "ER_REGEXP_MAX_LT_MIN";
+	exports[3694] = "ER_REGEXP_INVALID_BACK_REF";
+	exports[3695] = "ER_REGEXP_LOOK_BEHIND_LIMIT";
+	exports[3696] = "ER_REGEXP_MISSING_CLOSE_BRACKET";
+	exports[3697] = "ER_REGEXP_INVALID_RANGE";
+	exports[3698] = "ER_REGEXP_STACK_OVERFLOW";
+	exports[3699] = "ER_REGEXP_TIME_OUT";
+	exports[3700] = "ER_REGEXP_PATTERN_TOO_BIG";
+	exports[3701] = "ER_CANT_SET_ERROR_LOG_SERVICE";
+	exports[3702] = "ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE";
+	exports[3703] = "ER_COMPONENT_FILTER_DIAGNOSTICS";
+	exports[3704] = "ER_NOT_IMPLEMENTED_FOR_CARTESIAN_SRS";
+	exports[3705] = "ER_NOT_IMPLEMENTED_FOR_PROJECTED_SRS";
+	exports[3706] = "ER_NONPOSITIVE_RADIUS";
+	exports[3707] = "ER_RESTART_SERVER_FAILED";
+	exports[3708] = "ER_SRS_MISSING_MANDATORY_ATTRIBUTE";
+	exports[3709] = "ER_SRS_MULTIPLE_ATTRIBUTE_DEFINITIONS";
+	exports[3710] = "ER_SRS_NAME_CANT_BE_EMPTY_OR_WHITESPACE";
+	exports[3711] = "ER_SRS_ORGANIZATION_CANT_BE_EMPTY_OR_WHITESPACE";
+	exports[3712] = "ER_SRS_ID_ALREADY_EXISTS";
+	exports[3713] = "ER_WARN_SRS_ID_ALREADY_EXISTS";
+	exports[3714] = "ER_CANT_MODIFY_SRID_0";
+	exports[3715] = "ER_WARN_RESERVED_SRID_RANGE";
+	exports[3716] = "ER_CANT_MODIFY_SRS_USED_BY_COLUMN";
+	exports[3717] = "ER_SRS_INVALID_CHARACTER_IN_ATTRIBUTE";
+	exports[3718] = "ER_SRS_ATTRIBUTE_STRING_TOO_LONG";
+	exports[3719] = "ER_DEPRECATED_UTF8_ALIAS";
+	exports[3720] = "ER_DEPRECATED_NATIONAL";
+	exports[3721] = "ER_INVALID_DEFAULT_UTF8MB4_COLLATION";
+	exports[3722] = "ER_UNABLE_TO_COLLECT_LOG_STATUS";
+	exports[3723] = "ER_RESERVED_TABLESPACE_NAME";
+	exports[3724] = "ER_UNABLE_TO_SET_OPTION";
+	exports[3725] = "ER_REPLICA_POSSIBLY_DIVERGED_AFTER_DDL";
+	exports[3726] = "ER_SRS_NOT_GEOGRAPHIC";
+	exports[3727] = "ER_POLYGON_TOO_LARGE";
+	exports[3728] = "ER_SPATIAL_UNIQUE_INDEX";
+	exports[3729] = "ER_INDEX_TYPE_NOT_SUPPORTED_FOR_SPATIAL_INDEX";
+	exports[3730] = "ER_FK_CANNOT_DROP_PARENT";
+	exports[3731] = "ER_GEOMETRY_PARAM_LONGITUDE_OUT_OF_RANGE";
+	exports[3732] = "ER_GEOMETRY_PARAM_LATITUDE_OUT_OF_RANGE";
+	exports[3733] = "ER_FK_CANNOT_USE_VIRTUAL_COLUMN";
+	exports[3734] = "ER_FK_NO_COLUMN_PARENT";
+	exports[3735] = "ER_CANT_SET_ERROR_SUPPRESSION_LIST";
+	exports[3736] = "ER_SRS_GEOGCS_INVALID_AXES";
+	exports[3737] = "ER_SRS_INVALID_SEMI_MAJOR_AXIS";
+	exports[3738] = "ER_SRS_INVALID_INVERSE_FLATTENING";
+	exports[3739] = "ER_SRS_INVALID_ANGULAR_UNIT";
+	exports[3740] = "ER_SRS_INVALID_PRIME_MERIDIAN";
+	exports[3741] = "ER_TRANSFORM_SOURCE_SRS_NOT_SUPPORTED";
+	exports[3742] = "ER_TRANSFORM_TARGET_SRS_NOT_SUPPORTED";
+	exports[3743] = "ER_TRANSFORM_SOURCE_SRS_MISSING_TOWGS84";
+	exports[3744] = "ER_TRANSFORM_TARGET_SRS_MISSING_TOWGS84";
+	exports[3745] = "ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT";
+	exports[3746] = "ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT";
+	exports[3747] = "ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT";
+	exports[3748] = "ER_CLIENT_GTID_UNSAFE_CREATE_DROP_TEMP_TABLE_IN_TRX_IN_SBR";
+	exports[3749] = "ER_XA_CANT_CREATE_MDL_BACKUP";
+	exports[3750] = "ER_TABLE_WITHOUT_PK";
+	exports[3751] = "ER_WARN_DATA_TRUNCATED_FUNCTIONAL_INDEX";
+	exports[3752] = "ER_WARN_DATA_OUT_OF_RANGE_FUNCTIONAL_INDEX";
+	exports[3753] = "ER_FUNCTIONAL_INDEX_ON_JSON_OR_GEOMETRY_FUNCTION";
+	exports[3754] = "ER_FUNCTIONAL_INDEX_REF_AUTO_INCREMENT";
+	exports[3755] = "ER_CANNOT_DROP_COLUMN_FUNCTIONAL_INDEX";
+	exports[3756] = "ER_FUNCTIONAL_INDEX_PRIMARY_KEY";
+	exports[3757] = "ER_FUNCTIONAL_INDEX_ON_LOB";
+	exports[3758] = "ER_FUNCTIONAL_INDEX_FUNCTION_IS_NOT_ALLOWED";
+	exports[3759] = "ER_FULLTEXT_FUNCTIONAL_INDEX";
+	exports[3760] = "ER_SPATIAL_FUNCTIONAL_INDEX";
+	exports[3761] = "ER_WRONG_KEY_COLUMN_FUNCTIONAL_INDEX";
+	exports[3762] = "ER_FUNCTIONAL_INDEX_ON_FIELD";
+	exports[3763] = "ER_GENERATED_COLUMN_NAMED_FUNCTION_IS_NOT_ALLOWED";
+	exports[3764] = "ER_GENERATED_COLUMN_ROW_VALUE";
+	exports[3765] = "ER_GENERATED_COLUMN_VARIABLES";
+	exports[3766] = "ER_DEPENDENT_BY_DEFAULT_GENERATED_VALUE";
+	exports[3767] = "ER_DEFAULT_VAL_GENERATED_NON_PRIOR";
+	exports[3768] = "ER_DEFAULT_VAL_GENERATED_REF_AUTO_INC";
+	exports[3769] = "ER_DEFAULT_VAL_GENERATED_FUNCTION_IS_NOT_ALLOWED";
+	exports[3770] = "ER_DEFAULT_VAL_GENERATED_NAMED_FUNCTION_IS_NOT_ALLOWED";
+	exports[3771] = "ER_DEFAULT_VAL_GENERATED_ROW_VALUE";
+	exports[3772] = "ER_DEFAULT_VAL_GENERATED_VARIABLES";
+	exports[3773] = "ER_DEFAULT_AS_VAL_GENERATED";
+	exports[3774] = "ER_UNSUPPORTED_ACTION_ON_DEFAULT_VAL_GENERATED";
+	exports[3775] = "ER_GTID_UNSAFE_ALTER_ADD_COL_WITH_DEFAULT_EXPRESSION";
+	exports[3776] = "ER_FK_CANNOT_CHANGE_ENGINE";
+	exports[3777] = "ER_WARN_DEPRECATED_USER_SET_EXPR";
+	exports[3778] = "ER_WARN_DEPRECATED_UTF8MB3_COLLATION";
+	exports[3779] = "ER_WARN_DEPRECATED_NESTED_COMMENT_SYNTAX";
+	exports[3780] = "ER_FK_INCOMPATIBLE_COLUMNS";
+	exports[3781] = "ER_GR_HOLD_WAIT_TIMEOUT";
+	exports[3782] = "ER_GR_HOLD_KILLED";
+	exports[3783] = "ER_GR_HOLD_MEMBER_STATUS_ERROR";
+	exports[3784] = "ER_RPL_ENCRYPTION_FAILED_TO_FETCH_KEY";
+	exports[3785] = "ER_RPL_ENCRYPTION_KEY_NOT_FOUND";
+	exports[3786] = "ER_RPL_ENCRYPTION_KEYRING_INVALID_KEY";
+	exports[3787] = "ER_RPL_ENCRYPTION_HEADER_ERROR";
+	exports[3788] = "ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS";
+	exports[3789] = "ER_RPL_ENCRYPTION_KEY_EXISTS_UNEXPECTED";
+	exports[3790] = "ER_RPL_ENCRYPTION_FAILED_TO_GENERATE_KEY";
+	exports[3791] = "ER_RPL_ENCRYPTION_FAILED_TO_STORE_KEY";
+	exports[3792] = "ER_RPL_ENCRYPTION_FAILED_TO_REMOVE_KEY";
+	exports[3793] = "ER_RPL_ENCRYPTION_UNABLE_TO_CHANGE_OPTION";
+	exports[3794] = "ER_RPL_ENCRYPTION_MASTER_KEY_RECOVERY_FAILED";
+	exports[3795] = "ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE";
+	exports[3796] = "ER_GRP_TRX_CONSISTENCY_NOT_ALLOWED";
+	exports[3797] = "ER_GRP_TRX_CONSISTENCY_BEFORE";
+	exports[3798] = "ER_GRP_TRX_CONSISTENCY_AFTER_ON_TRX_BEGIN";
+	exports[3799] = "ER_GRP_TRX_CONSISTENCY_BEGIN_NOT_ALLOWED";
+	exports[3800] = "ER_FUNCTIONAL_INDEX_ROW_VALUE_IS_NOT_ALLOWED";
+	exports[3801] = "ER_RPL_ENCRYPTION_FAILED_TO_ENCRYPT";
+	exports[3802] = "ER_PAGE_TRACKING_NOT_STARTED";
+	exports[3803] = "ER_PAGE_TRACKING_RANGE_NOT_TRACKED";
+	exports[3804] = "ER_PAGE_TRACKING_CANNOT_PURGE";
+	exports[3805] = "ER_RPL_ENCRYPTION_CANNOT_ROTATE_BINLOG_MASTER_KEY";
+	exports[3806] = "ER_BINLOG_MASTER_KEY_RECOVERY_OUT_OF_COMBINATION";
+	exports[3807] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_OPERATE_KEY";
+	exports[3808] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_ROTATE_LOGS";
+	exports[3809] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_REENCRYPT_LOG";
+	exports[3810] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_UNUSED_KEYS";
+	exports[3811] = "ER_BINLOG_MASTER_KEY_ROTATION_FAIL_TO_CLEANUP_AUX_KEY";
+	exports[3812] = "ER_NON_BOOLEAN_EXPR_FOR_CHECK_CONSTRAINT";
+	exports[3813] = "ER_COLUMN_CHECK_CONSTRAINT_REFERENCES_OTHER_COLUMN";
+	exports[3814] = "ER_CHECK_CONSTRAINT_NAMED_FUNCTION_IS_NOT_ALLOWED";
+	exports[3815] = "ER_CHECK_CONSTRAINT_FUNCTION_IS_NOT_ALLOWED";
+	exports[3816] = "ER_CHECK_CONSTRAINT_VARIABLES";
+	exports[3817] = "ER_CHECK_CONSTRAINT_ROW_VALUE";
+	exports[3818] = "ER_CHECK_CONSTRAINT_REFERS_AUTO_INCREMENT_COLUMN";
+	exports[3819] = "ER_CHECK_CONSTRAINT_VIOLATED";
+	exports[3820] = "ER_CHECK_CONSTRAINT_REFERS_UNKNOWN_COLUMN";
+	exports[3821] = "ER_CHECK_CONSTRAINT_NOT_FOUND";
+	exports[3822] = "ER_CHECK_CONSTRAINT_DUP_NAME";
+	exports[3823] = "ER_CHECK_CONSTRAINT_CLAUSE_USING_FK_REFER_ACTION_COLUMN";
+	exports[3824] = "WARN_UNENCRYPTED_TABLE_IN_ENCRYPTED_DB";
+	exports[3825] = "ER_INVALID_ENCRYPTION_REQUEST";
+	exports[3826] = "ER_CANNOT_SET_TABLE_ENCRYPTION";
+	exports[3827] = "ER_CANNOT_SET_DATABASE_ENCRYPTION";
+	exports[3828] = "ER_CANNOT_SET_TABLESPACE_ENCRYPTION";
+	exports[3829] = "ER_TABLESPACE_CANNOT_BE_ENCRYPTED";
+	exports[3830] = "ER_TABLESPACE_CANNOT_BE_DECRYPTED";
+	exports[3831] = "ER_TABLESPACE_TYPE_UNKNOWN";
+	exports[3832] = "ER_TARGET_TABLESPACE_UNENCRYPTED";
+	exports[3833] = "ER_CANNOT_USE_ENCRYPTION_CLAUSE";
+	exports[3834] = "ER_INVALID_MULTIPLE_CLAUSES";
+	exports[3835] = "ER_UNSUPPORTED_USE_OF_GRANT_AS";
+	exports[3836] = "ER_UKNOWN_AUTH_ID_OR_ACCESS_DENIED_FOR_GRANT_AS";
+	exports[3837] = "ER_DEPENDENT_BY_FUNCTIONAL_INDEX";
+	exports[3838] = "ER_PLUGIN_NOT_EARLY";
+	exports[3839] = "ER_INNODB_REDO_LOG_ARCHIVE_START_SUBDIR_PATH";
+	exports[3840] = "ER_INNODB_REDO_LOG_ARCHIVE_START_TIMEOUT";
+	exports[3841] = "ER_INNODB_REDO_LOG_ARCHIVE_DIRS_INVALID";
+	exports[3842] = "ER_INNODB_REDO_LOG_ARCHIVE_LABEL_NOT_FOUND";
+	exports[3843] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_EMPTY";
+	exports[3844] = "ER_INNODB_REDO_LOG_ARCHIVE_NO_SUCH_DIR";
+	exports[3845] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_CLASH";
+	exports[3846] = "ER_INNODB_REDO_LOG_ARCHIVE_DIR_PERMISSIONS";
+	exports[3847] = "ER_INNODB_REDO_LOG_ARCHIVE_FILE_CREATE";
+	exports[3848] = "ER_INNODB_REDO_LOG_ARCHIVE_ACTIVE";
+	exports[3849] = "ER_INNODB_REDO_LOG_ARCHIVE_INACTIVE";
+	exports[3850] = "ER_INNODB_REDO_LOG_ARCHIVE_FAILED";
+	exports[3851] = "ER_INNODB_REDO_LOG_ARCHIVE_SESSION";
+	exports[3852] = "ER_STD_REGEX_ERROR";
+	exports[3853] = "ER_INVALID_JSON_TYPE";
+	exports[3854] = "ER_CANNOT_CONVERT_STRING";
+	exports[3855] = "ER_DEPENDENT_BY_PARTITION_FUNC";
+	exports[3856] = "ER_WARN_DEPRECATED_FLOAT_AUTO_INCREMENT";
+	exports[3857] = "ER_RPL_CANT_STOP_REPLICA_WHILE_LOCKED_BACKUP";
+	exports[3858] = "ER_WARN_DEPRECATED_FLOAT_DIGITS";
+	exports[3859] = "ER_WARN_DEPRECATED_FLOAT_UNSIGNED";
+	exports[3860] = "ER_WARN_DEPRECATED_INTEGER_DISPLAY_WIDTH";
+	exports[3861] = "ER_WARN_DEPRECATED_ZEROFILL";
+	exports[3862] = "ER_CLONE_DONOR";
+	exports[3863] = "ER_CLONE_PROTOCOL";
+	exports[3864] = "ER_CLONE_DONOR_VERSION";
+	exports[3865] = "ER_CLONE_OS";
+	exports[3866] = "ER_CLONE_PLATFORM";
+	exports[3867] = "ER_CLONE_CHARSET";
+	exports[3868] = "ER_CLONE_CONFIG";
+	exports[3869] = "ER_CLONE_SYS_CONFIG";
+	exports[3870] = "ER_CLONE_PLUGIN_MATCH";
+	exports[3871] = "ER_CLONE_LOOPBACK";
+	exports[3872] = "ER_CLONE_ENCRYPTION";
+	exports[3873] = "ER_CLONE_DISK_SPACE";
+	exports[3874] = "ER_CLONE_IN_PROGRESS";
+	exports[3875] = "ER_CLONE_DISALLOWED";
+	exports[3876] = "ER_CANNOT_GRANT_ROLES_TO_ANONYMOUS_USER";
+	exports[3877] = "ER_SECONDARY_ENGINE_PLUGIN";
+	exports[3878] = "ER_SECOND_PASSWORD_CANNOT_BE_EMPTY";
+	exports[3879] = "ER_DB_ACCESS_DENIED";
+	exports[3880] = "ER_DA_AUTH_ID_WITH_SYSTEM_USER_PRIV_IN_MANDATORY_ROLES";
+	exports[3881] = "ER_DA_RPL_GTID_TABLE_CANNOT_OPEN";
+	exports[3882] = "ER_GEOMETRY_IN_UNKNOWN_LENGTH_UNIT";
+	exports[3883] = "ER_DA_PLUGIN_INSTALL_ERROR";
+	exports[3884] = "ER_NO_SESSION_TEMP";
+	exports[3885] = "ER_DA_UNKNOWN_ERROR_NUMBER";
+	exports[3886] = "ER_COLUMN_CHANGE_SIZE";
+	exports[3887] = "ER_REGEXP_INVALID_CAPTURE_GROUP_NAME";
+	exports[3888] = "ER_DA_SSL_LIBRARY_ERROR";
+	exports[3889] = "ER_SECONDARY_ENGINE";
+	exports[3890] = "ER_SECONDARY_ENGINE_DDL";
+	exports[3891] = "ER_INCORRECT_CURRENT_PASSWORD";
+	exports[3892] = "ER_MISSING_CURRENT_PASSWORD";
+	exports[3893] = "ER_CURRENT_PASSWORD_NOT_REQUIRED";
+	exports[3894] = "ER_PASSWORD_CANNOT_BE_RETAINED_ON_PLUGIN_CHANGE";
+	exports[3895] = "ER_CURRENT_PASSWORD_CANNOT_BE_RETAINED";
+	exports[3896] = "ER_PARTIAL_REVOKES_EXIST";
+	exports[3897] = "ER_CANNOT_GRANT_SYSTEM_PRIV_TO_MANDATORY_ROLE";
+	exports[3898] = "ER_XA_REPLICATION_FILTERS";
+	exports[3899] = "ER_UNSUPPORTED_SQL_MODE";
+	exports[3900] = "ER_REGEXP_INVALID_FLAG";
+	exports[3901] = "ER_PARTIAL_REVOKE_AND_DB_GRANT_BOTH_EXISTS";
+	exports[3902] = "ER_UNIT_NOT_FOUND";
+	exports[3903] = "ER_INVALID_JSON_VALUE_FOR_FUNC_INDEX";
+	exports[3904] = "ER_JSON_VALUE_OUT_OF_RANGE_FOR_FUNC_INDEX";
+	exports[3905] = "ER_EXCEEDED_MV_KEYS_NUM";
+	exports[3906] = "ER_EXCEEDED_MV_KEYS_SPACE";
+	exports[3907] = "ER_FUNCTIONAL_INDEX_DATA_IS_TOO_LONG";
+	exports[3908] = "ER_WRONG_MVI_VALUE";
+	exports[3909] = "ER_WARN_FUNC_INDEX_NOT_APPLICABLE";
+	exports[3910] = "ER_GRP_RPL_UDF_ERROR";
+	exports[3911] = "ER_UPDATE_GTID_PURGED_WITH_GR";
+	exports[3912] = "ER_GROUPING_ON_TIMESTAMP_IN_DST";
+	exports[3913] = "ER_TABLE_NAME_CAUSES_TOO_LONG_PATH";
+	exports[3914] = "ER_AUDIT_LOG_INSUFFICIENT_PRIVILEGE";
+	exports[3915] = "ER_AUDIT_LOG_PASSWORD_HAS_BEEN_COPIED";
+	exports[3916] = "ER_DA_GRP_RPL_STARTED_AUTO_REJOIN";
+	exports[3917] = "ER_SYSVAR_CHANGE_DURING_QUERY";
+	exports[3918] = "ER_GLOBSTAT_CHANGE_DURING_QUERY";
+	exports[3919] = "ER_GRP_RPL_MESSAGE_SERVICE_INIT_FAILURE";
+	exports[3920] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_CLIENT";
+	exports[3921] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_LEVEL_CLIENT";
+	exports[3922] = "ER_WRONG_COMPRESSION_ALGORITHM_CLIENT";
+	exports[3923] = "ER_WRONG_COMPRESSION_LEVEL_CLIENT";
+	exports[3924] = "ER_CHANGE_SOURCE_WRONG_COMPRESSION_ALGORITHM_LIST_CLIENT";
+	exports[3925] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_CANNOT_BE_ANONYMOUS";
+	exports[3926] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_DOES_NOT_EXIST";
+	exports[3927] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_CORRUPT";
+	exports[3928] = "ER_CLIENT_PRIVILEGE_CHECKS_USER_NEEDS_RPL_APPLIER_PRIV";
+	exports[3929] = "ER_WARN_DA_PRIVILEGE_NOT_REGISTERED";
+	exports[3930] = "ER_CLIENT_KEYRING_UDF_KEY_INVALID";
+	exports[3931] = "ER_CLIENT_KEYRING_UDF_KEY_TYPE_INVALID";
+	exports[3932] = "ER_CLIENT_KEYRING_UDF_KEY_TOO_LONG";
+	exports[3933] = "ER_CLIENT_KEYRING_UDF_KEY_TYPE_TOO_LONG";
+	exports[3934] = "ER_JSON_SCHEMA_VALIDATION_ERROR_WITH_DETAILED_REPORT";
+	exports[3935] = "ER_DA_UDF_INVALID_CHARSET_SPECIFIED";
+	exports[3936] = "ER_DA_UDF_INVALID_CHARSET";
+	exports[3937] = "ER_DA_UDF_INVALID_COLLATION";
+	exports[3938] = "ER_DA_UDF_INVALID_EXTENSION_ARGUMENT_TYPE";
+	exports[3939] = "ER_MULTIPLE_CONSTRAINTS_WITH_SAME_NAME";
+	exports[3940] = "ER_CONSTRAINT_NOT_FOUND";
+	exports[3941] = "ER_ALTER_CONSTRAINT_ENFORCEMENT_NOT_SUPPORTED";
+	exports[3942] = "ER_TABLE_VALUE_CONSTRUCTOR_MUST_HAVE_COLUMNS";
+	exports[3943] = "ER_TABLE_VALUE_CONSTRUCTOR_CANNOT_HAVE_DEFAULT";
+	exports[3944] = "ER_CLIENT_QUERY_FAILURE_INVALID_NON_ROW_FORMAT";
+	exports[3945] = "ER_REQUIRE_ROW_FORMAT_INVALID_VALUE";
+	exports[3946] = "ER_FAILED_TO_DETERMINE_IF_ROLE_IS_MANDATORY";
+	exports[3947] = "ER_FAILED_TO_FETCH_MANDATORY_ROLE_LIST";
+	exports[3948] = "ER_CLIENT_LOCAL_FILES_DISABLED";
+	exports[3949] = "ER_IMP_INCOMPATIBLE_CFG_VERSION";
+	exports[3950] = "ER_DA_OOM";
+	exports[3951] = "ER_DA_UDF_INVALID_ARGUMENT_TO_SET_CHARSET";
+	exports[3952] = "ER_DA_UDF_INVALID_RETURN_TYPE_TO_SET_CHARSET";
+	exports[3953] = "ER_MULTIPLE_INTO_CLAUSES";
+	exports[3954] = "ER_MISPLACED_INTO";
+	exports[3955] = "ER_USER_ACCESS_DENIED_FOR_USER_ACCOUNT_BLOCKED_BY_PASSWORD_LOCK";
+	exports[3956] = "ER_WARN_DEPRECATED_YEAR_UNSIGNED";
+	exports[3957] = "ER_CLONE_NETWORK_PACKET";
+	exports[3958] = "ER_SDI_OPERATION_FAILED_MISSING_RECORD";
+	exports[3959] = "ER_DEPENDENT_BY_CHECK_CONSTRAINT";
+	exports[3960] = "ER_GRP_OPERATION_NOT_ALLOWED_GR_MUST_STOP";
+	exports[3961] = "ER_WARN_DEPRECATED_JSON_TABLE_ON_ERROR_ON_EMPTY";
+	exports[3962] = "ER_WARN_DEPRECATED_INNER_INTO";
+	exports[3963] = "ER_WARN_DEPRECATED_VALUES_FUNCTION_ALWAYS_NULL";
+	exports[3964] = "ER_WARN_DEPRECATED_SQL_CALC_FOUND_ROWS";
+	exports[3965] = "ER_WARN_DEPRECATED_FOUND_ROWS";
+	exports[3966] = "ER_MISSING_JSON_VALUE";
+	exports[3967] = "ER_MULTIPLE_JSON_VALUES";
+	exports[3968] = "ER_HOSTNAME_TOO_LONG";
+	exports[3969] = "ER_WARN_CLIENT_DEPRECATED_PARTITION_PREFIX_KEY";
+	exports[3970] = "ER_GROUP_REPLICATION_USER_EMPTY_MSG";
+	exports[3971] = "ER_GROUP_REPLICATION_USER_MANDATORY_MSG";
+	exports[3972] = "ER_GROUP_REPLICATION_PASSWORD_LENGTH";
+	exports[3973] = "ER_SUBQUERY_TRANSFORM_REJECTED";
+	exports[3974] = "ER_DA_GRP_RPL_RECOVERY_ENDPOINT_FORMAT";
+	exports[3975] = "ER_DA_GRP_RPL_RECOVERY_ENDPOINT_INVALID";
+	exports[3976] = "ER_WRONG_VALUE_FOR_VAR_PLUS_ACTIONABLE_PART";
+	exports[3977] = "ER_STATEMENT_NOT_ALLOWED_AFTER_START_TRANSACTION";
+	exports[3978] = "ER_FOREIGN_KEY_WITH_ATOMIC_CREATE_SELECT";
+	exports[3979] = "ER_NOT_ALLOWED_WITH_START_TRANSACTION";
+	exports[3980] = "ER_INVALID_JSON_ATTRIBUTE";
+	exports[3981] = "ER_ENGINE_ATTRIBUTE_NOT_SUPPORTED";
+	exports[3982] = "ER_INVALID_USER_ATTRIBUTE_JSON";
+	exports[3983] = "ER_INNODB_REDO_DISABLED";
+	exports[3984] = "ER_INNODB_REDO_ARCHIVING_ENABLED";
+	exports[3985] = "ER_MDL_OUT_OF_RESOURCES";
+	exports[3986] = "ER_IMPLICIT_COMPARISON_FOR_JSON";
+	exports[3987] = "ER_FUNCTION_DOES_NOT_SUPPORT_CHARACTER_SET";
+	exports[3988] = "ER_IMPOSSIBLE_STRING_CONVERSION";
+	exports[3989] = "ER_SCHEMA_READ_ONLY";
+	exports[3990] = "ER_RPL_ASYNC_RECONNECT_GTID_MODE_OFF";
+	exports[3991] = "ER_RPL_ASYNC_RECONNECT_AUTO_POSITION_OFF";
+	exports[3992] = "ER_DISABLE_GTID_MODE_REQUIRES_ASYNC_RECONNECT_OFF";
+	exports[3993] = "ER_DISABLE_AUTO_POSITION_REQUIRES_ASYNC_RECONNECT_OFF";
+	exports[3994] = "ER_INVALID_PARAMETER_USE";
+	exports[3995] = "ER_CHARACTER_SET_MISMATCH";
+	exports[3996] = "ER_WARN_VAR_VALUE_CHANGE_NOT_SUPPORTED";
+	exports[3997] = "ER_INVALID_TIME_ZONE_INTERVAL";
+	exports[3998] = "ER_INVALID_CAST";
+	exports[3999] = "ER_HYPERGRAPH_NOT_SUPPORTED_YET";
+	exports[4e3] = "ER_WARN_HYPERGRAPH_EXPERIMENTAL";
+	exports[4001] = "ER_DA_NO_ERROR_LOG_PARSER_CONFIGURED";
+	exports[4002] = "ER_DA_ERROR_LOG_TABLE_DISABLED";
+	exports[4003] = "ER_DA_ERROR_LOG_MULTIPLE_FILTERS";
+	exports[4004] = "ER_DA_CANT_OPEN_ERROR_LOG";
+	exports[4005] = "ER_USER_REFERENCED_AS_DEFINER";
+	exports[4006] = "ER_CANNOT_USER_REFERENCED_AS_DEFINER";
+	exports[4007] = "ER_REGEX_NUMBER_TOO_BIG";
+	exports[4008] = "ER_SPVAR_NONINTEGER_TYPE";
+	exports[4009] = "WARN_UNSUPPORTED_ACL_TABLES_READ";
+	exports[4010] = "ER_BINLOG_UNSAFE_ACL_TABLE_READ_IN_DML_DDL";
+	exports[4011] = "ER_STOP_REPLICA_MONITOR_IO_THREAD_TIMEOUT";
+	exports[4012] = "ER_STARTING_REPLICA_MONITOR_IO_THREAD";
+	exports[4013] = "ER_CANT_USE_ANONYMOUS_TO_GTID_WITH_GTID_MODE_NOT_ON";
+	exports[4014] = "ER_CANT_COMBINE_ANONYMOUS_TO_GTID_AND_AUTOPOSITION";
+	exports[4015] = "ER_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_REQUIRES_GTID_MODE_ON";
+	exports[4016] = "ER_SQL_REPLICA_SKIP_COUNTER_USED_WITH_GTID_MODE_ON";
+	exports[4017] = "ER_USING_ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_AS_LOCAL_OR_UUID";
+	exports[4018] = "ER_CANT_SET_ANONYMOUS_TO_GTID_AND_WAIT_UNTIL_SQL_THD_AFTER_GTIDS";
+	exports[4019] = "ER_CANT_SET_SQL_AFTER_OR_BEFORE_GTIDS_WITH_ANONYMOUS_TO_GTID";
+	exports[4020] = "ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_GROUP_NAME";
+	exports[4021] = "ER_CANT_USE_SAME_UUID_AS_GROUP_NAME";
+	exports[4022] = "ER_GRP_RPL_RECOVERY_CHANNEL_STILL_RUNNING";
+	exports[4023] = "ER_INNODB_INVALID_AUTOEXTEND_SIZE_VALUE";
+	exports[4024] = "ER_INNODB_INCOMPATIBLE_WITH_TABLESPACE";
+	exports[4025] = "ER_INNODB_AUTOEXTEND_SIZE_OUT_OF_RANGE";
+	exports[4026] = "ER_CANNOT_USE_AUTOEXTEND_SIZE_CLAUSE";
+	exports[4027] = "ER_ROLE_GRANTED_TO_ITSELF";
+	exports[4028] = "ER_TABLE_MUST_HAVE_A_VISIBLE_COLUMN";
+	exports[4029] = "ER_INNODB_COMPRESSION_FAILURE";
+	exports[4030] = "ER_WARN_ASYNC_CONN_FAILOVER_NETWORK_NAMESPACE";
+	exports[4031] = "ER_CLIENT_INTERACTION_TIMEOUT";
+	exports[4032] = "ER_INVALID_CAST_TO_GEOMETRY";
+	exports[4033] = "ER_INVALID_CAST_POLYGON_RING_DIRECTION";
+	exports[4034] = "ER_GIS_DIFFERENT_SRIDS_AGGREGATION";
+	exports[4035] = "ER_RELOAD_KEYRING_FAILURE";
+	exports[4036] = "ER_SDI_GET_KEYS_INVALID_TABLESPACE";
+	exports[4037] = "ER_CHANGE_RPL_SRC_WRONG_COMPRESSION_ALGORITHM_SIZE";
+	exports[4038] = "ER_WARN_DEPRECATED_TLS_VERSION_FOR_CHANNEL_CLI";
+	exports[4039] = "ER_CANT_USE_SAME_UUID_AS_VIEW_CHANGE_UUID";
+	exports[4040] = "ER_ANONYMOUS_TO_GTID_UUID_SAME_AS_VIEW_CHANGE_UUID";
+	exports[4041] = "ER_GRP_RPL_VIEW_CHANGE_UUID_FAIL_GET_VARIABLE";
+	exports[4042] = "ER_WARN_ADUIT_LOG_MAX_SIZE_AND_PRUNE_SECONDS";
+	exports[4043] = "ER_WARN_ADUIT_LOG_MAX_SIZE_CLOSE_TO_ROTATE_ON_SIZE";
+	exports[4044] = "ER_KERBEROS_CREATE_USER";
+	exports[4045] = "ER_INSTALL_PLUGIN_CONFLICT_CLIENT";
+	exports[4046] = "ER_DA_ERROR_LOG_COMPONENT_FLUSH_FAILED";
+	exports[4047] = "ER_WARN_SQL_AFTER_MTS_GAPS_GAP_NOT_CALCULATED";
+	exports[4048] = "ER_INVALID_ASSIGNMENT_TARGET";
+	exports[4049] = "ER_OPERATION_NOT_ALLOWED_ON_GR_SECONDARY";
+	exports[4050] = "ER_GRP_RPL_FAILOVER_CHANNEL_STATUS_PROPAGATION";
+	exports[4051] = "ER_WARN_AUDIT_LOG_FORMAT_UNIX_TIMESTAMP_ONLY_WHEN_JSON";
+	exports[4052] = "ER_INVALID_MFA_PLUGIN_SPECIFIED";
+	exports[4053] = "ER_IDENTIFIED_BY_UNSUPPORTED";
+	exports[4054] = "ER_INVALID_PLUGIN_FOR_REGISTRATION";
+	exports[4055] = "ER_PLUGIN_REQUIRES_REGISTRATION";
+	exports[4056] = "ER_MFA_METHOD_EXISTS";
+	exports[4057] = "ER_MFA_METHOD_NOT_EXISTS";
+	exports[4058] = "ER_AUTHENTICATION_POLICY_MISMATCH";
+	exports[4059] = "ER_PLUGIN_REGISTRATION_DONE";
+	exports[4060] = "ER_INVALID_USER_FOR_REGISTRATION";
+	exports[4061] = "ER_USER_REGISTRATION_FAILED";
+	exports[4062] = "ER_MFA_METHODS_INVALID_ORDER";
+	exports[4063] = "ER_MFA_METHODS_IDENTICAL";
+	exports[4064] = "ER_INVALID_MFA_OPERATIONS_FOR_PASSWORDLESS_USER";
+	exports[4065] = "ER_CHANGE_REPLICATION_SOURCE_NO_OPTIONS_FOR_GTID_ONLY";
+	exports[4066] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_REQ_ROW_FORMAT_WITH_GTID_ONLY";
+	exports[4067] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POSITION_WITH_GTID_ONLY";
+	exports[4068] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_GTID_ONLY_WITHOUT_POSITIONS";
+	exports[4069] = "ER_CHANGE_REP_SOURCE_CANT_DISABLE_AUTO_POS_WITHOUT_POSITIONS";
+	exports[4070] = "ER_CHANGE_REP_SOURCE_GR_CHANNEL_WITH_GTID_MODE_NOT_ON";
+	exports[4071] = "ER_CANT_USE_GTID_ONLY_WITH_GTID_MODE_NOT_ON";
+	exports[4072] = "ER_WARN_C_DISABLE_GTID_ONLY_WITH_SOURCE_AUTO_POS_INVALID_POS";
+	exports[4073] = "ER_DA_SSL_FIPS_MODE_ERROR";
+	exports[4074] = "ER_VALUE_OUT_OF_RANGE";
+	exports[4075] = "ER_FULLTEXT_WITH_ROLLUP";
+	exports[4076] = "ER_REGEXP_MISSING_RESOURCE";
+	exports[4077] = "ER_WARN_REGEXP_USING_DEFAULT";
+	exports[4078] = "ER_REGEXP_MISSING_FILE";
+	exports[4079] = "ER_WARN_DEPRECATED_COLLATION";
+	exports[4080] = "ER_CONCURRENT_PROCEDURE_USAGE";
+	exports[4081] = "ER_DA_GLOBAL_CONN_LIMIT";
+	exports[4082] = "ER_DA_CONN_LIMIT";
+	exports[4083] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE_INSTANT";
+	exports[4084] = "ER_WARN_SF_UDF_NAME_COLLISION";
+	exports[4085] = "ER_CANNOT_PURGE_BINLOG_WITH_BACKUP_LOCK";
+	exports[4086] = "ER_TOO_MANY_WINDOWS";
+	exports[4087] = "ER_MYSQLBACKUP_CLIENT_MSG";
+	exports[4088] = "ER_COMMENT_CONTAINS_INVALID_STRING";
+	exports[4089] = "ER_DEFINITION_CONTAINS_INVALID_STRING";
+	exports[4090] = "ER_CANT_EXECUTE_COMMAND_WITH_ASSIGNED_GTID_NEXT";
+	exports[4091] = "ER_XA_TEMP_TABLE";
+	exports[4092] = "ER_INNODB_MAX_ROW_VERSION";
+	exports[4093] = "ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_SIZE";
+	exports[4094] = "ER_OPERATION_NOT_ALLOWED_WHILE_PRIMARY_CHANGE_IS_RUNNING";
+	exports[4095] = "ER_WARN_DEPRECATED_DATETIME_DELIMITER";
+	exports[4096] = "ER_WARN_DEPRECATED_SUPERFLUOUS_DELIMITER";
+	exports[4097] = "ER_CANNOT_PERSIST_SENSITIVE_VARIABLES";
+	exports[4098] = "ER_WARN_CANNOT_SECURELY_PERSIST_SENSITIVE_VARIABLES";
+	exports[4099] = "ER_WARN_TRG_ALREADY_EXISTS";
+	exports[4100] = "ER_IF_NOT_EXISTS_UNSUPPORTED_TRG_EXISTS_ON_DIFFERENT_TABLE";
+	exports[4101] = "ER_IF_NOT_EXISTS_UNSUPPORTED_UDF_NATIVE_FCT_NAME_COLLISION";
+	exports[4102] = "ER_SET_PASSWORD_AUTH_PLUGIN_ERROR";
+	exports[4103] = "ER_REDUCED_DBLWR_FILE_CORRUPTED";
+	exports[4104] = "ER_REDUCED_DBLWR_PAGE_FOUND";
+	exports[4105] = "ER_SRS_INVALID_LATITUDE_OF_ORIGIN";
+	exports[4106] = "ER_SRS_INVALID_LONGITUDE_OF_ORIGIN";
+	exports[4107] = "ER_SRS_UNUSED_PROJ_PARAMETER_PRESENT";
+	exports[4108] = "ER_GIPK_COLUMN_EXISTS";
+	exports[4109] = "ER_GIPK_FAILED_AUTOINC_COLUMN_EXISTS";
+	exports[4110] = "ER_GIPK_COLUMN_ALTER_NOT_ALLOWED";
+	exports[4111] = "ER_DROP_PK_COLUMN_TO_DROP_GIPK";
+	exports[4112] = "ER_CREATE_SELECT_WITH_GIPK_DISALLOWED_IN_SBR";
+	exports[4113] = "ER_DA_EXPIRE_LOGS_DAYS_IGNORED";
+	exports[4114] = "ER_CTE_RECURSIVE_NOT_UNION";
+	exports[4115] = "ER_COMMAND_BACKEND_FAILED_TO_FETCH_SECURITY_CTX";
+	exports[4116] = "ER_COMMAND_SERVICE_BACKEND_FAILED";
+	exports[4117] = "ER_CLIENT_FILE_PRIVILEGE_FOR_REPLICATION_CHECKS";
+	exports[4118] = "ER_GROUP_REPLICATION_FORCE_MEMBERS_COMMAND_FAILURE";
+	exports[4119] = "ER_WARN_DEPRECATED_IDENT";
+	exports[4120] = "ER_INTERSECT_ALL_MAX_DUPLICATES_EXCEEDED";
+	exports[4121] = "ER_TP_QUERY_THRS_PER_GRP_EXCEEDS_TXN_THR_LIMIT";
+	exports[4122] = "ER_BAD_TIMESTAMP_FORMAT";
+	exports[4123] = "ER_SHAPE_PRIDICTION_UDF";
+	exports[4124] = "ER_SRS_INVALID_HEIGHT";
+	exports[4125] = "ER_SRS_INVALID_SCALING";
+	exports[4126] = "ER_SRS_INVALID_ZONE_WIDTH";
+	exports[4127] = "ER_SRS_INVALID_LATITUDE_POLAR_STERE_VAR_A";
+	exports[4128] = "ER_WARN_DEPRECATED_CLIENT_NO_SCHEMA_OPTION";
+	exports[4129] = "ER_TABLE_NOT_EMPTY";
+	exports[4130] = "ER_TABLE_NO_PRIMARY_KEY";
+	exports[4131] = "ER_TABLE_IN_SHARED_TABLESPACE";
+	exports[4132] = "ER_INDEX_OTHER_THAN_PK";
+	exports[4133] = "ER_LOAD_BULK_DATA_UNSORTED";
+	exports[4134] = "ER_BULK_EXECUTOR_ERROR";
+	exports[4135] = "ER_BULK_READER_LIBCURL_INIT_FAILED";
+	exports[4136] = "ER_BULK_READER_LIBCURL_ERROR";
+	exports[4137] = "ER_BULK_READER_SERVER_ERROR";
+	exports[4138] = "ER_BULK_READER_COMMUNICATION_ERROR";
+	exports[4139] = "ER_BULK_LOAD_DATA_FAILED";
+	exports[4140] = "ER_BULK_LOADER_COLUMN_TOO_BIG_FOR_LEFTOVER_BUFFER";
+	exports[4141] = "ER_BULK_LOADER_COMPONENT_ERROR";
+	exports[4142] = "ER_BULK_LOADER_FILE_CONTAINS_LESS_LINES_THAN_IGNORE_CLAUSE";
+	exports[4143] = "ER_BULK_PARSER_MISSING_ENCLOSED_BY";
+	exports[4144] = "ER_BULK_PARSER_ROW_BUFFER_MAX_TOTAL_COLS_EXCEEDED";
+	exports[4145] = "ER_BULK_PARSER_COPY_BUFFER_SIZE_EXCEEDED";
+	exports[4146] = "ER_BULK_PARSER_UNEXPECTED_END_OF_INPUT";
+	exports[4147] = "ER_BULK_PARSER_UNEXPECTED_ROW_TERMINATOR";
+	exports[4148] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_ENDING_ENCLOSED_BY";
+	exports[4149] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_NULL_ESCAPE";
+	exports[4150] = "ER_BULK_PARSER_UNEXPECTED_CHAR_AFTER_COLUMN_TERMINATOR";
+	exports[4151] = "ER_BULK_PARSER_INCOMPLETE_ESCAPE_SEQUENCE";
+	exports[4152] = "ER_LOAD_BULK_DATA_FAILED";
+	exports[4153] = "ER_LOAD_BULK_DATA_WRONG_VALUE_FOR_FIELD";
+	exports[4154] = "ER_LOAD_BULK_DATA_WARN_NULL_TO_NOTNULL";
+	exports[4155] = "ER_REQUIRE_TABLE_PRIMARY_KEY_CHECK_GENERATE_WITH_GR";
+	exports[4156] = "ER_CANT_CHANGE_SYS_VAR_IN_READ_ONLY_MODE";
+	exports[4157] = "ER_INNODB_INSTANT_ADD_DROP_NOT_SUPPORTED_MAX_SIZE";
+	exports[4158] = "ER_INNODB_INSTANT_ADD_NOT_SUPPORTED_MAX_FIELDS";
+	exports[4159] = "ER_CANT_SET_PERSISTED";
+	exports[4160] = "ER_INSTALL_COMPONENT_SET_NULL_VALUE";
+	exports[4161] = "ER_INSTALL_COMPONENT_SET_UNUSED_VALUE";
+	exports[4162] = "ER_WARN_DEPRECATED_USER_DEFINED_COLLATIONS";
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/long@5.3.2/node_modules/long/umd/index.js
+var require_umd = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/long@5.3.2/node_modules/long/umd/index.js": ((exports, module) => {
+	(function(global, factory) {
+		function preferDefault(exports$1) {
+			return exports$1.default || exports$1;
+		}
+		if (typeof define === "function" && define.amd) define([], function() {
+			var exports$1 = {};
+			factory(exports$1);
+			return preferDefault(exports$1);
+		});
+		else if (typeof exports === "object") {
+			factory(exports);
+			if (typeof module === "object") module.exports = preferDefault(exports);
+		} else (function() {
+			var exports$1 = {};
+			factory(exports$1);
+			global.Long = preferDefault(exports$1);
+		})();
+	})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports, function(_exports) {
+		Object.defineProperty(_exports, "__esModule", { value: true });
+		_exports.default = void 0;
+		/**
+		* @license
+		* Copyright 2009 The Closure Library Authors
+		* Copyright 2020 Daniel Wirtz / The long.js Authors.
+		*
+		* Licensed under the Apache License, Version 2.0 (the "License");
+		* you may not use this file except in compliance with the License.
+		* You may obtain a copy of the License at
+		*
+		*     http://www.apache.org/licenses/LICENSE-2.0
+		*
+		* Unless required by applicable law or agreed to in writing, software
+		* distributed under the License is distributed on an "AS IS" BASIS,
+		* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+		* See the License for the specific language governing permissions and
+		* limitations under the License.
+		*
+		* SPDX-License-Identifier: Apache-2.0
+		*/
+		var wasm = null;
+		try {
+			wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
+				0,
+				97,
+				115,
+				109,
+				1,
+				0,
+				0,
+				0,
+				1,
+				13,
+				2,
+				96,
+				0,
+				1,
+				127,
+				96,
+				4,
+				127,
+				127,
+				127,
+				127,
+				1,
+				127,
+				3,
+				7,
+				6,
+				0,
+				1,
+				1,
+				1,
+				1,
+				1,
+				6,
+				6,
+				1,
+				127,
+				1,
+				65,
+				0,
+				11,
+				7,
+				50,
+				6,
+				3,
+				109,
+				117,
+				108,
+				0,
+				1,
+				5,
+				100,
+				105,
+				118,
+				95,
+				115,
+				0,
+				2,
+				5,
+				100,
+				105,
+				118,
+				95,
+				117,
+				0,
+				3,
+				5,
+				114,
+				101,
+				109,
+				95,
+				115,
+				0,
+				4,
+				5,
+				114,
+				101,
+				109,
+				95,
+				117,
+				0,
+				5,
+				8,
+				103,
+				101,
+				116,
+				95,
+				104,
+				105,
+				103,
+				104,
+				0,
+				0,
+				10,
+				191,
+				1,
+				6,
+				4,
+				0,
+				35,
+				0,
+				11,
+				36,
+				1,
+				1,
+				126,
+				32,
+				0,
+				173,
+				32,
+				1,
+				173,
+				66,
+				32,
+				134,
+				132,
+				32,
+				2,
+				173,
+				32,
+				3,
+				173,
+				66,
+				32,
+				134,
+				132,
+				126,
+				34,
+				4,
+				66,
+				32,
+				135,
+				167,
+				36,
+				0,
+				32,
+				4,
+				167,
+				11,
+				36,
+				1,
+				1,
+				126,
+				32,
+				0,
+				173,
+				32,
+				1,
+				173,
+				66,
+				32,
+				134,
+				132,
+				32,
+				2,
+				173,
+				32,
+				3,
+				173,
+				66,
+				32,
+				134,
+				132,
+				127,
+				34,
+				4,
+				66,
+				32,
+				135,
+				167,
+				36,
+				0,
+				32,
+				4,
+				167,
+				11,
+				36,
+				1,
+				1,
+				126,
+				32,
+				0,
+				173,
+				32,
+				1,
+				173,
+				66,
+				32,
+				134,
+				132,
+				32,
+				2,
+				173,
+				32,
+				3,
+				173,
+				66,
+				32,
+				134,
+				132,
+				128,
+				34,
+				4,
+				66,
+				32,
+				135,
+				167,
+				36,
+				0,
+				32,
+				4,
+				167,
+				11,
+				36,
+				1,
+				1,
+				126,
+				32,
+				0,
+				173,
+				32,
+				1,
+				173,
+				66,
+				32,
+				134,
+				132,
+				32,
+				2,
+				173,
+				32,
+				3,
+				173,
+				66,
+				32,
+				134,
+				132,
+				129,
+				34,
+				4,
+				66,
+				32,
+				135,
+				167,
+				36,
+				0,
+				32,
+				4,
+				167,
+				11,
+				36,
+				1,
+				1,
+				126,
+				32,
+				0,
+				173,
+				32,
+				1,
+				173,
+				66,
+				32,
+				134,
+				132,
+				32,
+				2,
+				173,
+				32,
+				3,
+				173,
+				66,
+				32,
+				134,
+				132,
+				130,
+				34,
+				4,
+				66,
+				32,
+				135,
+				167,
+				36,
+				0,
+				32,
+				4,
+				167,
+				11
+			])), {}).exports;
+		} catch {}
+		/**
+		* Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
+		*  See the from* functions below for more convenient ways of constructing Longs.
+		* @exports Long
+		* @class A Long class for representing a 64 bit two's-complement integer value.
+		* @param {number} low The low (signed) 32 bits of the long
+		* @param {number} high The high (signed) 32 bits of the long
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @constructor
+		*/
+		function Long$1(low, high, unsigned) {
+			/**
+			* The low 32 bits as a signed value.
+			* @type {number}
+			*/
+			this.low = low | 0;
+			/**
+			* The high 32 bits as a signed value.
+			* @type {number}
+			*/
+			this.high = high | 0;
+			/**
+			* Whether unsigned or not.
+			* @type {boolean}
+			*/
+			this.unsigned = !!unsigned;
+		}
+		/**
+		* An indicator used to reliably determine if an object is a Long or not.
+		* @type {boolean}
+		* @const
+		* @private
+		*/
+		Long$1.prototype.__isLong__;
+		Object.defineProperty(Long$1.prototype, "__isLong__", { value: true });
+		/**
+		* @function
+		* @param {*} obj Object
+		* @returns {boolean}
+		* @inner
+		*/
+		function isLong(obj) {
+			return (obj && obj["__isLong__"]) === true;
+		}
+		/**
+		* @function
+		* @param {*} value number
+		* @returns {number}
+		* @inner
+		*/
+		function ctz32(value) {
+			var c = Math.clz32(value & -value);
+			return value ? 31 - c : c;
+		}
+		/**
+		* Tests if the specified object is a Long.
+		* @function
+		* @param {*} obj Object
+		* @returns {boolean}
+		*/
+		Long$1.isLong = isLong;
+		/**
+		* A cache of the Long representations of small integer values.
+		* @type {!Object}
+		* @inner
+		*/
+		var INT_CACHE = {};
+		/**
+		* A cache of the Long representations of small unsigned integer values.
+		* @type {!Object}
+		* @inner
+		*/
+		var UINT_CACHE = {};
+		/**
+		* @param {number} value
+		* @param {boolean=} unsigned
+		* @returns {!Long}
+		* @inner
+		*/
+		function fromInt(value, unsigned) {
+			var obj, cachedObj, cache;
+			if (unsigned) {
+				value >>>= 0;
+				if (cache = 0 <= value && value < 256) {
+					cachedObj = UINT_CACHE[value];
+					if (cachedObj) return cachedObj;
+				}
+				obj = fromBits(value, 0, true);
+				if (cache) UINT_CACHE[value] = obj;
+				return obj;
+			} else {
+				value |= 0;
+				if (cache = -128 <= value && value < 128) {
+					cachedObj = INT_CACHE[value];
+					if (cachedObj) return cachedObj;
+				}
+				obj = fromBits(value, value < 0 ? -1 : 0, false);
+				if (cache) INT_CACHE[value] = obj;
+				return obj;
+			}
+		}
+		/**
+		* Returns a Long representing the given 32 bit integer value.
+		* @function
+		* @param {number} value The 32 bit integer in question
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @returns {!Long} The corresponding Long value
+		*/
+		Long$1.fromInt = fromInt;
+		/**
+		* @param {number} value
+		* @param {boolean=} unsigned
+		* @returns {!Long}
+		* @inner
+		*/
+		function fromNumber(value, unsigned) {
+			if (isNaN(value)) return unsigned ? UZERO : ZERO;
+			if (unsigned) {
+				if (value < 0) return UZERO;
+				if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
+			} else {
+				if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
+				if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
+			}
+			if (value < 0) return fromNumber(-value, unsigned).neg();
+			return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
+		}
+		/**
+		* Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
+		* @function
+		* @param {number} value The number in question
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @returns {!Long} The corresponding Long value
+		*/
+		Long$1.fromNumber = fromNumber;
+		/**
+		* @param {number} lowBits
+		* @param {number} highBits
+		* @param {boolean=} unsigned
+		* @returns {!Long}
+		* @inner
+		*/
+		function fromBits(lowBits, highBits, unsigned) {
+			return new Long$1(lowBits, highBits, unsigned);
+		}
+		/**
+		* Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
+		*  assumed to use 32 bits.
+		* @function
+		* @param {number} lowBits The low 32 bits
+		* @param {number} highBits The high 32 bits
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @returns {!Long} The corresponding Long value
+		*/
+		Long$1.fromBits = fromBits;
+		/**
+		* @function
+		* @param {number} base
+		* @param {number} exponent
+		* @returns {number}
+		* @inner
+		*/
+		var pow_dbl = Math.pow;
+		/**
+		* @param {string} str
+		* @param {(boolean|number)=} unsigned
+		* @param {number=} radix
+		* @returns {!Long}
+		* @inner
+		*/
+		function fromString(str, unsigned, radix) {
+			if (str.length === 0) throw Error("empty string");
+			if (typeof unsigned === "number") {
+				radix = unsigned;
+				unsigned = false;
+			} else unsigned = !!unsigned;
+			if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
+			radix = radix || 10;
+			if (radix < 2 || 36 < radix) throw RangeError("radix");
+			var p;
+			if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
+			else if (p === 0) return fromString(str.substring(1), unsigned, radix).neg();
+			var radixToPower = fromNumber(pow_dbl(radix, 8));
+			var result = ZERO;
+			for (var i$4 = 0; i$4 < str.length; i$4 += 8) {
+				var size = Math.min(8, str.length - i$4), value = parseInt(str.substring(i$4, i$4 + size), radix);
+				if (size < 8) {
+					var power = fromNumber(pow_dbl(radix, size));
+					result = result.mul(power).add(fromNumber(value));
+				} else {
+					result = result.mul(radixToPower);
+					result = result.add(fromNumber(value));
+				}
+			}
+			result.unsigned = unsigned;
+			return result;
+		}
+		/**
+		* Returns a Long representation of the given string, written using the specified radix.
+		* @function
+		* @param {string} str The textual representation of the Long
+		* @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
+		* @param {number=} radix The radix in which the text is written (2-36), defaults to 10
+		* @returns {!Long} The corresponding Long value
+		*/
+		Long$1.fromString = fromString;
+		/**
+		* @function
+		* @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
+		* @param {boolean=} unsigned
+		* @returns {!Long}
+		* @inner
+		*/
+		function fromValue(val, unsigned) {
+			if (typeof val === "number") return fromNumber(val, unsigned);
+			if (typeof val === "string") return fromString(val, unsigned);
+			return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
+		}
+		/**
+		* Converts the specified value to a Long using the appropriate from* function for its type.
+		* @function
+		* @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @returns {!Long}
+		*/
+		Long$1.fromValue = fromValue;
+		/**
+		* @type {number}
+		* @const
+		* @inner
+		*/
+		var TWO_PWR_16_DBL = 65536;
+		/**
+		* @type {number}
+		* @const
+		* @inner
+		*/
+		var TWO_PWR_24_DBL = 1 << 24;
+		/**
+		* @type {number}
+		* @const
+		* @inner
+		*/
+		var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
+		/**
+		* @type {number}
+		* @const
+		* @inner
+		*/
+		var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
+		/**
+		* @type {number}
+		* @const
+		* @inner
+		*/
+		var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
+		/**
+		* @type {!Long}
+		* @const
+		* @inner
+		*/
+		var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var ZERO = fromInt(0);
+		/**
+		* Signed zero.
+		* @type {!Long}
+		*/
+		Long$1.ZERO = ZERO;
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var UZERO = fromInt(0, true);
+		/**
+		* Unsigned zero.
+		* @type {!Long}
+		*/
+		Long$1.UZERO = UZERO;
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var ONE = fromInt(1);
+		/**
+		* Signed one.
+		* @type {!Long}
+		*/
+		Long$1.ONE = ONE;
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var UONE = fromInt(1, true);
+		/**
+		* Unsigned one.
+		* @type {!Long}
+		*/
+		Long$1.UONE = UONE;
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var NEG_ONE = fromInt(-1);
+		/**
+		* Signed negative one.
+		* @type {!Long}
+		*/
+		Long$1.NEG_ONE = NEG_ONE;
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var MAX_VALUE = fromBits(-1, 2147483647, false);
+		/**
+		* Maximum signed value.
+		* @type {!Long}
+		*/
+		Long$1.MAX_VALUE = MAX_VALUE;
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var MAX_UNSIGNED_VALUE = fromBits(-1, -1, true);
+		/**
+		* Maximum unsigned value.
+		* @type {!Long}
+		*/
+		Long$1.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
+		/**
+		* @type {!Long}
+		* @inner
+		*/
+		var MIN_VALUE = fromBits(0, -2147483648, false);
+		/**
+		* Minimum signed value.
+		* @type {!Long}
+		*/
+		Long$1.MIN_VALUE = MIN_VALUE;
+		/**
+		* @alias Long.prototype
+		* @inner
+		*/
+		var LongPrototype = Long$1.prototype;
+		/**
+		* Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
+		* @this {!Long}
+		* @returns {number}
+		*/
+		LongPrototype.toInt = function toInt() {
+			return this.unsigned ? this.low >>> 0 : this.low;
+		};
+		/**
+		* Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
+		* @this {!Long}
+		* @returns {number}
+		*/
+		LongPrototype.toNumber = function toNumber() {
+			if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
+			return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
+		};
+		/**
+		* Converts the Long to a string written in the specified radix.
+		* @this {!Long}
+		* @param {number=} radix Radix (2-36), defaults to 10
+		* @returns {string}
+		* @override
+		* @throws {RangeError} If `radix` is out of range
+		*/
+		LongPrototype.toString = function toString(radix) {
+			radix = radix || 10;
+			if (radix < 2 || 36 < radix) throw RangeError("radix");
+			if (this.isZero()) return "0";
+			if (this.isNegative()) if (this.eq(MIN_VALUE)) {
+				var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
+				return div.toString(radix) + rem1.toInt().toString(radix);
+			} else return "-" + this.neg().toString(radix);
+			var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
+			var result = "";
+			while (true) {
+				var remDiv = rem.div(radixToPower), digits = (rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0).toString(radix);
+				rem = remDiv;
+				if (rem.isZero()) return digits + result;
+				else {
+					while (digits.length < 6) digits = "0" + digits;
+					result = "" + digits + result;
+				}
+			}
+		};
+		/**
+		* Gets the high 32 bits as a signed integer.
+		* @this {!Long}
+		* @returns {number} Signed high bits
+		*/
+		LongPrototype.getHighBits = function getHighBits() {
+			return this.high;
+		};
+		/**
+		* Gets the high 32 bits as an unsigned integer.
+		* @this {!Long}
+		* @returns {number} Unsigned high bits
+		*/
+		LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
+			return this.high >>> 0;
+		};
+		/**
+		* Gets the low 32 bits as a signed integer.
+		* @this {!Long}
+		* @returns {number} Signed low bits
+		*/
+		LongPrototype.getLowBits = function getLowBits() {
+			return this.low;
+		};
+		/**
+		* Gets the low 32 bits as an unsigned integer.
+		* @this {!Long}
+		* @returns {number} Unsigned low bits
+		*/
+		LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
+			return this.low >>> 0;
+		};
+		/**
+		* Gets the number of bits needed to represent the absolute value of this Long.
+		* @this {!Long}
+		* @returns {number}
+		*/
+		LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
+			if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
+			var val = this.high != 0 ? this.high : this.low;
+			for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
+			return this.high != 0 ? bit + 33 : bit + 1;
+		};
+		/**
+		* Tests if this Long can be safely represented as a JavaScript number.
+		* @this {!Long}
+		* @returns {boolean}
+		*/
+		LongPrototype.isSafeInteger = function isSafeInteger() {
+			var top11Bits = this.high >> 21;
+			if (!top11Bits) return true;
+			if (this.unsigned) return false;
+			return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
+		};
+		/**
+		* Tests if this Long's value equals zero.
+		* @this {!Long}
+		* @returns {boolean}
+		*/
+		LongPrototype.isZero = function isZero() {
+			return this.high === 0 && this.low === 0;
+		};
+		/**
+		* Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
+		* @returns {boolean}
+		*/
+		LongPrototype.eqz = LongPrototype.isZero;
+		/**
+		* Tests if this Long's value is negative.
+		* @this {!Long}
+		* @returns {boolean}
+		*/
+		LongPrototype.isNegative = function isNegative() {
+			return !this.unsigned && this.high < 0;
+		};
+		/**
+		* Tests if this Long's value is positive or zero.
+		* @this {!Long}
+		* @returns {boolean}
+		*/
+		LongPrototype.isPositive = function isPositive() {
+			return this.unsigned || this.high >= 0;
+		};
+		/**
+		* Tests if this Long's value is odd.
+		* @this {!Long}
+		* @returns {boolean}
+		*/
+		LongPrototype.isOdd = function isOdd() {
+			return (this.low & 1) === 1;
+		};
+		/**
+		* Tests if this Long's value is even.
+		* @this {!Long}
+		* @returns {boolean}
+		*/
+		LongPrototype.isEven = function isEven() {
+			return (this.low & 1) === 0;
+		};
+		/**
+		* Tests if this Long's value equals the specified's.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.equals = function equals(other) {
+			if (!isLong(other)) other = fromValue(other);
+			if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
+			return this.high === other.high && this.low === other.low;
+		};
+		/**
+		* Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.eq = LongPrototype.equals;
+		/**
+		* Tests if this Long's value differs from the specified's.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.notEquals = function notEquals(other) {
+			return !this.eq(other);
+		};
+		/**
+		* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.neq = LongPrototype.notEquals;
+		/**
+		* Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.ne = LongPrototype.notEquals;
+		/**
+		* Tests if this Long's value is less than the specified's.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.lessThan = function lessThan(other) {
+			return this.comp(other) < 0;
+		};
+		/**
+		* Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.lt = LongPrototype.lessThan;
+		/**
+		* Tests if this Long's value is less than or equal the specified's.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
+			return this.comp(other) <= 0;
+		};
+		/**
+		* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.lte = LongPrototype.lessThanOrEqual;
+		/**
+		* Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.le = LongPrototype.lessThanOrEqual;
+		/**
+		* Tests if this Long's value is greater than the specified's.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.greaterThan = function greaterThan(other) {
+			return this.comp(other) > 0;
+		};
+		/**
+		* Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.gt = LongPrototype.greaterThan;
+		/**
+		* Tests if this Long's value is greater than or equal the specified's.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
+			return this.comp(other) >= 0;
+		};
+		/**
+		* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.gte = LongPrototype.greaterThanOrEqual;
+		/**
+		* Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {boolean}
+		*/
+		LongPrototype.ge = LongPrototype.greaterThanOrEqual;
+		/**
+		* Compares this Long's value with the specified's.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {number} 0 if they are the same, 1 if the this is greater and -1
+		*  if the given one is greater
+		*/
+		LongPrototype.compare = function compare(other) {
+			if (!isLong(other)) other = fromValue(other);
+			if (this.eq(other)) return 0;
+			var thisNeg = this.isNegative(), otherNeg = other.isNegative();
+			if (thisNeg && !otherNeg) return -1;
+			if (!thisNeg && otherNeg) return 1;
+			if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
+			return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
+		};
+		/**
+		* Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
+		* @function
+		* @param {!Long|number|bigint|string} other Other value
+		* @returns {number} 0 if they are the same, 1 if the this is greater and -1
+		*  if the given one is greater
+		*/
+		LongPrototype.comp = LongPrototype.compare;
+		/**
+		* Negates this Long's value.
+		* @this {!Long}
+		* @returns {!Long} Negated Long
+		*/
+		LongPrototype.negate = function negate() {
+			if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
+			return this.not().add(ONE);
+		};
+		/**
+		* Negates this Long's value. This is an alias of {@link Long#negate}.
+		* @function
+		* @returns {!Long} Negated Long
+		*/
+		LongPrototype.neg = LongPrototype.negate;
+		/**
+		* Returns the sum of this and the specified Long.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} addend Addend
+		* @returns {!Long} Sum
+		*/
+		LongPrototype.add = function add(addend) {
+			if (!isLong(addend)) addend = fromValue(addend);
+			var a48 = this.high >>> 16;
+			var a32 = this.high & 65535;
+			var a16 = this.low >>> 16;
+			var a00 = this.low & 65535;
+			var b48 = addend.high >>> 16;
+			var b32 = addend.high & 65535;
+			var b16 = addend.low >>> 16;
+			var b00 = addend.low & 65535;
+			var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
+			c00 += a00 + b00;
+			c16 += c00 >>> 16;
+			c00 &= 65535;
+			c16 += a16 + b16;
+			c32 += c16 >>> 16;
+			c16 &= 65535;
+			c32 += a32 + b32;
+			c48 += c32 >>> 16;
+			c32 &= 65535;
+			c48 += a48 + b48;
+			c48 &= 65535;
+			return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
+		};
+		/**
+		* Returns the difference of this and the specified Long.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} subtrahend Subtrahend
+		* @returns {!Long} Difference
+		*/
+		LongPrototype.subtract = function subtract(subtrahend) {
+			if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
+			return this.add(subtrahend.neg());
+		};
+		/**
+		* Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
+		* @function
+		* @param {!Long|number|bigint|string} subtrahend Subtrahend
+		* @returns {!Long} Difference
+		*/
+		LongPrototype.sub = LongPrototype.subtract;
+		/**
+		* Returns the product of this and the specified Long.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} multiplier Multiplier
+		* @returns {!Long} Product
+		*/
+		LongPrototype.multiply = function multiply(multiplier) {
+			if (this.isZero()) return this;
+			if (!isLong(multiplier)) multiplier = fromValue(multiplier);
+			if (wasm) return fromBits(wasm["mul"](this.low, this.high, multiplier.low, multiplier.high), wasm["get_high"](), this.unsigned);
+			if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
+			if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
+			if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
+			if (this.isNegative()) if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
+			else return this.neg().mul(multiplier).neg();
+			else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
+			if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
+			var a48 = this.high >>> 16;
+			var a32 = this.high & 65535;
+			var a16 = this.low >>> 16;
+			var a00 = this.low & 65535;
+			var b48 = multiplier.high >>> 16;
+			var b32 = multiplier.high & 65535;
+			var b16 = multiplier.low >>> 16;
+			var b00 = multiplier.low & 65535;
+			var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
+			c00 += a00 * b00;
+			c16 += c00 >>> 16;
+			c00 &= 65535;
+			c16 += a16 * b00;
+			c32 += c16 >>> 16;
+			c16 &= 65535;
+			c16 += a00 * b16;
+			c32 += c16 >>> 16;
+			c16 &= 65535;
+			c32 += a32 * b00;
+			c48 += c32 >>> 16;
+			c32 &= 65535;
+			c32 += a16 * b16;
+			c48 += c32 >>> 16;
+			c32 &= 65535;
+			c32 += a00 * b32;
+			c48 += c32 >>> 16;
+			c32 &= 65535;
+			c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
+			c48 &= 65535;
+			return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
+		};
+		/**
+		* Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
+		* @function
+		* @param {!Long|number|bigint|string} multiplier Multiplier
+		* @returns {!Long} Product
+		*/
+		LongPrototype.mul = LongPrototype.multiply;
+		/**
+		* Returns this Long divided by the specified. The result is signed if this Long is signed or
+		*  unsigned if this Long is unsigned.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} divisor Divisor
+		* @returns {!Long} Quotient
+		*/
+		LongPrototype.divide = function divide(divisor) {
+			if (!isLong(divisor)) divisor = fromValue(divisor);
+			if (divisor.isZero()) throw Error("division by zero");
+			if (wasm) {
+				if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) return this;
+				return fromBits((this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high), wasm["get_high"](), this.unsigned);
+			}
+			if (this.isZero()) return this.unsigned ? UZERO : ZERO;
+			var approx, rem, res;
+			if (!this.unsigned) {
+				if (this.eq(MIN_VALUE)) if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
+				else if (divisor.eq(MIN_VALUE)) return ONE;
+				else {
+					approx = this.shr(1).div(divisor).shl(1);
+					if (approx.eq(ZERO)) return divisor.isNegative() ? ONE : NEG_ONE;
+					else {
+						rem = this.sub(divisor.mul(approx));
+						res = approx.add(rem.div(divisor));
+						return res;
+					}
+				}
+				else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
+				if (this.isNegative()) {
+					if (divisor.isNegative()) return this.neg().div(divisor.neg());
+					return this.neg().div(divisor).neg();
+				} else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
+				res = ZERO;
+			} else {
+				if (!divisor.unsigned) divisor = divisor.toUnsigned();
+				if (divisor.gt(this)) return UZERO;
+				if (divisor.gt(this.shru(1))) return UONE;
+				res = UZERO;
+			}
+			rem = this;
+			while (rem.gte(divisor)) {
+				approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
+				var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
+				while (approxRem.isNegative() || approxRem.gt(rem)) {
+					approx -= delta;
+					approxRes = fromNumber(approx, this.unsigned);
+					approxRem = approxRes.mul(divisor);
+				}
+				if (approxRes.isZero()) approxRes = ONE;
+				res = res.add(approxRes);
+				rem = rem.sub(approxRem);
+			}
+			return res;
+		};
+		/**
+		* Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
+		* @function
+		* @param {!Long|number|bigint|string} divisor Divisor
+		* @returns {!Long} Quotient
+		*/
+		LongPrototype.div = LongPrototype.divide;
+		/**
+		* Returns this Long modulo the specified.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} divisor Divisor
+		* @returns {!Long} Remainder
+		*/
+		LongPrototype.modulo = function modulo(divisor) {
+			if (!isLong(divisor)) divisor = fromValue(divisor);
+			if (wasm) return fromBits((this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high), wasm["get_high"](), this.unsigned);
+			return this.sub(this.div(divisor).mul(divisor));
+		};
+		/**
+		* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
+		* @function
+		* @param {!Long|number|bigint|string} divisor Divisor
+		* @returns {!Long} Remainder
+		*/
+		LongPrototype.mod = LongPrototype.modulo;
+		/**
+		* Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
+		* @function
+		* @param {!Long|number|bigint|string} divisor Divisor
+		* @returns {!Long} Remainder
+		*/
+		LongPrototype.rem = LongPrototype.modulo;
+		/**
+		* Returns the bitwise NOT of this Long.
+		* @this {!Long}
+		* @returns {!Long}
+		*/
+		LongPrototype.not = function not() {
+			return fromBits(~this.low, ~this.high, this.unsigned);
+		};
+		/**
+		* Returns count leading zeros of this Long.
+		* @this {!Long}
+		* @returns {!number}
+		*/
+		LongPrototype.countLeadingZeros = function countLeadingZeros() {
+			return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
+		};
+		/**
+		* Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
+		* @function
+		* @param {!Long}
+		* @returns {!number}
+		*/
+		LongPrototype.clz = LongPrototype.countLeadingZeros;
+		/**
+		* Returns count trailing zeros of this Long.
+		* @this {!Long}
+		* @returns {!number}
+		*/
+		LongPrototype.countTrailingZeros = function countTrailingZeros() {
+			return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
+		};
+		/**
+		* Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
+		* @function
+		* @param {!Long}
+		* @returns {!number}
+		*/
+		LongPrototype.ctz = LongPrototype.countTrailingZeros;
+		/**
+		* Returns the bitwise AND of this Long and the specified.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other Long
+		* @returns {!Long}
+		*/
+		LongPrototype.and = function and(other) {
+			if (!isLong(other)) other = fromValue(other);
+			return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
+		};
+		/**
+		* Returns the bitwise OR of this Long and the specified.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other Long
+		* @returns {!Long}
+		*/
+		LongPrototype.or = function or(other) {
+			if (!isLong(other)) other = fromValue(other);
+			return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
+		};
+		/**
+		* Returns the bitwise XOR of this Long and the given one.
+		* @this {!Long}
+		* @param {!Long|number|bigint|string} other Other Long
+		* @returns {!Long}
+		*/
+		LongPrototype.xor = function xor$2(other) {
+			if (!isLong(other)) other = fromValue(other);
+			return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
+		};
+		/**
+		* Returns this Long with bits shifted to the left by the given amount.
+		* @this {!Long}
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Shifted Long
+		*/
+		LongPrototype.shiftLeft = function shiftLeft(numBits) {
+			if (isLong(numBits)) numBits = numBits.toInt();
+			if ((numBits &= 63) === 0) return this;
+			else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
+			else return fromBits(0, this.low << numBits - 32, this.unsigned);
+		};
+		/**
+		* Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
+		* @function
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Shifted Long
+		*/
+		LongPrototype.shl = LongPrototype.shiftLeft;
+		/**
+		* Returns this Long with bits arithmetically shifted to the right by the given amount.
+		* @this {!Long}
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Shifted Long
+		*/
+		LongPrototype.shiftRight = function shiftRight(numBits) {
+			if (isLong(numBits)) numBits = numBits.toInt();
+			if ((numBits &= 63) === 0) return this;
+			else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
+			else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
+		};
+		/**
+		* Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
+		* @function
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Shifted Long
+		*/
+		LongPrototype.shr = LongPrototype.shiftRight;
+		/**
+		* Returns this Long with bits logically shifted to the right by the given amount.
+		* @this {!Long}
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Shifted Long
+		*/
+		LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
+			if (isLong(numBits)) numBits = numBits.toInt();
+			if ((numBits &= 63) === 0) return this;
+			if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
+			if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
+			return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
+		};
+		/**
+		* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
+		* @function
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Shifted Long
+		*/
+		LongPrototype.shru = LongPrototype.shiftRightUnsigned;
+		/**
+		* Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
+		* @function
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Shifted Long
+		*/
+		LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
+		/**
+		* Returns this Long with bits rotated to the left by the given amount.
+		* @this {!Long}
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Rotated Long
+		*/
+		LongPrototype.rotateLeft = function rotateLeft(numBits) {
+			var b;
+			if (isLong(numBits)) numBits = numBits.toInt();
+			if ((numBits &= 63) === 0) return this;
+			if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
+			if (numBits < 32) {
+				b = 32 - numBits;
+				return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
+			}
+			numBits -= 32;
+			b = 32 - numBits;
+			return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
+		};
+		/**
+		* Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
+		* @function
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Rotated Long
+		*/
+		LongPrototype.rotl = LongPrototype.rotateLeft;
+		/**
+		* Returns this Long with bits rotated to the right by the given amount.
+		* @this {!Long}
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Rotated Long
+		*/
+		LongPrototype.rotateRight = function rotateRight(numBits) {
+			var b;
+			if (isLong(numBits)) numBits = numBits.toInt();
+			if ((numBits &= 63) === 0) return this;
+			if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
+			if (numBits < 32) {
+				b = 32 - numBits;
+				return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
+			}
+			numBits -= 32;
+			b = 32 - numBits;
+			return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
+		};
+		/**
+		* Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
+		* @function
+		* @param {number|!Long} numBits Number of bits
+		* @returns {!Long} Rotated Long
+		*/
+		LongPrototype.rotr = LongPrototype.rotateRight;
+		/**
+		* Converts this Long to signed.
+		* @this {!Long}
+		* @returns {!Long} Signed long
+		*/
+		LongPrototype.toSigned = function toSigned() {
+			if (!this.unsigned) return this;
+			return fromBits(this.low, this.high, false);
+		};
+		/**
+		* Converts this Long to unsigned.
+		* @this {!Long}
+		* @returns {!Long} Unsigned long
+		*/
+		LongPrototype.toUnsigned = function toUnsigned() {
+			if (this.unsigned) return this;
+			return fromBits(this.low, this.high, true);
+		};
+		/**
+		* Converts this Long to its byte representation.
+		* @param {boolean=} le Whether little or big endian, defaults to big endian
+		* @this {!Long}
+		* @returns {!Array.<number>} Byte representation
+		*/
+		LongPrototype.toBytes = function toBytes(le) {
+			return le ? this.toBytesLE() : this.toBytesBE();
+		};
+		/**
+		* Converts this Long to its little endian byte representation.
+		* @this {!Long}
+		* @returns {!Array.<number>} Little endian byte representation
+		*/
+		LongPrototype.toBytesLE = function toBytesLE() {
+			var hi = this.high, lo = this.low;
+			return [
+				lo & 255,
+				lo >>> 8 & 255,
+				lo >>> 16 & 255,
+				lo >>> 24,
+				hi & 255,
+				hi >>> 8 & 255,
+				hi >>> 16 & 255,
+				hi >>> 24
+			];
+		};
+		/**
+		* Converts this Long to its big endian byte representation.
+		* @this {!Long}
+		* @returns {!Array.<number>} Big endian byte representation
+		*/
+		LongPrototype.toBytesBE = function toBytesBE() {
+			var hi = this.high, lo = this.low;
+			return [
+				hi >>> 24,
+				hi >>> 16 & 255,
+				hi >>> 8 & 255,
+				hi & 255,
+				lo >>> 24,
+				lo >>> 16 & 255,
+				lo >>> 8 & 255,
+				lo & 255
+			];
+		};
+		/**
+		* Creates a Long from its byte representation.
+		* @param {!Array.<number>} bytes Byte representation
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @param {boolean=} le Whether little or big endian, defaults to big endian
+		* @returns {Long} The corresponding Long value
+		*/
+		Long$1.fromBytes = function fromBytes(bytes, unsigned, le) {
+			return le ? Long$1.fromBytesLE(bytes, unsigned) : Long$1.fromBytesBE(bytes, unsigned);
+		};
+		/**
+		* Creates a Long from its little endian byte representation.
+		* @param {!Array.<number>} bytes Little endian byte representation
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @returns {Long} The corresponding Long value
+		*/
+		Long$1.fromBytesLE = function fromBytesLE(bytes, unsigned) {
+			return new Long$1(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
+		};
+		/**
+		* Creates a Long from its big endian byte representation.
+		* @param {!Array.<number>} bytes Big endian byte representation
+		* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+		* @returns {Long} The corresponding Long value
+		*/
+		Long$1.fromBytesBE = function fromBytesBE(bytes, unsigned) {
+			return new Long$1(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
+		};
+		if (typeof BigInt === "function") {
+			/**
+			* Returns a Long representing the given big integer.
+			* @function
+			* @param {number} value The big integer value
+			* @param {boolean=} unsigned Whether unsigned or not, defaults to signed
+			* @returns {!Long} The corresponding Long value
+			*/
+			Long$1.fromBigInt = function fromBigInt(value, unsigned) {
+				return fromBits(Number(BigInt.asIntN(32, value)), Number(BigInt.asIntN(32, value >> BigInt(32))), unsigned);
+			};
+			Long$1.fromValue = function fromValueWithBigInt(value, unsigned) {
+				if (typeof value === "bigint") return Long$1.fromBigInt(value, unsigned);
+				return fromValue(value, unsigned);
+			};
+			/**
+			* Converts the Long to its big integer representation.
+			* @this {!Long}
+			* @returns {bigint}
+			*/
+			LongPrototype.toBigInt = function toBigInt() {
+				var lowBigInt = BigInt(this.low >>> 0);
+				return BigInt(this.unsigned ? this.high >>> 0 : this.high) << BigInt(32) | lowBigInt;
+			};
+		}
+		_exports.default = Long$1;
+	});
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
+var require_safer = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js": ((exports, module) => {
+	var buffer = __require("buffer");
+	var Buffer$9 = buffer.Buffer;
+	var safer = {};
+	var key;
+	for (key in buffer) {
+		if (!buffer.hasOwnProperty(key)) continue;
+		if (key === "SlowBuffer" || key === "Buffer") continue;
+		safer[key] = buffer[key];
+	}
+	var Safer = safer.Buffer = {};
+	for (key in Buffer$9) {
+		if (!Buffer$9.hasOwnProperty(key)) continue;
+		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
+		Safer[key] = Buffer$9[key];
+	}
+	safer.Buffer.prototype = Buffer$9.prototype;
+	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
+		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
+		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
+		return Buffer$9(value, encodingOrOffset, length);
+	};
+	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
+		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
+		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
+		var buf = Buffer$9(size);
+		if (!fill || fill.length === 0) buf.fill(0);
+		else if (typeof encoding === "string") buf.fill(fill, encoding);
+		else buf.fill(fill);
+		return buf;
+	};
+	if (!safer.kStringMaxLength) try {
+		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
+	} catch (e) {}
+	if (!safer.constants) {
+		safer.constants = { MAX_LENGTH: safer.kMaxLength };
+		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
+	}
+	module.exports = safer;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/bom-handling.js
+var require_bom_handling = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/bom-handling.js": ((exports) => {
+	var BOMChar = "ï»¿";
+	exports.PrependBOM = PrependBOMWrapper;
+	function PrependBOMWrapper(encoder, options) {
+		this.encoder = encoder;
+		this.addBOM = true;
+	}
+	PrependBOMWrapper.prototype.write = function(str) {
+		if (this.addBOM) {
+			str = BOMChar + str;
+			this.addBOM = false;
+		}
+		return this.encoder.write(str);
+	};
+	PrependBOMWrapper.prototype.end = function() {
+		return this.encoder.end();
+	};
+	exports.StripBOM = StripBOMWrapper;
+	function StripBOMWrapper(decoder, options) {
+		this.decoder = decoder;
+		this.pass = false;
+		this.options = options || {};
+	}
+	StripBOMWrapper.prototype.write = function(buf) {
+		var res = this.decoder.write(buf);
+		if (this.pass || !res) return res;
+		if (res[0] === BOMChar) {
+			res = res.slice(1);
+			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
+		}
+		this.pass = true;
+		return res;
+	};
+	StripBOMWrapper.prototype.end = function() {
+		return this.decoder.end();
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js
+var require_merge_exports = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js": ((exports, module) => {
+	var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
+	function mergeModules$2(target, module$2) {
+		for (var key$1 in module$2) if (hasOwn(module$2, key$1)) target[key$1] = module$2[key$1];
+	}
+	module.exports = mergeModules$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/internal.js
+var require_internal = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/internal.js": ((exports, module) => {
+	var Buffer$8 = require_safer().Buffer;
+	module.exports = {
+		utf8: {
+			type: "_internal",
+			bomAware: true
+		},
+		cesu8: {
+			type: "_internal",
+			bomAware: true
+		},
+		unicode11utf8: "utf8",
+		ucs2: {
+			type: "_internal",
+			bomAware: true
+		},
+		utf16le: "ucs2",
+		binary: { type: "_internal" },
+		base64: { type: "_internal" },
+		hex: { type: "_internal" },
+		_internal: InternalCodec
+	};
+	function InternalCodec(codecOptions, iconv$1) {
+		this.enc = codecOptions.encodingName;
+		this.bomAware = codecOptions.bomAware;
+		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
+		else if (this.enc === "utf8") this.encoder = InternalEncoderUtf8;
+		else if (this.enc === "cesu8") {
+			this.enc = "utf8";
+			this.encoder = InternalEncoderCesu8;
+			if (Buffer$8.from("eda0bdedb2a9", "hex").toString() !== "ðŸ’©") {
+				this.decoder = InternalDecoderCesu8;
+				this.defaultCharUnicode = iconv$1.defaultCharUnicode;
+			}
+		}
+	}
+	InternalCodec.prototype.encoder = InternalEncoder;
+	InternalCodec.prototype.decoder = InternalDecoder;
+	var StringDecoder = __require("string_decoder").StringDecoder;
+	function InternalDecoder(options, codec) {
+		this.decoder = new StringDecoder(codec.enc);
+	}
+	InternalDecoder.prototype.write = function(buf) {
+		if (!Buffer$8.isBuffer(buf)) buf = Buffer$8.from(buf);
+		return this.decoder.write(buf);
+	};
+	InternalDecoder.prototype.end = function() {
+		return this.decoder.end();
+	};
+	function InternalEncoder(options, codec) {
+		this.enc = codec.enc;
+	}
+	InternalEncoder.prototype.write = function(str) {
+		return Buffer$8.from(str, this.enc);
+	};
+	InternalEncoder.prototype.end = function() {};
+	function InternalEncoderBase64(options, codec) {
+		this.prevStr = "";
+	}
+	InternalEncoderBase64.prototype.write = function(str) {
+		str = this.prevStr + str;
+		var completeQuads = str.length - str.length % 4;
+		this.prevStr = str.slice(completeQuads);
+		str = str.slice(0, completeQuads);
+		return Buffer$8.from(str, "base64");
+	};
+	InternalEncoderBase64.prototype.end = function() {
+		return Buffer$8.from(this.prevStr, "base64");
+	};
+	function InternalEncoderCesu8(options, codec) {}
+	InternalEncoderCesu8.prototype.write = function(str) {
+		var buf = Buffer$8.alloc(str.length * 3);
+		var bufIdx = 0;
+		for (var i$4 = 0; i$4 < str.length; i$4++) {
+			var charCode = str.charCodeAt(i$4);
+			if (charCode < 128) buf[bufIdx++] = charCode;
+			else if (charCode < 2048) {
+				buf[bufIdx++] = 192 + (charCode >>> 6);
+				buf[bufIdx++] = 128 + (charCode & 63);
+			} else {
+				buf[bufIdx++] = 224 + (charCode >>> 12);
+				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
+				buf[bufIdx++] = 128 + (charCode & 63);
+			}
+		}
+		return buf.slice(0, bufIdx);
+	};
+	InternalEncoderCesu8.prototype.end = function() {};
+	function InternalDecoderCesu8(options, codec) {
+		this.acc = 0;
+		this.contBytes = 0;
+		this.accBytes = 0;
+		this.defaultCharUnicode = codec.defaultCharUnicode;
+	}
+	InternalDecoderCesu8.prototype.write = function(buf) {
+		var acc = this.acc;
+		var contBytes = this.contBytes;
+		var accBytes = this.accBytes;
+		var res = "";
+		for (var i$4 = 0; i$4 < buf.length; i$4++) {
+			var curByte = buf[i$4];
+			if ((curByte & 192) !== 128) {
+				if (contBytes > 0) {
+					res += this.defaultCharUnicode;
+					contBytes = 0;
+				}
+				if (curByte < 128) res += String.fromCharCode(curByte);
+				else if (curByte < 224) {
+					acc = curByte & 31;
+					contBytes = 1;
+					accBytes = 1;
+				} else if (curByte < 240) {
+					acc = curByte & 15;
+					contBytes = 2;
+					accBytes = 1;
+				} else res += this.defaultCharUnicode;
+			} else if (contBytes > 0) {
+				acc = acc << 6 | curByte & 63;
+				contBytes--;
+				accBytes++;
+				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
+				else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
+				else res += String.fromCharCode(acc);
+			} else res += this.defaultCharUnicode;
+		}
+		this.acc = acc;
+		this.contBytes = contBytes;
+		this.accBytes = accBytes;
+		return res;
+	};
+	InternalDecoderCesu8.prototype.end = function() {
+		var res = 0;
+		if (this.contBytes > 0) res += this.defaultCharUnicode;
+		return res;
+	};
+	function InternalEncoderUtf8(options, codec) {
+		this.highSurrogate = "";
+	}
+	InternalEncoderUtf8.prototype.write = function(str) {
+		if (this.highSurrogate) {
+			str = this.highSurrogate + str;
+			this.highSurrogate = "";
+		}
+		if (str.length > 0) {
+			var charCode = str.charCodeAt(str.length - 1);
+			if (charCode >= 55296 && charCode < 56320) {
+				this.highSurrogate = str[str.length - 1];
+				str = str.slice(0, str.length - 1);
+			}
+		}
+		return Buffer$8.from(str, this.enc);
+	};
+	InternalEncoderUtf8.prototype.end = function() {
+		if (this.highSurrogate) {
+			var str = this.highSurrogate;
+			this.highSurrogate = "";
+			return Buffer$8.from(str, this.enc);
+		}
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf32.js
+var require_utf32 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf32.js": ((exports) => {
+	var Buffer$7 = require_safer().Buffer;
+	exports._utf32 = Utf32Codec;
+	function Utf32Codec(codecOptions, iconv$1) {
+		this.iconv = iconv$1;
+		this.bomAware = true;
+		this.isLE = codecOptions.isLE;
+	}
+	exports.utf32le = {
+		type: "_utf32",
+		isLE: true
+	};
+	exports.utf32be = {
+		type: "_utf32",
+		isLE: false
+	};
+	exports.ucs4le = "utf32le";
+	exports.ucs4be = "utf32be";
+	Utf32Codec.prototype.encoder = Utf32Encoder;
+	Utf32Codec.prototype.decoder = Utf32Decoder;
+	function Utf32Encoder(options, codec) {
+		this.isLE = codec.isLE;
+		this.highSurrogate = 0;
+	}
+	Utf32Encoder.prototype.write = function(str) {
+		var src = Buffer$7.from(str, "ucs2");
+		var dst = Buffer$7.alloc(src.length * 2);
+		var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
+		var offset = 0;
+		for (var i$4 = 0; i$4 < src.length; i$4 += 2) {
+			var code = src.readUInt16LE(i$4);
+			var isHighSurrogate = code >= 55296 && code < 56320;
+			var isLowSurrogate = code >= 56320 && code < 57344;
+			if (this.highSurrogate) if (isHighSurrogate || !isLowSurrogate) {
+				write32.call(dst, this.highSurrogate, offset);
+				offset += 4;
+			} else {
+				var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
+				write32.call(dst, codepoint, offset);
+				offset += 4;
+				this.highSurrogate = 0;
+				continue;
+			}
+			if (isHighSurrogate) this.highSurrogate = code;
+			else {
+				write32.call(dst, code, offset);
+				offset += 4;
+				this.highSurrogate = 0;
+			}
+		}
+		if (offset < dst.length) dst = dst.slice(0, offset);
+		return dst;
+	};
+	Utf32Encoder.prototype.end = function() {
+		if (!this.highSurrogate) return;
+		var buf = Buffer$7.alloc(4);
+		if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
+		else buf.writeUInt32BE(this.highSurrogate, 0);
+		this.highSurrogate = 0;
+		return buf;
+	};
+	function Utf32Decoder(options, codec) {
+		this.isLE = codec.isLE;
+		this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
+		this.overflow = [];
+	}
+	Utf32Decoder.prototype.write = function(src) {
+		if (src.length === 0) return "";
+		var i$4 = 0;
+		var codepoint = 0;
+		var dst = Buffer$7.alloc(src.length + 4);
+		var offset = 0;
+		var isLE = this.isLE;
+		var overflow = this.overflow;
+		var badChar = this.badChar;
+		if (overflow.length > 0) {
+			for (; i$4 < src.length && overflow.length < 4; i$4++) overflow.push(src[i$4]);
+			if (overflow.length === 4) {
+				if (isLE) codepoint = overflow[i$4] | overflow[i$4 + 1] << 8 | overflow[i$4 + 2] << 16 | overflow[i$4 + 3] << 24;
+				else codepoint = overflow[i$4 + 3] | overflow[i$4 + 2] << 8 | overflow[i$4 + 1] << 16 | overflow[i$4] << 24;
+				overflow.length = 0;
+				offset = _writeCodepoint(dst, offset, codepoint, badChar);
+			}
+		}
+		for (; i$4 < src.length - 3; i$4 += 4) {
+			if (isLE) codepoint = src[i$4] | src[i$4 + 1] << 8 | src[i$4 + 2] << 16 | src[i$4 + 3] << 24;
+			else codepoint = src[i$4 + 3] | src[i$4 + 2] << 8 | src[i$4 + 1] << 16 | src[i$4] << 24;
+			offset = _writeCodepoint(dst, offset, codepoint, badChar);
+		}
+		for (; i$4 < src.length; i$4++) overflow.push(src[i$4]);
+		return dst.slice(0, offset).toString("ucs2");
+	};
+	function _writeCodepoint(dst, offset, codepoint, badChar) {
+		if (codepoint < 0 || codepoint > 1114111) codepoint = badChar;
+		if (codepoint >= 65536) {
+			codepoint -= 65536;
+			var high = 55296 | codepoint >> 10;
+			dst[offset++] = high & 255;
+			dst[offset++] = high >> 8;
+			var codepoint = 56320 | codepoint & 1023;
+		}
+		dst[offset++] = codepoint & 255;
+		dst[offset++] = codepoint >> 8;
+		return offset;
+	}
+	Utf32Decoder.prototype.end = function() {
+		this.overflow.length = 0;
+	};
+	exports.utf32 = Utf32AutoCodec;
+	exports.ucs4 = "utf32";
+	function Utf32AutoCodec(options, iconv$1) {
+		this.iconv = iconv$1;
+	}
+	Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
+	Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
+	function Utf32AutoEncoder(options, codec) {
+		options = options || {};
+		if (options.addBOM === void 0) options.addBOM = true;
+		this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
+	}
+	Utf32AutoEncoder.prototype.write = function(str) {
+		return this.encoder.write(str);
+	};
+	Utf32AutoEncoder.prototype.end = function() {
+		return this.encoder.end();
+	};
+	function Utf32AutoDecoder(options, codec) {
+		this.decoder = null;
+		this.initialBufs = [];
+		this.initialBufsLen = 0;
+		this.options = options || {};
+		this.iconv = codec.iconv;
+	}
+	Utf32AutoDecoder.prototype.write = function(buf) {
+		if (!this.decoder) {
+			this.initialBufs.push(buf);
+			this.initialBufsLen += buf.length;
+			if (this.initialBufsLen < 32) return "";
+			var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
+			this.decoder = this.iconv.getDecoder(encoding, this.options);
+			var resStr = "";
+			for (var i$4 = 0; i$4 < this.initialBufs.length; i$4++) resStr += this.decoder.write(this.initialBufs[i$4]);
+			this.initialBufs.length = this.initialBufsLen = 0;
+			return resStr;
+		}
+		return this.decoder.write(buf);
+	};
+	Utf32AutoDecoder.prototype.end = function() {
+		if (!this.decoder) {
+			var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
+			this.decoder = this.iconv.getDecoder(encoding, this.options);
+			var resStr = "";
+			for (var i$4 = 0; i$4 < this.initialBufs.length; i$4++) resStr += this.decoder.write(this.initialBufs[i$4]);
+			var trail = this.decoder.end();
+			if (trail) resStr += trail;
+			this.initialBufs.length = this.initialBufsLen = 0;
+			return resStr;
+		}
+		return this.decoder.end();
+	};
+	function detectEncoding$1(bufs, defaultEncoding) {
+		var b = [];
+		var charsProcessed = 0;
+		var invalidLE = 0;
+		var invalidBE = 0;
+		var bmpCharsLE = 0;
+		var bmpCharsBE = 0;
+		outerLoop: for (var i$4 = 0; i$4 < bufs.length; i$4++) {
+			var buf = bufs[i$4];
+			for (var j = 0; j < buf.length; j++) {
+				b.push(buf[j]);
+				if (b.length === 4) {
+					if (charsProcessed === 0) {
+						if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) return "utf-32le";
+						if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) return "utf-32be";
+					}
+					if (b[0] !== 0 || b[1] > 16) invalidBE++;
+					if (b[3] !== 0 || b[2] > 16) invalidLE++;
+					if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
+					if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
+					b.length = 0;
+					charsProcessed++;
+					if (charsProcessed >= 100) break outerLoop;
+				}
+			}
+		}
+		if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
+		if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
+		return defaultEncoding || "utf-32le";
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf16.js
+var require_utf16 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf16.js": ((exports) => {
+	var Buffer$6 = require_safer().Buffer;
+	exports.utf16be = Utf16BECodec;
+	function Utf16BECodec() {}
+	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
+	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
+	Utf16BECodec.prototype.bomAware = true;
+	function Utf16BEEncoder() {}
+	Utf16BEEncoder.prototype.write = function(str) {
+		var buf = Buffer$6.from(str, "ucs2");
+		for (var i$4 = 0; i$4 < buf.length; i$4 += 2) {
+			var tmp = buf[i$4];
+			buf[i$4] = buf[i$4 + 1];
+			buf[i$4 + 1] = tmp;
+		}
+		return buf;
+	};
+	Utf16BEEncoder.prototype.end = function() {};
+	function Utf16BEDecoder() {
+		this.overflowByte = -1;
+	}
+	Utf16BEDecoder.prototype.write = function(buf) {
+		if (buf.length == 0) return "";
+		var buf2 = Buffer$6.alloc(buf.length + 1);
+		var i$4 = 0;
+		var j = 0;
+		if (this.overflowByte !== -1) {
+			buf2[0] = buf[0];
+			buf2[1] = this.overflowByte;
+			i$4 = 1;
+			j = 2;
+		}
+		for (; i$4 < buf.length - 1; i$4 += 2, j += 2) {
+			buf2[j] = buf[i$4 + 1];
+			buf2[j + 1] = buf[i$4];
+		}
+		this.overflowByte = i$4 == buf.length - 1 ? buf[buf.length - 1] : -1;
+		return buf2.slice(0, j).toString("ucs2");
+	};
+	Utf16BEDecoder.prototype.end = function() {
+		this.overflowByte = -1;
+	};
+	exports.utf16 = Utf16Codec;
+	function Utf16Codec(codecOptions, iconv$1) {
+		this.iconv = iconv$1;
+	}
+	Utf16Codec.prototype.encoder = Utf16Encoder;
+	Utf16Codec.prototype.decoder = Utf16Decoder;
+	function Utf16Encoder(options, codec) {
+		options = options || {};
+		if (options.addBOM === void 0) options.addBOM = true;
+		this.encoder = codec.iconv.getEncoder("utf-16le", options);
+	}
+	Utf16Encoder.prototype.write = function(str) {
+		return this.encoder.write(str);
+	};
+	Utf16Encoder.prototype.end = function() {
+		return this.encoder.end();
+	};
+	function Utf16Decoder(options, codec) {
+		this.decoder = null;
+		this.initialBufs = [];
+		this.initialBufsLen = 0;
+		this.options = options || {};
+		this.iconv = codec.iconv;
+	}
+	Utf16Decoder.prototype.write = function(buf) {
+		if (!this.decoder) {
+			this.initialBufs.push(buf);
+			this.initialBufsLen += buf.length;
+			if (this.initialBufsLen < 16) return "";
+			var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
+			this.decoder = this.iconv.getDecoder(encoding, this.options);
+			var resStr = "";
+			for (var i$4 = 0; i$4 < this.initialBufs.length; i$4++) resStr += this.decoder.write(this.initialBufs[i$4]);
+			this.initialBufs.length = this.initialBufsLen = 0;
+			return resStr;
+		}
+		return this.decoder.write(buf);
+	};
+	Utf16Decoder.prototype.end = function() {
+		if (!this.decoder) {
+			var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
+			this.decoder = this.iconv.getDecoder(encoding, this.options);
+			var resStr = "";
+			for (var i$4 = 0; i$4 < this.initialBufs.length; i$4++) resStr += this.decoder.write(this.initialBufs[i$4]);
+			var trail = this.decoder.end();
+			if (trail) resStr += trail;
+			this.initialBufs.length = this.initialBufsLen = 0;
+			return resStr;
+		}
+		return this.decoder.end();
+	};
+	function detectEncoding(bufs, defaultEncoding) {
+		var b = [];
+		var charsProcessed = 0;
+		var asciiCharsLE = 0;
+		var asciiCharsBE = 0;
+		outerLoop: for (var i$4 = 0; i$4 < bufs.length; i$4++) {
+			var buf = bufs[i$4];
+			for (var j = 0; j < buf.length; j++) {
+				b.push(buf[j]);
+				if (b.length === 2) {
+					if (charsProcessed === 0) {
+						if (b[0] === 255 && b[1] === 254) return "utf-16le";
+						if (b[0] === 254 && b[1] === 255) return "utf-16be";
+					}
+					if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
+					if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
+					b.length = 0;
+					charsProcessed++;
+					if (charsProcessed >= 100) break outerLoop;
+				}
+			}
+		}
+		if (asciiCharsBE > asciiCharsLE) return "utf-16be";
+		if (asciiCharsBE < asciiCharsLE) return "utf-16le";
+		return defaultEncoding || "utf-16le";
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf7.js
+var require_utf7 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf7.js": ((exports) => {
+	var Buffer$5 = require_safer().Buffer;
+	exports.utf7 = Utf7Codec;
+	exports.unicode11utf7 = "utf7";
+	function Utf7Codec(codecOptions, iconv$1) {
+		this.iconv = iconv$1;
+	}
+	Utf7Codec.prototype.encoder = Utf7Encoder;
+	Utf7Codec.prototype.decoder = Utf7Decoder;
+	Utf7Codec.prototype.bomAware = true;
+	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
+	function Utf7Encoder(options, codec) {
+		this.iconv = codec.iconv;
+	}
+	Utf7Encoder.prototype.write = function(str) {
+		return Buffer$5.from(str.replace(nonDirectChars, function(chunk) {
+			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
+		}.bind(this)));
+	};
+	Utf7Encoder.prototype.end = function() {};
+	function Utf7Decoder(options, codec) {
+		this.iconv = codec.iconv;
+		this.inBase64 = false;
+		this.base64Accum = "";
+	}
+	var base64Regex = /[A-Za-z0-9\/+]/;
+	var base64Chars = [];
+	for (var i$3 = 0; i$3 < 256; i$3++) base64Chars[i$3] = base64Regex.test(String.fromCharCode(i$3));
+	var plusChar = "+".charCodeAt(0);
+	var minusChar = "-".charCodeAt(0);
+	var andChar = "&".charCodeAt(0);
+	Utf7Decoder.prototype.write = function(buf) {
+		var res = "";
+		var lastI = 0;
+		var inBase64 = this.inBase64;
+		var base64Accum = this.base64Accum;
+		for (var i$4 = 0; i$4 < buf.length; i$4++) if (!inBase64) {
+			if (buf[i$4] == plusChar) {
+				res += this.iconv.decode(buf.slice(lastI, i$4), "ascii");
+				lastI = i$4 + 1;
+				inBase64 = true;
+			}
+		} else if (!base64Chars[buf[i$4]]) {
+			if (i$4 == lastI && buf[i$4] == minusChar) res += "+";
+			else {
+				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i$4), "ascii");
+				res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
+			}
+			if (buf[i$4] != minusChar) i$4--;
+			lastI = i$4 + 1;
+			inBase64 = false;
+			base64Accum = "";
+		}
+		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
+		else {
+			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
+			var canBeDecoded = b64str.length - b64str.length % 8;
+			base64Accum = b64str.slice(canBeDecoded);
+			b64str = b64str.slice(0, canBeDecoded);
+			res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
+		}
+		this.inBase64 = inBase64;
+		this.base64Accum = base64Accum;
+		return res;
+	};
+	Utf7Decoder.prototype.end = function() {
+		var res = "";
+		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$5.from(this.base64Accum, "base64"), "utf16-be");
+		this.inBase64 = false;
+		this.base64Accum = "";
+		return res;
+	};
+	exports.utf7imap = Utf7IMAPCodec;
+	function Utf7IMAPCodec(codecOptions, iconv$1) {
+		this.iconv = iconv$1;
+	}
+	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
+	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
+	Utf7IMAPCodec.prototype.bomAware = true;
+	function Utf7IMAPEncoder(options, codec) {
+		this.iconv = codec.iconv;
+		this.inBase64 = false;
+		this.base64Accum = Buffer$5.alloc(6);
+		this.base64AccumIdx = 0;
+	}
+	Utf7IMAPEncoder.prototype.write = function(str) {
+		var inBase64 = this.inBase64;
+		var base64Accum = this.base64Accum;
+		var base64AccumIdx = this.base64AccumIdx;
+		var buf = Buffer$5.alloc(str.length * 5 + 10);
+		var bufIdx = 0;
+		for (var i$4 = 0; i$4 < str.length; i$4++) {
+			var uChar = str.charCodeAt(i$4);
+			if (uChar >= 32 && uChar <= 126) {
+				if (inBase64) {
+					if (base64AccumIdx > 0) {
+						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
+						base64AccumIdx = 0;
+					}
+					buf[bufIdx++] = minusChar;
+					inBase64 = false;
+				}
+				if (!inBase64) {
+					buf[bufIdx++] = uChar;
+					if (uChar === andChar) buf[bufIdx++] = minusChar;
+				}
+			} else {
+				if (!inBase64) {
+					buf[bufIdx++] = andChar;
+					inBase64 = true;
+				}
+				if (inBase64) {
+					base64Accum[base64AccumIdx++] = uChar >> 8;
+					base64Accum[base64AccumIdx++] = uChar & 255;
+					if (base64AccumIdx == base64Accum.length) {
+						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
+						base64AccumIdx = 0;
+					}
+				}
+			}
+		}
+		this.inBase64 = inBase64;
+		this.base64AccumIdx = base64AccumIdx;
+		return buf.slice(0, bufIdx);
+	};
+	Utf7IMAPEncoder.prototype.end = function() {
+		var buf = Buffer$5.alloc(10);
+		var bufIdx = 0;
+		if (this.inBase64) {
+			if (this.base64AccumIdx > 0) {
+				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
+				this.base64AccumIdx = 0;
+			}
+			buf[bufIdx++] = minusChar;
+			this.inBase64 = false;
+		}
+		return buf.slice(0, bufIdx);
+	};
+	function Utf7IMAPDecoder(options, codec) {
+		this.iconv = codec.iconv;
+		this.inBase64 = false;
+		this.base64Accum = "";
+	}
+	var base64IMAPChars = base64Chars.slice();
+	base64IMAPChars[",".charCodeAt(0)] = true;
+	Utf7IMAPDecoder.prototype.write = function(buf) {
+		var res = "";
+		var lastI = 0;
+		var inBase64 = this.inBase64;
+		var base64Accum = this.base64Accum;
+		for (var i$4 = 0; i$4 < buf.length; i$4++) if (!inBase64) {
+			if (buf[i$4] == andChar) {
+				res += this.iconv.decode(buf.slice(lastI, i$4), "ascii");
+				lastI = i$4 + 1;
+				inBase64 = true;
+			}
+		} else if (!base64IMAPChars[buf[i$4]]) {
+			if (i$4 == lastI && buf[i$4] == minusChar) res += "&";
+			else {
+				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i$4), "ascii").replace(/,/g, "/");
+				res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
+			}
+			if (buf[i$4] != minusChar) i$4--;
+			lastI = i$4 + 1;
+			inBase64 = false;
+			base64Accum = "";
+		}
+		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
+		else {
+			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
+			var canBeDecoded = b64str.length - b64str.length % 8;
+			base64Accum = b64str.slice(canBeDecoded);
+			b64str = b64str.slice(0, canBeDecoded);
+			res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
+		}
+		this.inBase64 = inBase64;
+		this.base64Accum = base64Accum;
+		return res;
+	};
+	Utf7IMAPDecoder.prototype.end = function() {
+		var res = "";
+		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$5.from(this.base64Accum, "base64"), "utf16-be");
+		this.inBase64 = false;
+		this.base64Accum = "";
+		return res;
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-codec.js
+var require_sbcs_codec = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-codec.js": ((exports) => {
+	var Buffer$4 = require_safer().Buffer;
+	exports._sbcs = SBCSCodec;
+	function SBCSCodec(codecOptions, iconv$1) {
+		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
+		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
+		if (codecOptions.chars.length === 128) {
+			var asciiString = "";
+			for (var i$4 = 0; i$4 < 128; i$4++) asciiString += String.fromCharCode(i$4);
+			codecOptions.chars = asciiString + codecOptions.chars;
+		}
+		this.decodeBuf = Buffer$4.from(codecOptions.chars, "ucs2");
+		var encodeBuf = Buffer$4.alloc(65536, iconv$1.defaultCharSingleByte.charCodeAt(0));
+		for (var i$4 = 0; i$4 < codecOptions.chars.length; i$4++) encodeBuf[codecOptions.chars.charCodeAt(i$4)] = i$4;
+		this.encodeBuf = encodeBuf;
+	}
+	SBCSCodec.prototype.encoder = SBCSEncoder;
+	SBCSCodec.prototype.decoder = SBCSDecoder;
+	function SBCSEncoder(options, codec) {
+		this.encodeBuf = codec.encodeBuf;
+	}
+	SBCSEncoder.prototype.write = function(str) {
+		var buf = Buffer$4.alloc(str.length);
+		for (var i$4 = 0; i$4 < str.length; i$4++) buf[i$4] = this.encodeBuf[str.charCodeAt(i$4)];
+		return buf;
+	};
+	SBCSEncoder.prototype.end = function() {};
+	function SBCSDecoder(options, codec) {
+		this.decodeBuf = codec.decodeBuf;
+	}
+	SBCSDecoder.prototype.write = function(buf) {
+		var decodeBuf = this.decodeBuf;
+		var newBuf = Buffer$4.alloc(buf.length * 2);
+		var idx1 = 0;
+		var idx2 = 0;
+		for (var i$4 = 0; i$4 < buf.length; i$4++) {
+			idx1 = buf[i$4] * 2;
+			idx2 = i$4 * 2;
+			newBuf[idx2] = decodeBuf[idx1];
+			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
+		}
+		return newBuf.toString("ucs2");
+	};
+	SBCSDecoder.prototype.end = function() {};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data.js
+var require_sbcs_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data.js": ((exports, module) => {
+	module.exports = {
+		10029: "maccenteuro",
+		maccenteuro: {
+			type: "_sbcs",
+			chars: "Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄŽÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦\xA0ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€žÅ¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡"
+		},
+		808: "cp808",
+		ibm808: "cp808",
+		cp808: {
+			type: "_sbcs",
+			chars: "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–â‚¬â– \xA0"
+		},
+		mik: {
+			type: "_sbcs",
+			chars: "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ””â”´â”¬â”œâ”€â”¼â•£â•‘â•šâ•”â•©â•¦â• â•â•¬â”â–‘â–’â–“â”‚â”¤â„–Â§â•—â•â”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		cp720: {
+			type: "_sbcs",
+			chars: "Â€ÂÃ©Ã¢Â„Ã Â†Ã§ÃªÃ«Ã¨Ã¯Ã®ÂÂŽÂÂÙ‘Ù’Ã´Â¤Ù€Ã»Ã¹Ø¡Ø¢Ø£Ø¤Â£Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµÂ«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ø¶Ø·Ø¸Ø¹ØºÙÂµÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠâ‰¡Ù‹ÙŒÙÙŽÙÙâ‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		ascii8bit: "ascii",
+		usascii: "ascii",
+		ansix34: "ascii",
+		ansix341968: "ascii",
+		ansix341986: "ascii",
+		csascii: "ascii",
+		cp367: "ascii",
+		ibm367: "ascii",
+		isoir6: "ascii",
+		iso646us: "ascii",
+		iso646irv: "ascii",
+		us: "ascii",
+		latin1: "iso88591",
+		latin2: "iso88592",
+		latin3: "iso88593",
+		latin4: "iso88594",
+		latin5: "iso88599",
+		latin6: "iso885910",
+		latin7: "iso885913",
+		latin8: "iso885914",
+		latin9: "iso885915",
+		latin10: "iso885916",
+		csisolatin1: "iso88591",
+		csisolatin2: "iso88592",
+		csisolatin3: "iso88593",
+		csisolatin4: "iso88594",
+		csisolatincyrillic: "iso88595",
+		csisolatinarabic: "iso88596",
+		csisolatingreek: "iso88597",
+		csisolatinhebrew: "iso88598",
+		csisolatin5: "iso88599",
+		csisolatin6: "iso885910",
+		l1: "iso88591",
+		l2: "iso88592",
+		l3: "iso88593",
+		l4: "iso88594",
+		l5: "iso88599",
+		l6: "iso885910",
+		l7: "iso885913",
+		l8: "iso885914",
+		l9: "iso885915",
+		l10: "iso885916",
+		isoir14: "iso646jp",
+		isoir57: "iso646cn",
+		isoir100: "iso88591",
+		isoir101: "iso88592",
+		isoir109: "iso88593",
+		isoir110: "iso88594",
+		isoir144: "iso88595",
+		isoir127: "iso88596",
+		isoir126: "iso88597",
+		isoir138: "iso88598",
+		isoir148: "iso88599",
+		isoir157: "iso885910",
+		isoir166: "tis620",
+		isoir179: "iso885913",
+		isoir199: "iso885914",
+		isoir203: "iso885915",
+		isoir226: "iso885916",
+		cp819: "iso88591",
+		ibm819: "iso88591",
+		cyrillic: "iso88595",
+		arabic: "iso88596",
+		arabic8: "iso88596",
+		ecma114: "iso88596",
+		asmo708: "iso88596",
+		greek: "iso88597",
+		greek8: "iso88597",
+		ecma118: "iso88597",
+		elot928: "iso88597",
+		hebrew: "iso88598",
+		hebrew8: "iso88598",
+		turkish: "iso88599",
+		turkish8: "iso88599",
+		thai: "iso885911",
+		thai8: "iso885911",
+		celtic: "iso885914",
+		celtic8: "iso885914",
+		isoceltic: "iso885914",
+		tis6200: "tis620",
+		tis62025291: "tis620",
+		tis62025330: "tis620",
+		1e4: "macroman",
+		10006: "macgreek",
+		10007: "maccyrillic",
+		10079: "maciceland",
+		10081: "macturkish",
+		cspc8codepage437: "cp437",
+		cspc775baltic: "cp775",
+		cspc850multilingual: "cp850",
+		cspcp852: "cp852",
+		cspc862latinhebrew: "cp862",
+		cpgr: "cp869",
+		msee: "cp1250",
+		mscyrl: "cp1251",
+		msansi: "cp1252",
+		msgreek: "cp1253",
+		msturk: "cp1254",
+		mshebr: "cp1255",
+		msarab: "cp1256",
+		winbaltrim: "cp1257",
+		cp20866: "koi8r",
+		20866: "koi8r",
+		ibm878: "koi8r",
+		cskoi8r: "koi8r",
+		cp21866: "koi8u",
+		21866: "koi8u",
+		ibm1168: "koi8u",
+		strk10482002: "rk1048",
+		tcvn5712: "tcvn",
+		tcvn57121: "tcvn",
+		gb198880: "iso646cn",
+		cn: "iso646cn",
+		csiso14jisc6220ro: "iso646jp",
+		jisc62201969ro: "iso646jp",
+		jp: "iso646jp",
+		cshproman8: "hproman8",
+		r8: "hproman8",
+		roman8: "hproman8",
+		xroman8: "hproman8",
+		ibm1051: "hproman8",
+		mac: "macintosh",
+		csmacintosh: "macintosh"
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data-generated.js
+var require_sbcs_data_generated = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data-generated.js": ((exports, module) => {
+	module.exports = {
+		"437": "cp437",
+		"737": "cp737",
+		"775": "cp775",
+		"850": "cp850",
+		"852": "cp852",
+		"855": "cp855",
+		"856": "cp856",
+		"857": "cp857",
+		"858": "cp858",
+		"860": "cp860",
+		"861": "cp861",
+		"862": "cp862",
+		"863": "cp863",
+		"864": "cp864",
+		"865": "cp865",
+		"866": "cp866",
+		"869": "cp869",
+		"874": "windows874",
+		"922": "cp922",
+		"1046": "cp1046",
+		"1124": "cp1124",
+		"1125": "cp1125",
+		"1129": "cp1129",
+		"1133": "cp1133",
+		"1161": "cp1161",
+		"1162": "cp1162",
+		"1163": "cp1163",
+		"1250": "windows1250",
+		"1251": "windows1251",
+		"1252": "windows1252",
+		"1253": "windows1253",
+		"1254": "windows1254",
+		"1255": "windows1255",
+		"1256": "windows1256",
+		"1257": "windows1257",
+		"1258": "windows1258",
+		"28591": "iso88591",
+		"28592": "iso88592",
+		"28593": "iso88593",
+		"28594": "iso88594",
+		"28595": "iso88595",
+		"28596": "iso88596",
+		"28597": "iso88597",
+		"28598": "iso88598",
+		"28599": "iso88599",
+		"28600": "iso885910",
+		"28601": "iso885911",
+		"28603": "iso885913",
+		"28604": "iso885914",
+		"28605": "iso885915",
+		"28606": "iso885916",
+		"windows874": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½ï¿½ï¿½ï¿½â€¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½\xA0à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
+		},
+		"win874": "windows874",
+		"cp874": "windows874",
+		"windows1250": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°Å â€¹ÅšÅ¤Å½Å¹ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Å¡â€ºÅ›Å¥Å¾Åº\xA0Ë‡Ë˜ÅÂ¤Ä„Â¦Â§Â¨Â©ÅžÂ«Â¬Â­Â®Å»Â°Â±Ë›Å‚Â´ÂµÂ¶Â·Â¸Ä…ÅŸÂ»Ä½ËÄ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
+		},
+		"win1250": "windows1250",
+		"cp1250": "windows1250",
+		"windows1251": {
+			"type": "_sbcs",
+			"chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÐŒÐ‹ÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÑœÑ›ÑŸ\xA0ÐŽÑžÐˆÂ¤ÒÂ¦Â§ÐÂ©Ð„Â«Â¬Â­Â®Ð‡Â°Â±Ð†Ñ–Ò‘ÂµÂ¶Â·Ñ‘â„–Ñ”Â»Ñ˜Ð…Ñ•Ñ—ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
+		},
+		"win1251": "windows1251",
+		"cp1251": "windows1251",
+		"windows1252": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½Å½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½Å¾Å¸\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
+		},
+		"win1252": "windows1252",
+		"cp1252": "windows1252",
+		"windows1253": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½\xA0Î…Î†Â£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®â€•Â°Â±Â²Â³Î„ÂµÂ¶Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
+		},
+		"win1253": "windows1253",
+		"cp1253": "windows1253",
+		"windows1254": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½ï¿½Å¸\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
+		},
+		"win1254": "windows1254",
+		"cp1254": "windows1254",
+		"windows1255": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½\xA0Â¡Â¢Â£â‚ªÂ¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×€××‚×ƒ×°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
+		},
+		"win1255": "windows1255",
+		"cp1255": "windows1255",
+		"windows1256": {
+			"type": "_sbcs",
+			"chars": "â‚¬Ù¾â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Ù¹â€¹Å’Ú†Ú˜ÚˆÚ¯â€˜â€™â€œâ€â€¢â€“â€”Ú©â„¢Ú‘â€ºÅ“â€Œâ€Úº\xA0ØŒÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ø›Â»Â¼Â½Â¾ØŸÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ã—Ø·Ø¸Ø¹ØºÙ€ÙÙ‚ÙƒÃ Ù„Ã¢Ù…Ù†Ù‡ÙˆÃ§Ã¨Ã©ÃªÃ«Ù‰ÙŠÃ®Ã¯Ù‹ÙŒÙÙŽÃ´ÙÙÃ·Ù‘Ã¹Ù’Ã»Ã¼â€Žâ€Û’"
+		},
+		"win1256": "windows1256",
+		"cp1256": "windows1256",
+		"windows1257": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½Â¨Ë‡Â¸ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½Â¯Ë›ï¿½\xA0ï¿½Â¢Â£Â¤ï¿½Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾Ë™"
+		},
+		"win1257": "windows1257",
+		"cp1257": "windows1257",
+		"windows1258": {
+			"type": "_sbcs",
+			"chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºÅ“ï¿½ï¿½Å¸\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
+		},
+		"win1258": "windows1258",
+		"cp1258": "windows1258",
+		"iso88591": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
+		},
+		"cp28591": "iso88591",
+		"iso88592": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Ä„Ë˜ÅÂ¤Ä½ÅšÂ§Â¨Å ÅžÅ¤Å¹Â­Å½Å»Â°Ä…Ë›Å‚Â´Ä¾Å›Ë‡Â¸Å¡ÅŸÅ¥ÅºËÅ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
+		},
+		"cp28592": "iso88592",
+		"iso88593": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Ä¦Ë˜Â£Â¤ï¿½Ä¤Â§Â¨Ä°ÅžÄžÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅŸÄŸÄµÂ½ï¿½Å¼Ã€ÃÃ‚ï¿½Ã„ÄŠÄˆÃ‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃï¿½Ã‘Ã’Ã“Ã”Ä Ã–Ã—ÄœÃ™ÃšÃ›ÃœÅ¬ÅœÃŸÃ Ã¡Ã¢ï¿½Ã¤Ä‹Ä‰Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË™"
+		},
+		"cp28593": "iso88593",
+		"iso88594": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Ä„Ä¸Å–Â¤Ä¨Ä»Â§Â¨Å Ä’Ä¢Å¦Â­Å½Â¯Â°Ä…Ë›Å—Â´Ä©Ä¼Ë‡Â¸Å¡Ä“Ä£Å§ÅŠÅ¾Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÄªÄÅ…ÅŒÄ¶Ã”Ã•Ã–Ã—Ã˜Å²ÃšÃ›ÃœÅ¨ÅªÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ä«Ä‘Å†ÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë™"
+		},
+		"cp28594": "iso88594",
+		"iso88595": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0ÐÐ‚ÐƒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ñ“Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
+		},
+		"cp28595": "iso88595",
+		"iso88596": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØŒÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø›ï¿½ï¿½ï¿½ØŸï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
+		},
+		"cp28596": "iso88596",
+		"iso88597": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0â€˜â€™Â£â‚¬â‚¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½â€•Â°Â±Â²Â³Î„Î…Î†Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
+		},
+		"cp28597": "iso88597",
+		"iso88598": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€—××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
+		},
+		"cp28598": "iso88598",
+		"iso88599": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
+		},
+		"cp28599": "iso88599",
+		"iso885910": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Ä„Ä’Ä¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅŠÂ°Ä…Ä“Ä£Ä«Ä©Ä·Â·Ä¼Ä‘Å¡Å§Å¾â€•Å«Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÃÃÅ…ÅŒÃ“Ã”Ã•Ã–Å¨Ã˜Å²ÃšÃ›ÃœÃÃžÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ã¯Ã°Å†ÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸"
+		},
+		"cp28600": "iso885910",
+		"iso885911": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
+		},
+		"cp28601": "iso885911",
+		"iso885913": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0â€Â¢Â£Â¤â€žÂ¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³â€œÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾â€™"
+		},
+		"cp28603": "iso885913",
+		"iso885914": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0á¸‚á¸ƒÂ£ÄŠÄ‹á¸ŠÂ§áº€Â©áº‚á¸‹á»²Â­Â®Å¸á¸žá¸ŸÄ Ä¡á¹€á¹Â¶á¹–áºá¹—áºƒá¹ á»³áº„áº…á¹¡Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ´Ã‘Ã’Ã“Ã”Ã•Ã–á¹ªÃ˜Ã™ÃšÃ›ÃœÃÅ¶ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿"
+		},
+		"cp28604": "iso885914",
+		"iso885915": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Â¡Â¢Â£â‚¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»Å’Å“Å¸Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
+		},
+		"cp28605": "iso885915",
+		"iso885916": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Ä„Ä…Åâ‚¬â€žÅ Â§Å¡Â©È˜Â«Å¹Â­ÅºÅ»Â°Â±ÄŒÅ‚Å½â€Â¶Â·Å¾ÄÈ™Â»Å’Å“Å¸Å¼Ã€ÃÃ‚Ä‚Ã„Ä†Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄÅƒÃ’Ã“Ã”ÅÃ–ÅšÅ°Ã™ÃšÃ›ÃœÄ˜ÈšÃŸÃ Ã¡Ã¢ÄƒÃ¤Ä‡Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ä‘Å„Ã²Ã³Ã´Å‘Ã¶Å›Å±Ã¹ÃºÃ»Ã¼Ä™È›Ã¿"
+		},
+		"cp28606": "iso885916",
+		"cp437": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		"ibm437": "cp437",
+		"csibm437": "cp437",
+		"cp737": {
+			"type": "_sbcs",
+			"chars": "Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Ï…Ï†Ï‡Ïˆâ–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ï‰Î¬Î­Î®ÏŠÎ¯ÏŒÏÏ‹ÏŽÎ†ÎˆÎ‰ÎŠÎŒÎŽÎÂ±â‰¥â‰¤ÎªÎ«Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		"ibm737": "cp737",
+		"csibm737": "cp737",
+		"cp775": {
+			"type": "_sbcs",
+			"chars": "Ä†Ã¼Ã©ÄÃ¤Ä£Ã¥Ä‡Å‚Ä“Å–Å—Ä«Å¹Ã„Ã…Ã‰Ã¦Ã†ÅÃ¶Ä¢Â¢ÅšÅ›Ã–ÃœÃ¸Â£Ã˜Ã—Â¤Ä€ÄªÃ³Å»Å¼Åºâ€Â¦Â©Â®Â¬Â½Â¼ÅÂ«Â»â–‘â–’â–“â”‚â”¤Ä„ÄŒÄ˜Ä–â•£â•‘â•—â•Ä®Å â”â””â”´â”¬â”œâ”€â”¼Å²Åªâ•šâ•”â•©â•¦â• â•â•¬Å½Ä…ÄÄ™Ä—Ä¯Å¡Å³Å«Å¾â”˜â”Œâ–ˆâ–„â–Œâ–â–€Ã“ÃŸÅŒÅƒÃµÃ•ÂµÅ„Ä¶Ä·Ä»Ä¼Å†Ä’Å…â€™Â­Â±â€œÂ¾Â¶Â§Ã·â€žÂ°âˆ™Â·Â¹Â³Â²â– \xA0"
+		},
+		"ibm775": "cp775",
+		"csibm775": "cp775",
+		"cp850": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹ÃˆÄ±ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– \xA0"
+		},
+		"ibm850": "cp850",
+		"csibm850": "cp850",
+		"cp852": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã¤Å¯Ä‡Ã§Å‚Ã«ÅÅ‘Ã®Å¹Ã„Ä†Ã‰Ä¹ÄºÃ´Ã¶Ä½Ä¾ÅšÅ›Ã–ÃœÅ¤Å¥ÅÃ—ÄÃ¡Ã­Ã³ÃºÄ„Ä…Å½Å¾Ä˜Ä™Â¬ÅºÄŒÅŸÂ«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚ÄšÅžâ•£â•‘â•—â•Å»Å¼â”â””â”´â”¬â”œâ”€â”¼Ä‚Äƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ä‘ÄÄŽÃ‹ÄÅ‡ÃÃŽÄ›â”˜â”Œâ–ˆâ–„Å¢Å®â–€Ã“ÃŸÃ”ÅƒÅ„ÅˆÅ Å¡Å”ÃšÅ•Å°Ã½ÃÅ£Â´Â­ËË›Ë‡Ë˜Â§Ã·Â¸Â°Â¨Ë™Å±Å˜Å™â– \xA0"
+		},
+		"ibm852": "cp852",
+		"csibm852": "cp852",
+		"cp855": {
+			"type": "_sbcs",
+			"chars": "Ñ’Ð‚Ñ“ÐƒÑ‘ÐÑ”Ð„Ñ•Ð…Ñ–Ð†Ñ—Ð‡Ñ˜ÐˆÑ™Ð‰ÑšÐŠÑ›Ð‹ÑœÐŒÑžÐŽÑŸÐÑŽÐ®ÑŠÐªÐ°ÐÐ±Ð‘Ñ†Ð¦Ð´Ð”ÐµÐ•Ñ„Ð¤Ð³Ð“Â«Â»â–‘â–’â–“â”‚â”¤Ñ…Ð¥Ð¸Ð˜â•£â•‘â•—â•Ð¹Ð™â”â””â”´â”¬â”œâ”€â”¼ÐºÐšâ•šâ•”â•©â•¦â• â•â•¬Â¤Ð»Ð›Ð¼ÐœÐ½ÐÐ¾ÐžÐ¿â”˜â”Œâ–ˆâ–„ÐŸÑâ–€Ð¯Ñ€Ð ÑÐ¡Ñ‚Ð¢ÑƒÐ£Ð¶Ð–Ð²Ð’ÑŒÐ¬â„–Â­Ñ‹Ð«Ð·Ð—ÑˆÐ¨ÑÐ­Ñ‰Ð©Ñ‡Ð§Â§â– \xA0"
+		},
+		"ibm855": "cp855",
+		"csibm855": "cp855",
+		"cp856": {
+			"type": "_sbcs",
+			"chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ã—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»â–‘â–’â–“â”‚â”¤ï¿½ï¿½ï¿½Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼ï¿½ï¿½â•šâ•”â•©â•¦â• â•â•¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â”˜â”Œâ–ˆâ–„Â¦ï¿½â–€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– \xA0"
+		},
+		"ibm856": "cp856",
+		"csibm856": "cp856",
+		"cp857": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ä°Ã–ÃœÃ¸Â£Ã˜ÅžÅŸÃ¡Ã­Ã³ÃºÃ±Ã‘ÄžÄŸÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤ÂºÂªÃŠÃ‹Ãˆï¿½ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•Âµï¿½Ã—ÃšÃ›Ã™Ã¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– \xA0"
+		},
+		"ibm857": "cp857",
+		"csibm857": "cp857",
+		"cp858": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹Ãˆâ‚¬ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– \xA0"
+		},
+		"ibm858": "cp858",
+		"csibm858": "cp858",
+		"cp860": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃŠÃ¨ÃÃ”Ã¬ÃƒÃ‚Ã‰Ã€ÃˆÃ´ÃµÃ²ÃšÃ¹ÃŒÃ•ÃœÂ¢Â£Ã™â‚§Ã“Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Ã’Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		"ibm860": "cp860",
+		"csibm860": "cp860",
+		"cp861": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃžÃ„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã¾Ã»ÃÃ½Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃÃÃ“ÃšÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		"ibm861": "cp861",
+		"csibm861": "cp861",
+		"cp862": {
+			"type": "_sbcs",
+			"chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		"ibm862": "cp862",
+		"csibm862": "cp862",
+		"cp863": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã‚Ã Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®â€—Ã€Â§Ã‰ÃˆÃŠÃ´Ã‹ÃÃ»Ã¹Â¤Ã”ÃœÂ¢Â£Ã™Ã›Æ’Â¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃŽâŒÂ¬Â½Â¼Â¾Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		"ibm863": "cp863",
+		"csibm863": "cp863",
+		"cp864": {
+			"type": "_sbcs",
+			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·âˆ™âˆšâ–’â”€â”‚â”¼â”¤â”¬â”œâ”´â”â”Œâ””â”˜Î²âˆžÏ†Â±Â½Â¼â‰ˆÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½\xA0Â­ïº‚Â£Â¤ïº„ï¿½ï¿½ïºŽïºïº•ïº™ØŒïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»‘Ø›ïº±ïºµïº¹ØŸÂ¢ïº€ïºïºƒïº…ï»Šïº‹ïºïº‘ïº“ïº—ïº›ïºŸïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»…ï»‹ï»Â¦Â¬Ã·Ã—ï»‰Ù€ï»“ï»—ï»›ï»Ÿï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»Œï»Žï»ï»¡ï¹½Ù‘ï»¥ï»©ï»¬ï»°ï»²ï»ï»•ï»µï»¶ï»ï»™ï»±â– ï¿½"
+		},
+		"ibm864": "cp864",
+		"csibm864": "cp864",
+		"cp865": {
+			"type": "_sbcs",
+			"chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â¤â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– \xA0"
+		},
+		"ibm865": "cp865",
+		"csibm865": "cp865",
+		"cp866": {
+			"type": "_sbcs",
+			"chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–Â¤â– \xA0"
+		},
+		"ibm866": "cp866",
+		"csibm866": "cp866",
+		"cp869": {
+			"type": "_sbcs",
+			"chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½Â·Â¬Â¦â€˜â€™Îˆâ€•Î‰ÎŠÎªÎŒï¿½ï¿½ÎŽÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏŠÎÏŒÏÎ‘Î’Î“Î”Î•Î–Î—Â½Î˜Î™Â«Â»â–‘â–’â–“â”‚â”¤ÎšÎ›ÎœÎâ•£â•‘â•—â•ÎžÎŸâ”â””â”´â”¬â”œâ”€â”¼Î Î¡â•šâ•”â•©â•¦â• â•â•¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³â”˜â”Œâ–ˆâ–„Î´Îµâ–€Î¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Î„Â­Â±Ï…Ï†Ï‡Â§ÏˆÎ…Â°Â¨Ï‰Ï‹Î°ÏŽâ– \xA0"
+		},
+		"ibm869": "cp869",
+		"csibm869": "cp869",
+		"cp922": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â€¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ Ã‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÅ½ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿"
+		},
+		"ibm922": "cp922",
+		"csibm922": "cp922",
+		"cp1046": {
+			"type": "_sbcs",
+			"chars": "ïºˆÃ—Ã·ï£¶ï£µï£´ï£·ï¹±Âˆâ– â”‚â”€â”â”Œâ””â”˜ï¹¹ï¹»ï¹½ï¹¿ï¹·ïºŠï»°ï»³ï»²ï»Žï»ï»ï»¶ï»¸ï»ºï»¼\xA0ï£ºï£¹ï£¸Â¤ï£»ïº‹ïº‘ïº—ïº›ïºŸïº£ØŒÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Ø›ïº»ïº¿ï»ŠØŸï»‹Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»‡Ø¹Øºï»Œïº‚ïº„ïºŽï»“Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï»—ï»›ï»Ÿï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½"
+		},
+		"ibm1046": "cp1046",
+		"csibm1046": "cp1046",
+		"cp1124": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0ÐÐ‚ÒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ò‘Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
+		},
+		"ibm1124": "cp1124",
+		"csibm1124": "cp1124",
+		"cp1125": {
+			"type": "_sbcs",
+			"chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘ÒÒ‘Ð„Ñ”Ð†Ñ–Ð‡Ñ—Â·âˆšâ„–Â¤â– \xA0"
+		},
+		"ibm1125": "cp1125",
+		"csibm1125": "cp1125",
+		"cp1129": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
+		},
+		"ibm1129": "cp1129",
+		"csibm1129": "cp1129",
+		"cp1133": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0àºàº‚àº„àº‡àºˆàºªàºŠàºàº”àº•àº–àº—àº™àºšàº›àºœàºàºžàºŸàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»€à»à»‚à»ƒà»„à»ˆà»‰à»Šà»‹à»Œà»à»†ï¿½à»œà»â‚­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»‘à»’à»“à»”à»•à»–à»—à»˜à»™ï¿½ï¿½Â¢Â¬Â¦ï¿½"
+		},
+		"ibm1133": "cp1133",
+		"csibm1133": "cp1133",
+		"cp1161": {
+			"type": "_sbcs",
+			"chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹ˆà¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹‰à¹Šà¹‹â‚¬à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›Â¢Â¬Â¦\xA0"
+		},
+		"ibm1161": "cp1161",
+		"csibm1161": "cp1161",
+		"cp1162": {
+			"type": "_sbcs",
+			"chars": "â‚¬ÂÂ‚ÂƒÂ„â€¦Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
+		},
+		"ibm1162": "cp1162",
+		"csibm1162": "cp1162",
+		"cp1163": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Â¡Â¢Â£â‚¬Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
+		},
+		"ibm1163": "cp1163",
+		"csibm1163": "cp1163",
+		"maccroatian": {
+			"type": "_sbcs",
+			"chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆžÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºâ„¦Å¾Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦\xA0Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï¿½Â©â„Â¤â€¹â€ºÃ†Â»â€“Â·â€šâ€žâ€°Ã‚Ä‡ÃÄÃˆÃÃŽÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡"
+		},
+		"maccyrillic": {
+			"type": "_sbcs",
+			"chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°Â¢Â£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–Âµâˆ‚ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦\xA0Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
+		},
+		"macgreek": {
+			"type": "_sbcs",
+			"chars": "Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎžÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Î‡Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦\xA0Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎŽÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏŽÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°ï¿½"
+		},
+		"maciceland": {
+			"type": "_sbcs",
+			"chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦\xA0Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤ÃÃ°ÃžÃ¾Ã½Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
+		},
+		"macroman": {
+			"type": "_sbcs",
+			"chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦\xA0Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
+		},
+		"macromania": {
+			"type": "_sbcs",
+			"chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚ÅžâˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦ÄƒÅŸÂ¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦\xA0Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºÅ¢Å£â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
+		},
+		"macthai": {
+			"type": "_sbcs",
+			"chars": "Â«Â»â€¦ï¢Œï¢ï¢’ï¢•ï¢˜ï¢‹ï¢Žï¢‘ï¢”ï¢—â€œâ€ï¢™ï¿½â€¢ï¢„ï¢‰ï¢…ï¢†ï¢‡ï¢ˆï¢Šï¢ï¢ï¢“ï¢–â€˜â€™ï¿½\xA0à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï»¿â€‹â€“â€”à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹â„¢à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™Â®Â©ï¿½ï¿½ï¿½ï¿½"
+		},
+		"macturkish": {
+			"type": "_sbcs",
+			"chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦\xA0Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄžÄŸÄ°Ä±ÅžÅŸâ€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™ï¿½Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
+		},
+		"macukraine": {
+			"type": "_sbcs",
+			"chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°ÒÂ£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–ÂµÒ‘ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦\xA0Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
+		},
+		"koi8r": {
+			"type": "_sbcs",
+			"chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥\xA0âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘â•“â•”â••â•–â•—â•˜â•™â•šâ•›â•œâ•â•žâ•Ÿâ• â•¡Ðâ•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•ªâ•«â•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
+		},
+		"koi8u": {
+			"type": "_sbcs",
+			"chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥\xA0âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘â•â•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒâ•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
+		},
+		"koi8ru": {
+			"type": "_sbcs",
+			"chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥\xA0âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘Ñžâ•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒÐŽÂ©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
+		},
+		"koi8t": {
+			"type": "_sbcs",
+			"chars": "Ò›Ò“â€šÒ’â€žâ€¦â€ â€¡ï¿½â€°Ò³â€¹Ò²Ò·Ò¶ï¿½Òšâ€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®Ñ‘Â¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ðï¿½Ó¢Â¶Â·ï¿½â„–ï¿½Â»ï¿½ï¿½ï¿½Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
+		},
+		"armscii8": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0ï¿½Ö‡Ö‰)(Â»Â«â€”.Õ,-ÖŠâ€¦ÕœÕ›ÕžÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯Õ€Õ°ÕÕ±Õ‚Õ²ÕƒÕ³Õ„Õ´Õ…ÕµÕ†Õ¶Õ‡Õ·ÕˆÕ¸Õ‰Õ¹ÕŠÕºÕ‹Õ»ÕŒÕ¼ÕÕ½ÕŽÕ¾ÕÕ¿ÕÖ€Õ‘ÖÕ’Ö‚Õ“ÖƒÕ”Ö„Õ•Ö…Õ–Ö†Õšï¿½"
+		},
+		"rk1048": {
+			"type": "_sbcs",
+			"chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÒšÒºÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÒ›Ò»ÑŸ\xA0Ò°Ò±Ó˜Â¤Ó¨Â¦Â§ÐÂ©Ò’Â«Â¬Â­Â®Ò®Â°Â±Ð†Ñ–Ó©ÂµÂ¶Â·Ñ‘â„–Ò“Â»Ó™Ò¢Ò£Ò¯ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
+		},
+		"tcvn": {
+			"type": "_sbcs",
+			"chars": "\0Ãšá»¤á»ªá»¬á»®\x07\b	\n\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Ã€áº¢ÃƒÃáº áº¶áº¬Ãˆáººáº¼Ã‰áº¸á»†ÃŒá»ˆÄ¨Ãá»ŠÃ’á»ŽÃ•Ã“á»Œá»˜á»œá»žá» á»šá»¢Ã™á»¦Å¨\xA0Ä‚Ã‚ÃŠÃ”Æ Æ¯ÄÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘áº°Ì€Ì‰ÌƒÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»€áº·áº§áº©áº«áº¥áº­Ã¨á»‚áº»áº½Ã©áº¹á»á»ƒá»…áº¿á»‡Ã¬á»‰á»„áº¾á»’Ä©Ã­á»‹Ã²á»”á»ÃµÃ³á»á»“á»•á»—á»‘á»™á»á»Ÿá»¡á»›á»£Ã¹á»–á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»"
+		},
+		"georgianacademy": {
+			"type": "_sbcs",
+			"chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ¯áƒ°áƒ±áƒ²áƒ³áƒ´áƒµáƒ¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
+		},
+		"georgianps": {
+			"type": "_sbcs",
+			"chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸\xA0Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ±áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒ²áƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ³áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ´áƒ¯áƒ°áƒµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
+		},
+		"pt154": {
+			"type": "_sbcs",
+			"chars": "Ò–Ò’Ó®Ò“â€žâ€¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒšÒºÒ¸Ò—â€˜â€™â€œâ€â€¢â€“â€”Ò³Ò·Ò¡Ó£Ò£Ò›Ò»Ò¹\xA0ÐŽÑžÐˆÓ¨Ò˜Ò°Â§ÐÂ©Ó˜Â«Â¬Ó¯Â®ÒœÂ°Ò±Ð†Ñ–Ò™Ó©Â¶Â·Ñ‘â„–Ó™Â»Ñ˜ÒªÒ«ÒÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
+		},
+		"viscii": {
+			"type": "_sbcs",
+			"chars": "\0áº²áº´áºª\x07\b	\n\v\f\rá»¶á»¸\x1Bá»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»€á»‚á»„á»†á»á»’á»”á»–á»˜á»¢á»šá»œá»žá»Šá»Žá»Œá»ˆá»¦Å¨á»¤á»²Ã•áº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»ƒá»…á»‡á»‘á»“á»•á»—á» Æ á»™á»á»Ÿá»‹á»°á»¨á»ªá»¬Æ¡á»›Æ¯Ã€ÃÃ‚Ãƒáº¢Ä‚áº³áºµÃˆÃ‰ÃŠáººÃŒÃÄ¨á»³Äá»©Ã’Ã“Ã”áº¡á»·á»«á»­Ã™Ãšá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äƒá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»‰Ä‘á»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®"
+		},
+		"iso646cn": {
+			"type": "_sbcs",
+			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
+		},
+		"iso646jp": {
+			"type": "_sbcs",
+			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
+		},
+		"hproman8": {
+			"type": "_sbcs",
+			"chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ\xA0Ã€Ã‚ÃˆÃŠÃ‹ÃŽÃÂ´Ë‹Ë†Â¨ËœÃ™Ã›â‚¤Â¯ÃÃ½Â°Ã‡Ã§Ã‘Ã±Â¡Â¿Â¤Â£Â¥Â§Æ’Â¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼Ã…Ã®Ã˜Ã†Ã¥Ã­Ã¸Ã¦Ã„Ã¬Ã–ÃœÃ‰Ã¯ÃŸÃ”ÃÃƒÃ£ÃÃ°ÃÃŒÃ“Ã’Ã•ÃµÅ Å¡ÃšÅ¸Ã¿ÃžÃ¾Â·ÂµÂ¶Â¾â€”Â¼Â½ÂªÂºÂ«â– Â»Â±ï¿½"
+		},
+		"macintosh": {
+			"type": "_sbcs",
+			"chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦\xA0Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
+		},
+		"ascii": {
+			"type": "_sbcs",
+			"chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
+		},
+		"tis620": {
+			"type": "_sbcs",
+			"chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
+		}
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-codec.js
+var require_dbcs_codec = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-codec.js": ((exports) => {
+	var Buffer$3 = require_safer().Buffer;
+	exports._dbcs = DBCSCodec;
+	var UNASSIGNED = -1;
+	var GB18030_CODE = -2;
+	var SEQ_START = -10;
+	var NODE_START = -1e3;
+	var UNASSIGNED_NODE = new Array(256);
+	var DEF_CHAR = -1;
+	for (var i$2 = 0; i$2 < 256; i$2++) UNASSIGNED_NODE[i$2] = UNASSIGNED;
+	function DBCSCodec(codecOptions, iconv$1) {
+		this.encodingName = codecOptions.encodingName;
+		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
+		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
+		var mappingTable = codecOptions.table();
+		this.decodeTables = [];
+		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
+		this.decodeTableSeq = [];
+		for (var i$4 = 0; i$4 < mappingTable.length; i$4++) this._addDecodeChunk(mappingTable[i$4]);
+		if (typeof codecOptions.gb18030 === "function") {
+			this.gb18030 = codecOptions.gb18030();
+			var commonThirdByteNodeIdx = this.decodeTables.length;
+			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
+			var commonFourthByteNodeIdx = this.decodeTables.length;
+			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
+			var firstByteNode = this.decodeTables[0];
+			for (var i$4 = 129; i$4 <= 254; i$4++) {
+				var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i$4]];
+				for (var j = 48; j <= 57; j++) {
+					if (secondByteNode[j] === UNASSIGNED) secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
+					else if (secondByteNode[j] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 2");
+					var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
+					for (var k = 129; k <= 254; k++) {
+						if (thirdByteNode[k] === UNASSIGNED) thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
+						else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) continue;
+						else if (thirdByteNode[k] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 3");
+						var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
+						for (var l = 48; l <= 57; l++) if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;
+					}
+				}
+			}
+		}
+		this.defaultCharUnicode = iconv$1.defaultCharUnicode;
+		this.encodeTable = [];
+		this.encodeTableSeq = [];
+		var skipEncodeChars = {};
+		if (codecOptions.encodeSkipVals) for (var i$4 = 0; i$4 < codecOptions.encodeSkipVals.length; i$4++) {
+			var val = codecOptions.encodeSkipVals[i$4];
+			if (typeof val === "number") skipEncodeChars[val] = true;
+			else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
+		}
+		this._fillEncodeTable(0, 0, skipEncodeChars);
+		if (codecOptions.encodeAdd) {
+			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
+		}
+		this.defCharSB = this.encodeTable[0][iconv$1.defaultCharSingleByte.charCodeAt(0)];
+		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
+		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
+	}
+	DBCSCodec.prototype.encoder = DBCSEncoder;
+	DBCSCodec.prototype.decoder = DBCSDecoder;
+	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
+		var bytes = [];
+		for (; addr > 0; addr >>>= 8) bytes.push(addr & 255);
+		if (bytes.length == 0) bytes.push(0);
+		var node = this.decodeTables[0];
+		for (var i$4 = bytes.length - 1; i$4 > 0; i$4--) {
+			var val = node[bytes[i$4]];
+			if (val == UNASSIGNED) {
+				node[bytes[i$4]] = NODE_START - this.decodeTables.length;
+				this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
+			} else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
+			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
+		}
+		return node;
+	};
+	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
+		var curAddr = parseInt(chunk[0], 16);
+		var writeTable = this._getDecodeTrieNode(curAddr);
+		curAddr = curAddr & 255;
+		for (var k = 1; k < chunk.length; k++) {
+			var part = chunk[k];
+			if (typeof part === "string") for (var l = 0; l < part.length;) {
+				var code = part.charCodeAt(l++);
+				if (code >= 55296 && code < 56320) {
+					var codeTrail = part.charCodeAt(l++);
+					if (codeTrail >= 56320 && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
+					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
+				} else if (code > 4080 && code <= 4095) {
+					var len = 4095 - code + 2;
+					var seq = [];
+					for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
+					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
+					this.decodeTableSeq.push(seq);
+				} else writeTable[curAddr++] = code;
+			}
+			else if (typeof part === "number") {
+				var charCode = writeTable[curAddr - 1] + 1;
+				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
+			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
+		}
+		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
+	};
+	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
+		var high = uCode >> 8;
+		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
+		return this.encodeTable[high];
+	};
+	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
+		var bucket = this._getEncodeBucket(uCode);
+		var low = uCode & 255;
+		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
+		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
+	};
+	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
+		var uCode = seq[0];
+		var bucket = this._getEncodeBucket(uCode);
+		var low = uCode & 255;
+		var node;
+		if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
+		else {
+			node = {};
+			if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
+			bucket[low] = SEQ_START - this.encodeTableSeq.length;
+			this.encodeTableSeq.push(node);
+		}
+		for (var j = 1; j < seq.length - 1; j++) {
+			var oldVal = node[uCode];
+			if (typeof oldVal === "object") node = oldVal;
+			else {
+				node = node[uCode] = {};
+				if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
+			}
+		}
+		uCode = seq[seq.length - 1];
+		node[uCode] = dbcsCode;
+	};
+	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
+		var node = this.decodeTables[nodeIdx];
+		var hasValues = false;
+		var subNodeEmpty = {};
+		for (var i$4 = 0; i$4 < 256; i$4++) {
+			var uCode = node[i$4];
+			var mbCode = prefix + i$4;
+			if (skipEncodeChars[mbCode]) continue;
+			if (uCode >= 0) {
+				this._setEncodeChar(uCode, mbCode);
+				hasValues = true;
+			} else if (uCode <= NODE_START) {
+				var subNodeIdx = NODE_START - uCode;
+				if (!subNodeEmpty[subNodeIdx]) {
+					var newPrefix = mbCode << 8 >>> 0;
+					if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;
+					else subNodeEmpty[subNodeIdx] = true;
+				}
+			} else if (uCode <= SEQ_START) {
+				this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
+				hasValues = true;
+			}
+		}
+		return hasValues;
+	};
+	function DBCSEncoder(options, codec) {
+		this.leadSurrogate = -1;
+		this.seqObj = void 0;
+		this.encodeTable = codec.encodeTable;
+		this.encodeTableSeq = codec.encodeTableSeq;
+		this.defaultCharSingleByte = codec.defCharSB;
+		this.gb18030 = codec.gb18030;
+	}
+	DBCSEncoder.prototype.write = function(str) {
+		var newBuf = Buffer$3.alloc(str.length * (this.gb18030 ? 4 : 3));
+		var leadSurrogate = this.leadSurrogate;
+		var seqObj = this.seqObj;
+		var nextChar = -1;
+		var i$4 = 0;
+		var j = 0;
+		while (true) {
+			if (nextChar === -1) {
+				if (i$4 == str.length) break;
+				var uCode = str.charCodeAt(i$4++);
+			} else {
+				var uCode = nextChar;
+				nextChar = -1;
+			}
+			if (uCode >= 55296 && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
+				leadSurrogate = uCode;
+				continue;
+			} else {
+				leadSurrogate = uCode;
+				uCode = UNASSIGNED;
+			}
+			else if (leadSurrogate !== -1) {
+				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
+				leadSurrogate = -1;
+			} else uCode = UNASSIGNED;
+			else if (leadSurrogate !== -1) {
+				nextChar = uCode;
+				uCode = UNASSIGNED;
+				leadSurrogate = -1;
+			}
+			var dbcsCode = UNASSIGNED;
+			if (seqObj !== void 0 && uCode != UNASSIGNED) {
+				var resCode = seqObj[uCode];
+				if (typeof resCode === "object") {
+					seqObj = resCode;
+					continue;
+				} else if (typeof resCode === "number") dbcsCode = resCode;
+				else if (resCode == void 0) {
+					resCode = seqObj[DEF_CHAR];
+					if (resCode !== void 0) {
+						dbcsCode = resCode;
+						nextChar = uCode;
+					}
+				}
+				seqObj = void 0;
+			} else if (uCode >= 0) {
+				var subtable = this.encodeTable[uCode >> 8];
+				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
+				if (dbcsCode <= SEQ_START) {
+					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
+					continue;
+				}
+				if (dbcsCode == UNASSIGNED && this.gb18030) {
+					var idx = findIdx(this.gb18030.uChars, uCode);
+					if (idx != -1) {
+						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
+						newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
+						dbcsCode = dbcsCode % 12600;
+						newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
+						dbcsCode = dbcsCode % 1260;
+						newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
+						dbcsCode = dbcsCode % 10;
+						newBuf[j++] = 48 + dbcsCode;
+						continue;
+					}
+				}
+			}
+			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
+			if (dbcsCode < 256) newBuf[j++] = dbcsCode;
+			else if (dbcsCode < 65536) {
+				newBuf[j++] = dbcsCode >> 8;
+				newBuf[j++] = dbcsCode & 255;
+			} else if (dbcsCode < 16777216) {
+				newBuf[j++] = dbcsCode >> 16;
+				newBuf[j++] = dbcsCode >> 8 & 255;
+				newBuf[j++] = dbcsCode & 255;
+			} else {
+				newBuf[j++] = dbcsCode >>> 24;
+				newBuf[j++] = dbcsCode >>> 16 & 255;
+				newBuf[j++] = dbcsCode >>> 8 & 255;
+				newBuf[j++] = dbcsCode & 255;
+			}
+		}
+		this.seqObj = seqObj;
+		this.leadSurrogate = leadSurrogate;
+		return newBuf.slice(0, j);
+	};
+	DBCSEncoder.prototype.end = function() {
+		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
+		var newBuf = Buffer$3.alloc(10);
+		var j = 0;
+		if (this.seqObj) {
+			var dbcsCode = this.seqObj[DEF_CHAR];
+			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j++] = dbcsCode;
+			else {
+				newBuf[j++] = dbcsCode >> 8;
+				newBuf[j++] = dbcsCode & 255;
+			}
+			this.seqObj = void 0;
+		}
+		if (this.leadSurrogate !== -1) {
+			newBuf[j++] = this.defaultCharSingleByte;
+			this.leadSurrogate = -1;
+		}
+		return newBuf.slice(0, j);
+	};
+	DBCSEncoder.prototype.findIdx = findIdx;
+	function DBCSDecoder(options, codec) {
+		this.nodeIdx = 0;
+		this.prevBytes = [];
+		this.decodeTables = codec.decodeTables;
+		this.decodeTableSeq = codec.decodeTableSeq;
+		this.defaultCharUnicode = codec.defaultCharUnicode;
+		this.gb18030 = codec.gb18030;
+	}
+	DBCSDecoder.prototype.write = function(buf) {
+		var newBuf = Buffer$3.alloc(buf.length * 2);
+		var nodeIdx = this.nodeIdx;
+		var prevBytes = this.prevBytes;
+		var prevOffset = this.prevBytes.length;
+		var seqStart = -this.prevBytes.length;
+		var uCode;
+		for (var i$4 = 0, j = 0; i$4 < buf.length; i$4++) {
+			var curByte = i$4 >= 0 ? buf[i$4] : prevBytes[i$4 + prevOffset];
+			var uCode = this.decodeTables[nodeIdx][curByte];
+			if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
+				uCode = this.defaultCharUnicode.charCodeAt(0);
+				i$4 = seqStart;
+			} else if (uCode === GB18030_CODE) {
+				if (i$4 >= 3) var ptr = (buf[i$4 - 3] - 129) * 12600 + (buf[i$4 - 2] - 48) * 1260 + (buf[i$4 - 1] - 129) * 10 + (curByte - 48);
+				else var ptr = (prevBytes[i$4 - 3 + prevOffset] - 129) * 12600 + ((i$4 - 2 >= 0 ? buf[i$4 - 2] : prevBytes[i$4 - 2 + prevOffset]) - 48) * 1260 + ((i$4 - 1 >= 0 ? buf[i$4 - 1] : prevBytes[i$4 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
+				var idx = findIdx(this.gb18030.gbChars, ptr);
+				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
+			} else if (uCode <= NODE_START) {
+				nodeIdx = NODE_START - uCode;
+				continue;
+			} else if (uCode <= SEQ_START) {
+				var seq = this.decodeTableSeq[SEQ_START - uCode];
+				for (var k = 0; k < seq.length - 1; k++) {
+					uCode = seq[k];
+					newBuf[j++] = uCode & 255;
+					newBuf[j++] = uCode >> 8;
+				}
+				uCode = seq[seq.length - 1];
+			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
+			if (uCode >= 65536) {
+				uCode -= 65536;
+				var uCodeLead = 55296 | uCode >> 10;
+				newBuf[j++] = uCodeLead & 255;
+				newBuf[j++] = uCodeLead >> 8;
+				uCode = 56320 | uCode & 1023;
+			}
+			newBuf[j++] = uCode & 255;
+			newBuf[j++] = uCode >> 8;
+			nodeIdx = 0;
+			seqStart = i$4 + 1;
+		}
+		this.nodeIdx = nodeIdx;
+		this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
+		return newBuf.slice(0, j).toString("ucs2");
+	};
+	DBCSDecoder.prototype.end = function() {
+		var ret = "";
+		while (this.prevBytes.length > 0) {
+			ret += this.defaultCharUnicode;
+			var bytesArr = this.prevBytes.slice(1);
+			this.prevBytes = [];
+			this.nodeIdx = 0;
+			if (bytesArr.length > 0) ret += this.write(bytesArr);
+		}
+		this.prevBytes = [];
+		this.nodeIdx = 0;
+		return ret;
+	};
+	function findIdx(table, val) {
+		if (table[0] > val) return -1;
+		var l = 0;
+		var r = table.length;
+		while (l < r - 1) {
+			var mid = l + (r - l + 1 >> 1);
+			if (table[mid] <= val) l = mid;
+			else r = mid;
+		}
+		return l;
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/shiftjis.json
+var require_shiftjis = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/shiftjis.json": ((exports, module) => {
+	module.exports = [
+		[
+			"0",
+			"\0",
+			128
+		],
+		[
+			"a1",
+			"ï½¡",
+			62
+		],
+		[
+			"8140",
+			"ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
+			9,
+			"ï¼‹ï¼Â±Ã—"
+		],
+		["8180", "Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"],
+		["81b8", "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"],
+		["81c8", "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"],
+		["81da", "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"],
+		["81f0", "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"],
+		["81fc", "â—¯"],
+		[
+			"824f",
+			"ï¼",
+			9
+		],
+		[
+			"8260",
+			"ï¼¡",
+			25
+		],
+		[
+			"8281",
+			"ï½",
+			25
+		],
+		[
+			"829f",
+			"ã",
+			82
+		],
+		[
+			"8340",
+			"ã‚¡",
+			62
+		],
+		[
+			"8380",
+			"ãƒ ",
+			22
+		],
+		[
+			"839f",
+			"Î‘",
+			16,
+			"Î£",
+			6
+		],
+		[
+			"83bf",
+			"Î±",
+			16,
+			"Ïƒ",
+			6
+		],
+		[
+			"8440",
+			"Ð",
+			5,
+			"ÐÐ–",
+			25
+		],
+		[
+			"8470",
+			"Ð°",
+			5,
+			"Ñ‘Ð¶",
+			7
+		],
+		[
+			"8480",
+			"Ð¾",
+			17
+		],
+		["849f", "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"],
+		[
+			"8740",
+			"â‘ ",
+			19,
+			"â… ",
+			9
+		],
+		["875f", "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"],
+		["877e", "ã»"],
+		[
+			"8780",
+			"ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
+			4,
+			"ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
+		],
+		["889f", "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"],
+		["8940", "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††"],
+		["8980", "åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œæŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"],
+		["8a40", "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«"],
+		["8a80", "æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"],
+		["8b40", "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘"],
+		["8b80", "æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"],
+		["8c40", "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨"],
+		["8c80", "åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"],
+		["8d40", "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™"],
+		["8d80", "é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"],
+		["8e40", "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢"],
+		["8e80", "æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"],
+		["8f40", "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³"],
+		["8f80", "æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿå‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"],
+		["9040", "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨"],
+		["9080", "é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"],
+		["9140", "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»"],
+		["9180", "æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Žè‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"],
+		["9240", "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„"],
+		["9280", "é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µå¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"],
+		["9340", "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬"],
+		["9380", "å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"],
+		["9440", "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…"],
+		["9480", "æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"],
+		["9540", "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·"],
+		["9580", "æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"],
+		["9640", "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†"],
+		["9680", "æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"],
+		["9740", "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²"],
+		["9780", "æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"],
+		["9840", "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"],
+		["989f", "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"],
+		["9940", "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­"],
+		["9980", "å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"],
+		["9a40", "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸"],
+		["9a80", "å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"],
+		["9b40", "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€"],
+		["9b80", "å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"],
+		["9c40", "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ "],
+		["9c80", "æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚šæ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"],
+		["9d40", "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«"],
+		["9d80", "æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"],
+		["9e40", "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Ž"],
+		["9e80", "æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"],
+		["9f40", "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯"],
+		["9f80", "éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"],
+		["e040", "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒ"],
+		["e080", "çƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"],
+		["e140", "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿"],
+		["e180", "ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"],
+		["e240", "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°"],
+		["e280", "çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"],
+		["e340", "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·"],
+		["e380", "ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼ºç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"],
+		["e440", "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤"],
+		["e480", "è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"],
+		["e540", "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬"],
+		["e580", "è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"],
+		["e640", "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§"],
+		["e680", "è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"],
+		["e740", "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œ"],
+		["e780", "è½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"],
+		["e840", "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™"],
+		["e880", "é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™žé™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"],
+		["e940", "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒ"],
+		["e980", "é¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"],
+		["ea40", "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯"],
+		["ea80", "é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ å ¯æ§‡é™ç‘¤å‡œç†™"],
+		["ed40", "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨"],
+		["ed80", "ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"],
+		["ee40", "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™"],
+		["ee80", "è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"],
+		[
+			"eeef",
+			"â…°",
+			9,
+			"ï¿¢ï¿¤ï¼‡ï¼‚"
+		],
+		[
+			"f040",
+			"î€€",
+			62
+		],
+		[
+			"f080",
+			"î€¿",
+			124
+		],
+		[
+			"f140",
+			"î‚¼",
+			62
+		],
+		[
+			"f180",
+			"îƒ»",
+			124
+		],
+		[
+			"f240",
+			"î…¸",
+			62
+		],
+		[
+			"f280",
+			"î†·",
+			124
+		],
+		[
+			"f340",
+			"îˆ´",
+			62
+		],
+		[
+			"f380",
+			"î‰³",
+			124
+		],
+		[
+			"f440",
+			"î‹°",
+			62
+		],
+		[
+			"f480",
+			"îŒ¯",
+			124
+		],
+		[
+			"f540",
+			"îŽ¬",
+			62
+		],
+		[
+			"f580",
+			"î«",
+			124
+		],
+		[
+			"f640",
+			"î‘¨",
+			62
+		],
+		[
+			"f680",
+			"î’§",
+			124
+		],
+		[
+			"f740",
+			"î”¤",
+			62
+		],
+		[
+			"f780",
+			"î•£",
+			124
+		],
+		[
+			"f840",
+			"î— ",
+			62
+		],
+		[
+			"f880",
+			"î˜Ÿ",
+			124
+		],
+		["f940", "îšœ"],
+		[
+			"fa40",
+			"â…°",
+			9,
+			"â… ",
+			9,
+			"ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡âˆµçºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Š"
+		],
+		["fa80", "å…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯"],
+		["fb40", "æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™"],
+		["fb80", "ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™"],
+		["fc40", "é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"]
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/eucjp.json
+var require_eucjp = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/eucjp.json": ((exports, module) => {
+	module.exports = [
+		[
+			"0",
+			"\0",
+			127
+		],
+		[
+			"8ea1",
+			"ï½¡",
+			62
+		],
+		[
+			"a1a1",
+			"ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
+			9,
+			"ï¼‹ï¼Â±Ã—Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡"
+		],
+		["a2a1", "â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"],
+		["a2ba", "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"],
+		["a2ca", "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"],
+		["a2dc", "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"],
+		["a2f2", "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"],
+		["a2fe", "â—¯"],
+		[
+			"a3b0",
+			"ï¼",
+			9
+		],
+		[
+			"a3c1",
+			"ï¼¡",
+			25
+		],
+		[
+			"a3e1",
+			"ï½",
+			25
+		],
+		[
+			"a4a1",
+			"ã",
+			82
+		],
+		[
+			"a5a1",
+			"ã‚¡",
+			85
+		],
+		[
+			"a6a1",
+			"Î‘",
+			16,
+			"Î£",
+			6
+		],
+		[
+			"a6c1",
+			"Î±",
+			16,
+			"Ïƒ",
+			6
+		],
+		[
+			"a7a1",
+			"Ð",
+			5,
+			"ÐÐ–",
+			25
+		],
+		[
+			"a7d1",
+			"Ð°",
+			5,
+			"Ñ‘Ð¶",
+			25
+		],
+		["a8a1", "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"],
+		[
+			"ada1",
+			"â‘ ",
+			19,
+			"â… ",
+			9
+		],
+		["adc0", "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"],
+		[
+			"addf",
+			"ã»ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
+			4,
+			"ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
+		],
+		["b0a1", "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"],
+		["b1a1", "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œ"],
+		["b2a1", "æŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"],
+		["b3a1", "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±"],
+		["b4a1", "ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"],
+		["b5a1", "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬"],
+		["b6a1", "ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"],
+		["b7a1", "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²"],
+		["b8a1", "æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"],
+		["b9a1", "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼"],
+		["baa1", "æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"],
+		["bba1", "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚"],
+		["bca1", "æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"],
+		["bda1", "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿ"],
+		["bea1", "å‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"],
+		["bfa1", "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾"],
+		["c0a1", "æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"],
+		["c1a1", "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Ž"],
+		["c2a1", "è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"],
+		["c3a1", "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µ"],
+		["c4a1", "å¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"],
+		["c5a1", "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°"],
+		["c6a1", "è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"],
+		["c7a1", "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦"],
+		["c8a1", "å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"],
+		["c9a1", "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœ"],
+		["caa1", "ç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"],
+		["cba1", "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€"],
+		["cca1", "æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"],
+		["cda1", "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒ"],
+		["cea1", "ç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"],
+		["cfa1", "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"],
+		["d0a1", "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"],
+		["d1a1", "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨"],
+		["d2a1", "è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"],
+		["d3a1", "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰"],
+		["d4a1", "åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"],
+		["d5a1", "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“"],
+		["d6a1", "å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"],
+		["d7a1", "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚š"],
+		["d8a1", "æ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"],
+		["d9a1", "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼"],
+		["daa1", "æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"],
+		["dba1", "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Žæ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£"],
+		["dca1", "æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"],
+		["dda1", "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾"],
+		["dea1", "æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"],
+		["dfa1", "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒçƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼"],
+		["e0a1", "ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"],
+		["e1a1", "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°"],
+		["e2a1", "ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"],
+		["e3a1", "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­"],
+		["e4a1", "ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"],
+		["e5a1", "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼º"],
+		["e6a1", "ç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"],
+		["e7a1", "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™"],
+		["e8a1", "èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"],
+		["e9a1", "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™"],
+		["eaa1", "è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"],
+		["eba1", "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«"],
+		["eca1", "è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"],
+		["eda1", "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œè½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸"],
+		["eea1", "ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"],
+		["efa1", "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™ž"],
+		["f0a1", "é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"],
+		["f1a1", "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒé¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·"],
+		["f2a1", "é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"],
+		["f3a1", "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ "],
+		["f4a1", "å ¯æ§‡é™ç‘¤å‡œç†™"],
+		["f9a1", "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·"],
+		["faa1", "å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"],
+		["fba1", "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡š"],
+		["fca1", "é‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"],
+		[
+			"fcf1",
+			"â…°",
+			9,
+			"ï¿¢ï¿¤ï¼‡ï¼‚"
+		],
+		["8fa2af", "Ë˜Ë‡Â¸Ë™ËÂ¯Ë›Ëšï½žÎ„Î…"],
+		["8fa2c2", "Â¡Â¦Â¿"],
+		["8fa2eb", "ÂºÂªÂ©Â®â„¢Â¤â„–"],
+		["8fa6e1", "Î†ÎˆÎ‰ÎŠÎª"],
+		["8fa6e7", "ÎŒ"],
+		["8fa6e9", "ÎŽÎ«"],
+		["8fa6ec", "Î"],
+		["8fa6f1", "Î¬Î­Î®Î¯ÏŠÎÏŒÏ‚ÏÏ‹Î°ÏŽ"],
+		[
+			"8fa7c2",
+			"Ð‚",
+			10,
+			"ÐŽÐ"
+		],
+		[
+			"8fa7f2",
+			"Ñ’",
+			10,
+			"ÑžÑŸ"
+		],
+		["8fa9a1", "Ã†Ä"],
+		["8fa9a4", "Ä¦"],
+		["8fa9a6", "Ä²"],
+		["8fa9a8", "ÅÄ¿"],
+		["8fa9ab", "ÅŠÃ˜Å’"],
+		["8fa9af", "Å¦Ãž"],
+		["8fa9c1", "Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å‚Å€Å‰Å‹Ã¸Å“ÃŸÅ§Ã¾"],
+		["8faaa1", "ÃÃ€Ã„Ã‚Ä‚ÇÄ€Ä„Ã…ÃƒÄ†ÄˆÄŒÃ‡ÄŠÄŽÃ‰ÃˆÃ‹ÃŠÄšÄ–Ä’Ä˜"],
+		["8faaba", "ÄœÄžÄ¢Ä Ä¤ÃÃŒÃÃŽÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅƒÅ‡Å…Ã‘Ã“Ã’Ã–Ã”Ç‘ÅÅŒÃ•Å”Å˜Å–ÅšÅœÅ ÅžÅ¤Å¢ÃšÃ™ÃœÃ›Å¬Ç“Å°ÅªÅ²Å®Å¨Ç—Ç›Ç™Ç•Å´ÃÅ¸Å¶Å¹Å½Å»"],
+		["8faba1", "Ã¡Ã Ã¤Ã¢ÄƒÇŽÄÄ…Ã¥Ã£Ä‡Ä‰ÄÃ§Ä‹ÄÃ©Ã¨Ã«ÃªÄ›Ä—Ä“Ä™ÇµÄÄŸ"],
+		["8fabbd", "Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"],
+		["8fabc5", "Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼Å„ÅˆÅ†Ã±Ã³Ã²Ã¶Ã´Ç’Å‘ÅÃµÅ•Å™Å—Å›ÅÅ¡ÅŸÅ¥Å£ÃºÃ¹Ã¼Ã»Å­Ç”Å±Å«Å³Å¯Å©Ç˜ÇœÇšÇ–ÅµÃ½Ã¿Å·ÅºÅ¾Å¼"],
+		["8fb0a1", "ä¸‚ä¸„ä¸…ä¸Œä¸’ä¸Ÿä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹€ä¹ä¹„ä¹‡ä¹‘ä¹šä¹œä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäº–äº—äºäº¯äº¹ä»ƒä»ä»šä»›ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼€ä¼‚ä¼ƒä¼ˆä¼‹ä¼Œä¼’ä¼•ä¼–ä¼—ä¼™ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½€ä½‚ä½ˆä½‰ä½‹ä½Œä½’ä½”ä½–ä½˜ä½Ÿä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾‚ä¾„"],
+		["8fb1a1", "ä¾…ä¾‰ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾”ä¾—ä¾™ä¾šä¾žä¾Ÿä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿€ä¿ä¿…ä¿†ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿ä¿’ä¿œä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿å€€å€å€„å€‡å€Šå€Œå€Žå€å€“å€—å€˜å€›å€œå€å€žå€¢å€§å€®å€°å€²å€³å€µå€åå‚å…å†åŠåŒåŽå‘å’å“å—å™åŸå å¢å£å¦å§åªå­å°å±å€»å‚å‚ƒå‚„å‚†å‚Šå‚Žå‚å‚"],
+		[
+			"8fb2a1",
+			"å‚’å‚“å‚”å‚–å‚›å‚œå‚ž",
+			4,
+			"å‚ªå‚¯å‚°å‚¹å‚ºå‚½åƒ€åƒƒåƒ„åƒ‡åƒŒåƒŽåƒåƒ“åƒ”åƒ˜åƒœåƒåƒŸåƒ¢åƒ¤åƒ¦åƒ¨åƒ©åƒ¯åƒ±åƒ¶åƒºåƒ¾å„ƒå„†å„‡å„ˆå„‹å„Œå„å„Žåƒ²å„å„—å„™å„›å„œå„å„žå„£å„§å„¨å„¬å„­å„¯å„±å„³å„´å„µå„¸å„¹å…‚å…Šå…å…“å…•å…—å…˜å…Ÿå…¤å…¦å…¾å†ƒå†„å†‹å†Žå†˜å†å†¡å†£å†­å†¸å†ºå†¼å†¾å†¿å‡‚"
+		],
+		["8fb3a1", "å‡ˆå‡å‡‘å‡’å‡“å‡•å‡˜å‡žå‡¢å‡¥å‡®å‡²å‡³å‡´å‡·åˆåˆ‚åˆ…åˆ’åˆ“åˆ•åˆ–åˆ˜åˆ¢åˆ¨åˆ±åˆ²åˆµåˆ¼å‰…å‰‰å‰•å‰—å‰˜å‰šå‰œå‰Ÿå‰ å‰¡å‰¦å‰®å‰·å‰¸å‰¹åŠ€åŠ‚åŠ…åŠŠåŠŒåŠ“åŠ•åŠ–åŠ—åŠ˜åŠšåŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ¯åŠ°åŠ¶åŠ·åŠ¸åŠºåŠ»åŠ½å‹€å‹„å‹†å‹ˆå‹Œå‹å‹‘å‹”å‹–å‹›å‹œå‹¡å‹¥å‹¨å‹©å‹ªå‹¬å‹°å‹±å‹´å‹¶å‹·åŒ€åŒƒåŒŠåŒ‹"],
+		["8fb4a1", "åŒŒåŒ‘åŒ“åŒ˜åŒ›åŒœåŒžåŒŸåŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ°åŒ²åŒµåŒ¼åŒ½åŒ¾å‚åŒå‹å™å›å¡å£å¥å¬å­å²å¹å¾åŽƒåŽ‡åŽˆåŽŽåŽ“åŽ”åŽ™åŽåŽ¡åŽ¤åŽªåŽ«åŽ¯åŽ²åŽ´åŽµåŽ·åŽ¸åŽºåŽ½å€å…åå’å“å•åšååžå å¦å§åµå‚å“åšå¡å§å¨åªå¯å±å´åµå‘ƒå‘„å‘‡å‘å‘å‘žå‘¢å‘¤å‘¦å‘§å‘©å‘«å‘­å‘®å‘´å‘¿"],
+		["8fb5a1", "å’å’ƒå’…å’ˆå’‰å’å’‘å’•å’–å’œå’Ÿå’¡å’¦å’§å’©å’ªå’­å’®å’±å’·å’¹å’ºå’»å’¿å“†å“Šå“å“Žå“ å“ªå“¬å“¯å“¶å“¼å“¾å“¿å”€å”å”…å”ˆå”‰å”Œå”å”Žå”•å”ªå”«å”²å”µå”¶å”»å”¼å”½å•å•‡å•‰å•Šå•å•å•‘å•˜å•šå•›å•žå• å•¡å•¤å•¦å•¿å–å–‚å–†å–ˆå–Žå–å–‘å–’å–“å–”å–—å–£å–¤å–­å–²å–¿å—å—ƒå—†å—‰å—‹å—Œå—Žå—‘å—’"],
+		[
+			"8fb6a1",
+			"å—“å——å—˜å—›å—žå—¢å—©å—¶å—¿å˜…å˜ˆå˜Šå˜",
+			5,
+			"å˜™å˜¬å˜°å˜³å˜µå˜·å˜¹å˜»å˜¼å˜½å˜¿å™€å™å™ƒå™„å™†å™‰å™‹å™å™å™”å™žå™ å™¡å™¢å™£å™¦å™©å™­å™¯å™±å™²å™µåš„åš…åšˆåš‹åšŒåš•åš™åššåšåšžåšŸåš¦åš§åš¨åš©åš«åš¬åš­åš±åš³åš·åš¾å›…å›‰å›Šå›‹å›å›å›Œå›å›™å›œå›å›Ÿå›¡å›¤",
+			4,
+			"å›±å›«å›­"
+		],
+		[
+			"8fb7a1",
+			"å›¶å›·åœåœ‚åœ‡åœŠåœŒåœ‘åœ•åœšåœ›åœåœ åœ¢åœ£åœ¤åœ¥åœ©åœªåœ¬åœ®åœ¯åœ³åœ´åœ½åœ¾åœ¿å…å†åŒåå’å¢å¥å§å¨å«å­",
+			4,
+			"å³å´åµå·å¹åºå»å¼å¾åžåžƒåžŒåž”åž—åž™åžšåžœåžåžžåžŸåž¡åž•åž§åž¨åž©åž¬åž¸åž½åŸ‡åŸˆåŸŒåŸåŸ•åŸåŸžåŸ¤åŸ¦åŸ§åŸ©åŸ­åŸ°åŸµåŸ¶åŸ¸åŸ½åŸ¾åŸ¿å ƒå „å ˆå ‰åŸ¡"
+		],
+		["8fb8a1", "å Œå å ›å žå Ÿå  å ¦å §å ­å ²å ¹å ¿å¡‰å¡Œå¡å¡å¡å¡•å¡Ÿå¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢€å¢å¢‡å¢ˆå¢‰å¢Šå¢Œå¢å¢å¢å¢”å¢–å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£„å¢¼å£‚å£ˆå£å£Žå£å£’å£”å£–å£šå£å£¡å£¢å£©å£³å¤…å¤†å¤‹å¤Œå¤’å¤“å¤”è™å¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥ƒå¥†å¥’å¥“å¥™å¥›å¥å¥žå¥Ÿå¥¡å¥£å¥«å¥­"],
+		["8fb9a1", "å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦‹å¦Œå¦Žå¦’å¦•å¦—å¦Ÿå¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§ƒå§„å§ˆå§Šå§å§’å§å§žå§Ÿå§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨€å¨„å¨Œå¨å¨Žå¨’å¨“å¨žå¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©„å©…å©‡å©ˆå©Œå©å©•å©žå©£å©¥å©§å©­å©·å©ºå©»å©¾åª‹åªåª“åª–åª™åªœåªžåªŸåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿"],
+		[
+			"8fbaa1",
+			"å«„å«†å«ˆå«å«šå«œå« å«¥å«ªå«®å«µå«¶å«½å¬€å¬å¬ˆå¬—å¬´å¬™å¬›å¬å¬¡å¬¥å¬­å¬¸å­å­‹å­Œå­’å­–å­žå­¨å­®å­¯å­¼å­½å­¾å­¿å®å®„å®†å®Šå®Žå®å®‘å®“å®”å®–å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯€å¯å¯å¯å¯–",
+			4,
+			"å¯ å¯¯å¯±å¯´å¯½å°Œå°—å°žå°Ÿå°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±™å±šå±œå±¢å±£å±§å±¨å±©"
+		],
+		["8fbba1", "å±­å±°å±´å±µå±ºå±»å±¼å±½å²‡å²ˆå²Šå²å²’å²å²Ÿå² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³‰å³‹å³’å³å³—å³®å³±å³²å³´å´å´†å´å´’å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµ‚åµƒåµ†åµˆåµ•åµ‘åµ™åµŠåµŸåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶ƒå¶ˆå¶Šå¶’å¶“å¶”å¶•å¶™å¶›å¶Ÿå¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·ƒå·‡å·‹å·å·Žå·˜å·™å· å·¤"],
+		[
+			"8fbca1",
+			"å·©å·¸å·¹å¸€å¸‡å¸å¸’å¸”å¸•å¸˜å¸Ÿå¸ å¸®å¸¨å¸²å¸µå¸¾å¹‹å¹å¹‰å¹‘å¹–å¹˜å¹›å¹œå¹žå¹¨å¹ª",
+			4,
+			"å¹°åº€åº‹åºŽåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»†å»Œå»‹å»Žå»‘å»’å»”å»•å»œå»žå»¥å»«å¼‚å¼†å¼‡å¼ˆå¼Žå¼™å¼œå¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½€å½„å½…å½‡å½å½å½”å½˜å½›å½ å½£å½¤å½§"
+		],
+		[
+			"8fbda1",
+			"å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾‰å¾å¾å¾–å¾œå¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿„å¿‡å¿ˆå¿‰å¿‹å¿",
+			4,
+			"å¿žå¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼æ€‡æ€Šæ€æ€“æ€”æ€—æ€˜æ€šæ€Ÿæ€¤æ€­æ€³æ€µæ€æ‡æˆæ‰æŒæ‘æ”æ–æ—ææ¡æ§æ±æ¾æ¿æ‚‚æ‚†æ‚ˆæ‚Šæ‚Žæ‚‘æ‚“æ‚•æ‚˜æ‚æ‚žæ‚¢æ‚¤æ‚¥æ‚¨æ‚°æ‚±æ‚·"
+		],
+		[
+			"8fbea1",
+			"æ‚»æ‚¾æƒ‚æƒ„æƒˆæƒ‰æƒŠæƒ‹æƒŽæƒæƒ”æƒ•æƒ™æƒ›æƒæƒžæƒ¢æƒ¥æƒ²æƒµæƒ¸æƒ¼æƒ½æ„‚æ„‡æ„Šæ„Œæ„",
+			4,
+			"æ„–æ„—æ„™æ„œæ„žæ„¢æ„ªæ„«æ„°æ„±æ„µæ„¶æ„·æ„¹æ…æ……æ…†æ…‰æ…žæ… æ…¬æ…²æ…¸æ…»æ…¼æ…¿æ†€æ†æ†ƒæ†„æ†‹æ†æ†’æ†“æ†—æ†˜æ†œæ†æ†Ÿæ† æ†¥æ†¨æ†ªæ†­æ†¸æ†¹æ†¼æ‡€æ‡æ‡‚æ‡Žæ‡æ‡•æ‡œæ‡æ‡žæ‡Ÿæ‡¡æ‡¢æ‡§æ‡©æ‡¥"
+		],
+		["8fbfa1", "æ‡¬æ‡­æ‡¯æˆæˆƒæˆ„æˆ‡æˆ“æˆ•æˆœæˆ æˆ¢æˆ£æˆ§æˆ©æˆ«æˆ¹æˆ½æ‰‚æ‰ƒæ‰„æ‰†æ‰Œæ‰æ‰‘æ‰’æ‰”æ‰–æ‰šæ‰œæ‰¤æ‰­æ‰¯æ‰³æ‰ºæ‰½æŠæŠŽæŠæŠæŠ¦æŠ¨æŠ³æŠ¶æŠ·æŠºæŠ¾æŠ¿æ‹„æ‹Žæ‹•æ‹–æ‹šæ‹ªæ‹²æ‹´æ‹¼æ‹½æŒƒæŒ„æŒŠæŒ‹æŒæŒæŒ“æŒ–æŒ˜æŒ©æŒªæŒ­æŒµæŒ¶æŒ¹æŒ¼ææ‚æƒæ„æ†æŠæ‹æŽæ’æ“æ”æ˜æ›æ¥æ¦æ¬æ­æ±æ´æµ"],
+		["8fc0a1", "æ¸æ¼æ½æ¿æŽ‚æŽ„æŽ‡æŽŠæŽæŽ”æŽ•æŽ™æŽšæŽžæŽ¤æŽ¦æŽ­æŽ®æŽ¯æŽ½ææ…æˆæŽæ‘æ“æ”æ•æœæ æ¥æªæ¬æ²æ³æµæ¸æ¹æ‰æŠææ’æ”æ˜æžæ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿æ‘‹æ‘æ‘‘æ‘’æ‘“æ‘”æ‘šæ‘›æ‘œæ‘æ‘Ÿæ‘ æ‘¡æ‘£æ‘­æ‘³æ‘´æ‘»æ‘½æ’…æ’‡æ’æ’æ’‘æ’˜æ’™æ’›æ’æ’Ÿæ’¡æ’£æ’¦æ’¨æ’¬æ’³æ’½æ’¾æ’¿"],
+		["8fc1a1", "æ“„æ“‰æ“Šæ“‹æ“Œæ“Žæ“æ“‘æ“•æ“—æ“¤æ“¥æ“©æ“ªæ“­æ“°æ“µæ“·æ“»æ“¿æ”æ”„æ”ˆæ”‰æ”Šæ”æ”“æ””æ”–æ”™æ”›æ”žæ”Ÿæ”¢æ”¦æ”©æ”®æ”±æ”ºæ”¼æ”½æ•ƒæ•‡æ•‰æ•æ•’æ•”æ•Ÿæ• æ•§æ•«æ•ºæ•½æ–æ–…æ–Šæ–’æ–•æ–˜æ–æ– æ–£æ–¦æ–®æ–²æ–³æ–´æ–¿æ—‚æ—ˆæ—‰æ—Žæ—æ—”æ—–æ—˜æ—Ÿæ—°æ—²æ—´æ—µæ—¹æ—¾æ—¿æ˜€æ˜„æ˜ˆæ˜‰æ˜æ˜‘æ˜’æ˜•æ˜–æ˜"],
+		["8fc2a1", "æ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜±æ˜³æ˜¹æ˜·æ™€æ™…æ™†æ™Šæ™Œæ™‘æ™Žæ™—æ™˜æ™™æ™›æ™œæ™ æ™¡æ›»æ™ªæ™«æ™¬æ™¾æ™³æ™µæ™¿æ™·æ™¸æ™¹æ™»æš€æ™¼æš‹æšŒæšæšæš’æš™æššæš›æšœæšŸæš æš¤æš­æš±æš²æšµæš»æš¿æ›€æ›‚æ›ƒæ›ˆæ›Œæ›Žæ›æ›”æ››æ›Ÿæ›¨æ›«æ›¬æ›®æ›ºæœ…æœ‡æœŽæœ“æœ™æœœæœ æœ¢æœ³æœ¾æ…æ‡æˆæŒæ”æ•æ"],
+		[
+			"8fc3a1",
+			"æ¦æ¬æ®æ´æ¶æ»æžæž„æžŽæžæž‘æž“æž–æž˜æž™æž›æž°æž±æž²æžµæž»æž¼æž½æŸ¹æŸ€æŸ‚æŸƒæŸ…æŸˆæŸ‰æŸ’æŸ—æŸ™æŸœæŸ¡æŸ¦æŸ°æŸ²æŸ¶æŸ·æ¡’æ ”æ ™æ æ Ÿæ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡„æ¡…æ¡Šæ¡Œæ¡•æ¡—æ¡˜æ¡›æ¡«æ¡®",
+			4,
+			"æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢‚æ¢„æ¢†æ¢ˆæ¢–æ¢˜æ¢šæ¢œæ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£…æ£ˆæ£Œæ£"
+		],
+		["8fc4a1", "æ£æ£‘æ£“æ£–æ£™æ£œæ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤†æ¤‰æ¤Šæ¤æ¤‘æ¤“æ¤–æ¤—æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥‚æ¥…æ¥‰æ¥Žæ¥—æ¥›æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦€æ¦æ¦’æ¦–æ¦˜æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§…æ§ˆæ§‘æ§–æ§—æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨€æ¨æ¨ƒæ¨æ¨‘æ¨•æ¨šæ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²"],
+		["8fc5a1", "æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©…æ©†æ©‰æ©Šæ©Žæ©æ©‘æ©’æ©•æ©–æ©›æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªƒæª†æª‡æª‰æª‹æª‘æª›æªæªžæªŸæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«†æ«‰æ«ˆæ«Œæ«æ«”æ«•æ«–æ«œæ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬‚æ¬ƒæ¬†æ¬‡æ¬‰æ¬æ¬æ¬‘æ¬—æ¬›æ¬žæ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­†æ­Šæ­æ­’æ­–æ­˜æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½"],
+		["8fc6a1", "æ­¾æ®‚æ®…æ®—æ®›æ®Ÿæ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯ƒæ¯„æ¯‰æ¯Œæ¯–æ¯šæ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°‚æ°„æ°…æ°‰æ°æ°Žæ°æ°’æ°™æ°Ÿæ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±Šæ±‹æ±æ±æ±’æ±”æ±™æ±›æ±œæ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²…æ²†æ²‡æ²‰æ²”æ²•æ²—æ²˜æ²œæ²Ÿæ²°æ²²æ²´æ³‚æ³†æ³æ³æ³æ³‘æ³’æ³”æ³–"],
+		["8fc7a1", "æ³šæ³œæ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´„æ´‡æ´Šæ´Žæ´æ´‘æ´“æ´šæ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµ—æµžæµŸæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶‚æ¶‡æ¶‘æ¶’æ¶”æ¶–æ¶—æ¶˜æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·„æ·ˆæ·Šæ·Žæ·æ·–æ·›æ·æ·Ÿæ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸€æ¸„æ¸žæ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹„æ¹…æ¹ˆæ¹‰æ¹‹æ¹æ¹‘æ¹’æ¹“æ¹”æ¹—æ¹œæ¹æ¹ž"],
+		["8fc8a1", "æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæº“æº™æº æº§æº­æº®æº±æº³æº»æº¿æ»€æ»æ»ƒæ»‡æ»ˆæ»Šæ»æ»Žæ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼„æ¼ˆæ¼Šæ¼Œæ¼æ¼–æ¼˜æ¼šæ¼›æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½‘æ½’æ½“æ½—æ½™æ½šæ½æ½žæ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾ƒæ¾‡æ¾ˆæ¾‹æ¾Œæ¾æ¾æ¾’æ¾“æ¾”æ¾–æ¾šæ¾Ÿæ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿…æ¿‡æ¿ˆæ¿Š"],
+		[
+			"8fc9a1",
+			"æ¿šæ¿žæ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ç€€ç€…ç€†ç€‡ç€ç€—ç€ ç€£ç€¯ç€´ç€·ç€¹ç€¼çƒç„çˆç‰çŠç‹ç”ç•ççžçŽç¤ç¥ç¬ç®çµç¶ç¾ç‚ç‚…ç‚†ç‚”",
+			4,
+			"ç‚›ç‚¤ç‚«ç‚°ç‚±ç‚´ç‚·çƒŠçƒ‘çƒ“çƒ”çƒ•çƒ–çƒ˜çƒœçƒ¤çƒºç„ƒ",
+			4,
+			"ç„‹ç„Œç„ç„žç„ ç„«ç„­ç„¯ç„°ç„±ç„¸ç…ç……ç…†ç…‡ç…Šç…‹ç…ç…’ç…—ç…šç…œç…žç… "
+		],
+		["8fcaa1", "ç…¨ç…¹ç†€ç†…ç†‡ç†Œç†’ç†šç†›ç† ç†¢ç†¯ç†°ç†²ç†³ç†ºç†¿ç‡€ç‡ç‡„ç‡‹ç‡Œç‡“ç‡–ç‡™ç‡šç‡œç‡¸ç‡¾çˆ€çˆ‡çˆˆçˆ‰çˆ“çˆ—çˆšçˆçˆŸçˆ¤çˆ«çˆ¯çˆ´çˆ¸çˆ¹ç‰ç‰‚ç‰ƒç‰…ç‰Žç‰ç‰ç‰“ç‰•ç‰–ç‰šç‰œç‰žç‰ ç‰£ç‰¨ç‰«ç‰®ç‰¯ç‰±ç‰·ç‰¸ç‰»ç‰¼ç‰¿çŠ„çŠ‰çŠçŠŽçŠ“çŠ›çŠ¨çŠ­çŠ®çŠ±çŠ´çŠ¾ç‹ç‹‡ç‹‰ç‹Œç‹•ç‹–ç‹˜ç‹Ÿç‹¥ç‹³ç‹´ç‹ºç‹»"],
+		["8fcba1", "ç‹¾çŒ‚çŒ„çŒ…çŒ‡çŒ‹çŒçŒ’çŒ“çŒ˜çŒ™çŒžçŒ¢çŒ¤çŒ§çŒ¨çŒ¬çŒ±çŒ²çŒµçŒºçŒ»çŒ½çƒççç’ç–ç˜ççžçŸç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼çŽ€çŽçŽƒçŽ…çŽ†çŽŽçŽçŽ“çŽ•çŽ—çŽ˜çŽœçŽžçŽŸçŽ çŽ¢çŽ¥çŽ¦çŽªçŽ«çŽ­çŽµçŽ·çŽ¹çŽ¼çŽ½çŽ¿ç…ç†ç‰ç‹çŒçç’ç“ç–ç™çç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½"],
+		[
+			"8fcca1",
+			"ç¿ç€çç„ç‡çŠç‘çšç›ç¤ç¦ç¨",
+			9,
+			"ç¹ç‘€ç‘ƒç‘„ç‘†ç‘‡ç‘‹ç‘ç‘‘ç‘’ç‘—ç‘ç‘¢ç‘¦ç‘§ç‘¨ç‘«ç‘­ç‘®ç‘±ç‘²ç’€ç’ç’…ç’†ç’‡ç’‰ç’ç’ç’‘ç’’ç’˜ç’™ç’šç’œç’Ÿç’ ç’¡ç’£ç’¦ç’¨ç’©ç’ªç’«ç’®ç’¯ç’±ç’²ç’µç’¹ç’»ç’¿ç“ˆç“‰ç“Œç“ç““ç“˜ç“šç“›ç“žç“Ÿç“¤ç“¨ç“ªç“«ç“¯ç“´ç“ºç“»ç“¼ç“¿ç”†"
+		],
+		[
+			"8fcda1",
+			"ç”’ç”–ç”—ç” ç”¡ç”¤ç”§ç”©ç”ªç”¯ç”¶ç”¹ç”½ç”¾ç”¿ç•€ç•ƒç•‡ç•ˆç•Žç•ç•’ç•—ç•žç•Ÿç•¡ç•¯ç•±ç•¹",
+			5,
+			"ç–ç–…ç–ç–’ç–“ç–•ç–™ç–œç–¢ç–¤ç–´ç–ºç–¿ç—€ç—ç—„ç—†ç—Œç—Žç—ç——ç—œç—Ÿç— ç—¡ç—¤ç—§ç—¬ç—®ç—¯ç—±ç—¹ç˜€ç˜‚ç˜ƒç˜„ç˜‡ç˜ˆç˜Šç˜Œç˜ç˜’ç˜“ç˜•ç˜–ç˜™ç˜›ç˜œç˜ç˜žç˜£ç˜¥ç˜¦ç˜©ç˜­ç˜²ç˜³ç˜µç˜¸ç˜¹"
+		],
+		[
+			"8fcea1",
+			"ç˜ºç˜¼ç™Šç™€ç™ç™ƒç™„ç™…ç™‰ç™‹ç™•ç™™ç™Ÿç™¤ç™¥ç™­ç™®ç™¯ç™±ç™´çšçš…çšŒçšçš•çš›çšœçšçšŸçš çš¢",
+			6,
+			"çšªçš­çš½ç›ç›…ç›‰ç›‹ç›Œç›Žç›”ç›™ç› ç›¦ç›¨ç›¬ç›°ç›±ç›¶ç›¹ç›¼çœ€çœ†çœŠçœŽçœ’çœ”çœ•çœ—çœ™çœšçœœçœ¢çœ¨çœ­çœ®çœ¯çœ´çœµçœ¶çœ¹çœ½çœ¾ç‚ç…ç†çŠççŽçç’ç–ç—çœçžçŸç ç¢"
+		],
+		["8fcfa1", "ç¤ç§çªç¬ç°ç²ç³ç´çºç½çž€çž„çžŒçžçž”çž•çž–çžšçžŸçž¢çž§çžªçž®çž¯çž±çžµçž¾çŸƒçŸ‰çŸ‘çŸ’çŸ•çŸ™çŸžçŸŸçŸ çŸ¤çŸ¦çŸªçŸ¬çŸ°çŸ±çŸ´çŸ¸çŸ»ç …ç †ç ‰ç ç Žç ‘ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ƒç¡„ç¡‡ç¡ˆç¡Œç¡Žç¡’ç¡œç¡žç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢Šç¢ç¢”ç¢˜ç¢¡ç¢ç¢žç¢Ÿç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³"],
+		["8fd0a1", "ç¢»ç¢½ç¢¿ç£‡ç£ˆç£‰ç£Œç£Žç£’ç£“ç£•ç£–ç£¤ç£›ç£Ÿç£ ç£¡ç£¦ç£ªç£²ç£³ç¤€ç£¶ç£·ç£ºç£»ç£¿ç¤†ç¤Œç¤ç¤šç¤œç¤žç¤Ÿç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥„ç¥…ç¥†ç¥Šç¥‹ç¥ç¥‘ç¥”ç¥˜ç¥›ç¥œç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦‹ç¦Œç¦‘ç¦“ç¦”ç¦•ç¦–ç¦˜ç¦›ç¦œç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§‚ç§„ç§‡ç§ˆç§Šç§ç§”ç§–ç§šç§ç§ž"],
+		["8fd1a1", "ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨‚ç¨ƒç¨‡ç¨‰ç¨Šç¨Œç¨‘ç¨•ç¨›ç¨žç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©„ç©…ç©‡ç©ˆç©Œç©•ç©–ç©™ç©œç©ç©Ÿç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çª€çª‚çª…çª†çªŠçª‹çªçª‘çª”çªžçª çª£çª¬çª³çªµçª¹çª»çª¼ç«†ç«‰ç«Œç«Žç«‘ç«›ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬‡ç¬”ç¬Ÿç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°"],
+		[
+			"8fd2a1",
+			"ç¬±ç¬´ç¬½ç¬¿ç­€ç­ç­‡ç­Žç­•ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®„ç®‰ç®Žç®ç®‘ç®–ç®›ç®žç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯‚ç¯…ç¯ˆç¯Šç¯”ç¯–ç¯—ç¯™ç¯šç¯›ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°‚ç°ƒç°„ç°†ç°‰ç°‹ç°Œç°Žç°ç°™ç°›ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±†ç±Šç±•ç±‘ç±’ç±“ç±™",
+			5
+		],
+		["8fd3a1", "ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²†ç²‡ç²ç²”ç²žç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³„ç³‡ç³ˆç³‰ç³ç³ç³“ç³”ç³•ç³—ç³™ç³šç³ç³¦ç³©ç³«ç³µç´ƒç´‡ç´ˆç´‰ç´ç´‘ç´’ç´“ç´–ç´ç´žç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµ€çµçµ‡çµˆçµçµ‘çµ“çµ—çµ™çµšçµœçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶‚ç¶ƒç¶…ç¶†ç¶ˆç¶‹ç¶Œç¶ç¶‘ç¶–ç¶—ç¶"],
+		[
+			"8fd4a1",
+			"ç¶žç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·‚",
+			4,
+			"ç·Œç·ç·Žç·—ç·™ç¸€ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ˆç¸ç¸‘ç¸•ç¸—ç¸œç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹„ç¹…ç¹‡ç¹Žç¹ç¹’ç¹˜ç¹Ÿç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçº†çº‡çºŠçºçº‘çº•çº˜çºšçºçºžç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ƒç½„ç½‡ç½ç½’ç½“ç½›ç½œç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­"
+		],
+		["8fd5a1", "ç½±ç½½ç½¾ç½¿ç¾€ç¾‹ç¾ç¾ç¾ç¾‘ç¾–ç¾—ç¾œç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿€ç¿ƒç¿ˆç¿Žç¿ç¿›ç¿Ÿç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿è€‡è€ˆè€Šè€è€Žè€è€‘è€“è€”è€–è€è€žè€Ÿè€ è€¤è€¦è€¬è€®è€°è€´è€µè€·è€¹è€ºè€¼è€¾è€è„è è¤è¦è­è±èµè‚è‚ˆè‚Žè‚œè‚žè‚¦è‚§è‚«è‚¸è‚¹èƒˆèƒèƒèƒ’èƒ”èƒ•èƒ—èƒ˜èƒ èƒ­èƒ®"],
+		["8fd6a1", "èƒ°èƒ²èƒ³èƒ¶èƒ¹èƒºèƒ¾è„ƒè„‹è„–è„—è„˜è„œè„žè„ è„¤è„§è„¬è„°è„µè„ºè„¼è……è…‡è…Šè…Œè…’è…—è… è…¡è…§è…¨è…©è…­è…¯è…·è†è†è†„è†…è††è†‹è†Žè†–è†˜è†›è†žè†¢è†®è†²è†´è†»è‡‹è‡ƒè‡…è‡Šè‡Žè‡è‡•è‡—è‡›è‡è‡žè‡¡è‡¤è‡«è‡¬è‡°è‡±è‡²è‡µè‡¶è‡¸è‡¹è‡½è‡¿èˆ€èˆƒèˆèˆ“èˆ”èˆ™èˆšèˆèˆ¡èˆ¢èˆ¨èˆ²èˆ´èˆºè‰ƒè‰„è‰…è‰†"],
+		["8fd7a1", "è‰‹è‰Žè‰è‰‘è‰–è‰œè‰ è‰£è‰§è‰­è‰´è‰»è‰½è‰¿èŠ€èŠèŠƒèŠ„èŠ‡èŠ‰èŠŠèŠŽèŠ‘èŠ”èŠ–èŠ˜èŠšèŠ›èŠ èŠ¡èŠ£èŠ¤èŠ§èŠ¨èŠ©èŠªèŠ®èŠ°èŠ²èŠ´èŠ·èŠºèŠ¼èŠ¾èŠ¿è‹†è‹è‹•è‹šè‹ è‹¢è‹¤è‹¨è‹ªè‹­è‹¯è‹¶è‹·è‹½è‹¾èŒ€èŒèŒ‡èŒˆèŒŠèŒ‹è”èŒ›èŒèŒžèŒŸèŒ¡èŒ¢èŒ¬èŒ­èŒ®èŒ°èŒ³èŒ·èŒºèŒ¼èŒ½è‚èƒè„è‡èèŽè‘è•è–è—è°è¸"],
+		["8fd8a1", "è½è¿èŽ€èŽ‚èŽ„èŽ†èŽèŽ’èŽ”èŽ•èŽ˜èŽ™èŽ›èŽœèŽèŽ¦èŽ§èŽ©èŽ¬èŽ¾èŽ¿è€è‡è‰èèè‘è”èè“è¨èªè¶è¸è¹è¼èè†èŠèè‘è•è™èŽ­è¯è¹è‘…è‘‡è‘ˆè‘Šè‘è‘è‘‘è‘’è‘–è‘˜è‘™è‘šè‘œè‘ è‘¤è‘¥è‘§è‘ªè‘°è‘³è‘´è‘¶è‘¸è‘¼è‘½è’è’…è’’è’“è’•è’žè’¦è’¨è’©è’ªè’¯è’±è’´è’ºè’½è’¾è“€è“‚è“‡è“ˆè“Œè“è““"],
+		[
+			"8fd9a1",
+			"è“œè“§è“ªè“¯è“°è“±è“²è“·è”²è“ºè“»è“½è”‚è”ƒè”‡è”Œè”Žè”è”œè”žè”¢è”£è”¤è”¥è”§è”ªè”«è”¯è”³è”´è”¶è”¿è•†è•",
+			4,
+			"è•–è•™è•œ",
+			6,
+			"è•¤è•«è•¯è•¹è•ºè•»è•½è•¿è–è–…è–†è–‰è–‹è–Œè–è–“è–˜è–è–Ÿè– è–¢è–¥è–§è–´è–¶è–·è–¸è–¼è–½è–¾è–¿è—‚è—‡è—Šè—‹è—Žè–­è—˜è—šè—Ÿè— è—¦è—¨è—­è—³è—¶è—¼"
+		],
+		[
+			"8fdaa1",
+			"è—¿è˜€è˜„è˜…è˜è˜Žè˜è˜‘è˜’è˜˜è˜™è˜›è˜žè˜¡è˜§è˜©è˜¶è˜¸è˜ºè˜¼è˜½è™€è™‚è™†è™’è™“è™–è™—è™˜è™™è™è™ ",
+			4,
+			"è™©è™¬è™¯è™µè™¶è™·è™ºèšèš‘èš–èš˜èššèšœèš¡èš¦èš§èš¨èš­èš±èš³èš´èšµèš·èš¸èš¹èš¿è›€è›è›ƒè›…è›‘è›’è›•è›—è›šè›œè› è›£è›¥è›§èšˆè›ºè›¼è›½èœ„èœ…èœ‡èœ‹èœŽèœèœèœ“èœ”èœ™èœžèœŸèœ¡èœ£"
+		],
+		[
+			"8fdba1",
+			"èœ¨èœ®èœ¯èœ±èœ²èœ¹èœºèœ¼èœ½èœ¾è€èƒè…èè˜èè¡è¤è¥è¯è±è²è»èžƒ",
+			6,
+			"èž‹èžŒèžèž“èž•èž—èž˜èž™èžžèž èž£èž§èž¬èž­èž®èž±èžµèž¾èž¿èŸèŸˆèŸ‰èŸŠèŸŽèŸ•èŸ–èŸ™èŸšèŸœèŸŸèŸ¢èŸ£èŸ¤èŸªèŸ«èŸ­èŸ±èŸ³èŸ¸èŸºèŸ¿è è ƒè †è ‰è Šè ‹è è ™è ’è “è ”è ˜è šè ›è œè žè Ÿè ¨è ­è ®è °è ²è µ"
+		],
+		[
+			"8fdca1",
+			"è ºè ¼è¡è¡ƒè¡…è¡ˆè¡‰è¡Šè¡‹è¡Žè¡‘è¡•è¡–è¡˜è¡šè¡œè¡Ÿè¡ è¡¤è¡©è¡±è¡¹è¡»è¢€è¢˜è¢šè¢›è¢œè¢Ÿè¢ è¢¨è¢ªè¢ºè¢½è¢¾è£€è£Š",
+			4,
+			"è£‘è£’è£“è£›è£žè£§è£¯è£°è£±è£µè£·è¤è¤†è¤è¤Žè¤è¤•è¤–è¤˜è¤™è¤šè¤œè¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥€è¥‚è¥…è¥†è¥‰è¥è¥’è¥—è¥šè¥›è¥œè¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º"
+		],
+		[
+			"8fdda1",
+			"è¥»è¥¼è¥½è¦‰è¦è¦è¦”è¦•è¦›è¦œè¦Ÿè¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§”",
+			4,
+			"è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨„è¨…è¨‡è¨è¨‘è¨’è¨”è¨•è¨žè¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©€è©ƒè©…è©‡è©‰è©è©Žè©“è©–è©—è©˜è©œè©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èª€èªƒèª†èª‹èªèªèª’èª–èª—èª™èªŸèª§èª©èª®èª¯èª³"
+		],
+		[
+			"8fdea1",
+			"èª¶èª·èª»èª¾è«ƒè«†è«ˆè«‰è«Šè«‘è«“è«”è«•è«—è«è«Ÿè«¬è«°è«´è«µè«¶è«¼è«¿è¬…è¬†è¬‹è¬‘è¬œè¬žè¬Ÿè¬Šè¬­è¬°è¬·è¬¼è­‚",
+			4,
+			"è­ˆè­’è­“è­”è­™è­è­žè­£è­­è­¶è­¸è­¹è­¼è­¾è®è®„è®…è®‹è®è®è®”è®•è®œè®žè®Ÿè°¸è°¹è°½è°¾è±…è±‡è±‰è±‹è±è±‘è±“è±”è±—è±˜è±›è±è±™è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²†"
+		],
+		["8fdfa1", "è²‡è²‹è²è²’è²“è²™è²›è²œè²¤è²¹è²ºè³…è³†è³‰è³‹è³è³–è³•è³™è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´ƒè´‰è´’è´—è´›èµ¥èµ©èµ¬èµ®èµ¿è¶‚è¶„è¶ˆè¶è¶è¶‘è¶•è¶žè¶Ÿè¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·€è·…è·†è·‡è·ˆè·Šè·Žè·‘è·”è·•è·—è·™è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸„è¸…è¸†è¸‹è¸‘è¸”è¸–è¸ è¸¡è¸¢"],
+		["8fe0a1", "è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹€è¹è¹‹è¹è¹Žè¹è¹”è¹›è¹œè¹è¹žè¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èº‚èºƒèº‰èºèº’èº•èºšèº›èºèºžèº¢èº§èº©èº­èº®èº³èºµèººèº»è»€è»è»ƒè»„è»‡è»è»‘è»”è»œè»¨è»®è»°è»±è»·è»¹è»ºè»­è¼€è¼‚è¼‡è¼ˆè¼è¼è¼–è¼—è¼˜è¼žè¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½€è½"],
+		[
+			"8fe1a1",
+			"è½ƒè½‡è½è½‘",
+			4,
+			"è½˜è½è½žè½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿€è¿è¿†è¿Šè¿‹è¿è¿è¿’è¿“è¿•è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾é€‚é€„é€ˆé€Œé€˜é€›é€¨é€©é€¯é€ªé€¬é€­é€³é€´é€·é€¿éƒé„éŒé›éé¢é¦é§é¬é°é´é¹é‚…é‚ˆé‚‹é‚Œé‚Žé‚é‚•é‚—é‚˜é‚™é‚›é‚ é‚¡é‚¢é‚¥é‚°é‚²é‚³é‚´é‚¶é‚½éƒŒé‚¾éƒƒ"
+		],
+		["8fe2a1", "éƒ„éƒ…éƒ‡éƒˆéƒ•éƒ—éƒ˜éƒ™éƒœéƒéƒŸéƒ¥éƒ’éƒ¶éƒ«éƒ¯éƒ°éƒ´éƒ¾éƒ¿é„€é„„é„…é„†é„ˆé„é„é„”é„–é„—é„˜é„šé„œé„žé„ é„¥é„¢é„£é„§é„©é„®é„¯é„±é„´é„¶é„·é„¹é„ºé„¼é„½é…ƒé…‡é…ˆé…é…“é…—é…™é…šé…›é…¡é…¤é…§é…­é…´é…¹é…ºé…»é†é†ƒé†…é††é†Šé†Žé†‘é†“é†”é†•é†˜é†žé†¡é†¦é†¨é†¬é†­é†®é†°é†±é†²é†³é†¶é†»é†¼é†½é†¿"],
+		[
+			"8fe3a1",
+			"é‡‚é‡ƒé‡…é‡“é‡”é‡—é‡™é‡šé‡žé‡¤é‡¥é‡©é‡ªé‡¬",
+			5,
+			"é‡·é‡¹é‡»é‡½éˆ€éˆéˆ„éˆ…éˆ†éˆ‡éˆ‰éˆŠéˆŒéˆéˆ’éˆ“éˆ–éˆ˜éˆœéˆéˆ£éˆ¤éˆ¥éˆ¦éˆ¨éˆ®éˆ¯éˆ°éˆ³éˆµéˆ¶éˆ¸éˆ¹éˆºéˆ¼éˆ¾é‰€é‰‚é‰ƒé‰†é‰‡é‰Šé‰é‰Žé‰é‰‘é‰˜é‰™é‰œé‰é‰ é‰¡é‰¥é‰§é‰¨é‰©é‰®é‰¯é‰°é‰µ",
+			4,
+			"é‰»é‰¼é‰½é‰¿éŠˆéŠ‰éŠŠéŠéŠŽéŠ’éŠ—"
+		],
+		[
+			"8fe4a1",
+			"éŠ™éŠŸéŠ éŠ¤éŠ¥éŠ§éŠ¨éŠ«éŠ¯éŠ²éŠ¶éŠ¸éŠºéŠ»éŠ¼éŠ½éŠ¿",
+			4,
+			"é‹…é‹†é‹‡é‹ˆé‹‹é‹Œé‹é‹Žé‹é‹“é‹•é‹—é‹˜é‹™é‹œé‹é‹Ÿé‹ é‹¡é‹£é‹¥é‹§é‹¨é‹¬é‹®é‹°é‹¹é‹»é‹¿éŒ€éŒ‚éŒˆéŒéŒ‘éŒ”éŒ•éŒœéŒéŒžéŒŸéŒ¡éŒ¤éŒ¥éŒ§éŒ©éŒªéŒ³éŒ´éŒ¶éŒ·é‡éˆé‰éé‘é’é•é—é˜éšéžé¤é¥é§é©éªé­é¯é°é±é³é´é¶"
+		],
+		[
+			"8fe5a1",
+			"éºé½é¿éŽ€éŽéŽ‚éŽˆéŽŠéŽ‹éŽéŽéŽ’éŽ•éŽ˜éŽ›éŽžéŽ¡éŽ£éŽ¤éŽ¦éŽ¨éŽ«éŽ´éŽµéŽ¶éŽºéŽ©éé„é…é†é‡é‰",
+			4,
+			"é“é™éœéžéŸé¢é¦é§é¹é·é¸éºé»é½éé‚é„éˆé‰ééŽéé•é–é—éŸé®é¯é±é²é³é´é»é¿é½é‘ƒé‘…é‘ˆé‘Šé‘Œé‘•é‘™é‘œé‘Ÿé‘¡é‘£é‘¨é‘«é‘­é‘®é‘¯é‘±é‘²é’„é’ƒé•¸é•¹"
+		],
+		["8fe6a1", "é•¾é–„é–ˆé–Œé–é–Žé–é–žé–Ÿé–¡é–¦é–©é–«é–¬é–´é–¶é–ºé–½é–¿é—†é—ˆé—‰é—‹é—é—‘é—’é—“é—™é—šé—é—žé—Ÿé— é—¤é—¦é˜é˜žé˜¢é˜¤é˜¥é˜¦é˜¬é˜±é˜³é˜·é˜¸é˜¹é˜ºé˜¼é˜½é™é™’é™”é™–é™—é™˜é™¡é™®é™´é™»é™¼é™¾é™¿éšéš‚éšƒéš„éš‰éš‘éš–éššéšéšŸéš¤éš¥éš¦éš©éš®éš¯éš³éšºé›Šé›’å¶²é›˜é›šé›é›žé›Ÿé›©é›¯é›±é›ºéœ‚"],
+		["8fe7a1", "éœƒéœ…éœ‰éœšéœ›éœéœ¡éœ¢éœ£éœ¨éœ±éœ³ééƒéŠéŽéé•é—é˜éšé›é£é§éªé®é³é¶é·é¸é»é½é¿éž€éž‰éž•éž–éž—éž™éžšéžžéžŸéž¢éž¬éž®éž±éž²éžµéž¶éž¸éž¹éžºéž¼éž¾éž¿éŸéŸ„éŸ…éŸ‡éŸ‰éŸŠéŸŒéŸéŸŽéŸéŸ‘éŸ”éŸ—éŸ˜éŸ™éŸéŸžéŸ éŸ›éŸ¡éŸ¤éŸ¯éŸ±éŸ´éŸ·éŸ¸éŸºé ‡é Šé ™é é Žé ”é –é œé žé  é £é ¦"],
+		[
+			"8fe8a1",
+			"é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡„é¡‡é¡Šé¡‘é¡’é¡“é¡–é¡—é¡™é¡šé¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£‚é£…é£ˆé£Œé£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤‚é¤‡é¤ˆé¤‘é¤•é¤–é¤—é¤šé¤›é¤œé¤Ÿé¤¢é¤¦é¤§é¤«é¤±",
+			4,
+			"é¤¹é¤ºé¤»é¤¼é¥€é¥é¥†é¥‡é¥ˆé¥é¥Žé¥”é¥˜é¥™é¥›é¥œé¥žé¥Ÿé¥ é¦›é¦é¦Ÿé¦¦é¦°é¦±é¦²é¦µ"
+		],
+		[
+			"8fe9a1",
+			"é¦¹é¦ºé¦½é¦¿é§ƒé§‰é§“é§”é§™é§šé§œé§žé§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨‚é¨ƒé¨„é¨‹é¨Œé¨é¨‘é¨–é¨žé¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©‡é©é©„é©Šé©‹é©Œé©Žé©‘é©”é©–é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«ƒé«†é«ˆé«Žé«é«’é«•é«–é«—é«›é«œé« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿",
+			4
+		],
+		[
+			"8feaa1",
+			"é¬„é¬…é¬ˆé¬‰é¬‹é¬Œé¬é¬Žé¬é¬’é¬–é¬™é¬›é¬œé¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­ˆé­‹é­Œé­•é­–é­—é­›é­žé­¡é­£é­¥é­¦é­¨é­ª",
+			4,
+			"é­³é­µé­·é­¸é­¹é­¿é®€é®„é®…é®†é®‡é®‰é®Šé®‹é®é®é®é®”é®šé®é®žé®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯‡é¯ˆé¯Žé¯é¯—é¯˜é¯é¯Ÿé¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸"
+		],
+		[
+			"8feba1",
+			"é¯¹é¯ºé¯½é¯¿é°€é°‚é°‹é°é°‘é°–é°˜é°™é°šé°œé°žé°¢é°£é°¦",
+			4,
+			"é°±é°µé°¶é°·é°½é±é±ƒé±„é±…é±‰é±Šé±Žé±é±é±“é±”é±–é±˜é±›é±é±žé±Ÿé±£é±©é±ªé±œé±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´‹é´‚é´‘é´—é´˜é´œé´é´žé´¯é´°é´²é´³é´´é´ºé´¼éµ…é´½éµ‚éµƒéµ‡éµŠéµ“éµ”éµŸéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»"
+		],
+		["8feca1", "éµ¼éµ¾é¶ƒé¶„é¶†é¶Šé¶é¶Žé¶’é¶“é¶•é¶–é¶—é¶˜é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·ƒé·‡é·‰é·Šé·”é·•é·–é·—é·šé·žé·Ÿé· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸Šé¸‚é¸‡é¸Žé¸é¸‘é¸’é¸•é¸–é¸™é¸œé¸é¹ºé¹»é¹¼éº€éº‚éºƒéº„éº…éº‡éºŽéºéº–éº˜éº›éºžéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»†é»ˆé»‹é»•é»Ÿé»¤é»§é»¬é»­é»®é»°é»±é»²é»µ"],
+		[
+			"8feda1",
+			"é»¸é»¿é¼‚é¼ƒé¼‰é¼é¼é¼‘é¼’é¼”é¼–é¼—é¼™é¼šé¼›é¼Ÿé¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½ƒ",
+			4,
+			"é½“é½•é½–é½—é½˜é½šé½é½žé½¨é½©é½­",
+			4,
+			"é½³é½µé½ºé½½é¾é¾é¾‘é¾’é¾”é¾–é¾—é¾žé¾¡é¾¢é¾£é¾¥"
+		]
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json
+var require_cp936 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json": ((exports, module) => {
+	module.exports = [
+		[
+			"0",
+			"\0",
+			127,
+			"â‚¬"
+		],
+		[
+			"8140",
+			"ä¸‚ä¸„ä¸…ä¸†ä¸ä¸’ä¸—ä¸Ÿä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹€ä¹ä¹‚ä¹„ä¹†ä¹Šä¹‘ä¹•ä¹—ä¹šä¹›ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª",
+			5,
+			"ä¹²ä¹´",
+			9,
+			"ä¹¿",
+			6,
+			"äº‡äºŠ"
+		],
+		[
+			"8180",
+			"äºäº–äº—äº™äºœäºäºžäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ˆä»Œä»ä»ä»’ä»šä»›ä»œä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼€ä¼‚",
+			6,
+			"ä¼‹ä¼Œä¼’",
+			4,
+			"ä¼œä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾",
+			4,
+			"ä½„ä½…ä½‡",
+			5,
+			"ä½’ä½”ä½–ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾€ä¾ä¾‚ä¾…ä¾†ä¾‡ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾•ä¾–ä¾˜ä¾™ä¾šä¾œä¾žä¾Ÿä¾¡ä¾¢"
+		],
+		[
+			"8240",
+			"ä¾¤ä¾«ä¾­ä¾°",
+			4,
+			"ä¾¶",
+			8,
+			"ä¿€ä¿ä¿‚ä¿†ä¿‡ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿’",
+			4,
+			"ä¿™ä¿›ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿",
+			11
+		],
+		[
+			"8280",
+			"å€‹å€Žå€å€‘å€“å€•å€–å€—å€›å€å€žå€ å€¢å€£å€¤å€§å€«å€¯",
+			10,
+			"å€»å€½å€¿å€åå‚å„å…å†å‰åŠå‹åå",
+			4,
+			"å–å—å˜å™å›å",
+			7,
+			"å¦",
+			5,
+			"å­",
+			8,
+			"å¸å¹åºå¼å½å‚å‚‚å‚ƒå‚„å‚†å‚‡å‚‰å‚Šå‚‹å‚Œå‚Ž",
+			20,
+			"å‚¤å‚¦å‚ªå‚«å‚­",
+			4,
+			"å‚³",
+			6,
+			"å‚¼"
+		],
+		[
+			"8340",
+			"å‚½",
+			17,
+			"åƒ",
+			5,
+			"åƒ—åƒ˜åƒ™åƒ›",
+			10,
+			"åƒ¨åƒ©åƒªåƒ«åƒ¯åƒ°åƒ±åƒ²åƒ´åƒ¶",
+			4,
+			"åƒ¼",
+			9,
+			"å„ˆ"
+		],
+		[
+			"8380",
+			"å„‰å„Šå„Œ",
+			5,
+			"å„“",
+			13,
+			"å„¢",
+			28,
+			"å…‚å…‡å…Šå…Œå…Žå…å…å…’å…“å…—å…˜å…™å…›å…",
+			4,
+			"å…£å…¤å…¦å…§å…©å…ªå…¯å…²å…ºå…¾å…¿å†ƒå†„å††å†‡å†Šå†‹å†Žå†å†å†‘å†“å†”å†˜å†šå†å†žå†Ÿå†¡å†£å†¦",
+			4,
+			"å†­å†®å†´å†¸å†¹å†ºå†¾å†¿å‡å‡‚å‡ƒå‡…å‡ˆå‡Šå‡å‡Žå‡å‡’",
+			5
+		],
+		[
+			"8440",
+			"å‡˜å‡™å‡šå‡œå‡žå‡Ÿå‡¢å‡£å‡¥",
+			5,
+			"å‡¬å‡®å‡±å‡²å‡´å‡·å‡¾åˆ„åˆ…åˆ‰åˆ‹åˆŒåˆåˆåˆ“åˆ”åˆ•åˆœåˆžåˆŸåˆ¡åˆ¢åˆ£åˆ¥åˆ¦åˆ§åˆªåˆ¬åˆ¯åˆ±åˆ²åˆ´åˆµåˆ¼åˆ¾å‰„",
+			5,
+			"å‰‹å‰Žå‰å‰’å‰“å‰•å‰—å‰˜"
+		],
+		[
+			"8480",
+			"å‰™å‰šå‰›å‰å‰Ÿå‰ å‰¢å‰£å‰¤å‰¦å‰¨å‰«å‰¬å‰­å‰®å‰°å‰±å‰³",
+			9,
+			"å‰¾åŠ€åŠƒ",
+			4,
+			"åŠ‰",
+			6,
+			"åŠ‘åŠ’åŠ”",
+			6,
+			"åŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ®åŠ¯åŠ°åŠ´",
+			9,
+			"å‹€å‹å‹‚å‹„å‹…å‹†å‹ˆå‹Šå‹Œå‹å‹Žå‹å‹‘å‹“å‹”å‹•å‹—å‹™",
+			5,
+			"å‹ å‹¡å‹¢å‹£å‹¥",
+			10,
+			"å‹±",
+			7,
+			"å‹»å‹¼å‹½åŒåŒ‚åŒƒåŒ„åŒ‡åŒ‰åŒŠåŒ‹åŒŒåŒŽ"
+		],
+		[
+			"8540",
+			"åŒ‘åŒ’åŒ“åŒ”åŒ˜åŒ›åŒœåŒžåŒŸåŒ¢åŒ¤åŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ¯",
+			9,
+			"åŒ¼åŒ½å€å‚å„å†å‹åŒååå”å˜å™å›åå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾åŽ€åŽåŽƒåŽ‡åŽˆåŽŠåŽŽåŽ"
+		],
+		[
+			"8580",
+			"åŽ",
+			4,
+			"åŽ–åŽ—åŽ™åŽ›åŽœåŽžåŽ åŽ¡åŽ¤åŽ§åŽªåŽ«åŽ¬åŽ­åŽ¯",
+			6,
+			"åŽ·åŽ¸åŽ¹åŽºåŽ¼åŽ½åŽ¾å€åƒ",
+			4,
+			"åŽååå’å“å•åšåœååžå¡å¢å§å´åºå¾å¿å€å‚å…å‡å‹å”å˜å™åšåœå¢å¤å¥åªå°å³å¶å·åºå½å¿å‘å‘‚å‘„å‘…å‘‡å‘‰å‘Œå‘å‘Žå‘å‘‘å‘šå‘",
+			4,
+			"å‘£å‘¥å‘§å‘©",
+			7,
+			"å‘´å‘¹å‘ºå‘¾å‘¿å’å’ƒå’…å’‡å’ˆå’‰å’Šå’å’‘å’“å’—å’˜å’œå’žå’Ÿå’ å’¡"
+		],
+		[
+			"8640",
+			"å’¢å’¥å’®å’°å’²å’µå’¶å’·å’¹å’ºå’¼å’¾å“ƒå“…å“Šå“‹å“–å“˜å“›å“ ",
+			4,
+			"å“«å“¬å“¯å“°å“±å“´",
+			5,
+			"å“»å“¾å”€å”‚å”ƒå”„å”…å”ˆå”Š",
+			4,
+			"å”’å”“å”•",
+			5,
+			"å”œå”å”žå”Ÿå”¡å”¥å”¦"
+		],
+		[
+			"8680",
+			"å”¨å”©å”«å”­å”²å”´å”µå”¶å”¸å”¹å”ºå”»å”½å•€å•‚å•…å•‡å•ˆå•‹",
+			4,
+			"å•‘å•’å•“å•”å•—",
+			4,
+			"å•å•žå•Ÿå• å•¢å•£å•¨å•©å•«å•¯",
+			5,
+			"å•¹å•ºå•½å•¿å–…å–†å–Œå–å–Žå–å–’å–“å–•å––å–—å–šå–›å–žå– ",
+			6,
+			"å–¨",
+			8,
+			"å–²å–´å–¶å–¸å–ºå–¼å–¿",
+			4,
+			"å—†å—‡å—ˆå—Šå—‹å—Žå—å—å—•å——",
+			4,
+			"å—žå— å—¢å—§å—©å—­å—®å—°å—±å—´å—¶å—¸",
+			4,
+			"å—¿å˜‚å˜ƒå˜„å˜…"
+		],
+		[
+			"8740",
+			"å˜†å˜‡å˜Šå˜‹å˜å˜",
+			7,
+			"å˜™å˜šå˜œå˜å˜ å˜¡å˜¢å˜¥å˜¦å˜¨å˜©å˜ªå˜«å˜®å˜¯å˜°å˜³å˜µå˜·å˜¸å˜ºå˜¼å˜½å˜¾å™€",
+			11,
+			"å™",
+			4,
+			"å™•å™–å™šå™›å™",
+			4
+		],
+		[
+			"8780",
+			"å™£å™¥å™¦å™§å™­å™®å™¯å™°å™²å™³å™´å™µå™·å™¸å™¹å™ºå™½",
+			7,
+			"åš‡",
+			6,
+			"åšåš‘åš’åš”",
+			14,
+			"åš¤",
+			10,
+			"åš°",
+			6,
+			"åš¸åš¹åšºåš»åš½",
+			12,
+			"å›‹",
+			8,
+			"å›•å›–å›˜å›™å›œå›£å›¥",
+			5,
+			"å›¬å›®å›¯å›²å›³å›¶å›·å›¸å›»å›¼åœ€åœåœ‚åœ…åœ‡åœ‹",
+			6
+		],
+		[
+			"8840",
+			"åœ’",
+			9,
+			"åœåœžåœ åœ¡åœ¢åœ¤åœ¥åœ¦åœ§åœ«åœ±åœ²åœ´",
+			4,
+			"åœ¼åœ½åœ¿ååƒå„å…å†åˆå‰å‹å’",
+			4,
+			"å˜å™å¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿åž€"
+		],
+		[
+			"8880",
+			"åžåž‡åžˆåž‰åžŠåž",
+			4,
+			"åž”",
+			6,
+			"åžœåžåžžåžŸåž¥åž¨åžªåž¬åž¯åž°åž±åž³åžµåž¶åž·åž¹",
+			8,
+			"åŸ„",
+			6,
+			"åŸŒåŸåŸåŸ‘åŸ“åŸ–åŸ—åŸ›åŸœåŸžåŸ¡åŸ¢åŸ£åŸ¥",
+			7,
+			"åŸ®åŸ°åŸ±åŸ²åŸ³åŸµåŸ¶åŸ·åŸ»åŸ¼åŸ¾åŸ¿å å ƒå „å …å ˆå ‰å Šå Œå Žå å å ’å “å ”å –å —å ˜å šå ›å œå å Ÿå ¢å £å ¥",
+			4,
+			"å «",
+			4,
+			"å ±å ²å ³å ´å ¶",
+			7
+		],
+		[
+			"8940",
+			"å ¾",
+			5,
+			"å¡…",
+			6,
+			"å¡Žå¡å¡å¡’å¡“å¡•å¡–å¡—å¡™",
+			4,
+			"å¡Ÿ",
+			5,
+			"å¡¦",
+			4,
+			"å¡­",
+			16,
+			"å¡¿å¢‚å¢„å¢†å¢‡å¢ˆå¢Šå¢‹å¢Œ"
+		],
+		[
+			"8980",
+			"å¢",
+			4,
+			"å¢”",
+			4,
+			"å¢›å¢œå¢å¢ ",
+			7,
+			"å¢ª",
+			17,
+			"å¢½å¢¾å¢¿å£€å£‚å£ƒå£„å£†",
+			10,
+			"å£’å£“å£”å£–",
+			13,
+			"å£¥",
+			5,
+			"å£­å£¯å£±å£²å£´å£µå£·å£¸å£º",
+			7,
+			"å¤ƒå¤…å¤†å¤ˆ",
+			4,
+			"å¤Žå¤å¤‘å¤’å¤“å¤—å¤˜å¤›å¤å¤žå¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»"
+		],
+		[
+			"8a40",
+			"å¤½å¤¾å¤¿å¥€å¥ƒå¥…å¥†å¥Šå¥Œå¥å¥å¥’å¥“å¥™å¥›",
+			4,
+			"å¥¡å¥£å¥¤å¥¦",
+			12,
+			"å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦€å¦…å¦‰å¦‹å¦Œå¦Žå¦å¦å¦‘å¦”å¦•å¦˜å¦šå¦›å¦œå¦å¦Ÿå¦ å¦¡å¦¢å¦¦"
+		],
+		[
+			"8a80",
+			"å¦§å¦¬å¦­å¦°å¦±å¦³",
+			5,
+			"å¦ºå¦¼å¦½å¦¿",
+			6,
+			"å§‡å§ˆå§‰å§Œå§å§Žå§å§•å§–å§™å§›å§ž",
+			4,
+			"å§¤å§¦å§§å§©å§ªå§«å§­",
+			11,
+			"å§ºå§¼å§½å§¾å¨€å¨‚å¨Šå¨‹å¨å¨Žå¨å¨å¨’å¨”å¨•å¨–å¨—å¨™å¨šå¨›å¨å¨žå¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª",
+			6,
+			"å¨³å¨µå¨·",
+			4,
+			"å¨½å¨¾å¨¿å©",
+			4,
+			"å©‡å©ˆå©‹",
+			9,
+			"å©–å©—å©˜å©™å©›",
+			5
+		],
+		[
+			"8b40",
+			"å©¡å©£å©¤å©¥å©¦å©¨å©©å©«",
+			8,
+			"å©¸å©¹å©»å©¼å©½å©¾åª€",
+			17,
+			"åª“",
+			6,
+			"åªœ",
+			13,
+			"åª«åª¬"
+		],
+		[
+			"8b80",
+			"åª­",
+			4,
+			"åª´åª¶åª·åª¹",
+			4,
+			"åª¿å«€å«ƒ",
+			5,
+			"å«Šå«‹å«",
+			4,
+			"å«“å«•å«—å«™å«šå«›å«å«žå«Ÿå«¢å«¤å«¥å«§å«¨å«ªå«¬",
+			4,
+			"å«²",
+			22,
+			"å¬Š",
+			11,
+			"å¬˜",
+			25,
+			"å¬³å¬µå¬¶å¬¸",
+			7,
+			"å­",
+			6
+		],
+		[
+			"8c40",
+			"å­ˆ",
+			7,
+			"å­’å­–å­žå­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®‚å®†å®Šå®å®Žå®å®‘å®’å®”å®–å®Ÿå®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯€å¯å¯ƒå¯ˆå¯‰å¯Šå¯‹å¯å¯Žå¯"
+		],
+		[
+			"8c80",
+			"å¯‘å¯”",
+			8,
+			"å¯ å¯¢å¯£å¯¦å¯§å¯©",
+			4,
+			"å¯¯å¯±",
+			6,
+			"å¯½å¯¾å°€å°‚å°ƒå°…å°‡å°ˆå°‹å°Œå°å°Žå°å°’å°“å°—å°™å°›å°žå°Ÿå° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±ƒå±„å±†å±‡å±Œå±å±’å±“å±”å±–å±—å±˜å±šå±›å±œå±å±Ÿå±¢å±¤å±§",
+			6,
+			"å±°å±²",
+			6,
+			"å±»å±¼å±½å±¾å²€å²ƒ",
+			4,
+			"å²‰å²Šå²‹å²Žå²å²’å²“å²•å²",
+			4,
+			"å²¤",
+			4
+		],
+		[
+			"8d40",
+			"å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³€å³‚å³ƒå³…",
+			5,
+			"å³Œ",
+			5,
+			"å³“",
+			5,
+			"å³š",
+			6,
+			"å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±",
+			9,
+			"å³¼",
+			4
+		],
+		[
+			"8d80",
+			"å´å´„å´…å´ˆ",
+			5,
+			"å´",
+			4,
+			"å´•å´—å´˜å´™å´šå´œå´å´Ÿ",
+			4,
+			"å´¥å´¨å´ªå´«å´¬å´¯",
+			4,
+			"å´µ",
+			7,
+			"å´¿",
+			7,
+			"åµˆåµ‰åµ",
+			10,
+			"åµ™åµšåµœåµž",
+			10,
+			"åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ",
+			12,
+			"å¶ƒ",
+			21,
+			"å¶šå¶›å¶œå¶žå¶Ÿå¶ "
+		],
+		[
+			"8e40",
+			"å¶¡",
+			21,
+			"å¶¸",
+			12,
+			"å·†",
+			6,
+			"å·Ž",
+			12,
+			"å·œå·Ÿå· å·£å·¤å·ªå·¬å·­"
+		],
+		[
+			"8e80",
+			"å·°å·µå·¶å·¸",
+			4,
+			"å·¿å¸€å¸„å¸‡å¸‰å¸Šå¸‹å¸å¸Žå¸’å¸“å¸—å¸ž",
+			7,
+			"å¸¨",
+			4,
+			"å¸¯å¸°å¸²",
+			4,
+			"å¸¹å¸ºå¸¾å¸¿å¹€å¹å¹ƒå¹†",
+			5,
+			"å¹",
+			6,
+			"å¹–",
+			4,
+			"å¹œå¹å¹Ÿå¹ å¹£",
+			14,
+			"å¹µå¹·å¹¹å¹¾åºåº‚åºƒåº…åºˆåº‰åºŒåºåºŽåº’åº˜åº›åºåº¡åº¢åº£åº¤åº¨",
+			4,
+			"åº®",
+			4,
+			"åº´åººåº»åº¼åº½åº¿",
+			6
+		],
+		[
+			"8f40",
+			"å»†å»‡å»ˆå»‹",
+			5,
+			"å»”å»•å»—å»˜å»™å»šå»œ",
+			11,
+			"å»©å»«",
+			8,
+			"å»µå»¸å»¹å»»å»¼å»½å¼…å¼†å¼‡å¼‰å¼Œå¼å¼Žå¼å¼’å¼”å¼–å¼™å¼šå¼œå¼å¼žå¼¡å¼¢å¼£å¼¤"
+		],
+		[
+			"8f80",
+			"å¼¨å¼«å¼¬å¼®å¼°å¼²",
+			6,
+			"å¼»å¼½å¼¾å¼¿å½",
+			14,
+			"å½‘å½”å½™å½šå½›å½œå½žå½Ÿå½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾ƒå¾†å¾å¾Žå¾å¾‘å¾“å¾”å¾–å¾šå¾›å¾å¾žå¾Ÿå¾ å¾¢",
+			5,
+			"å¾©å¾«å¾¬å¾¯",
+			5,
+			"å¾¶å¾¸å¾¹å¾ºå¾»å¾¾",
+			4,
+			"å¿‡å¿ˆå¿Šå¿‹å¿Žå¿“å¿”å¿•å¿šå¿›å¿œå¿žå¿Ÿå¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ€‡"
+		],
+		[
+			"9040",
+			"æ€ˆæ€‰æ€‹æ€Œæ€æ€‘æ€“æ€—æ€˜æ€šæ€žæ€Ÿæ€¢æ€£æ€¤æ€¬æ€­æ€®æ€°",
+			4,
+			"æ€¶",
+			4,
+			"æ€½æ€¾æ€æ„",
+			6,
+			"æŒæŽææ‘æ“æ”æ–æ—æ˜æ›æœæžæŸæ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ‚€"
+		],
+		[
+			"9080",
+			"æ‚æ‚‚æ‚…æ‚†æ‚‡æ‚ˆæ‚Šæ‚‹æ‚Žæ‚æ‚æ‚‘æ‚“æ‚•æ‚—æ‚˜æ‚™æ‚œæ‚žæ‚¡æ‚¢æ‚¤æ‚¥æ‚§æ‚©æ‚ªæ‚®æ‚°æ‚³æ‚µæ‚¶æ‚·æ‚¹æ‚ºæ‚½",
+			7,
+			"æƒ‡æƒˆæƒ‰æƒŒ",
+			4,
+			"æƒ’æƒ“æƒ”æƒ–æƒ—æƒ™æƒ›æƒžæƒ¡",
+			4,
+			"æƒªæƒ±æƒ²æƒµæƒ·æƒ¸æƒ»",
+			4,
+			"æ„‚æ„ƒæ„„æ„…æ„‡æ„Šæ„‹æ„Œæ„",
+			4,
+			"æ„–æ„—æ„˜æ„™æ„›æ„œæ„æ„žæ„¡æ„¢æ„¥æ„¨æ„©æ„ªæ„¬",
+			18,
+			"æ…€",
+			6
+		],
+		[
+			"9140",
+			"æ…‡æ…‰æ…‹æ…æ…æ…æ…’æ…“æ…”æ…–",
+			6,
+			"æ…žæ…Ÿæ… æ…¡æ…£æ…¤æ…¥æ…¦æ…©",
+			6,
+			"æ…±æ…²æ…³æ…´æ…¶æ…¸",
+			18,
+			"æ†Œæ†æ†",
+			4,
+			"æ†•"
+		],
+		[
+			"9180",
+			"æ†–",
+			6,
+			"æ†ž",
+			8,
+			"æ†ªæ†«æ†­",
+			9,
+			"æ†¸",
+			5,
+			"æ†¿æ‡€æ‡æ‡ƒ",
+			4,
+			"æ‡‰æ‡Œ",
+			4,
+			"æ‡“æ‡•",
+			16,
+			"æ‡§",
+			13,
+			"æ‡¶",
+			8,
+			"æˆ€",
+			5,
+			"æˆ‡æˆ‰æˆ“æˆ”æˆ™æˆœæˆæˆžæˆ æˆ£æˆ¦æˆ§æˆ¨æˆ©æˆ«æˆ­æˆ¯æˆ°æˆ±æˆ²æˆµæˆ¶æˆ¸",
+			4,
+			"æ‰‚æ‰„æ‰…æ‰†æ‰Š"
+		],
+		[
+			"9240",
+			"æ‰æ‰æ‰•æ‰–æ‰—æ‰™æ‰šæ‰œ",
+			6,
+			"æ‰¤æ‰¥æ‰¨æ‰±æ‰²æ‰´æ‰µæ‰·æ‰¸æ‰ºæ‰»æ‰½æŠæŠ‚æŠƒæŠ…æŠ†æŠ‡æŠˆæŠ‹",
+			5,
+			"æŠ”æŠ™æŠœæŠæŠžæŠ£æŠ¦æŠ§æŠ©æŠªæŠ­æŠ®æŠ¯æŠ°æŠ²æŠ³æŠ´æŠ¶æŠ·æŠ¸æŠºæŠ¾æ‹€æ‹"
+		],
+		[
+			"9280",
+			"æ‹ƒæ‹‹æ‹æ‹‘æ‹•æ‹æ‹žæ‹ æ‹¡æ‹¤æ‹ªæ‹«æ‹°æ‹²æ‹µæ‹¸æ‹¹æ‹ºæ‹»æŒ€æŒƒæŒ„æŒ…æŒ†æŒŠæŒ‹æŒŒæŒæŒæŒæŒ’æŒ“æŒ”æŒ•æŒ—æŒ˜æŒ™æŒœæŒ¦æŒ§æŒ©æŒ¬æŒ­æŒ®æŒ°æŒ±æŒ³",
+			5,
+			"æŒ»æŒ¼æŒ¾æŒ¿æ€ææ„æ‡æˆæŠæ‘æ’æ“æ”æ–",
+			7,
+			"æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿æŽæŽƒæŽ„æŽ…æŽ†æŽ‹æŽæŽ‘æŽ“æŽ”æŽ•æŽ—æŽ™",
+			6,
+			"æŽ¡æŽ¤æŽ¦æŽ«æŽ¯æŽ±æŽ²æŽµæŽ¶æŽ¹æŽ»æŽ½æŽ¿æ€"
+		],
+		[
+			"9340",
+			"ææ‚æƒæ…æ‡æˆæŠæ‹æŒæ‘æ“æ”æ•æ—",
+			6,
+			"æŸæ¢æ¤",
+			4,
+			"æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æƒæ„æ†",
+			4,
+			"ææŽæ‘æ’æ•",
+			5,
+			"ææŸæ¢æ£æ¤"
+		],
+		[
+			"9380",
+			"æ¥æ§æ¨æ©æ«æ®",
+			5,
+			"æµ",
+			4,
+			"æ»æ¼æ¾æ‘€æ‘‚æ‘ƒæ‘‰æ‘‹",
+			6,
+			"æ‘“æ‘•æ‘–æ‘—æ‘™",
+			4,
+			"æ‘Ÿ",
+			7,
+			"æ‘¨æ‘ªæ‘«æ‘¬æ‘®",
+			9,
+			"æ‘»",
+			6,
+			"æ’ƒæ’†æ’ˆ",
+			8,
+			"æ’“æ’”æ’—æ’˜æ’šæ’›æ’œæ’æ’Ÿ",
+			4,
+			"æ’¥æ’¦æ’§æ’¨æ’ªæ’«æ’¯æ’±æ’²æ’³æ’´æ’¶æ’¹æ’»æ’½æ’¾æ’¿æ“æ“ƒæ“„æ“†",
+			6,
+			"æ“æ“‘æ““æ“”æ“•æ“–æ“™æ“š"
+		],
+		[
+			"9440",
+			"æ“›æ“œæ“æ“Ÿæ“ æ“¡æ“£æ“¥æ“§",
+			24,
+			"æ”",
+			7,
+			"æ”Š",
+			7,
+			"æ”“",
+			4,
+			"æ”™",
+			8
+		],
+		[
+			"9480",
+			"æ”¢æ”£æ”¤æ”¦",
+			4,
+			"æ”¬æ”­æ”°æ”±æ”²æ”³æ”·æ”ºæ”¼æ”½æ•€",
+			4,
+			"æ•†æ•‡æ•Šæ•‹æ•æ•Žæ•æ•’æ•“æ•”æ•—æ•˜æ•šæ•œæ•Ÿæ• æ•¡æ•¤æ•¥æ•§æ•¨æ•©æ•ªæ•­æ•®æ•¯æ•±æ•³æ•µæ•¶æ•¸",
+			14,
+			"æ–ˆæ–‰æ–Šæ–æ–Žæ–æ–’æ–”æ–•æ––æ–˜æ–šæ–æ–žæ– æ–¢æ–£æ–¦æ–¨æ–ªæ–¬æ–®æ–±",
+			7,
+			"æ–ºæ–»æ–¾æ–¿æ—€æ—‚æ—‡æ—ˆæ—‰æ—Šæ—æ—æ—‘æ—“æ—”æ—•æ—˜",
+			7,
+			"æ—¡æ—£æ—¤æ—ªæ—«"
+		],
+		[
+			"9540",
+			"æ—²æ—³æ—´æ—µæ—¸æ—¹æ—»",
+			4,
+			"æ˜æ˜„æ˜…æ˜‡æ˜ˆæ˜‰æ˜‹æ˜æ˜æ˜‘æ˜’æ˜–æ˜—æ˜˜æ˜šæ˜›æ˜œæ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜²æ˜³æ˜·",
+			4,
+			"æ˜½æ˜¿æ™€æ™‚æ™„",
+			6,
+			"æ™æ™Žæ™æ™‘æ™˜"
+		],
+		[
+			"9580",
+			"æ™™æ™›æ™œæ™æ™žæ™ æ™¢æ™£æ™¥æ™§æ™©",
+			4,
+			"æ™±æ™²æ™³æ™µæ™¸æ™¹æ™»æ™¼æ™½æ™¿æš€æšæšƒæš…æš†æšˆæš‰æšŠæš‹æšæšŽæšæšæš’æš“æš”æš•æš˜",
+			4,
+			"æšž",
+			8,
+			"æš©",
+			4,
+			"æš¯",
+			4,
+			"æšµæš¶æš·æš¸æšºæš»æš¼æš½æš¿",
+			25,
+			"æ›šæ›ž",
+			7,
+			"æ›§æ›¨æ›ª",
+			5,
+			"æ›±æ›µæ›¶æ›¸æ›ºæ›»æ›½æœæœ‚æœƒ"
+		],
+		[
+			"9640",
+			"æœ„æœ…æœ†æœ‡æœŒæœŽæœæœ‘æœ’æœ“æœ–æœ˜æœ™æœšæœœæœžæœ ",
+			5,
+			"æœ§æœ©æœ®æœ°æœ²æœ³æœ¶æœ·æœ¸æœ¹æœ»æœ¼æœ¾æœ¿ææ„æ…æ‡æŠæ‹ææ’æ”æ•æ—",
+			4,
+			"ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶"
+		],
+		[
+			"9680",
+			"æ¸æ¹æºæ»æ½æž€æž‚æžƒæž…æž†æžˆæžŠæžŒæžæžŽæžæž‘æž’æž“æž”æž–æž™æž›æžŸæž æž¡æž¤æž¦æž©æž¬æž®æž±æž²æž´æž¹",
+			7,
+			"æŸ‚æŸ…",
+			9,
+			"æŸ•æŸ–æŸ—æŸ›æŸŸæŸ¡æŸ£æŸ¤æŸ¦æŸ§æŸ¨æŸªæŸ«æŸ­æŸ®æŸ²æŸµ",
+			7,
+			"æŸ¾æ æ ‚æ ƒæ „æ †æ æ æ ’æ ”æ •æ ˜",
+			4,
+			"æ žæ Ÿæ  æ ¢",
+			6,
+			"æ «",
+			6,
+			"æ ´æ µæ ¶æ ºæ »æ ¿æ¡‡æ¡‹æ¡æ¡æ¡’æ¡–",
+			5
+		],
+		[
+			"9740",
+			"æ¡œæ¡æ¡žæ¡Ÿæ¡ªæ¡¬",
+			7,
+			"æ¡µæ¡¸",
+			8,
+			"æ¢‚æ¢„æ¢‡",
+			7,
+			"æ¢æ¢‘æ¢’æ¢”æ¢•æ¢–æ¢˜",
+			9,
+			"æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸"
+		],
+		[
+			"9780",
+			"æ¢¹",
+			6,
+			"æ£æ£ƒ",
+			5,
+			"æ£Šæ£Œæ£Žæ£æ£æ£‘æ£“æ£”æ£–æ£—æ£™æ£›",
+			4,
+			"æ£¡æ£¢æ£¤",
+			9,
+			"æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤€æ¤‚æ¤ƒæ¤„æ¤†",
+			4,
+			"æ¤Œæ¤æ¤‘æ¤“",
+			11,
+			"æ¤¡æ¤¢æ¤£æ¤¥",
+			7,
+			"æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥€æ¥æ¥ƒ",
+			16,
+			"æ¥•æ¥–æ¥˜æ¥™æ¥›æ¥œæ¥Ÿ"
+		],
+		[
+			"9840",
+			"æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²",
+			4,
+			"æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦ƒæ¦…æ¦Šæ¦‹æ¦Œæ¦Ž",
+			5,
+			"æ¦–æ¦—æ¦™æ¦šæ¦",
+			9,
+			"æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½"
+		],
+		[
+			"9880",
+			"æ¦¾æ¦¿æ§€æ§‚",
+			7,
+			"æ§‹æ§æ§æ§‘æ§’æ§“æ§•",
+			5,
+			"æ§œæ§æ§žæ§¡",
+			11,
+			"æ§®æ§¯æ§°æ§±æ§³",
+			9,
+			"æ§¾æ¨€",
+			9,
+			"æ¨‹",
+			11,
+			"æ¨™",
+			5,
+			"æ¨ æ¨¢",
+			5,
+			"æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶",
+			6,
+			"æ¨¿",
+			4,
+			"æ©…æ©†æ©ˆ",
+			7,
+			"æ©‘",
+			6,
+			"æ©š"
+		],
+		[
+			"9940",
+			"æ©œ",
+			4,
+			"æ©¢æ©£æ©¤æ©¦",
+			10,
+			"æ©²",
+			6,
+			"æ©ºæ©»æ©½æ©¾æ©¿æªæª‚æªƒæª…",
+			8,
+			"æªæª’",
+			4,
+			"æª˜",
+			7,
+			"æª¡",
+			5
+		],
+		[
+			"9980",
+			"æª§æª¨æªªæª­",
+			114,
+			"æ¬¥æ¬¦æ¬¨",
+			6
+		],
+		[
+			"9a40",
+			"æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­€æ­æ­‚æ­„æ­…æ­ˆæ­Šæ­‹æ­",
+			11,
+			"æ­š",
+			7,
+			"æ­¨æ­©æ­«",
+			13,
+			"æ­ºæ­½æ­¾æ­¿æ®€æ®…æ®ˆ"
+		],
+		[
+			"9a80",
+			"æ®Œæ®Žæ®æ®æ®‘æ®”æ®•æ®—æ®˜æ®™æ®œ",
+			4,
+			"æ®¢",
+			7,
+			"æ®«",
+			7,
+			"æ®¶æ®¸",
+			6,
+			"æ¯€æ¯ƒæ¯„æ¯†",
+			4,
+			"æ¯Œæ¯Žæ¯æ¯‘æ¯˜æ¯šæ¯œ",
+			4,
+			"æ¯¢",
+			7,
+			"æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾",
+			6,
+			"æ°ˆ",
+			4,
+			"æ°Žæ°’æ°—æ°œæ°æ°žæ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±ƒæ±„æ±…æ±ˆæ±‹",
+			4,
+			"æ±‘æ±’æ±“æ±–æ±˜"
+		],
+		[
+			"9b40",
+			"æ±™æ±šæ±¢æ±£æ±¥æ±¦æ±§æ±«",
+			4,
+			"æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²€æ²„æ²‡æ²Šæ²‹æ²æ²Žæ²‘æ²’æ²•æ²–æ²—æ²˜æ²šæ²œæ²æ²žæ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³€æ³æ³‚æ³ƒæ³†æ³‡æ³ˆæ³‹æ³æ³Žæ³æ³‘æ³’æ³˜"
+		],
+		[
+			"9b80",
+			"æ³™æ³šæ³œæ³æ³Ÿæ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´€æ´‚æ´ƒæ´…æ´†æ´ˆæ´‰æ´Šæ´æ´æ´æ´‘æ´“æ´”æ´•æ´–æ´˜æ´œæ´æ´Ÿ",
+			5,
+			"æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµ€æµ‚æµ„æµ‰æµŒæµæµ•æµ–æµ—æµ˜æµ›æµæµŸæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½",
+			4,
+			"æ¶ƒæ¶„æ¶†æ¶‡æ¶Šæ¶‹æ¶æ¶æ¶æ¶’æ¶–",
+			4,
+			"æ¶œæ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹",
+			5,
+			"æ·æ·‚æ·ƒæ·ˆæ·‰æ·Š"
+		],
+		[
+			"9c40",
+			"æ·æ·Žæ·æ·æ·’æ·“æ·”æ·•æ·—æ·šæ·›æ·œæ·Ÿæ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½",
+			7,
+			"æ¸†æ¸‡æ¸ˆæ¸‰æ¸‹æ¸æ¸’æ¸“æ¸•æ¸˜æ¸™æ¸›æ¸œæ¸žæ¸Ÿæ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ"
+		],
+		[
+			"9c80",
+			"æ¸¶æ¸·æ¸¹æ¸»",
+			7,
+			"æ¹…",
+			7,
+			"æ¹æ¹æ¹‘æ¹’æ¹•æ¹—æ¹™æ¹šæ¹œæ¹æ¹žæ¹ ",
+			10,
+			"æ¹¬æ¹­æ¹¯",
+			14,
+			"æº€æºæº‚æº„æº‡æºˆæºŠ",
+			4,
+			"æº‘",
+			6,
+			"æº™æºšæº›æºæºžæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»€æ»ƒæ»„æ»…æ»†æ»ˆæ»‰æ»Šæ»Œæ»æ»Žæ»æ»’æ»–æ»˜æ»™æ»›æ»œæ»æ»£æ»§æ»ª",
+			5
+		],
+		[
+			"9d40",
+			"æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º",
+			7,
+			"æ¼ƒæ¼„æ¼…æ¼‡æ¼ˆæ¼Š",
+			4,
+			"æ¼æ¼‘æ¼’æ¼–",
+			9,
+			"æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·",
+			6,
+			"æ¼¿æ½€æ½æ½‚"
+		],
+		[
+			"9d80",
+			"æ½ƒæ½„æ½…æ½ˆæ½‰æ½Šæ½Œæ½Ž",
+			9,
+			"æ½™æ½šæ½›æ½æ½Ÿæ½ æ½¡æ½£æ½¤æ½¥æ½§",
+			5,
+			"æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½",
+			6,
+			"æ¾…æ¾†æ¾‡æ¾Šæ¾‹æ¾",
+			12,
+			"æ¾æ¾žæ¾Ÿæ¾ æ¾¢",
+			4,
+			"æ¾¨",
+			10,
+			"æ¾´æ¾µæ¾·æ¾¸æ¾º",
+			5,
+			"æ¿æ¿ƒ",
+			5,
+			"æ¿Š",
+			6,
+			"æ¿“",
+			10,
+			"æ¿Ÿæ¿¢æ¿£æ¿¤æ¿¥"
+		],
+		[
+			"9e40",
+			"æ¿¦",
+			7,
+			"æ¿°",
+			32,
+			"ç€’",
+			7,
+			"ç€œ",
+			6,
+			"ç€¤",
+			6
+		],
+		[
+			"9e80",
+			"ç€«",
+			9,
+			"ç€¶ç€·ç€¸ç€º",
+			17,
+			"ççŽç",
+			13,
+			"çŸ",
+			11,
+			"ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ç‚ç‚‚ç‚ƒç‚„ç‚†ç‚‡ç‚ˆç‚‹ç‚Œç‚ç‚ç‚ç‚‘ç‚“ç‚—ç‚˜ç‚šç‚›ç‚ž",
+			12,
+			"ç‚°ç‚²ç‚´ç‚µç‚¶ç‚ºç‚¾ç‚¿çƒ„çƒ…çƒ†çƒ‡çƒ‰çƒ‹",
+			12,
+			"çƒš"
+		],
+		[
+			"9f40",
+			"çƒœçƒçƒžçƒ çƒ¡çƒ¢çƒ£çƒ¥çƒªçƒ®çƒ°",
+			6,
+			"çƒ¸çƒºçƒ»çƒ¼çƒ¾",
+			10,
+			"ç„‹",
+			4,
+			"ç„‘ç„’ç„”ç„—ç„›",
+			10,
+			"ç„§",
+			7,
+			"ç„²ç„³ç„´"
+		],
+		[
+			"9f80",
+			"ç„µç„·",
+			13,
+			"ç…†ç…‡ç…ˆç…‰ç…‹ç…ç…",
+			12,
+			"ç…ç…Ÿ",
+			4,
+			"ç…¥ç…©",
+			4,
+			"ç…¯ç…°ç…±ç…´ç…µç…¶ç…·ç…¹ç…»ç…¼ç…¾",
+			5,
+			"ç†…",
+			4,
+			"ç†‹ç†Œç†ç†Žç†ç†‘ç†’ç†“ç†•ç†–ç†—ç†š",
+			4,
+			"ç†¡",
+			6,
+			"ç†©ç†ªç†«ç†­",
+			5,
+			"ç†´ç†¶ç†·ç†¸ç†º",
+			8,
+			"ç‡„",
+			9,
+			"ç‡",
+			4
+		],
+		[
+			"a040",
+			"ç‡–",
+			9,
+			"ç‡¡ç‡¢ç‡£ç‡¤ç‡¦ç‡¨",
+			5,
+			"ç‡¯",
+			9,
+			"ç‡º",
+			11,
+			"çˆ‡",
+			19
+		],
+		[
+			"a080",
+			"çˆ›çˆœçˆž",
+			9,
+			"çˆ©çˆ«çˆ­çˆ®çˆ¯çˆ²çˆ³çˆ´çˆºçˆ¼çˆ¾ç‰€",
+			6,
+			"ç‰‰ç‰Šç‰‹ç‰Žç‰ç‰ç‰‘ç‰“ç‰”ç‰•ç‰—ç‰˜ç‰šç‰œç‰žç‰ ç‰£ç‰¤ç‰¥ç‰¨ç‰ªç‰«ç‰¬ç‰­ç‰°ç‰±ç‰³ç‰´ç‰¶ç‰·ç‰¸ç‰»ç‰¼ç‰½çŠ‚çŠƒçŠ…",
+			4,
+			"çŠŒçŠŽçŠçŠ‘çŠ“",
+			11,
+			"çŠ ",
+			11,
+			"çŠ®çŠ±çŠ²çŠ³çŠµçŠº",
+			6,
+			"ç‹…ç‹†ç‹‡ç‹‰ç‹Šç‹‹ç‹Œç‹ç‹‘ç‹“ç‹”ç‹•ç‹–ç‹˜ç‹šç‹›"
+		],
+		[
+			"a1a1",
+			"ã€€ã€ã€‚Â·Ë‰Ë‡Â¨ã€ƒã€…â€”ï½žâ€–â€¦â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
+			7,
+			"ã€–ã€—ã€ã€‘Â±Ã—Ã·âˆ¶âˆ§âˆ¨âˆ‘âˆâˆªâˆ©âˆˆâˆ·âˆšâŠ¥âˆ¥âˆ âŒ’âŠ™âˆ«âˆ®â‰¡â‰Œâ‰ˆâˆ½âˆâ‰ â‰®â‰¯â‰¤â‰¥âˆžâˆµâˆ´â™‚â™€Â°â€²â€³â„ƒï¼„Â¤ï¿ ï¿¡â€°Â§â„–â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â€»â†’â†â†‘â†“ã€“"
+		],
+		[
+			"a2a1",
+			"â…°",
+			9
+		],
+		[
+			"a2b1",
+			"â’ˆ",
+			19,
+			"â‘´",
+			19,
+			"â‘ ",
+			9
+		],
+		[
+			"a2e5",
+			"ãˆ ",
+			9
+		],
+		[
+			"a2f1",
+			"â… ",
+			11
+		],
+		[
+			"a3a1",
+			"ï¼ï¼‚ï¼ƒï¿¥ï¼…",
+			88,
+			"ï¿£"
+		],
+		[
+			"a4a1",
+			"ã",
+			82
+		],
+		[
+			"a5a1",
+			"ã‚¡",
+			85
+		],
+		[
+			"a6a1",
+			"Î‘",
+			16,
+			"Î£",
+			6
+		],
+		[
+			"a6c1",
+			"Î±",
+			16,
+			"Ïƒ",
+			6
+		],
+		["a6e0", "ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹€ï¸½ï¸¾ï¹ï¹‚ï¹ƒï¹„"],
+		["a6ee", "ï¸»ï¸¼ï¸·ï¸¸ï¸±"],
+		["a6f4", "ï¸³ï¸´"],
+		[
+			"a7a1",
+			"Ð",
+			5,
+			"ÐÐ–",
+			25
+		],
+		[
+			"a7d1",
+			"Ð°",
+			5,
+			"Ñ‘Ð¶",
+			25
+		],
+		[
+			"a840",
+			"ËŠË‹Ë™â€“â€•â€¥â€µâ„…â„‰â†–â†—â†˜â†™âˆ•âˆŸâˆ£â‰’â‰¦â‰§âŠ¿â•",
+			35,
+			"â–",
+			6
+		],
+		[
+			"a880",
+			"â–ˆ",
+			7,
+			"â–“â–”â–•â–¼â–½â—¢â—£â—¤â—¥â˜‰âŠ•ã€’ã€ã€ž"
+		],
+		["a8a1", "ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼ÃªÉ‘"],
+		["a8bd", "Å„Åˆ"],
+		["a8c0", "É¡"],
+		[
+			"a8c5",
+			"ã„…",
+			36
+		],
+		[
+			"a940",
+			"ã€¡",
+			8,
+			"ãŠ£ãŽŽãŽãŽœãŽãŽžãŽ¡ã„ãŽã‘ã’ã•ï¸°ï¿¢ï¿¤"
+		],
+		["a959", "â„¡ãˆ±"],
+		["a95c", "â€"],
+		[
+			"a960",
+			"ãƒ¼ã‚›ã‚œãƒ½ãƒ¾ã€†ã‚ã‚žï¹‰",
+			9,
+			"ï¹”ï¹•ï¹–ï¹—ï¹™",
+			8
+		],
+		[
+			"a980",
+			"ï¹¢",
+			4,
+			"ï¹¨ï¹©ï¹ªï¹«"
+		],
+		["a996", "ã€‡"],
+		[
+			"a9a4",
+			"â”€",
+			75
+		],
+		[
+			"aa40",
+			"ç‹œç‹ç‹Ÿç‹¢",
+			5,
+			"ç‹ªç‹«ç‹µç‹¶ç‹¹ç‹½ç‹¾ç‹¿çŒ€çŒ‚çŒ„",
+			5,
+			"çŒ‹çŒŒçŒçŒçŒçŒ‘çŒ’çŒ”çŒ˜çŒ™çŒšçŒŸçŒ çŒ£çŒ¤çŒ¦çŒ§çŒ¨çŒ­çŒ¯çŒ°çŒ²çŒ³çŒµçŒ¶çŒºçŒ»çŒ¼çŒ½ç€",
+			8
+		],
+		[
+			"aa80",
+			"ç‰çŠç‹çŒçŽçç‘ç“ç”ç•ç–ç˜",
+			7,
+			"ç¡",
+			10,
+			"ç®ç°ç±"
+		],
+		[
+			"ab40",
+			"ç²",
+			11,
+			"ç¿",
+			4,
+			"çŽ…çŽ†çŽˆçŽŠçŽŒçŽçŽçŽçŽ’çŽ“çŽ”çŽ•çŽ—çŽ˜çŽ™çŽšçŽœçŽçŽžçŽ çŽ¡çŽ£",
+			5,
+			"çŽªçŽ¬çŽ­çŽ±çŽ´çŽµçŽ¶çŽ¸çŽ¹çŽ¼çŽ½çŽ¾çŽ¿ççƒ",
+			4
+		],
+		[
+			"ab80",
+			"ç‹çŒçŽç’",
+			6,
+			"çšç›çœççŸç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³",
+			4
+		],
+		[
+			"ac40",
+			"ç¸",
+			10,
+			"ç„ç‡çˆç‹çŒççŽç‘",
+			8,
+			"çœ",
+			5,
+			"ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·",
+			4,
+			"ç½ç¾ç¿ç‘€ç‘‚",
+			11
+		],
+		[
+			"ac80",
+			"ç‘Ž",
+			6,
+			"ç‘–ç‘˜ç‘ç‘ ",
+			12,
+			"ç‘®ç‘¯ç‘±",
+			4,
+			"ç‘¸ç‘¹ç‘º"
+		],
+		[
+			"ad40",
+			"ç‘»ç‘¼ç‘½ç‘¿ç’‚ç’„ç’…ç’†ç’ˆç’‰ç’Šç’Œç’ç’ç’‘",
+			10,
+			"ç’ç’Ÿ",
+			7,
+			"ç’ª",
+			15,
+			"ç’»",
+			12
+		],
+		[
+			"ad80",
+			"ç“ˆ",
+			9,
+			"ç““",
+			8,
+			"ç“ç“Ÿç“¡ç“¥ç“§",
+			6,
+			"ç“°ç“±ç“²"
+		],
+		[
+			"ae40",
+			"ç“³ç“µç“¸",
+			6,
+			"ç”€ç”ç”‚ç”ƒç”…",
+			7,
+			"ç”Žç”ç”’ç””ç”•ç”–ç”—ç”›ç”ç”žç” ",
+			4,
+			"ç”¦ç”§ç”ªç”®ç”´ç”¶ç”¹ç”¼ç”½ç”¿ç•ç•‚ç•ƒç•„ç•†ç•‡ç•‰ç•Šç•ç•ç•‘ç•’ç•“ç••ç•–ç•—ç•˜"
+		],
+		[
+			"ae80",
+			"ç•",
+			7,
+			"ç•§ç•¨ç•©ç•«",
+			6,
+			"ç•³ç•µç•¶ç•·ç•º",
+			4,
+			"ç–€ç–ç–‚ç–„ç–…ç–‡"
+		],
+		[
+			"af40",
+			"ç–ˆç–‰ç–Šç–Œç–ç–Žç–ç–“ç–•ç–˜ç–›ç–œç–žç–¢ç–¦",
+			4,
+			"ç–­ç–¶ç–·ç–ºç–»ç–¿ç—€ç—ç—†ç—‹ç—Œç—Žç—ç—ç—‘ç—“ç——ç—™ç—šç—œç—ç—Ÿç— ç—¡ç—¥ç—©ç—¬ç—­ç—®ç—¯ç—²ç—³ç—µç—¶ç—·ç—¸ç—ºç—»ç—½ç—¾ç˜‚ç˜„ç˜†ç˜‡"
+		],
+		["af80", "ç˜ˆç˜‰ç˜‹ç˜ç˜Žç˜ç˜‘ç˜’ç˜“ç˜”ç˜–ç˜šç˜œç˜ç˜žç˜¡ç˜£ç˜§ç˜¨ç˜¬ç˜®ç˜¯ç˜±ç˜²ç˜¶ç˜·ç˜¹ç˜ºç˜»ç˜½ç™ç™‚ç™„"],
+		[
+			"b040",
+			"ç™…",
+			6,
+			"ç™Ž",
+			5,
+			"ç™•ç™—",
+			4,
+			"ç™ç™Ÿç™ ç™¡ç™¢ç™¤",
+			6,
+			"ç™¬ç™­ç™®ç™°",
+			7,
+			"ç™¹ç™ºç™¼ç™¿çš€çšçšƒçš…çš‰çšŠçšŒçšçšçšçš’çš”çš•çš—çš˜çššçš›"
+		],
+		[
+			"b080",
+			"çšœ",
+			7,
+			"çš¥",
+			8,
+			"çš¯çš°çš³çšµ",
+			9,
+			"ç›€ç›ç›ƒå•Šé˜¿åŸƒæŒ¨å“Žå”‰å“€çš‘ç™Œè”¼çŸ®è‰¾ç¢çˆ±éš˜éžæ°¨å®‰ä¿ºæŒ‰æš—å²¸èƒºæ¡ˆè‚®æ˜‚ç›Žå‡¹æ•–ç†¬ç¿±è¢„å‚²å¥¥æ‡Šæ¾³èŠ­æŒæ‰’å­å§ç¬†å…«ç–¤å·´æ‹”è·‹é¶æŠŠè€™åéœ¸ç½¢çˆ¸ç™½æŸç™¾æ‘†ä½°è´¥æ‹œç¨—æ–‘ç­æ¬æ‰³èˆ¬é¢æ¿ç‰ˆæ‰®æ‹Œä¼´ç“£åŠåŠžç»Šé‚¦å¸®æ¢†æ¦œè†€ç»‘æ£’ç£…èšŒé•‘å‚è°¤è‹žèƒžåŒ…è¤’å‰¥"
+		],
+		[
+			"b140",
+			"ç›„ç›‡ç›‰ç›‹ç›Œç›“ç›•ç›™ç›šç›œç›ç›žç› ",
+			4,
+			"ç›¦",
+			7,
+			"ç›°ç›³ç›µç›¶ç›·ç›ºç›»ç›½ç›¿çœ€çœ‚çœƒçœ…çœ†çœŠçœŒçœŽ",
+			10,
+			"çœ›çœœçœçœžçœ¡çœ£çœ¤çœ¥çœ§çœªçœ«"
+		],
+		[
+			"b180",
+			"çœ¬çœ®çœ°",
+			4,
+			"çœ¹çœ»çœ½çœ¾çœ¿ç‚ç„ç…ç†çˆ",
+			7,
+			"ç’",
+			7,
+			"çœè–„é›¹ä¿å ¡é¥±å®æŠ±æŠ¥æš´è±¹é²çˆ†æ¯ç¢‘æ‚²å‘åŒ—è¾ˆèƒŒè´é’¡å€ç‹ˆå¤‡æƒ«ç„™è¢«å¥”è‹¯æœ¬ç¬¨å´©ç»·ç”­æ³µè¹¦è¿¸é€¼é¼»æ¯”é„™ç¬”å½¼ç¢§è“–è”½æ¯•æ¯™æ¯–å¸åº‡ç—¹é—­æ•å¼Šå¿…è¾Ÿå£è‡‚é¿é™›éž­è¾¹ç¼–è´¬æ‰ä¾¿å˜åžè¾¨è¾©è¾«éæ ‡å½ªè†˜è¡¨é³–æ†‹åˆ«ç˜ªå½¬æ–Œæ¿’æ»¨å®¾æ‘ˆå…µå†°æŸ„ä¸™ç§‰é¥¼ç‚³"
+		],
+		[
+			"b240",
+			"ççžçŸç ç¤ç§ç©çªç­",
+			11,
+			"çºç»ç¼çžçž‚çžƒçž†",
+			5,
+			"çžçžçž“",
+			11,
+			"çž¡çž£çž¤çž¦çž¨çž«çž­çž®çž¯çž±çž²çž´çž¶",
+			4
+		],
+		[
+			"b280",
+			"çž¼çž¾çŸ€",
+			12,
+			"çŸŽ",
+			8,
+			"çŸ˜çŸ™çŸšçŸ",
+			4,
+			"çŸ¤ç—…å¹¶çŽ»è æ’­æ‹¨é’µæ³¢åšå‹ƒæé“‚ç®”ä¼¯å¸›èˆ¶è„–è†Šæ¸¤æ³Šé©³æ•åœå“ºè¡¥åŸ ä¸å¸ƒæ­¥ç°¿éƒ¨æ€–æ“¦çŒœè£ææ‰è´¢ç¬è¸©é‡‡å½©èœè”¡é¤å‚èš•æ®‹æƒ­æƒ¨ç¿è‹èˆ±ä»“æ²§è—æ“ç³™æ§½æ›¹è‰åŽ•ç­–ä¾§å†Œæµ‹å±‚è¹­æ’å‰èŒ¬èŒ¶æŸ¥ç¢´æ½å¯Ÿå²”å·®è¯§æ‹†æŸ´è±ºæ€æŽºè‰é¦‹è°—ç¼ é“²äº§é˜é¢¤æ˜ŒçŒ–"
+		],
+		[
+			"b340",
+			"çŸ¦çŸ¨çŸªçŸ¯çŸ°çŸ±çŸ²çŸ´çŸµçŸ·çŸ¹çŸºçŸ»çŸ¼ç ƒ",
+			5,
+			"ç Šç ‹ç Žç ç ç “ç •ç ™ç ›ç žç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡‚ç¡ƒç¡„ç¡†ç¡ˆç¡‰ç¡Šç¡‹ç¡ç¡ç¡‘ç¡“ç¡”ç¡˜ç¡™ç¡š"
+		],
+		[
+			"b380",
+			"ç¡›ç¡œç¡ž",
+			11,
+			"ç¡¯",
+			7,
+			"ç¡¸ç¡¹ç¡ºç¡»ç¡½",
+			6,
+			"åœºå°å¸¸é•¿å¿è‚ åŽ‚æ•žç•…å”±å€¡è¶…æŠ„é’žæœå˜²æ½®å·¢åµç‚’è½¦æ‰¯æ’¤æŽ£å½»æ¾ˆéƒ´è‡£è¾°å°˜æ™¨å¿±æ²‰é™ˆè¶è¡¬æ’‘ç§°åŸŽæ©™æˆå‘ˆä¹˜ç¨‹æƒ©æ¾„è¯šæ‰¿é€žéª‹ç§¤åƒç—´æŒåŒ™æ± è¿Ÿå¼›é©°è€»é½¿ä¾ˆå°ºèµ¤ç¿…æ–¥ç‚½å……å†²è™«å´‡å® æŠ½é…¬ç•´è¸Œç¨ æ„ç­¹ä»‡ç»¸çž…ä¸‘è‡­åˆå‡ºæ©±åŽ¨èº‡é”„é›æ»é™¤æ¥š"
+		],
+		[
+			"b440",
+			"ç¢„ç¢…ç¢†ç¢ˆç¢Šç¢‹ç¢ç¢ç¢’ç¢”ç¢•ç¢–ç¢™ç¢ç¢žç¢ ç¢¢ç¢¤ç¢¦ç¢¨",
+			7,
+			"ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£€ç£‚ç£ƒç£„ç£†ç£‡ç£ˆç£Œç£ç£Žç£ç£‘ç£’ç£“ç£–ç£—ç£˜ç£š",
+			9
+		],
+		[
+			"b480",
+			"ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­",
+			4,
+			"ç£³ç£µç£¶ç£¸ç£¹ç£»",
+			5,
+			"ç¤‚ç¤ƒç¤„ç¤†",
+			6,
+			"ç¡€å‚¨çŸ—æè§¦å¤„æ£å·ç©¿æ¤½ä¼ èˆ¹å–˜ä¸²ç–®çª—å¹¢åºŠé—¯åˆ›å¹ç‚Šæ¶é”¤åž‚æ˜¥æ¤¿é†‡å”‡æ·³çº¯è ¢æˆ³ç»°ç–µèŒ¨ç£é›Œè¾žæ…ˆç“·è¯æ­¤åˆºèµæ¬¡èªè‘±å›±åŒ†ä»Žä¸›å‡‘ç²—é†‹ç°‡ä¿ƒè¹¿ç¯¡çªœæ‘§å´”å‚¬è„†ç˜ç²¹æ·¬ç¿ æ‘å­˜å¯¸ç£‹æ’®æ“æŽªæŒ«é”™æ­è¾¾ç­”ç˜©æ‰“å¤§å‘†æ­¹å‚£æˆ´å¸¦æ®†ä»£è´·è¢‹å¾…é€®"
+		],
+		[
+			"b540",
+			"ç¤",
+			5,
+			"ç¤”",
+			9,
+			"ç¤Ÿ",
+			4,
+			"ç¤¥",
+			14,
+			"ç¤µ",
+			4,
+			"ç¤½ç¤¿ç¥‚ç¥ƒç¥„ç¥…ç¥‡ç¥Š",
+			8,
+			"ç¥”ç¥•ç¥˜ç¥™ç¥¡ç¥£"
+		],
+		[
+			"b580",
+			"ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°",
+			6,
+			"ç¥¹ç¥»",
+			4,
+			"ç¦‚ç¦ƒç¦†ç¦‡ç¦ˆç¦‰ç¦‹ç¦Œç¦ç¦Žç¦ç¦‘ç¦’æ€ è€½æ‹…ä¸¹å•éƒ¸æŽ¸èƒ†æ—¦æ°®ä½†æƒ®æ·¡è¯žå¼¹è›‹å½“æŒ¡å…šè¡æ¡£åˆ€æ£è¹ˆå€’å²›ç¥·å¯¼åˆ°ç¨»æ‚¼é“ç›—å¾·å¾—çš„è¹¬ç¯ç™»ç­‰çžªå‡³é‚“å ¤ä½Žæ»´è¿ªæ•Œç¬›ç‹„æ¶¤ç¿Ÿå«¡æŠµåº•åœ°è’‚ç¬¬å¸å¼Ÿé€’ç¼”é¢ æŽ‚æ»‡ç¢˜ç‚¹å…¸é›åž«ç”µä½ƒç”¸åº—æƒ¦å¥ æ·€æ®¿ç¢‰å¼é›•å‡‹åˆæŽ‰åŠé’“è°ƒè·Œçˆ¹ç¢Ÿè¶è¿­è°å "
+		],
+		[
+			"b640",
+			"ç¦“",
+			6,
+			"ç¦›",
+			11,
+			"ç¦¨",
+			10,
+			"ç¦´",
+			4,
+			"ç¦¼ç¦¿ç§‚ç§„ç§…ç§‡ç§ˆç§Šç§Œç§Žç§ç§ç§“ç§”ç§–ç§—ç§™",
+			5,
+			"ç§ ç§¡ç§¢ç§¥ç§¨ç§ª"
+		],
+		[
+			"b680",
+			"ç§¬ç§®ç§±",
+			6,
+			"ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨„ç¨…ç¨‡ç¨ˆç¨‰ç¨Šç¨Œç¨",
+			4,
+			"ç¨•ç¨–ç¨˜ç¨™ç¨›ç¨œä¸ç›¯å®é’‰é¡¶é¼Žé”­å®šè®¢ä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨æ ‹ä¾—æ«å†»æ´žå…œæŠ–æ–—é™¡è±†é€—ç—˜éƒ½ç£æ¯’çŠŠç‹¬è¯»å µç¹èµŒæœé•€è‚šåº¦æ¸¡å¦’ç«¯çŸ­é”»æ®µæ–­ç¼Žå †å…‘é˜Ÿå¯¹å¢©å¨è¹²æ•¦é¡¿å›¤é’ç›¾éæŽ‡å“†å¤šå¤ºåž›èº²æœµè·ºèˆµå‰æƒ°å •è›¾å³¨é¹…ä¿„é¢è®¹å¨¥æ¶åŽ„æ‰¼éé„‚é¥¿æ©è€Œå„¿è€³å°”é¥µæ´±äºŒ"
+		],
+		[
+			"b740",
+			"ç¨ç¨Ÿç¨¡ç¨¢ç¨¤",
+			14,
+			"ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©€",
+			5,
+			"ç©‡",
+			9,
+			"ç©’",
+			4,
+			"ç©˜",
+			16
+		],
+		[
+			"b780",
+			"ç©©",
+			6,
+			"ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çª‚çª…çª‡çª‰çªŠçª‹çªŒçªŽçªçªçª“çª”çª™çªšçª›çªžçª¡çª¢è´°å‘ç½šç­ä¼ä¹é˜€æ³•çè—©å¸†ç•ªç¿»æ¨ŠçŸ¾é’’ç¹å‡¡çƒ¦åè¿”èŒƒè´©çŠ¯é¥­æ³›åŠèŠ³æ–¹è‚ªæˆ¿é˜²å¦¨ä»¿è®¿çººæ”¾è²éžå•¡é£žè‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹èŠ¬é…šå©æ°›åˆ†çº·åŸç„šæ±¾ç²‰å¥‹ä»½å¿¿æ„¤ç²ªä¸°å°æž«èœ‚å³°é”‹é£Žç–¯çƒ½é€¢å†¯ç¼è®½å¥‰å‡¤ä½›å¦å¤«æ•·è‚¤å­µæ‰¶æ‹‚è¾å¹…æ°Ÿç¬¦ä¼ä¿˜æœ"
+		],
+		[
+			"b840",
+			"çª£çª¤çª§çª©çªªçª«çª®",
+			4,
+			"çª´",
+			10,
+			"ç«€",
+			10,
+			"ç«Œ",
+			9,
+			"ç«—ç«˜ç«šç«›ç«œç«ç«¡ç«¢ç«¤ç«§",
+			5,
+			"ç«®ç«°ç«±ç«²ç«³"
+		],
+		[
+			"b880",
+			"ç«´",
+			4,
+			"ç«»ç«¼ç«¾ç¬€ç¬ç¬‚ç¬…ç¬‡ç¬‰ç¬Œç¬ç¬Žç¬ç¬’ç¬“ç¬–ç¬—ç¬˜ç¬šç¬œç¬ç¬Ÿç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼—ç”«æŠšè¾…ä¿¯é‡œæ–§è„¯è…‘åºœè…èµ´å‰¯è¦†èµ‹å¤å‚…ä»˜é˜œçˆ¶è…¹è´Ÿå¯Œè®£é™„å¦‡ç¼šå’å™¶å˜Žè¯¥æ”¹æ¦‚é’™ç›–æº‰å¹²ç”˜æ†æŸ‘ç«¿è‚èµ¶æ„Ÿç§†æ•¢èµ£å†ˆåˆšé’¢ç¼¸è‚›çº²å²—æ¸¯æ ç¯™çš‹é«˜è†ç¾”ç³•æžé•ç¨¿å‘Šå“¥æ­Œææˆˆé¸½èƒ³ç–™å‰²é©è‘›æ ¼è›¤é˜éš”é“¬ä¸ªå„ç»™æ ¹è·Ÿè€•æ›´åºšç¾¹"
+		],
+		[
+			"b940",
+			"ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿",
+			5,
+			"ç­†ç­ˆç­Šç­ç­Žç­“ç­•ç­—ç­™ç­œç­žç­Ÿç­¡ç­£",
+			10,
+			"ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®‚ç®ƒç®„ç®†",
+			6,
+			"ç®Žç®"
+		],
+		[
+			"b980",
+			"ç®‘ç®’ç®“ç®–ç®˜ç®™ç®šç®›ç®žç®Ÿç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹",
+			7,
+			"ç¯‚ç¯ƒç¯„åŸ‚è€¿æ¢—å·¥æ”»åŠŸæ­é¾šä¾›èº¬å…¬å®«å¼“å·©æ±žæ‹±è´¡å…±é’©å‹¾æ²Ÿè‹Ÿç‹—åž¢æž„è´­å¤Ÿè¾œè‡å’•ç®ä¼°æ²½å­¤å§‘é¼“å¤è›Šéª¨è°·è‚¡æ•…é¡¾å›ºé›‡åˆ®ç“œå‰å¯¡æŒ‚è¤‚ä¹–æ‹æ€ªæ£ºå…³å®˜å† è§‚ç®¡é¦†ç½æƒ¯çŒè´¯å…‰å¹¿é€›ç‘°è§„åœ­ç¡…å½’é¾Ÿé—ºè½¨é¬¼è¯¡ç™¸æ¡‚æŸœè·ªè´µåˆ½è¾Šæ»šæ£é”…éƒ­å›½æžœè£¹è¿‡å“ˆ"
+		],
+		[
+			"ba40",
+			"ç¯…ç¯ˆç¯‰ç¯Šç¯‹ç¯ç¯Žç¯ç¯ç¯’ç¯”",
+			4,
+			"ç¯›ç¯œç¯žç¯Ÿç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²",
+			4,
+			"ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿",
+			7,
+			"ç°ˆç°‰ç°Šç°ç°Žç°",
+			5,
+			"ç°—ç°˜ç°™"
+		],
+		[
+			"ba80",
+			"ç°š",
+			4,
+			"ç° ",
+			5,
+			"ç°¨ç°©ç°«",
+			12,
+			"ç°¹",
+			5,
+			"ç±‚éª¸å­©æµ·æ°¦äº¥å®³éª‡é…£æ†¨é‚¯éŸ©å«æ¶µå¯’å‡½å–Šç½•ç¿°æ’¼ææ—±æ†¾æ‚ç„Šæ±—æ±‰å¤¯æ­èˆªå£•åšŽè±ªæ¯«éƒå¥½è€—å·æµ©å‘µå–è·èæ ¸ç¦¾å’Œä½•åˆç›’è²‰é˜‚æ²³æ¶¸èµ«è¤é¹¤è´ºå˜¿é»‘ç—•å¾ˆç‹ æ¨å“¼äº¨æ¨ªè¡¡æ’è½°å“„çƒ˜è™¹é¸¿æ´ªå®å¼˜çº¢å–‰ä¾¯çŒ´å¼åŽšå€™åŽå‘¼ä¹Žå¿½ç‘šå£¶è‘«èƒ¡è´ç‹ç³Šæ¹–"
+		],
+		[
+			"bb40",
+			"ç±ƒ",
+			9,
+			"ç±Ž",
+			36,
+			"ç±µ",
+			5,
+			"ç±¾",
+			9
+		],
+		[
+			"bb80",
+			"ç²ˆç²Š",
+			6,
+			"ç²“ç²”ç²–ç²™ç²šç²›ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´",
+			4,
+			"ç²ºç²»å¼§è™Žå”¬æŠ¤äº’æ²ªæˆ·èŠ±å“—åŽçŒ¾æ»‘ç”»åˆ’åŒ–è¯æ§å¾Šæ€€æ·®åæ¬¢çŽ¯æ¡“è¿˜ç¼“æ¢æ‚£å”¤ç—ªè±¢ç„•æ¶£å®¦å¹»è’æ…Œé»„ç£ºè—ç°§çš‡å‡°æƒ¶ç…Œæ™ƒå¹Œæè°Žç°æŒ¥è¾‰å¾½æ¢è›”å›žæ¯æ‚”æ…§å‰æƒ æ™¦è´¿ç§½ä¼šçƒ©æ±‡è®³è¯²ç»˜è¤æ˜å©šé­‚æµ‘æ··è±æ´»ä¼™ç«èŽ·æˆ–æƒ‘éœè´§ç¥¸å‡»åœ¾åŸºæœºç•¸ç¨½ç§¯ç®•"
+		],
+		[
+			"bc40",
+			"ç²¿ç³€ç³‚ç³ƒç³„ç³†ç³‰ç³‹ç³Ž",
+			6,
+			"ç³˜ç³šç³›ç³ç³žç³¡",
+			6,
+			"ç³©",
+			5,
+			"ç³°",
+			7,
+			"ç³¹ç³ºç³¼",
+			13,
+			"ç´‹",
+			5
+		],
+		[
+			"bc80",
+			"ç´‘",
+			14,
+			"ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°",
+			6,
+			"è‚Œé¥¥è¿¹æ¿€è®¥é¸¡å§¬ç»©ç¼‰å‰æžæ£˜è¾‘ç±é›†åŠæ€¥ç–¾æ±²å³å«‰çº§æŒ¤å‡ è„Šå·±è“ŸæŠ€å†€å­£ä¼Žç¥­å‰‚æ‚¸æµŽå¯„å¯‚è®¡è®°æ—¢å¿Œé™…å¦“ç»§çºªå˜‰æž·å¤¹ä½³å®¶åŠ èšé¢Šè´¾ç”²é’¾å‡ç¨¼ä»·æž¶é©¾å«æ­¼ç›‘åšå°–ç¬ºé—´ç…Žå…¼è‚©è‰°å¥¸ç¼„èŒ§æ£€æŸ¬ç¢±ç¡·æ‹£æ¡ç®€ä¿­å‰ªå‡èæ§›é‰´è·µè´±è§é”®ç®­ä»¶"
+		],
+		[
+			"bd40",
+			"ç´·",
+			54,
+			"çµ¯",
+			7
+		],
+		[
+			"bd80",
+			"çµ¸",
+			32,
+			"å¥èˆ°å‰‘é¥¯æ¸æº…æ¶§å»ºåƒµå§œå°†æµ†æ±Ÿç–†è’‹æ¡¨å¥–è®²åŒ é…±é™è•‰æ¤’ç¤ç„¦èƒ¶äº¤éƒŠæµ‡éª„å¨‡åš¼æ…é“°çŸ«ä¾¥è„šç‹¡è§’é¥ºç¼´ç»žå‰¿æ•™é…µè½¿è¾ƒå«çª–æ­æŽ¥çš†ç§¸è¡—é˜¶æˆªåŠ«èŠ‚æ¡”æ°æ·ç«ç«­æ´ç»“è§£å§æˆ’è—‰èŠ¥ç•Œå€Ÿä»‹ç–¥è¯«å±Šå·¾ç­‹æ–¤é‡‘ä»Šæ´¥è¥Ÿç´§é”¦ä»…è°¨è¿›é³æ™‹ç¦è¿‘çƒ¬æµ¸"
+		],
+		[
+			"be40",
+			"ç¶™",
+			12,
+			"ç¶§",
+			6,
+			"ç¶¯",
+			42
+		],
+		[
+			"be80",
+			"ç·š",
+			32,
+			"å°½åŠ²è†å…¢èŒŽç›æ™¶é²¸äº¬æƒŠç²¾ç²³ç»äº•è­¦æ™¯é¢ˆé™å¢ƒæ•¬é•œå¾„ç—‰é–ç«Ÿç«žå‡€ç‚¯çª˜æªç©¶çº çŽ–éŸ­ä¹…ç¸ä¹é…’åŽ©æ•‘æ—§è‡¼èˆ…å’Žå°±ç–šéž æ‹˜ç‹™ç–½å±…é©¹èŠå±€å’€çŸ©ä¸¾æ²®èšæ‹’æ®å·¨å…·è·è¸žé”¯ä¿±å¥æƒ§ç‚¬å‰§æé¹ƒå¨Ÿå€¦çœ·å·ç»¢æ’…æ”«æŠ‰æŽ˜å€”çˆµè§‰å†³è¯€ç»å‡èŒé’§å†›å›å³»"
+		],
+		[
+			"bf40",
+			"ç·»",
+			62
+		],
+		[
+			"bf80",
+			"ç¸ºç¸¼",
+			4,
+			"ç¹‚",
+			4,
+			"ç¹ˆ",
+			21,
+			"ä¿Šç«£æµšéƒ¡éªå–€å’–å¡å’¯å¼€æ©æ¥·å‡¯æ…¨åˆŠå ªå‹˜åŽç çœ‹åº·æ…·ç³ æ‰›æŠ—äº¢ç‚•è€ƒæ‹·çƒ¤é å·è‹›æŸ¯æ£µç£•é¢—ç§‘å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å•ƒåž¦æ³å‘å­ç©ºæå­”æŽ§æŠ å£æ‰£å¯‡æž¯å“­çªŸè‹¦é…·åº“è£¤å¤¸åž®æŒŽè·¨èƒ¯å—ç­·ä¾©å¿«å®½æ¬¾åŒ¡ç­ç‹‚æ¡†çŸ¿çœ¶æ—·å†µäºç›”å²¿çª¥è‘µå¥Žé­å‚€"
+		],
+		[
+			"c040",
+			"ç¹ž",
+			35,
+			"çºƒ",
+			23,
+			"çºœçºçºž"
+		],
+		[
+			"c080",
+			"çº®çº´çº»çº¼ç»–ç»¤ç»¬ç»¹ç¼Šç¼ç¼žç¼·ç¼¹ç¼»",
+			6,
+			"ç½ƒç½†",
+			9,
+			"ç½’ç½“é¦ˆæ„§æºƒå¤æ˜†æ†å›°æ‹¬æ‰©å»“é˜”åžƒæ‹‰å–‡èœ¡è…Šè¾£å•¦èŽ±æ¥èµ–è“å©ªæ æ‹¦ç¯®é˜‘å…°æ¾œè°°æ½è§ˆæ‡’ç¼†çƒ‚æ»¥ç…æ¦”ç‹¼å»ŠéƒŽæœ—æµªæžåŠ³ç‰¢è€ä½¬å§¥é…ªçƒ™æ¶å‹’ä¹é›·é•­è•¾ç£Šç´¯å„¡åž’æ“‚è‚‹ç±»æ³ªæ£±æ¥žå†·åŽ˜æ¢¨çŠé»Žç¯±ç‹¸ç¦»æ¼“ç†æŽé‡Œé²¤ç¤¼èŽ‰è”åæ —ä¸½åŽ‰åŠ±ç ¾åŽ†åˆ©å‚ˆä¾‹ä¿"
+		],
+		[
+			"c140",
+			"ç½–ç½™ç½›ç½œç½ç½žç½ ç½£",
+			4,
+			"ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾€ç¾‚",
+			7,
+			"ç¾‹ç¾ç¾",
+			4,
+			"ç¾•",
+			4,
+			"ç¾›ç¾œç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨",
+			6,
+			"ç¾±"
+		],
+		[
+			"c180",
+			"ç¾³",
+			4,
+			"ç¾ºç¾»ç¾¾ç¿€ç¿‚ç¿ƒç¿„ç¿†ç¿‡ç¿ˆç¿‰ç¿‹ç¿ç¿",
+			4,
+			"ç¿–ç¿—ç¿™",
+			5,
+			"ç¿¢ç¿£ç—¢ç«‹ç²’æ²¥éš¶åŠ›ç’ƒå“©ä¿©è”èŽ²è¿žé•°å»‰æ€œæ¶Ÿå¸˜æ•›è„¸é“¾æ‹ç‚¼ç»ƒç²®å‡‰æ¢ç²±è‰¯ä¸¤è¾†é‡æ™¾äº®è°…æ’©èŠåƒšç–—ç‡Žå¯¥è¾½æ½¦äº†æ’‚é•£å»–æ–™åˆ—è£‚çƒˆåŠ£çŒŽç³æž—ç£·éœ–ä¸´é‚»é³žæ·‹å‡›èµåæ‹ŽçŽ²è±é›¶é¾„é“ƒä¼¶ç¾šå‡Œçµé™µå²­é¢†å¦ä»¤æºœç‰æ¦´ç¡«é¦ç•™åˆ˜ç˜¤æµæŸ³å…­é¾™è‹å’™ç¬¼çª¿"
+		],
+		[
+			"c240",
+			"ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´",
+			6,
+			"ç¿½ç¿¾ç¿¿è€‚è€‡è€ˆè€‰è€Šè€Žè€è€‘è€“è€šè€›è€è€žè€Ÿè€¡è€£è€¤è€«",
+			5,
+			"è€²è€´è€¹è€ºè€¼è€¾è€èè„è…è‡èˆè‰èŽèèè‘è“è•è–è—"
+		],
+		[
+			"c280",
+			"è™è›",
+			13,
+			"è«",
+			5,
+			"è²",
+			11,
+			"éš†åž„æ‹¢é™‡æ¥¼å¨„æ‚ç¯“æ¼é™‹èŠ¦å¢é¢…åºç‚‰æŽ³å¤è™é²éº“ç¢Œéœ²è·¯èµ‚é¹¿æ½žç¦„å½•é™†æˆ®é©´å•é“ä¾£æ—…å±¥å±¡ç¼•è™‘æ°¯å¾‹çŽ‡æ»¤ç»¿å³¦æŒ›å­ªæ»¦åµä¹±æŽ ç•¥æŠ¡è½®ä¼¦ä»‘æ²¦çº¶è®ºèèžºç½—é€»é”£ç®©éª¡è£¸è½æ´›éª†ç»œå¦ˆéº»çŽ›ç èš‚é©¬éª‚å˜›å—åŸ‹ä¹°éº¦å–è¿ˆè„‰çž’é¦’è›®æ»¡è”“æ›¼æ…¢æ¼«"
+		],
+		[
+			"c340",
+			"è¾è‚è‚‚è‚…è‚ˆè‚Šè‚",
+			5,
+			"è‚”è‚•è‚—è‚™è‚žè‚£è‚¦è‚§è‚¨è‚¬è‚°è‚³è‚µè‚¶è‚¸è‚¹è‚»èƒ…èƒ‡",
+			4,
+			"èƒ",
+			6,
+			"èƒ˜èƒŸèƒ èƒ¢èƒ£èƒ¦èƒ®èƒµèƒ·èƒ¹èƒ»èƒ¾èƒ¿è„€è„è„ƒè„„è„…è„‡è„ˆè„‹"
+		],
+		[
+			"c380",
+			"è„Œè„•è„—è„™è„›è„œè„è„Ÿ",
+			12,
+			"è„­è„®è„°è„³è„´è„µè„·è„¹",
+			4,
+			"è„¿è°©èŠ’èŒ«ç›²æ°“å¿™èŽ½çŒ«èŒ…é”šæ¯›çŸ›é“†å¯èŒ‚å†’å¸½è²Œè´¸ä¹ˆçŽ«æžšæ¢…é…¶éœ‰ç…¤æ²¡çœ‰åª’é•æ¯ç¾Žæ˜§å¯å¦¹åªšé—¨é—·ä»¬èŒè’™æª¬ç›Ÿé”°çŒ›æ¢¦å­Ÿçœ¯é†šé¡ç³œè¿·è°œå¼¥ç±³ç§˜è§…æ³Œèœœå¯†å¹‚æ£‰çœ ç»µå†•å…å‹‰å¨©ç¼…é¢è‹—æçž„è—ç§’æ¸ºåº™å¦™è”‘ç­æ°‘æŠ¿çš¿æ•æ‚¯é—½æ˜ŽèžŸé¸£é“­åå‘½è°¬æ‘¸"
+		],
+		[
+			"c440",
+			"è…€",
+			5,
+			"è…‡è…‰è…è…Žè…è…’è…–è…—è…˜è…›",
+			4,
+			"è…¡è…¢è…£è…¤è…¦è…¨è…ªè…«è…¬è…¯è…²è…³è…µè…¶è…·è…¸è†è†ƒ",
+			4,
+			"è†‰è†‹è†Œè†è†Žè†è†’",
+			5,
+			"è†™è†šè†ž",
+			4,
+			"è†¤è†¥"
+		],
+		[
+			"c480",
+			"è†§è†©è†«",
+			7,
+			"è†´",
+			5,
+			"è†¼è†½è†¾è†¿è‡„è‡…è‡‡è‡ˆè‡‰è‡‹è‡",
+			6,
+			"æ‘¹è˜‘æ¨¡è†œç£¨æ‘©é­”æŠ¹æœ«èŽ«å¢¨é»˜æ²«æ¼ å¯žé™Œè°‹ç‰ŸæŸæ‹‡ç‰¡äº©å§†æ¯å¢“æš®å¹•å‹Ÿæ…•æœ¨ç›®ç¦ç‰§ç©†æ‹¿å“ªå‘é’ é‚£å¨œçº³æ°–ä¹ƒå¥¶è€å¥ˆå—ç”·éš¾å›ŠæŒ è„‘æ¼é—¹æ·–å‘¢é¦å†…å«©èƒ½å¦®éœ“å€ªæ³¥å°¼æ‹Ÿä½ åŒ¿è…»é€†æººè”«æ‹ˆå¹´ç¢¾æ’µæ»å¿µå¨˜é…¿é¸Ÿå°¿æè‚å­½å•®é•Šé•æ¶…æ‚¨æŸ ç‹žå‡å®"
+		],
+		[
+			"c540",
+			"è‡”",
+			14,
+			"è‡¤è‡¥è‡¦è‡¨è‡©è‡«è‡®",
+			4,
+			"è‡µ",
+			5,
+			"è‡½è‡¿èˆƒèˆ‡",
+			4,
+			"èˆŽèˆèˆ‘èˆ“èˆ•",
+			5,
+			"èˆèˆ èˆ¤èˆ¥èˆ¦èˆ§èˆ©èˆ®èˆ²èˆºèˆ¼èˆ½èˆ¿"
+		],
+		[
+			"c580",
+			"è‰€è‰è‰‚è‰ƒè‰…è‰†è‰ˆè‰Šè‰Œè‰è‰Žè‰",
+			7,
+			"è‰™è‰›è‰œè‰è‰žè‰ ",
+			7,
+			"è‰©æ‹§æ³žç‰›æ‰­é’®çº½è„“æµ“å†œå¼„å¥´åŠªæ€’å¥³æš–è™ç–ŸæŒªæ‡¦ç³¯è¯ºå“¦æ¬§é¸¥æ®´è—•å‘•å¶æ²¤å•ªè¶´çˆ¬å¸•æ€•ç¶æ‹æŽ’ç‰Œå¾˜æ¹ƒæ´¾æ”€æ½˜ç›˜ç£ç›¼ç•”åˆ¤å›ä¹“åºžæ—è€ªèƒ–æŠ›å’†åˆ¨ç‚®è¢è·‘æ³¡å‘¸èƒšåŸ¹è£´èµ”é™ªé…ä½©æ²›å–·ç›†ç °æŠ¨çƒ¹æ¾Žå½­è“¬æ£šç¡¼ç¯·è†¨æœ‹é¹æ§ç¢°å¯ç ’éœ¹æ‰¹æŠ«åŠˆçµæ¯—"
+		],
+		["c640", "è‰ªè‰«è‰¬è‰­è‰±è‰µè‰¶è‰·è‰¸è‰»è‰¼èŠ€èŠèŠƒèŠ…èŠ†èŠ‡èŠ‰èŠŒèŠèŠ“èŠ”èŠ•èŠ–èŠšèŠ›èŠžèŠ èŠ¢èŠ£èŠ§èŠ²èŠµèŠ¶èŠºèŠ»èŠ¼èŠ¿è‹€è‹‚è‹ƒè‹…è‹†è‹‰è‹è‹–è‹™è‹šè‹è‹¢è‹§è‹¨è‹©è‹ªè‹¬è‹­è‹®è‹°è‹²è‹³è‹µè‹¶è‹¸"],
+		[
+			"c680",
+			"è‹ºè‹¼",
+			4,
+			"èŒŠèŒ‹èŒèŒèŒ’èŒ“èŒ–èŒ˜èŒ™èŒ",
+			9,
+			"èŒ©èŒªèŒ®èŒ°èŒ²èŒ·èŒ»èŒ½å•¤è„¾ç–²çš®åŒ¹ç—žåƒ»å±è­¬ç¯‡åç‰‡éª—é£˜æ¼‚ç“¢ç¥¨æ’‡çž¥æ‹¼é¢‘è´«å“è˜ä¹’åªè‹¹èå¹³å‡­ç“¶è¯„å±å¡æ³¼é¢‡å©†ç ´é­„è¿«ç²•å‰–æ‰‘é“ºä»†èŽ†è‘¡è©è’²åŸ”æœ´åœƒæ™®æµ¦è°±æ›ç€‘æœŸæ¬ºæ –æˆšå¦»ä¸ƒå‡„æ¼†æŸ’æ²å…¶æ£‹å¥‡æ­§ç•¦å´Žè„é½æ——ç¥ˆç¥éª‘èµ·å²‚ä¹žä¼å¯å¥‘ç Œå™¨æ°”è¿„å¼ƒæ±½æ³£è®«æŽ"
+		],
+		[
+			"c740",
+			"èŒ¾èŒ¿èè‚è„è…èˆèŠ",
+			4,
+			"è“è•",
+			4,
+			"èè¢è°",
+			6,
+			"è¹èºè¾",
+			6,
+			"èŽ‡èŽˆèŽŠèŽ‹èŽŒèŽèŽèŽèŽ‘èŽ”èŽ•èŽ–èŽ—èŽ™èŽšèŽèŽŸèŽ¡",
+			6,
+			"èŽ¬èŽ­èŽ®"
+		],
+		["c780", "èŽ¯èŽµèŽ»èŽ¾èŽ¿è‚èƒè„è†èˆè‰è‹èèŽèè‘è’è“è•è—è™èšè›èžè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½ç‰µæ‰¦é’Žé“…åƒè¿ç­¾ä»Ÿè°¦ä¹¾é»”é’±é’³å‰æ½œé£æµ…è°´å ‘åµŒæ¬ æ­‰æžªå‘›è…”ç¾Œå¢™è”·å¼ºæŠ¢æ©‡é”¹æ•²æ‚„æ¡¥çž§ä¹”ä¾¨å·§éž˜æ’¬ç¿˜å³­ä¿çªåˆ‡èŒ„ä¸”æ€¯çªƒé’¦ä¾µäº²ç§¦ç´å‹¤èŠ¹æ“’ç¦½å¯æ²é’è½»æ°¢å€¾å¿æ¸…æ“Žæ™´æ°°æƒ…é¡·è¯·åº†ç¼ç©·ç§‹ä¸˜é‚±çƒæ±‚å›šé…‹æ³…è¶‹åŒºè›†æ›²èº¯å±ˆé©±æ¸ "],
+		[
+			"c840",
+			"è®è¯è³",
+			4,
+			"èºè»è¼è¾è¿è€è‚è…è‡èˆè‰èŠèè’",
+			5,
+			"è™èšè›èž",
+			5,
+			"è©",
+			7,
+			"è²",
+			5,
+			"è¹èºè»è¾",
+			7,
+			"è‘‡è‘ˆè‘‰"
+		],
+		[
+			"c880",
+			"è‘Š",
+			6,
+			"è‘’",
+			4,
+			"è‘˜è‘è‘žè‘Ÿè‘ è‘¢è‘¤",
+			4,
+			"è‘ªè‘®è‘¯è‘°è‘²è‘´è‘·è‘¹è‘»è‘¼å–å¨¶é¾‹è¶£åŽ»åœˆé¢§æƒé†›æ³‰å…¨ç—Šæ‹³çŠ¬åˆ¸åŠç¼ºç‚”ç˜¸å´é¹Šæ¦·ç¡®é›€è£™ç¾¤ç„¶ç‡ƒå†‰æŸ“ç“¤å£¤æ”˜åš·è®©é¥¶æ‰°ç»•æƒ¹çƒ­å£¬ä»äººå¿éŸ§ä»»è®¤åˆƒå¦Šçº«æ‰”ä»æ—¥æˆŽèŒ¸è“‰è£èžç†”æº¶å®¹ç»’å†—æ‰æŸ”è‚‰èŒ¹è •å„’å­ºå¦‚è¾±ä¹³æ±å…¥è¤¥è½¯é˜®è•Šç‘žé”é—°æ¶¦è‹¥å¼±æ’’æ´’è¨è…®é³ƒå¡žèµ›ä¸‰å"
+		],
+		[
+			"c940",
+			"è‘½",
+			4,
+			"è’ƒè’„è’…è’†è’Šè’è’",
+			7,
+			"è’˜è’šè’›è’è’žè’Ÿè’ è’¢",
+			12,
+			"è’°è’±è’³è’µè’¶è’·è’»è’¼è’¾è“€è“‚è“ƒè“…è“†è“‡è“ˆè“‹è“Œè“Žè“è“’è“”è“•è“—"
+		],
+		[
+			"c980",
+			"è“˜",
+			4,
+			"è“žè“¡è“¢è“¤è“§",
+			4,
+			"è“­è“®è“¯è“±",
+			10,
+			"è“½è“¾è”€è”è”‚ä¼žæ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚ç‘Ÿè‰²æ¶©æ£®åƒ§èŽŽç ‚æ€åˆ¹æ²™çº±å‚»å•¥ç…žç­›æ™’çŠè‹«æ‰å±±åˆ ç…½è¡«é—ªé™•æ“…èµ¡è†³å–„æ±•æ‰‡ç¼®å¢’ä¼¤å•†èµæ™Œä¸Šå°šè£³æ¢¢æŽç¨çƒ§èŠå‹ºéŸ¶å°‘å“¨é‚µç»å¥¢èµŠè›‡èˆŒèˆèµ¦æ‘„å°„æ…‘æ¶‰ç¤¾è®¾ç ·ç”³å‘»ä¼¸èº«æ·±å¨ ç»…ç¥žæ²ˆå®¡å©¶ç”šè‚¾æ…Žæ¸—å£°ç”Ÿç”¥ç‰²å‡ç»³"
+		],
+		[
+			"ca40",
+			"è”ƒ",
+			8,
+			"è”è”Žè”è”è”’è””è”•è”–è”˜è”™è”›è”œè”è”žè” è”¢",
+			8,
+			"è”­",
+			9,
+			"è”¾",
+			4,
+			"è•„è•…è•†è•‡è•‹",
+			10
+		],
+		[
+			"ca80",
+			"è•—è•˜è•šè•›è•œè•è•Ÿ",
+			4,
+			"è•¥è•¦è•§è•©",
+			8,
+			"è•³è•µè•¶è•·è•¸è•¼è•½è•¿è–€è–çœç››å‰©èƒœåœ£å¸ˆå¤±ç‹®æ–½æ¹¿è¯—å°¸è™±åçŸ³æ‹¾æ—¶ä»€é£Ÿèš€å®žè¯†å²çŸ¢ä½¿å±Žé©¶å§‹å¼ç¤ºå£«ä¸–æŸ¿äº‹æ‹­èª“é€åŠ¿æ˜¯å—œå™¬é€‚ä»•ä¾é‡Šé¥°æ°å¸‚æƒå®¤è§†è¯•æ”¶æ‰‹é¦–å®ˆå¯¿æŽˆå”®å—ç˜¦å…½è”¬æž¢æ¢³æ®ŠæŠ’è¾“å”èˆ’æ·‘ç–ä¹¦èµŽå­°ç†Ÿè–¯æš‘æ›™ç½²èœ€é»é¼ å±žæœ¯è¿°æ ‘æŸæˆç«–å¢…åº¶æ•°æ¼±"
+		],
+		[
+			"cb40",
+			"è–‚è–ƒè–†è–ˆ",
+			6,
+			"è–",
+			10,
+			"è–",
+			6,
+			"è–¥è–¦è–§è–©è–«è–¬è–­è–±",
+			5,
+			"è–¸è–º",
+			6,
+			"è—‚",
+			6,
+			"è—Š",
+			4,
+			"è—‘è—’"
+		],
+		[
+			"cb80",
+			"è—”è—–",
+			5,
+			"è—",
+			6,
+			"è—¥è—¦è—§è—¨è—ª",
+			14,
+			"æ•åˆ·è€æ‘”è¡°ç”©å¸…æ “æ‹´éœœåŒçˆ½è°æ°´ç¡ç¨Žå®çž¬é¡ºèˆœè¯´ç¡•æœ”çƒæ–¯æ’•å˜¶æ€ç§å¸ä¸æ­»è‚†å¯ºå—£å››ä¼ºä¼¼é¥²å·³æ¾è€¸æ€‚é¢‚é€å®‹è®¼è¯µæœè‰˜æ“žå—½è‹é…¥ä¿—ç´ é€Ÿç²Ÿåƒ³å¡‘æº¯å®¿è¯‰è‚ƒé…¸è’œç®—è™½éš‹éšç»¥é«“ç¢Žå²ç©—é‚éš§ç¥Ÿå­™æŸç¬‹è“‘æ¢­å”†ç¼©çç´¢é”æ‰€å¡Œä»–å®ƒå¥¹å¡”"
+		],
+		[
+			"cc40",
+			"è—¹è—ºè—¼è—½è—¾è˜€",
+			4,
+			"è˜†",
+			10,
+			"è˜’è˜“è˜”è˜•è˜—",
+			15,
+			"è˜¨è˜ª",
+			13,
+			"è˜¹è˜ºè˜»è˜½è˜¾è˜¿è™€"
+		],
+		[
+			"cc80",
+			"è™",
+			11,
+			"è™’è™“è™•",
+			4,
+			"è™›è™œè™è™Ÿè™ è™¡è™£",
+			7,
+			"ç­æŒžè¹‹è¸èƒŽè‹”æŠ¬å°æ³°é…žå¤ªæ€æ±°åæ‘Šè´ªç˜«æ»©å›æª€ç—°æ½­è°­è°ˆå¦æ¯¯è¢’ç¢³æŽ¢å¹ç‚­æ±¤å¡˜æªå ‚æ£ è†›å”ç³–å€˜èººæ·Œè¶Ÿçƒ«æŽæ¶›æ»”ç»¦è„æ¡ƒé€ƒæ·˜é™¶è®¨å¥—ç‰¹è—¤è…¾ç–¼èªŠæ¢¯å‰”è¸¢é”‘æé¢˜è¹„å•¼ä½“æ›¿åšæƒ•æ¶•å‰ƒå±‰å¤©æ·»å¡«ç”°ç”œæ¬èˆ”è…†æŒ‘æ¡è¿¢çœºè·³è´´é“å¸–åŽ…å¬çƒƒ"
+		],
+		[
+			"cd40",
+			"è™­è™¯è™°è™²",
+			6,
+			"èšƒ",
+			6,
+			"èšŽ",
+			4,
+			"èš”èš–",
+			5,
+			"èšž",
+			4,
+			"èš¥èš¦èš«èš­èš®èš²èš³èš·èš¸èš¹èš»",
+			4,
+			"è›è›‚è›ƒè›…è›ˆè›Œè›è›’è›“è›•è›–è›—è›šè›œ"
+		],
+		["cd80", "è›è› è›¡è›¢è›£è›¥è›¦è›§è›¨è›ªè›«è›¬è›¯è›µè›¶è›·è›ºè›»è›¼è›½è›¿èœèœ„èœ…èœ†èœ‹èœŒèœŽèœèœèœ‘èœ”èœ–æ±€å»·åœäº­åº­æŒºè‰‡é€šæ¡é…®çž³åŒé“œå½¤ç«¥æ¡¶æ…ç­’ç»Ÿç—›å·æŠ•å¤´é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”æ¹å›¢æŽ¨é¢“è…¿èœ•è¤ªé€€åžå±¯è‡€æ‹–æ‰˜è„±é¸µé™€é©®é©¼æ¤­å¦¥æ‹“å”¾æŒ–å“‡è›™æ´¼å¨ƒç“¦è¢œæ­ªå¤–è±Œå¼¯æ¹¾çŽ©é¡½ä¸¸çƒ·å®Œç¢—æŒ½æ™šçš–æƒ‹å®›å©‰ä¸‡è…•æ±ªçŽ‹äº¡æž‰ç½‘å¾€æ—ºæœ›å¿˜å¦„å¨"],
+		[
+			"ce40",
+			"èœ™èœ›èœèœŸèœ èœ¤èœ¦èœ§èœ¨èœªèœ«èœ¬èœ­èœ¯èœ°èœ²èœ³èœµèœ¶èœ¸èœ¹èœºèœ¼èœ½è€",
+			6,
+			"èŠè‹èèèè‘è’è”è•è–è˜èš",
+			5,
+			"è¡è¢è¦",
+			7,
+			"è¯è±è²è³èµ"
+		],
+		[
+			"ce80",
+			"è·è¸è¹èºè¿èž€èžèž„èž†èž‡èž‰èžŠèžŒèžŽ",
+			4,
+			"èž”èž•èž–èž˜",
+			6,
+			"èž ",
+			4,
+			"å·å¾®å±éŸ¦è¿æ¡…å›´å”¯æƒŸä¸ºæ½ç»´è‹‡èŽå§”ä¼Ÿä¼ªå°¾çº¬æœªè”šå‘³ç•èƒƒå–‚é­ä½æ¸­è°“å°‰æ…°å«ç˜Ÿæ¸©èšŠæ–‡é—»çº¹å»ç¨³ç´Šé—®å—¡ç¿ç“®æŒèœ—æ¶¡çªæˆ‘æ–¡å§æ¡æ²ƒå·«å‘œé’¨ä¹Œæ±¡è¯¬å±‹æ— èŠœæ¢§å¾å´æ¯‹æ­¦äº”æ‚åˆèˆžä¼ä¾®åžæˆŠé›¾æ™¤ç‰©å‹¿åŠ¡æ‚Ÿè¯¯æ˜”ç†™æžè¥¿ç¡’çŸ½æ™°å˜»å¸é”¡ç‰º"
+		],
+		[
+			"cf40",
+			"èž¥èž¦èž§èž©èžªèž®èž°èž±èž²èž´èž¶èž·èž¸èž¹èž»èž¼èž¾èž¿èŸ",
+			4,
+			"èŸ‡èŸˆèŸ‰èŸŒ",
+			4,
+			"èŸ”",
+			6,
+			"èŸœèŸèŸžèŸŸèŸ¡èŸ¢èŸ£èŸ¤èŸ¦èŸ§èŸ¨èŸ©èŸ«èŸ¬èŸ­èŸ¯",
+			9
+		],
+		[
+			"cf80",
+			"èŸºèŸ»èŸ¼èŸ½èŸ¿è €è è ‚è „",
+			5,
+			"è ‹",
+			7,
+			"è ”è —è ˜è ™è šè œ",
+			4,
+			"è £ç¨€æ¯å¸Œæ‚‰è†å¤•æƒœç†„çƒ¯æºªæ±çŠ€æª„è¢­å¸­ä¹ åª³å–œé“£æ´—ç³»éš™æˆç»†çžŽè™¾åŒ£éœžè¾–æš‡å³¡ä¾ ç‹­ä¸‹åŽ¦å¤å“æŽ€é”¨å…ˆä»™é²œçº¤å’¸è´¤è¡”èˆ·é—²æ¶Žå¼¦å«Œæ˜¾é™©çŽ°çŒ®åŽ¿è…ºé¦…ç¾¡å®ªé™·é™çº¿ç›¸åŽ¢é•¶é¦™ç®±è¥„æ¹˜ä¹¡ç¿”ç¥¥è¯¦æƒ³å“äº«é¡¹å··æ©¡åƒå‘è±¡è§ç¡éœ„å‰Šå“®åš£é”€æ¶ˆå®µæ·†æ™“"
+		],
+		[
+			"d040",
+			"è ¤",
+			13,
+			"è ³",
+			5,
+			"è ºè »è ½è ¾è ¿è¡è¡‚è¡ƒè¡†",
+			5,
+			"è¡Ž",
+			5,
+			"è¡•è¡–è¡˜è¡š",
+			6,
+			"è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º"
+		],
+		[
+			"d080",
+			"è¡»è¡¼è¢€è¢ƒè¢†è¢‡è¢‰è¢Šè¢Œè¢Žè¢è¢è¢‘è¢“è¢”è¢•è¢—",
+			4,
+			"è¢",
+			4,
+			"è¢£è¢¥",
+			5,
+			"å°å­æ ¡è‚–å•¸ç¬‘æ•ˆæ¥”äº›æ­‡èŽéž‹åæŒŸæºé‚ªæ–œèƒè°å†™æ¢°å¸èŸ¹æ‡ˆæ³„æ³»è°¢å±‘è–ªèŠ¯é”Œæ¬£è¾›æ–°å¿»å¿ƒä¿¡è¡…æ˜Ÿè…¥çŒ©æƒºå…´åˆ‘åž‹å½¢é‚¢è¡Œé†’å¹¸ææ€§å§“å…„å‡¶èƒ¸åŒˆæ±¹é›„ç†Šä¼‘ä¿®ç¾žæœ½å—…é”ˆç§€è¢–ç»£å¢ŸæˆŒéœ€è™šå˜˜é¡»å¾è®¸è“„é…—å™æ—­åºç•œæ¤çµ®å©¿ç»ªç»­è½©å–§å®£æ‚¬æ—‹çŽ„"
+		],
+		[
+			"d140",
+			"è¢¬è¢®è¢¯è¢°è¢²",
+			4,
+			"è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£€è£ƒè£„è£‡è£ˆè£Šè£‹è£Œè£è£è£è£‘è£“è£–è£—è£š",
+			4,
+			"è£ è£¡è£¦è£§è£©",
+			6,
+			"è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤€è¤è¤ƒ",
+			5
+		],
+		[
+			"d180",
+			"è¤‰è¤‹",
+			4,
+			"è¤‘è¤”",
+			4,
+			"è¤œ",
+			4,
+			"è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·é€‰ç™£çœ©ç»šé´è–›å­¦ç©´é›ªè¡€å‹‹ç†å¾ªæ—¬è¯¢å¯»é©¯å·¡æ®‰æ±›è®­è®¯é€Šè¿…åŽ‹æŠ¼é¸¦é¸­å‘€ä¸«èŠ½ç‰™èšœå´–è¡™æ¶¯é›…å“‘äºšè®¶ç„‰å’½é˜‰çƒŸæ·¹ç›ä¸¥ç ”èœ’å²©å»¶è¨€é¢œé˜Žç‚Žæ²¿å¥„æŽ©çœ¼è¡æ¼”è‰³å °ç‡•åŽŒç šé›å”å½¦ç„°å®´è°šéªŒæ®ƒå¤®é¸¯ç§§æ¨æ‰¬ä½¯ç–¡ç¾Šæ´‹é˜³æ°§ä»°ç—’å…»æ ·æ¼¾é‚€è…°å¦–ç‘¶"
+		],
+		[
+			"d240",
+			"è¤¸",
+			8,
+			"è¥‚è¥ƒè¥…",
+			24,
+			"è¥ ",
+			5,
+			"è¥§",
+			19,
+			"è¥¼"
+		],
+		[
+			"d280",
+			"è¥½è¥¾è¦€è¦‚è¦„è¦…è¦‡",
+			26,
+			"æ‘‡å°§é¥çª‘è°£å§šå’¬èˆ€è¯è¦è€€æ¤°å™Žè€¶çˆ·é‡Žå†¶ä¹Ÿé¡µæŽ–ä¸šå¶æ›³è…‹å¤œæ¶²ä¸€å£¹åŒ»æ–é“±ä¾ä¼Šè¡£é¢å¤·é—ç§»ä»ªèƒ°ç–‘æ²‚å®œå§¨å½æ¤…èšå€šå·²ä¹™çŸ£ä»¥è‰ºæŠ‘æ˜“é‚‘å±¹äº¿å½¹è‡†é€¸è‚„ç–«äº¦è£”æ„æ¯…å¿†ä¹‰ç›Šæº¢è¯£è®®è°Šè¯‘å¼‚ç¿¼ç¿Œç»ŽèŒµè«å› æ®·éŸ³é˜´å§»åŸé“¶æ·«å¯…é¥®å°¹å¼•éš"
+		],
+		[
+			"d340",
+			"è¦¢",
+			30,
+			"è§ƒè§è§“è§”è§•è§—è§˜è§™è§›è§è§Ÿè§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´",
+			6
+		],
+		[
+			"d380",
+			"è§»",
+			4,
+			"è¨",
+			5,
+			"è¨ˆ",
+			21,
+			"å°è‹±æ¨±å©´é¹°åº”ç¼¨èŽ¹è¤è¥è§è‡è¿Žèµ¢ç›ˆå½±é¢–ç¡¬æ˜ å“Ÿæ‹¥ä½£è‡ƒç—ˆåº¸é›è¸Šè›¹å’æ³³æ¶Œæ°¸æ¿å‹‡ç”¨å¹½ä¼˜æ‚ å¿§å°¤ç”±é‚®é“€çŠ¹æ²¹æ¸¸é…‰æœ‰å‹å³ä½‘é‡‰è¯±åˆå¹¼è¿‚æ·¤äºŽç›‚æ¦†è™žæ„šèˆ†ä½™ä¿žé€¾é±¼æ„‰æ¸æ¸”éš…äºˆå¨±é›¨ä¸Žå±¿ç¦¹å®‡è¯­ç¾½çŽ‰åŸŸèŠ‹éƒåé‡å–»å³ªå¾¡æ„ˆæ¬²ç‹±è‚²èª‰"
+		],
+		[
+			"d440",
+			"è¨ž",
+			31,
+			"è¨¿",
+			8,
+			"è©‰",
+			21
+		],
+		[
+			"d480",
+			"è©Ÿ",
+			25,
+			"è©º",
+			6,
+			"æµ´å¯“è£•é¢„è±«é©­é¸³æ¸Šå†¤å…ƒåž£è¢åŽŸæ´è¾•å›­å‘˜åœ†çŒ¿æºç¼˜è¿œè‹‘æ„¿æ€¨é™¢æ›°çº¦è¶Šè·ƒé’¥å²³ç²¤æœˆæ‚¦é˜…è€˜äº‘éƒ§åŒ€é™¨å…è¿è•´é…æ™•éŸµå­•åŒç ¸æ‚æ ½å“‰ç¾å®°è½½å†åœ¨å’±æ”’æš‚èµžèµƒè„è‘¬é­ç³Ÿå‡¿è—»æž£æ—©æ¾¡èš¤èºå™ªé€ çš‚ç¶ç‡¥è´£æ‹©åˆ™æ³½è´¼æ€Žå¢žæ†Žæ›¾èµ æ‰Žå–³æ¸£æœ­è½§"
+		],
+		[
+			"d540",
+			"èª",
+			7,
+			"èª‹",
+			7,
+			"èª”",
+			46
+		],
+		[
+			"d580",
+			"è«ƒ",
+			32,
+			"é“¡é—¸çœ¨æ …æ¦¨å’‹ä¹ç‚¸è¯ˆæ‘˜æ–‹å®…çª„å€ºå¯¨çž»æ¯¡è©¹ç²˜æ²¾ç›æ–©è¾—å´­å±•è˜¸æ ˆå æˆ˜ç«™æ¹›ç»½æ¨Ÿç« å½°æ¼³å¼ æŽŒæ¶¨æ–ä¸ˆå¸è´¦ä»—èƒ€ç˜´éšœæ‹›æ˜­æ‰¾æ²¼èµµç…§ç½©å…†è‚‡å¬é®æŠ˜å“²è›°è¾™è€…é”—è”—è¿™æµ™çæ–ŸçœŸç”„ç §è‡»è´žé’ˆä¾¦æž•ç–¹è¯Šéœ‡æŒ¯é•‡é˜µè’¸æŒ£çå¾ç‹°äº‰æ€”æ•´æ‹¯æ­£æ”¿"
+		],
+		[
+			"d640",
+			"è«¤",
+			34,
+			"è¬ˆ",
+			27
+		],
+		[
+			"d680",
+			"è¬¤è¬¥è¬§",
+			30,
+			"å¸§ç—‡éƒ‘è¯èŠæžæ”¯å±èœ˜çŸ¥è‚¢è„‚æ±ä¹‹ç»‡èŒç›´æ¤æ®–æ‰§å€¼ä¾„å€æŒ‡æ­¢è¶¾åªæ—¨çº¸å¿—æŒšæŽ·è‡³è‡´ç½®å¸œå³™åˆ¶æ™ºç§©ç¨šè´¨ç‚™ç—”æ»žæ²»çª’ä¸­ç›…å¿ é’Ÿè¡·ç»ˆç§è‚¿é‡ä»²ä¼—èˆŸå‘¨å·žæ´²è¯Œç²¥è½´è‚˜å¸šå’’çš±å®™æ˜¼éª¤ç æ ªè››æœ±çŒªè¯¸è¯›é€ç«¹çƒ›ç…®æ‹„çž©å˜±ä¸»è‘—æŸ±åŠ©è›€è´®é“¸ç­‘"
+		],
+		[
+			"d740",
+			"è­†",
+			31,
+			"è­§",
+			4,
+			"è­­",
+			25
+		],
+		[
+			"d780",
+			"è®‡",
+			24,
+			"è®¬è®±è®»è¯‡è¯è¯ªè°‰è°žä½æ³¨ç¥é©»æŠ“çˆªæ‹½ä¸“ç –è½¬æ’°èµšç¯†æ¡©åº„è£…å¦†æ’žå£®çŠ¶æ¤Žé”¥è¿½èµ˜å ç¼€è°†å‡†æ‰æ‹™å“æ¡Œç¢èŒé…Œå•„ç€ç¼æµŠå…¹å’¨èµ„å§¿æ»‹æ·„å­œç´«ä»”ç±½æ»“å­è‡ªæ¸å­—é¬ƒæ£•è¸ªå®—ç»¼æ€»çºµé‚¹èµ°å¥æç§Ÿè¶³å’æ—ç¥–è¯…é˜»ç»„é’»çº‚å˜´é†‰æœ€ç½ªå°Šéµæ˜¨å·¦ä½æŸžåšä½œååº§"
+		],
+		[
+			"d840",
+			"è°¸",
+			8,
+			"è±‚è±ƒè±„è±…è±ˆè±Šè±‹è±",
+			7,
+			"è±–è±—è±˜è±™è±›",
+			5,
+			"è±£",
+			6,
+			"è±¬",
+			6,
+			"è±´è±µè±¶è±·è±»",
+			6,
+			"è²ƒè²„è²†è²‡"
+		],
+		[
+			"d880",
+			"è²ˆè²‹è²",
+			6,
+			"è²•è²–è²—è²™",
+			20,
+			"äºä¸Œå…€ä¸å»¿å…ä¸•äº˜ä¸žé¬²å­¬å™©ä¸¨ç¦ºä¸¿åŒ•ä¹‡å¤­çˆ»å®æ°å›Ÿèƒ¤é¦—æ¯“ç¾é¼—ä¸¶äºŸé¼ä¹œä¹©äº“èŠˆå­›å•¬å˜ä»„åŽåŽåŽ£åŽ¥åŽ®é¥èµåŒšåµåŒ¦åŒ®åŒ¾èµœå¦å£åˆ‚åˆˆåˆŽåˆ­åˆ³åˆ¿å‰€å‰Œå‰žå‰¡å‰œè’¯å‰½åŠ‚åŠåŠåŠ“å†‚ç½”äº»ä»ƒä»‰ä»‚ä»¨ä»¡ä»«ä»žä¼›ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼‰ä¼«ä½žä½§æ”¸ä½šä½"
+		],
+		[
+			"d940",
+			"è²®",
+			62
+		],
+		[
+			"d980",
+			"è³­",
+			32,
+			"ä½Ÿä½—ä¼²ä¼½ä½¶ä½´ä¾‘ä¾‰ä¾ƒä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾”ä¿¦ä¿¨ä¿ªä¿…ä¿šä¿£ä¿œä¿‘ä¿Ÿä¿¸å€©åŒä¿³å€¬å€å€®å€­ä¿¾å€œå€Œå€¥å€¨å¾åƒå•åˆåŽå¬å»å‚¥å‚§å‚©å‚ºåƒ–å„†åƒ­åƒ¬åƒ¦åƒ®å„‡å„‹ä»æ°½ä½˜ä½¥ä¿Žé¾ æ±†ç±´å…®å·½é»‰é¦˜å†å¤”å‹¹åŒè¨‡åŒå‡«å¤™å…•äº å…–äº³è¡®è¢¤äºµè„”è£’ç¦€å¬´è ƒç¾¸å†«å†±å†½å†¼"
+		],
+		[
+			"da40",
+			"è´Ž",
+			14,
+			"è´ èµ‘èµ’èµ—èµŸèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸",
+			8,
+			"è¶‚è¶ƒè¶†è¶‡è¶ˆè¶‰è¶Œ",
+			4,
+			"è¶’è¶“è¶•",
+			9,
+			"è¶ è¶¡"
+		],
+		[
+			"da80",
+			"è¶¢è¶¤",
+			12,
+			"è¶²è¶¶è¶·è¶¹è¶»è¶½è·€è·è·‚è·…è·‡è·ˆè·‰è·Šè·è·è·’è·“è·”å‡‡å†–å†¢å†¥è® è®¦è®§è®ªè®´è®µè®·è¯‚è¯ƒè¯‹è¯è¯Žè¯’è¯“è¯”è¯–è¯˜è¯™è¯œè¯Ÿè¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°€è°‚è°„è°‡è°Œè°è°‘è°’è°”è°•è°–è°™è°›è°˜è°è°Ÿè° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºé˜é˜¢é˜¡é˜±é˜ªé˜½é˜¼é™‚é™‰é™”é™Ÿé™§é™¬é™²é™´éšˆéšéš—éš°é‚—é‚›é‚é‚™é‚¬é‚¡é‚´é‚³é‚¶é‚º"
+		],
+		[
+			"db40",
+			"è·•è·˜è·™è·œè· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾",
+			6,
+			"è¸†è¸‡è¸ˆè¸‹è¸è¸Žè¸è¸‘è¸’è¸“è¸•",
+			7,
+			"è¸ è¸¡è¸¤",
+			4,
+			"è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾"
+		],
+		[
+			"db80",
+			"è¸¿è¹ƒè¹…è¹†è¹Œ",
+			4,
+			"è¹“",
+			5,
+			"è¹š",
+			11,
+			"è¹§è¹¨è¹ªè¹«è¹®è¹±é‚¸é‚°éƒéƒ…é‚¾éƒéƒ„éƒ‡éƒ“éƒ¦éƒ¢éƒœéƒ—éƒ›éƒ«éƒ¯éƒ¾é„„é„¢é„žé„£é„±é„¯é„¹é…ƒé…†åˆå¥‚åŠ¢åŠ¬åŠ­åŠ¾å“¿å‹å‹–å‹°åŸç‡®çŸå»´å‡µå‡¼é¬¯åŽ¶å¼ç•šå·¯åŒåž©åž¡å¡¾å¢¼å£…å£‘åœ©åœ¬åœªåœ³åœ¹åœ®åœ¯åœåœ»å‚å©åž…å«åž†å¼å»å¨å­å¶å³åž­åž¤åžŒåž²åŸåž§åž´åž“åž åŸ•åŸ˜åŸšåŸ™åŸ’åž¸åŸ´åŸ¯åŸ¸åŸ¤åŸ"
+		],
+		[
+			"dc40",
+			"è¹³è¹µè¹·",
+			4,
+			"è¹½è¹¾èº€èº‚èºƒèº„èº†èºˆ",
+			6,
+			"èº‘èº’èº“èº•",
+			6,
+			"èºèºŸ",
+			11,
+			"èº­èº®èº°èº±èº³",
+			6,
+			"èº»",
+			7
+		],
+		[
+			"dc80",
+			"è»ƒ",
+			10,
+			"è»",
+			21,
+			"å ‹å åŸ½åŸ­å €å žå ™å¡„å  å¡¥å¡¬å¢å¢‰å¢šå¢€é¦¨é¼™æ‡¿è‰¹è‰½è‰¿èŠèŠŠèŠ¨èŠ„èŠŽèŠ‘èŠ—èŠ™èŠ«èŠ¸èŠ¾èŠ°è‹ˆè‹Šè‹£èŠ˜èŠ·èŠ®è‹‹è‹Œè‹èŠ©èŠ´èŠ¡èŠªèŠŸè‹„è‹ŽèŠ¤è‹¡èŒ‰è‹·è‹¤èŒèŒ‡è‹œè‹´è‹’è‹˜èŒŒè‹»è‹“èŒ‘èŒšèŒ†èŒ”èŒ•è‹ è‹•èŒœè‘è›èœèŒˆèŽ’èŒ¼èŒ´èŒ±èŽ›èžèŒ¯èè‡èƒèŸè€èŒ—è èŒ­èŒºèŒ³è¦è¥"
+		],
+		[
+			"dd40",
+			"è»¥",
+			62
+		],
+		[
+			"dd80",
+			"è¼¤",
+			32,
+			"è¨èŒ›è©è¬èªè­è®èŽ°è¸èŽ³èŽ´èŽ èŽªèŽ“èŽœèŽ…è¼èŽ¶èŽ©è½èŽ¸è»èŽ˜èŽžèŽ¨èŽºèŽ¼èèè¥è˜å ‡è˜è‹èè½è–èœè¸è‘è†è”èŸèèƒè¸è¹èªè…è€è¦è°è¡è‘œè‘‘è‘šè‘™è‘³è’‡è’ˆè‘ºè’‰è‘¸è¼è‘†è‘©è‘¶è’Œè’Žè±è‘­è“è“è“è“¦è’½è““è“Šè’¿è’ºè“ è’¡è’¹è’´è’—è“¥è“£è”Œç”è”¸è“°è”¹è”Ÿè”º"
+		],
+		[
+			"de40",
+			"è½…",
+			32,
+			"è½ªè¾€è¾Œè¾’è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿€è¿ƒè¿†"
+		],
+		[
+			"de80",
+			"è¿‰",
+			4,
+			"è¿è¿’è¿–è¿—è¿šè¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿é€‡é€ˆé€Œé€Žé€“é€•é€˜è•–è”»è“¿è“¼è•™è•ˆè•¨è•¤è•žè•ºçž¢è•ƒè•²è•»è–¤è–¨è–‡è–è•¹è–®è–œè–…è–¹è–·è–°è—“è—è—œè—¿è˜§è˜…è˜©è˜–è˜¼å»¾å¼ˆå¤¼å¥è€·å¥•å¥šå¥˜åŒå°¢å°¥å°¬å°´æ‰Œæ‰ªæŠŸæŠ»æ‹Šæ‹šæ‹—æ‹®æŒ¢æ‹¶æŒ¹æ‹æƒæŽ­æ¶æ±æºæŽŽæŽ´æ­æŽ¬æŽŠæ©æŽ®æŽ¼æ²æ¸æ æ¿æ„æžæŽæ‘’æ†æŽ¾æ‘…æ‘æ‹æ›æ æŒæ¦æ¡æ‘žæ’„æ‘­æ’–"
+		],
+		[
+			"df40",
+			"é€™é€œé€£é€¤é€¥é€§",
+			5,
+			"é€°",
+			4,
+			"é€·é€¹é€ºé€½é€¿é€éƒé…é†éˆ",
+			4,
+			"éŽé”é•é–é™éšéœ",
+			5,
+			"é¤é¦é§é©éªé«é¬é¯",
+			4,
+			"é¶",
+			6,
+			"é¾é‚"
+		],
+		[
+			"df80",
+			"é‚„é‚…é‚†é‚‡é‚‰é‚Šé‚Œ",
+			4,
+			"é‚’é‚”é‚–é‚˜é‚šé‚œé‚žé‚Ÿé‚ é‚¤é‚¥é‚§é‚¨é‚©é‚«é‚­é‚²é‚·é‚¼é‚½é‚¿éƒ€æ‘ºæ’·æ’¸æ’™æ’ºæ“€æ“æ“—æ“¤æ“¢æ”‰æ”¥æ”®å¼‹å¿’ç”™å¼‘åŸå±å½å©å¨å»å’å–å†å‘‹å‘’å‘“å‘”å‘–å‘ƒå¡å‘—å‘™å£å²å’‚å’”å‘·å‘±å‘¤å’šå’›å’„å‘¶å‘¦å’å“å’­å“‚å’´å“’å’§å’¦å““å“”å‘²å’£å“•å’»å’¿å“Œå“™å“šå“œå’©å’ªå’¤å“å“å“žå”›å“§å” å“½å””å“³å”¢å”£å”å”‘å”§å”ªå•§å–å–µå•‰å•­å•å••å”¿å•å”¼"
+		],
+		[
+			"e040",
+			"éƒ‚éƒƒéƒ†éƒˆéƒ‰éƒ‹éƒŒéƒéƒ’éƒ”éƒ•éƒ–éƒ˜éƒ™éƒšéƒžéƒŸéƒ éƒ£éƒ¤éƒ¥éƒ©éƒªéƒ¬éƒ®éƒ°éƒ±éƒ²éƒ³éƒµéƒ¶éƒ·éƒ¹éƒºéƒ»éƒ¼éƒ¿é„€é„é„ƒé„…",
+			19,
+			"é„šé„›é„œ"
+		],
+		[
+			"e080",
+			"é„é„Ÿé„ é„¡é„¤",
+			10,
+			"é„°é„²",
+			6,
+			"é„º",
+			8,
+			"é…„å”·å•–å•µå•¶å•·å”³å”°å•œå–‹å—’å–ƒå–±å–¹å–ˆå–å–Ÿå•¾å—–å–‘å•»å—Ÿå–½å–¾å–”å–™å—ªå—·å—‰å˜Ÿå—‘å—«å—¬å—”å—¦å—å—„å—¯å—¥å—²å—³å—Œå—å—¨å—µå—¤è¾”å˜žå˜ˆå˜Œå˜å˜¤å˜£å—¾å˜€å˜§å˜­å™˜å˜¹å™—å˜¬å™å™¢å™™å™œå™Œå™”åš†å™¤å™±å™«å™»å™¼åš…åš“åš¯å›”å›—å›å›¡å›µå›«å›¹å›¿åœ„åœŠåœ‰åœœå¸å¸™å¸”å¸‘å¸±å¸»å¸¼"
+		],
+		[
+			"e140",
+			"é……é…‡é…ˆé…‘é…“é…”é…•é…–é…˜é…™é…›é…œé…Ÿé… é…¦é…§é…¨é…«é…­é…³é…ºé…»é…¼é†€",
+			4,
+			"é††é†ˆé†Šé†Žé†é†“",
+			6,
+			"é†œ",
+			5,
+			"é†¤",
+			5,
+			"é†«é†¬é†°é†±é†²é†³é†¶é†·é†¸é†¹é†»"
+		],
+		[
+			"e180",
+			"é†¼",
+			10,
+			"é‡ˆé‡‹é‡é‡’",
+			9,
+			"é‡",
+			8,
+			"å¸·å¹„å¹”å¹›å¹žå¹¡å²Œå±ºå²å²å²–å²ˆå²˜å²™å²‘å²šå²œå²µå²¢å²½å²¬å²«å²±å²£å³å²·å³„å³’å³¤å³‹å³¥å´‚å´ƒå´§å´¦å´®å´¤å´žå´†å´›åµ˜å´¾å´´å´½åµ¬åµ›åµ¯åµåµ«åµ‹åµŠåµ©åµ´å¶‚å¶™å¶è±³å¶·å·…å½³å½·å¾‚å¾‡å¾‰å¾Œå¾•å¾™å¾œå¾¨å¾­å¾µå¾¼è¡¢å½¡çŠ­çŠ°çŠ´çŠ·çŠ¸ç‹ƒç‹ç‹Žç‹ç‹’ç‹¨ç‹¯ç‹©ç‹²ç‹´ç‹·çŒç‹³çŒƒç‹º"
+		],
+		[
+			"e240",
+			"é‡¦",
+			62
+		],
+		[
+			"e280",
+			"éˆ¥",
+			32,
+			"ç‹»çŒ—çŒ“çŒ¡çŒŠçŒžçŒçŒ•çŒ¢çŒ¹çŒ¥çŒ¬çŒ¸çŒ±ççç—ç ç¬ç¯ç¾èˆ›å¤¥é£§å¤¤å¤‚é¥£é¥§",
+			5,
+			"é¥´é¥·é¥½é¦€é¦„é¦‡é¦Šé¦é¦é¦‘é¦“é¦”é¦•åº€åº‘åº‹åº–åº¥åº åº¹åºµåº¾åº³èµ“å»’å»‘å»›å»¨å»ªè†ºå¿„å¿‰å¿–å¿æ€ƒå¿®æ€„å¿¡å¿¤å¿¾æ€…æ€†å¿ªå¿­å¿¸æ€™æ€µæ€¦æ€›æ€æ€æ€©æ€«æ€Šæ€¿æ€¡æ¸æ¹æ»æºæ‚"
+		],
+		[
+			"e340",
+			"é‰†",
+			45,
+			"é‰µ",
+			16
+		],
+		[
+			"e380",
+			"éŠ†",
+			7,
+			"éŠ",
+			24,
+			"æªæ½æ‚–æ‚šæ‚­æ‚æ‚ƒæ‚’æ‚Œæ‚›æƒ¬æ‚»æ‚±æƒæƒ˜æƒ†æƒšæ‚´æ„ æ„¦æ„•æ„£æƒ´æ„€æ„Žæ„«æ…Šæ…µæ†¬æ†”æ†§æ†·æ‡”æ‡µå¿éš³é—©é—«é—±é—³é—µé—¶é—¼é—¾é˜ƒé˜„é˜†é˜ˆé˜Šé˜‹é˜Œé˜é˜é˜’é˜•é˜–é˜—é˜™é˜šä¸¬çˆ¿æˆ•æ°µæ±”æ±œæ±Šæ²£æ²…æ²æ²”æ²Œæ±¨æ±©æ±´æ±¶æ²†æ²©æ³æ³”æ²­æ³·æ³¸æ³±æ³—æ²²æ³ æ³–æ³ºæ³«æ³®æ²±æ³“æ³¯æ³¾"
+		],
+		[
+			"e440",
+			"éŠ¨",
+			5,
+			"éŠ¯",
+			24,
+			"é‹‰",
+			31
+		],
+		[
+			"e480",
+			"é‹©",
+			32,
+			"æ´¹æ´§æ´Œæµƒæµˆæ´‡æ´„æ´™æ´Žæ´«æµæ´®æ´µæ´šæµæµ’æµ”æ´³æ¶‘æµ¯æ¶žæ¶ æµžæ¶“æ¶”æµœæµ æµ¼æµ£æ¸šæ·‡æ·…æ·žæ¸Žæ¶¿æ· æ¸‘æ·¦æ·æ·™æ¸–æ¶«æ¸Œæ¶®æ¸«æ¹®æ¹Žæ¹«æº²æ¹Ÿæº†æ¹“æ¹”æ¸²æ¸¥æ¹„æ»Ÿæº±æº˜æ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»—æº´æ»æºæ»‚æºŸæ½¢æ½†æ½‡æ¼¤æ¼•æ»¹æ¼¯æ¼¶æ½‹æ½´æ¼ªæ¼‰æ¼©æ¾‰æ¾æ¾Œæ½¸æ½²æ½¼æ½ºæ¿‘"
+		],
+		[
+			"e540",
+			"éŒŠ",
+			51,
+			"éŒ¿",
+			10
+		],
+		[
+			"e580",
+			"éŠ",
+			31,
+			"é«æ¿‰æ¾§æ¾¹æ¾¶æ¿‚æ¿¡æ¿®æ¿žæ¿ æ¿¯ç€šç€£ç€›ç€¹ç€µççžå®€å®„å®•å®“å®¥å®¸ç”¯éªžæ´å¯¤å¯®è¤°å¯°è¹‡è¬‡è¾¶è¿“è¿•è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨é€…é€„é€‹é€¦é€‘é€é€–é€¡é€µé€¶é€­é€¯é„é‘é’éé¨é˜é¢é›æš¹é´é½é‚‚é‚ˆé‚ƒé‚‹å½å½—å½–å½˜å°»å’«å±å±™å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è‰´å¼¼é¬»å±®å¦å¦ƒå¦å¦©å¦ªå¦£"
+		],
+		[
+			"e640",
+			"é¬",
+			34,
+			"éŽ",
+			27
+		],
+		[
+			"e680",
+			"éŽ¬",
+			29,
+			"é‹éŒéå¦—å§Šå¦«å¦žå¦¤å§’å¦²å¦¯å§—å¦¾å¨…å¨†å§å¨ˆå§£å§˜å§¹å¨Œå¨‰å¨²å¨´å¨‘å¨£å¨“å©€å©§å©Šå©•å¨¼å©¢å©µèƒ¬åªªåª›å©·å©ºåª¾å««åª²å«’å«”åª¸å« å«£å«±å«–å«¦å«˜å«œå¬‰å¬—å¬–å¬²å¬·å­€å°•å°œå­šå­¥å­³å­‘å­“å­¢é©µé©·é©¸é©ºé©¿é©½éª€éªéª…éªˆéªŠéªéª’éª“éª–éª˜éª›éªœéªéªŸéª éª¢éª£éª¥éª§çºŸçº¡çº£çº¥çº¨çº©"
+		],
+		[
+			"e740",
+			"éŽ",
+			7,
+			"é—",
+			54
+		],
+		[
+			"e780",
+			"éŽ",
+			32,
+			"çº­çº°çº¾ç»€ç»ç»‚ç»‰ç»‹ç»Œç»ç»”ç»—ç»›ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼‚ç¼ƒç¼‡ç¼ˆç¼‹ç¼Œç¼ç¼‘ç¼’ç¼—ç¼™ç¼œç¼›ç¼Ÿç¼¡",
+			6,
+			"ç¼ªç¼«ç¼¬ç¼­ç¼¯",
+			4,
+			"ç¼µå¹ºç•¿å·›ç”¾é‚•çŽŽçŽ‘çŽ®çŽ¢çŽŸçç‚ç‘çŽ·çŽ³ç€ç‰çˆç¥ç™é¡¼çŠç©ç§çžçŽºç²ççªç‘›ç¦ç¥ç¨ç°ç®ç¬"
+		],
+		[
+			"e840",
+			"é¯",
+			14,
+			"é¿",
+			43,
+			"é‘¬é‘­é‘®é‘¯"
+		],
+		[
+			"e880",
+			"é‘°",
+			20,
+			"é’‘é’–é’˜é“‡é“é““é“”é“šé“¦é“»é”œé” ç›çšç‘ç‘œç‘—ç‘•ç‘™ç‘·ç‘­ç‘¾ç’œç’Žç’€ç’ç’‡ç’‹ç’žç’¨ç’©ç’ç’§ç“’ç’ºéŸªéŸ«éŸ¬æŒæ“æžæˆæ©æž¥æž‡æªæ³æž˜æž§æµæž¨æžžæž­æž‹æ·æ¼æŸ°æ ‰æŸ˜æ ŠæŸ©æž°æ ŒæŸ™æžµæŸšæž³æŸæ €æŸƒæž¸æŸ¢æ ŽæŸæŸ½æ ²æ ³æ¡ æ¡¡æ¡Žæ¡¢æ¡„æ¡¤æ¢ƒæ æ¡•æ¡¦æ¡æ¡§æ¡€æ ¾æ¡Šæ¡‰æ ©æ¢µæ¢æ¡´æ¡·æ¢“æ¡«æ£‚æ¥®æ£¼æ¤Ÿæ¤ æ£¹"
+		],
+		[
+			"e940",
+			"é”§é”³é”½é•ƒé•ˆé•‹é••é•šé• é•®é•´é•µé•·",
+			7,
+			"é–€",
+			42
+		],
+		[
+			"e980",
+			"é–«",
+			32,
+			"æ¤¤æ£°æ¤‹æ¤æ¥—æ££æ¤æ¥±æ¤¹æ¥ æ¥‚æ¥æ¦„æ¥«æ¦€æ¦˜æ¥¸æ¤´æ§Œæ¦‡æ¦ˆæ§Žæ¦‰æ¥¦æ¥£æ¥¹æ¦›æ¦§æ¦»æ¦«æ¦­æ§”æ¦±æ§æ§Šæ§Ÿæ¦•æ§ æ¦æ§¿æ¨¯æ§­æ¨—æ¨˜æ©¥æ§²æ©„æ¨¾æª æ©æ©›æ¨µæªŽæ©¹æ¨½æ¨¨æ©˜æ©¼æª‘æªæª©æª—æª«çŒ·ç’æ®æ®‚æ®‡æ®„æ®’æ®“æ®æ®šæ®›æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾‚è¾„è¾‡è¾‹"
+		],
+		[
+			"ea40",
+			"é—Œ",
+			27,
+			"é—¬é—¿é˜‡é˜“é˜˜é˜›é˜žé˜ é˜£",
+			6,
+			"é˜«é˜¬é˜­é˜¯é˜°é˜·é˜¸é˜¹é˜ºé˜¾é™é™ƒé™Šé™Žé™é™‘é™’é™“é™–é™—"
+		],
+		[
+			"ea80",
+			"é™˜é™™é™šé™œé™é™žé™ é™£é™¥é™¦é™«é™­",
+			4,
+			"é™³é™¸",
+			12,
+			"éš‡éš‰éšŠè¾è¾Žè¾è¾˜è¾šè»Žæˆ‹æˆ—æˆ›æˆŸæˆ¢æˆ¡æˆ¥æˆ¤æˆ¬è‡§ç“¯ç“´ç“¿ç”ç”‘ç”“æ”´æ—®æ—¯æ—°æ˜Šæ˜™æ²æ˜ƒæ˜•æ˜€ç‚…æ›·æ˜æ˜´æ˜±æ˜¶æ˜µè€†æ™Ÿæ™”æ™æ™æ™–æ™¡æ™—æ™·æš„æšŒæš§æšæš¾æ››æ›œæ›¦æ›©è´²è´³è´¶è´»è´½èµ€èµ…èµ†èµˆèµ‰èµ‡èµèµ•èµ™è§‡è§Šè§‹è§Œè§Žè§è§è§‘ç‰®çŠŸç‰ç‰¦ç‰¯ç‰¾ç‰¿çŠ„çŠ‹çŠçŠçŠ’æŒˆæŒ²æŽ°"
+		],
+		[
+			"eb40",
+			"éšŒéšŽéš‘éš’éš“éš•éš–éššéš›éš",
+			9,
+			"éš¨",
+			7,
+			"éš±éš²éš´éšµéš·éš¸éšºéš»éš¿é›‚é›ƒé›ˆé›Šé›‹é›é›‘é›“é›”é›–",
+			9,
+			"é›¡",
+			6,
+			"é›«"
+		],
+		[
+			"eb80",
+			"é›¬é›­é›®é›°é›±é›²é›´é›µé›¸é›ºé›»é›¼é›½é›¿éœ‚éœƒéœ…éœŠéœ‹éœŒéœéœ‘éœ’éœ”éœ•éœ—",
+			4,
+			"éœéœŸéœ æ¿æ“˜è€„æ¯ªæ¯³æ¯½æ¯µæ¯¹æ°…æ°‡æ°†æ°æ°•æ°˜æ°™æ°šæ°¡æ°©æ°¤æ°ªæ°²æ”µæ••æ•«ç‰ç‰’ç‰–çˆ°è™¢åˆ–è‚Ÿè‚œè‚“è‚¼æœŠè‚½è‚±è‚«è‚­è‚´è‚·èƒ§èƒ¨èƒ©èƒªèƒ›èƒ‚èƒ„èƒ™èƒèƒ—æœèƒèƒ«èƒ±èƒ´èƒ­è„è„Žèƒ²èƒ¼æœ•è„’è±šè„¶è„žè„¬è„˜è„²è…ˆè…Œè…“è…´è…™è…šè…±è… è…©è…¼è…½è…­è…§å¡åªµè†ˆè†‚è†‘æ»•è†£è†ªè‡Œæœ¦è‡Šè†»"
+		],
+		[
+			"ec40",
+			"éœ¡",
+			8,
+			"éœ«éœ¬éœ®éœ¯éœ±éœ³",
+			4,
+			"éœºéœ»éœ¼éœ½éœ¿",
+			18,
+			"é”é•é—é˜éšéœééŸé£é¤é¦é§é¨éª",
+			7
+		],
+		[
+			"ec80",
+			"é²éµé·",
+			4,
+			"é½",
+			7,
+			"éž†",
+			4,
+			"éžŒéžŽéžéžéž“éž•éž–éž—éž™",
+			4,
+			"è‡è†¦æ¬¤æ¬·æ¬¹æ­ƒæ­†æ­™é£‘é£’é£“é£•é£™é£šæ®³å½€æ¯‚è§³æ–é½‘æ–“æ–¼æ—†æ—„æ—ƒæ—Œæ—Žæ—’æ—–ç‚€ç‚œç‚–ç‚ç‚»çƒ€ç‚·ç‚«ç‚±çƒ¨çƒŠç„ç„“ç„–ç„¯ç„±ç…³ç…œç…¨ç……ç…²ç…Šç…¸ç…ºç†˜ç†³ç†µç†¨ç† ç‡ ç‡”ç‡§ç‡¹çˆçˆ¨ç¬ç„˜ç…¦ç†¹æˆ¾æˆ½æ‰ƒæ‰ˆæ‰‰ç¤»ç¥€ç¥†ç¥‰ç¥›ç¥œç¥“ç¥šç¥¢ç¥—ç¥ ç¥¯ç¥§ç¥ºç¦…ç¦Šç¦šç¦§ç¦³å¿‘å¿"
+		],
+		[
+			"ed40",
+			"éžžéžŸéž¡éž¢éž¤",
+			6,
+			"éž¬éž®éž°éž±éž³éžµ",
+			46
+		],
+		[
+			"ed80",
+			"éŸ¤éŸ¥éŸ¨éŸ®",
+			4,
+			"éŸ´éŸ·",
+			23,
+			"æ€¼ææšæ§ææ™æ£æ‚«æ„†æ„æ…æ†©æ†æ‡‹æ‡‘æˆ†è‚€è¿æ²“æ³¶æ·¼çŸ¶çŸ¸ç €ç ‰ç —ç ˜ç ‘æ–«ç ­ç œç ç ¹ç ºç »ç Ÿç ¼ç ¥ç ¬ç £ç ©ç¡Žç¡­ç¡–ç¡—ç ¦ç¡ç¡‡ç¡Œç¡ªç¢›ç¢“ç¢šç¢‡ç¢œç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£”ç£™ç£‰ç£¬ç£²ç¤…ç£´ç¤“ç¤¤ç¤žç¤´é¾›é»¹é»»é»¼ç›±çœ„çœç›¹çœ‡çœˆçœšçœ¢çœ™çœ­çœ¦çœµçœ¸çç‘ç‡çƒçšç¨"
+		],
+		[
+			"ee40",
+			"é ",
+			62
+		],
+		[
+			"ee80",
+			"é¡Ž",
+			32,
+			"ç¢ç¥ç¿çžç½çž€çžŒçž‘çžŸçž çž°çžµçž½ç”ºç•€ç•Žç•‹ç•ˆç•›ç•²ç•¹ç–ƒç½˜ç½¡ç½Ÿè©ˆç½¨ç½´ç½±ç½¹ç¾ç½¾ç›ç›¥è ²é’…é’†é’‡é’‹é’Šé’Œé’é’é’é’”é’—é’•é’šé’›é’œé’£é’¤é’«é’ªé’­é’¬é’¯é’°é’²é’´é’¶",
+			4,
+			"é’¼é’½é’¿é“„é“ˆ",
+			6,
+			"é“é“‘é“’é“•é“–é“—é“™é“˜é“›é“žé“Ÿé“ é“¢é“¤é“¥é“§é“¨é“ª"
+		],
+		[
+			"ef40",
+			"é¡¯",
+			5,
+			"é¢‹é¢Žé¢’é¢•é¢™é¢£é¢¨",
+			37,
+			"é£é£é£”é£–é£—é£›é£œé£é£ ",
+			4
+		],
+		[
+			"ef80",
+			"é£¥é£¦é£©",
+			30,
+			"é“©é“«é“®é“¯é“³é“´é“µé“·é“¹é“¼é“½é“¿é”ƒé”‚é”†é”‡é”‰é”Šé”é”Žé”é”’",
+			4,
+			"é”˜é”›é”é”žé”Ÿé”¢é”ªé”«é”©é”¬é”±é”²é”´é”¶é”·é”¸é”¼é”¾é”¿é•‚é”µé•„é•…é•†é•‰é•Œé•Žé•é•’é•“é•”é•–é•—é•˜é•™é•›é•žé•Ÿé•é•¡é•¢é•¤",
+			8,
+			"é•¯é•±é•²é•³é”ºçŸ§çŸ¬é›‰ç§•ç§­ç§£ç§«ç¨†åµ‡ç¨ƒç¨‚ç¨žç¨”"
+		],
+		[
+			"f040",
+			"é¤ˆ",
+			4,
+			"é¤Žé¤é¤‘",
+			28,
+			"é¤¯",
+			26
+		],
+		[
+			"f080",
+			"é¥Š",
+			9,
+			"é¥–",
+			12,
+			"é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦‚é¦ƒé¦‰ç¨¹ç¨·ç©‘é»é¦¥ç©°çšˆçšŽçš“çš™çš¤ç“žç“ ç”¬é¸ é¸¢é¸¨",
+			4,
+			"é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹‚é¹„é¹†é¹‡é¹ˆé¹‰é¹‹é¹Œé¹Žé¹‘é¹•é¹—é¹šé¹›é¹œé¹žé¹£é¹¦",
+			6,
+			"é¹±é¹­é¹³ç–’ç–”ç––ç– ç–ç–¬ç–£ç–³ç–´ç–¸ç—„ç–±ç–°ç—ƒç—‚ç—–ç—ç—£ç—¨ç—¦ç—¤ç—«ç—§ç˜ƒç—±ç—¼ç—¿ç˜ç˜€ç˜…ç˜Œç˜—ç˜Šç˜¥ç˜˜ç˜•ç˜™"
+		],
+		[
+			"f140",
+			"é¦Œé¦Žé¦š",
+			10,
+			"é¦¦é¦§é¦©",
+			47
+		],
+		[
+			"f180",
+			"é§™",
+			32,
+			"ç˜›ç˜¼ç˜¢ç˜ ç™€ç˜­ç˜°ç˜¿ç˜µç™ƒç˜¾ç˜³ç™ç™žç™”ç™œç™–ç™«ç™¯ç¿Šç«¦ç©¸ç©¹çª€çª†çªˆçª•çª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢‚è¢¢è£†è¢·è¢¼è£‰è£¢è£Žè££è£¥è£±è¤šè£¼è£¨è£¾è£°è¤¡è¤™è¤“è¤›è¤Šè¤´è¤«è¤¶è¥è¥¦è¥»ç–‹èƒ¥çš²çš´çŸœè€’è€”è€–è€œè€ è€¢è€¥è€¦è€§è€©è€¨è€±è€‹è€µèƒè†èè’è©è±è¦ƒé¡¸é¢€é¢ƒ"
+		],
+		[
+			"f240",
+			"é§º",
+			62
+		],
+		[
+			"f280",
+			"é¨¹",
+			32,
+			"é¢‰é¢Œé¢é¢é¢”é¢šé¢›é¢žé¢Ÿé¢¡é¢¢é¢¥é¢¦è™è™”è™¬è™®è™¿è™ºè™¼è™»èš¨èšèš‹èš¬èšèš§èš£èšªèš“èš©èš¶è›„èšµè›Žèš°èšºèš±èš¯è›‰è›èš´è›©è›±è›²è›­è›³è›èœ“è›žè›´è›Ÿè›˜è›‘èœƒèœ‡è›¸èœˆèœŠèœèœ‰èœ£èœ»èœžèœ¥èœ®èœšèœ¾èˆèœ´èœ±èœ©èœ·èœ¿èž‚èœ¢è½è¾è»è è°èŒè®èž‹è“è£è¼è¤è™è¥èž“èž¯èž¨èŸ’"
+		],
+		[
+			"f340",
+			"é©š",
+			17,
+			"é©²éªƒéª‰éªéªŽéª”éª•éª™éª¦éª©",
+			6,
+			"éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«ƒé«„é«†",
+			4,
+			"é«é«Žé«é«é«’é«”é«•é«–é«—é«™é«šé«›é«œ"
+		],
+		[
+			"f380",
+			"é«é«žé« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°",
+			8,
+			"é«ºé«¼",
+			6,
+			"é¬„é¬…é¬†èŸ†èžˆèž…èž­èž—èžƒèž«èŸ¥èž¬èžµèž³èŸ‹èŸ“èž½èŸ‘èŸ€èŸŠèŸ›èŸªèŸ èŸ®è –è “èŸ¾è Šè ›è ¡è ¹è ¼ç¼¶ç½‚ç½„ç½…èˆç«ºç«½ç¬ˆç¬ƒç¬„ç¬•ç¬Šç¬«ç¬ç­‡ç¬¸ç¬ªç¬™ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬žç­˜ç­šç­…ç­µç­Œç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®…ç®ªç®œç®¢ç®«ç®´ç¯‘ç¯ç¯Œç¯ç¯šç¯¥ç¯¦ç¯ªç°Œç¯¾ç¯¼ç°ç°–ç°‹"
+		],
+		[
+			"f440",
+			"é¬‡é¬‰",
+			5,
+			"é¬é¬‘é¬’é¬”",
+			10,
+			"é¬ é¬¡é¬¢é¬¤",
+			10,
+			"é¬°é¬±é¬³",
+			7,
+			"é¬½é¬¾é¬¿é­€é­†é­Šé­‹é­Œé­Žé­é­’é­“é­•",
+			5
+		],
+		[
+			"f480",
+			"é­›",
+			32,
+			"ç°Ÿç°ªç°¦ç°¸ç±ç±€è‡¾èˆèˆ‚èˆ„è‡¬è¡„èˆ¡èˆ¢èˆ£èˆ­èˆ¯èˆ¨èˆ«èˆ¸èˆ»èˆ³èˆ´èˆ¾è‰„è‰‰è‰‹è‰è‰šè‰Ÿè‰¨è¡¾è¢…è¢ˆè£˜è£Ÿè¥žç¾ç¾Ÿç¾§ç¾¯ç¾°ç¾²ç±¼æ•‰ç²‘ç²ç²œç²žç²¢ç²²ç²¼ç²½ç³ç³‡ç³Œç³ç³ˆç³…ç³—ç³¨è‰®æš¨ç¾¿ç¿Žç¿•ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹‡çº›éº¸éº´èµ³è¶„è¶”è¶‘è¶±èµ§èµ­è±‡è±‰é…Šé…é…Žé…é…¤"
+		],
+		[
+			"f540",
+			"é­¼",
+			62
+		],
+		[
+			"f580",
+			"é®»",
+			32,
+			"é…¢é…¡é…°é…©é…¯é…½é…¾é…²é…´é…¹é†Œé†…é†é†é†‘é†¢é†£é†ªé†­é†®é†¯é†µé†´é†ºè±•é¹¾è¶¸è·«è¸…è¹™è¹©è¶µè¶¿è¶¼è¶ºè·„è·–è·—è·šè·žè·Žè·è·›è·†è·¬è··è·¸è·£è·¹è·»è·¤è¸‰è·½è¸”è¸è¸Ÿè¸¬è¸®è¸£è¸¯è¸ºè¹€è¸¹è¸µè¸½è¸±è¹‰è¹è¹‚è¹‘è¹’è¹Šè¹°è¹¶è¹¼è¹¯è¹´èº…èºèº”èºèºœèºžè±¸è²‚è²Šè²…è²˜è²”æ–›è§–è§žè§šè§œ"
+		],
+		[
+			"f640",
+			"é¯œ",
+			62
+		],
+		[
+			"f680",
+			"é°›",
+			32,
+			"è§¥è§«è§¯è¨¾è¬¦é“é›©é›³é›¯éœ†éœéœˆéœéœŽéœªéœ­éœ°éœ¾é¾€é¾ƒé¾…",
+			5,
+			"é¾Œé»¾é¼‹é¼éš¹éš¼éš½é›Žé›’çž¿é› éŠŽéŠ®é‹ˆéŒ¾éªéŠéŽé¾é‘«é±¿é²‚é²…é²†é²‡é²ˆç¨£é²‹é²Žé²é²‘é²’é²”é²•é²šé²›é²ž",
+			5,
+			"é²¥",
+			4,
+			"é²«é²­é²®é²°",
+			7,
+			"é²ºé²»é²¼é²½é³„é³…é³†é³‡é³Šé³‹"
+		],
+		[
+			"f740",
+			"é°¼",
+			62
+		],
+		[
+			"f780",
+			"é±»é±½é±¾é²€é²ƒé²„é²‰é²Šé²Œé²é²“é²–é²—é²˜é²™é²é²ªé²¬é²¯é²¹é²¾",
+			4,
+			"é³ˆé³‰é³‘é³’é³šé³›é³ é³¡é³Œ",
+			4,
+			"é³“é³”é³•é³—é³˜é³™é³œé³é³Ÿé³¢é¼éž…éž‘éž’éž”éž¯éž«éž£éž²éž´éª±éª°éª·é¹˜éª¶éªºéª¼é«é«€é«…é«‚é«‹é«Œé«‘é­…é­ƒé­‡é­‰é­ˆé­é­‘é£¨é¤é¤®é¥•é¥”é«Ÿé«¡é«¦é«¯é««é«»é«­é«¹é¬ˆé¬é¬“é¬Ÿé¬£éº½éº¾ç¸»éº‚éº‡éºˆéº‹éº’é–éºéºŸé»›é»œé»é» é»Ÿé»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½„"
+		],
+		[
+			"f840",
+			"é³£",
+			62
+		],
+		[
+			"f880",
+			"é´¢",
+			32
+		],
+		[
+			"f940",
+			"éµƒ",
+			62
+		],
+		[
+			"f980",
+			"é¶‚",
+			32
+		],
+		[
+			"fa40",
+			"é¶£",
+			62
+		],
+		[
+			"fa80",
+			"é·¢",
+			32
+		],
+		[
+			"fb40",
+			"é¸ƒ",
+			27,
+			"é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹€é¹é¹é¹’é¹“é¹”é¹–é¹™é¹é¹Ÿé¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´",
+			9,
+			"éº€"
+		],
+		[
+			"fb80",
+			"éºéºƒéº„éº…éº†éº‰éºŠéºŒ",
+			5,
+			"éº”",
+			8,
+			"éºžéº ",
+			5,
+			"éº§éº¨éº©éºª"
+		],
+		[
+			"fc40",
+			"éº«",
+			8,
+			"éºµéº¶éº·éº¹éººéº¼éº¿",
+			4,
+			"é»…é»†é»‡é»ˆé»Šé»‹é»Œé»é»’é»“é»•é»–é»—é»™é»šé»žé»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°",
+			8,
+			"é»ºé»½é»¿",
+			6
+		],
+		[
+			"fc80",
+			"é¼†",
+			4,
+			"é¼Œé¼é¼‘é¼’é¼”é¼•é¼–é¼˜é¼š",
+			5,
+			"é¼¡é¼£",
+			8,
+			"é¼­é¼®é¼°é¼±"
+		],
+		[
+			"fd40",
+			"é¼²",
+			4,
+			"é¼¸é¼ºé¼¼é¼¿",
+			4,
+			"é½…",
+			10,
+			"é½’",
+			38
+		],
+		[
+			"fd80",
+			"é½¹",
+			5,
+			"é¾é¾‚é¾",
+			11,
+			"é¾œé¾é¾žé¾¡",
+			4,
+			"ï¤¬ï¥¹ï¦•ï§§ï§±"
+		],
+		["fe40", "ï¨Œï¨ï¨Žï¨ï¨‘ï¨“ï¨”ï¨˜ï¨Ÿï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"]
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json
+var require_gbk_added = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json": ((exports, module) => {
+	module.exports = [
+		[
+			"a140",
+			"î“†",
+			62
+		],
+		[
+			"a180",
+			"î”…",
+			32
+		],
+		[
+			"a240",
+			"î”¦",
+			62
+		],
+		[
+			"a280",
+			"î•¥",
+			32
+		],
+		[
+			"a2ab",
+			"î¦",
+			5
+		],
+		["a2e3", "â‚¬î­"],
+		["a2ef", "î®î¯"],
+		["a2fd", "î°î±"],
+		[
+			"a340",
+			"î–†",
+			62
+		],
+		[
+			"a380",
+			"î—…",
+			31,
+			"ã€€"
+		],
+		[
+			"a440",
+			"î—¦",
+			62
+		],
+		[
+			"a480",
+			"î˜¥",
+			32
+		],
+		[
+			"a4f4",
+			"î²",
+			10
+		],
+		[
+			"a540",
+			"î™†",
+			62
+		],
+		[
+			"a580",
+			"îš…",
+			32
+		],
+		[
+			"a5f7",
+			"î½",
+			7
+		],
+		[
+			"a640",
+			"îš¦",
+			62
+		],
+		[
+			"a680",
+			"î›¥",
+			32
+		],
+		[
+			"a6b9",
+			"îž…",
+			7
+		],
+		[
+			"a6d9",
+			"îž",
+			6
+		],
+		["a6ec", "îž”îž•"],
+		["a6f3", "îž–"],
+		[
+			"a6f6",
+			"îž—",
+			8
+		],
+		[
+			"a740",
+			"îœ†",
+			62
+		],
+		[
+			"a780",
+			"î…",
+			32
+		],
+		[
+			"a7c2",
+			"îž ",
+			14
+		],
+		[
+			"a7f2",
+			"îž¯",
+			12
+		],
+		[
+			"a896",
+			"îž¼",
+			10
+		],
+		["a8bc", "á¸¿"],
+		["a8bf", "Ç¹"],
+		["a8c1", "îŸ‰îŸŠîŸ‹îŸŒ"],
+		[
+			"a8ea",
+			"îŸ",
+			20
+		],
+		["a958", "îŸ¢"],
+		["a95b", "îŸ£"],
+		["a95d", "îŸ¤îŸ¥îŸ¦"],
+		[
+			"a989",
+			"ã€¾â¿°",
+			11
+		],
+		[
+			"a997",
+			"îŸ´",
+			12
+		],
+		[
+			"a9f0",
+			"î ",
+			14
+		],
+		[
+			"aaa1",
+			"î€€",
+			93
+		],
+		[
+			"aba1",
+			"îž",
+			93
+		],
+		[
+			"aca1",
+			"î‚¼",
+			93
+		],
+		[
+			"ada1",
+			"î„š",
+			93
+		],
+		[
+			"aea1",
+			"î…¸",
+			93
+		],
+		[
+			"afa1",
+			"î‡–",
+			93
+		],
+		[
+			"d7fa",
+			"î ",
+			4
+		],
+		[
+			"f8a1",
+			"îˆ´",
+			93
+		],
+		[
+			"f9a1",
+			"îŠ’",
+			93
+		],
+		[
+			"faa1",
+			"î‹°",
+			93
+		],
+		[
+			"fba1",
+			"îŽ",
+			93
+		],
+		[
+			"fca1",
+			"îŽ¬",
+			93
+		],
+		[
+			"fda1",
+			"îŠ",
+			93
+		],
+		["fe50", "âºî –î —î ˜âº„ã‘³ã‘‡âºˆâº‹î žã–žã˜šã˜ŽâºŒâº—ã¥®ã¤˜î ¦ã§ã§Ÿã©³ã§î «î ¬ã­Žã±®ã³ âº§î ±î ²âºªä–ä…Ÿâº®äŒ·âº³âº¶âº·î »äŽ±äŽ¬âº»ää“–ä™¡ä™Œî¡ƒ"],
+		[
+			"fe80",
+			"äœ£äœ©ä¼äžâ»Šä¥‡ä¥ºä¥½ä¦‚ä¦ƒä¦…ä¦†ä¦Ÿä¦›ä¦·ä¦¶î¡”î¡•ä²£ä²Ÿä² ä²¡ä±·ä²¢ä´“",
+			6,
+			"ä¶®î¡¤î‘¨",
+			93
+		],
+		["8135f437", "îŸ‡"]
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
+var require_gb18030_ranges = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json": ((exports, module) => {
+	module.exports = {
+		"uChars": [
+			128,
+			165,
+			169,
+			178,
+			184,
+			216,
+			226,
+			235,
+			238,
+			244,
+			248,
+			251,
+			253,
+			258,
+			276,
+			284,
+			300,
+			325,
+			329,
+			334,
+			364,
+			463,
+			465,
+			467,
+			469,
+			471,
+			473,
+			475,
+			477,
+			506,
+			594,
+			610,
+			712,
+			716,
+			730,
+			930,
+			938,
+			962,
+			970,
+			1026,
+			1104,
+			1106,
+			8209,
+			8215,
+			8218,
+			8222,
+			8231,
+			8241,
+			8244,
+			8246,
+			8252,
+			8365,
+			8452,
+			8454,
+			8458,
+			8471,
+			8482,
+			8556,
+			8570,
+			8596,
+			8602,
+			8713,
+			8720,
+			8722,
+			8726,
+			8731,
+			8737,
+			8740,
+			8742,
+			8748,
+			8751,
+			8760,
+			8766,
+			8777,
+			8781,
+			8787,
+			8802,
+			8808,
+			8816,
+			8854,
+			8858,
+			8870,
+			8896,
+			8979,
+			9322,
+			9372,
+			9548,
+			9588,
+			9616,
+			9622,
+			9634,
+			9652,
+			9662,
+			9672,
+			9676,
+			9680,
+			9702,
+			9735,
+			9738,
+			9793,
+			9795,
+			11906,
+			11909,
+			11913,
+			11917,
+			11928,
+			11944,
+			11947,
+			11951,
+			11956,
+			11960,
+			11964,
+			11979,
+			12284,
+			12292,
+			12312,
+			12319,
+			12330,
+			12351,
+			12436,
+			12447,
+			12535,
+			12543,
+			12586,
+			12842,
+			12850,
+			12964,
+			13200,
+			13215,
+			13218,
+			13253,
+			13263,
+			13267,
+			13270,
+			13384,
+			13428,
+			13727,
+			13839,
+			13851,
+			14617,
+			14703,
+			14801,
+			14816,
+			14964,
+			15183,
+			15471,
+			15585,
+			16471,
+			16736,
+			17208,
+			17325,
+			17330,
+			17374,
+			17623,
+			17997,
+			18018,
+			18212,
+			18218,
+			18301,
+			18318,
+			18760,
+			18811,
+			18814,
+			18820,
+			18823,
+			18844,
+			18848,
+			18872,
+			19576,
+			19620,
+			19738,
+			19887,
+			40870,
+			59244,
+			59336,
+			59367,
+			59413,
+			59417,
+			59423,
+			59431,
+			59437,
+			59443,
+			59452,
+			59460,
+			59478,
+			59493,
+			63789,
+			63866,
+			63894,
+			63976,
+			63986,
+			64016,
+			64018,
+			64021,
+			64025,
+			64034,
+			64037,
+			64042,
+			65074,
+			65093,
+			65107,
+			65112,
+			65127,
+			65132,
+			65375,
+			65510,
+			65536
+		],
+		"gbChars": [
+			0,
+			36,
+			38,
+			45,
+			50,
+			81,
+			89,
+			95,
+			96,
+			100,
+			103,
+			104,
+			105,
+			109,
+			126,
+			133,
+			148,
+			172,
+			175,
+			179,
+			208,
+			306,
+			307,
+			308,
+			309,
+			310,
+			311,
+			312,
+			313,
+			341,
+			428,
+			443,
+			544,
+			545,
+			558,
+			741,
+			742,
+			749,
+			750,
+			805,
+			819,
+			820,
+			7922,
+			7924,
+			7925,
+			7927,
+			7934,
+			7943,
+			7944,
+			7945,
+			7950,
+			8062,
+			8148,
+			8149,
+			8152,
+			8164,
+			8174,
+			8236,
+			8240,
+			8262,
+			8264,
+			8374,
+			8380,
+			8381,
+			8384,
+			8388,
+			8390,
+			8392,
+			8393,
+			8394,
+			8396,
+			8401,
+			8406,
+			8416,
+			8419,
+			8424,
+			8437,
+			8439,
+			8445,
+			8482,
+			8485,
+			8496,
+			8521,
+			8603,
+			8936,
+			8946,
+			9046,
+			9050,
+			9063,
+			9066,
+			9076,
+			9092,
+			9100,
+			9108,
+			9111,
+			9113,
+			9131,
+			9162,
+			9164,
+			9218,
+			9219,
+			11329,
+			11331,
+			11334,
+			11336,
+			11346,
+			11361,
+			11363,
+			11366,
+			11370,
+			11372,
+			11375,
+			11389,
+			11682,
+			11686,
+			11687,
+			11692,
+			11694,
+			11714,
+			11716,
+			11723,
+			11725,
+			11730,
+			11736,
+			11982,
+			11989,
+			12102,
+			12336,
+			12348,
+			12350,
+			12384,
+			12393,
+			12395,
+			12397,
+			12510,
+			12553,
+			12851,
+			12962,
+			12973,
+			13738,
+			13823,
+			13919,
+			13933,
+			14080,
+			14298,
+			14585,
+			14698,
+			15583,
+			15847,
+			16318,
+			16434,
+			16438,
+			16481,
+			16729,
+			17102,
+			17122,
+			17315,
+			17320,
+			17402,
+			17418,
+			17859,
+			17909,
+			17911,
+			17915,
+			17916,
+			17936,
+			17939,
+			17961,
+			18664,
+			18703,
+			18814,
+			18962,
+			19043,
+			33469,
+			33470,
+			33471,
+			33484,
+			33485,
+			33490,
+			33497,
+			33501,
+			33505,
+			33513,
+			33520,
+			33536,
+			33550,
+			37845,
+			37921,
+			37948,
+			38029,
+			38038,
+			38064,
+			38065,
+			38066,
+			38069,
+			38075,
+			38076,
+			38078,
+			39108,
+			39109,
+			39113,
+			39114,
+			39115,
+			39116,
+			39265,
+			39394,
+			189e3
+		]
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp949.json
+var require_cp949 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp949.json": ((exports, module) => {
+	module.exports = [
+		[
+			"0",
+			"\0",
+			127
+		],
+		[
+			"8141",
+			"ê°‚ê°ƒê°…ê°†ê°‹",
+			4,
+			"ê°˜ê°žê°Ÿê°¡ê°¢ê°£ê°¥",
+			6,
+			"ê°®ê°²ê°³ê°´"
+		],
+		[
+			"8161",
+			"ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±",
+			9,
+			"ê±Œê±Ž",
+			5,
+			"ê±•"
+		],
+		[
+			"8181",
+			"ê±–ê±—ê±™ê±šê±›ê±",
+			18,
+			"ê±²ê±³ê±µê±¶ê±¹ê±»",
+			4,
+			"ê²‚ê²‡ê²ˆê²ê²Žê²ê²‘ê²’ê²“ê²•",
+			6,
+			"ê²žê²¢",
+			5,
+			"ê²«ê²­ê²®ê²±",
+			6,
+			"ê²ºê²¾ê²¿ê³€ê³‚ê³ƒê³…ê³†ê³‡ê³‰ê³Šê³‹ê³",
+			7,
+			"ê³–ê³˜",
+			7,
+			"ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·",
+			4,
+			"ê³¾ê³¿ê´ê´‚ê´ƒê´…ê´‡",
+			4,
+			"ê´Žê´ê´’ê´“"
+		],
+		[
+			"8241",
+			"ê´”ê´•ê´–ê´—ê´™ê´šê´›ê´ê´žê´Ÿê´¡",
+			7,
+			"ê´ªê´«ê´®",
+			5
+		],
+		[
+			"8261",
+			"ê´¶ê´·ê´¹ê´ºê´»ê´½",
+			6,
+			"êµ†êµˆêµŠ",
+			5,
+			"êµ‘êµ’êµ“êµ•êµ–êµ—"
+		],
+		[
+			"8281",
+			"êµ™",
+			7,
+			"êµ¢êµ¤",
+			7,
+			"êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶€ê¶ƒ",
+			4,
+			"ê¶Šê¶‹ê¶ê¶Žê¶ê¶‘",
+			10,
+			"ê¶ž",
+			5,
+			"ê¶¥",
+			17,
+			"ê¶¸",
+			7,
+			"ê·‚ê·ƒê·…ê·†ê·‡ê·‰",
+			6,
+			"ê·’ê·”",
+			7,
+			"ê·ê·žê·Ÿê·¡ê·¢ê·£ê·¥",
+			18
+		],
+		[
+			"8341",
+			"ê·ºê·»ê·½ê·¾ê¸‚",
+			5,
+			"ê¸Šê¸Œê¸Ž",
+			5,
+			"ê¸•",
+			7
+		],
+		[
+			"8361",
+			"ê¸",
+			18,
+			"ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"
+		],
+		[
+			"8381",
+			"ê¸½ê¸¾ê¸¿ê¹‚ê¹„ê¹‡ê¹ˆê¹‰ê¹‹ê¹ê¹‘ê¹’ê¹“ê¹•ê¹—",
+			4,
+			"ê¹žê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±",
+			6,
+			"ê¹ºê¹¾",
+			5,
+			"êº†",
+			5,
+			"êº",
+			46,
+			"êº¿ê»ê»‚ê»ƒê»…",
+			6,
+			"ê»Žê»’",
+			5,
+			"ê»šê»›ê»",
+			8
+		],
+		[
+			"8441",
+			"ê»¦ê»§ê»©ê»ªê»¬ê»®",
+			5,
+			"ê»µê»¶ê»·ê»¹ê»ºê»»ê»½",
+			8
+		],
+		[
+			"8461",
+			"ê¼†ê¼‰ê¼Šê¼‹ê¼Œê¼Žê¼ê¼‘",
+			18
+		],
+		[
+			"8481",
+			"ê¼¤",
+			7,
+			"ê¼®ê¼¯ê¼±ê¼³ê¼µ",
+			6,
+			"ê¼¾ê½€ê½„ê½…ê½†ê½‡ê½Š",
+			5,
+			"ê½‘",
+			10,
+			"ê½ž",
+			5,
+			"ê½¦",
+			18,
+			"ê½º",
+			5,
+			"ê¾ê¾‚ê¾ƒê¾…ê¾†ê¾‡ê¾‰",
+			6,
+			"ê¾’ê¾“ê¾”ê¾–",
+			5,
+			"ê¾",
+			26,
+			"ê¾ºê¾»ê¾½ê¾¾"
+		],
+		[
+			"8541",
+			"ê¾¿ê¿",
+			5,
+			"ê¿Šê¿Œê¿",
+			4,
+			"ê¿•",
+			6,
+			"ê¿",
+			4
+		],
+		[
+			"8561",
+			"ê¿¢",
+			5,
+			"ê¿ª",
+			5,
+			"ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹",
+			6,
+			"ë€‚ë€ƒ"
+		],
+		[
+			"8581",
+			"ë€…",
+			6,
+			"ë€ë€Žë€ë€‘ë€’ë€“ë€•",
+			6,
+			"ë€ž",
+			9,
+			"ë€©",
+			26,
+			"ë†ë‡ë‰ë‹ëëëë‘ë’ë–ë˜ëšë›ëœëž",
+			29,
+			"ë¾ë¿ë‚ë‚‚ë‚ƒë‚…",
+			6,
+			"ë‚Žë‚ë‚’",
+			5,
+			"ë‚›ë‚ë‚žë‚£ë‚¤"
+		],
+		[
+			"8641",
+			"ë‚¥ë‚¦ë‚§ë‚ªë‚°ë‚²ë‚¶ë‚·ë‚¹ë‚ºë‚»ë‚½",
+			6,
+			"ëƒ†ëƒŠ",
+			5,
+			"ëƒ’"
+		],
+		[
+			"8661",
+			"ëƒ“ëƒ•ëƒ–ëƒ—ëƒ™",
+			6,
+			"ëƒ¡ëƒ¢ëƒ£ëƒ¤ëƒ¦",
+			10
+		],
+		[
+			"8681",
+			"ëƒ±",
+			22,
+			"ë„Šë„ë„Žë„ë„‘ë„”ë„•ë„–ë„—ë„šë„ž",
+			4,
+			"ë„¦ë„§ë„©ë„ªë„«ë„­",
+			6,
+			"ë„¶ë„º",
+			5,
+			"ë…‚ë…ƒë……ë…†ë…‡ë…‰",
+			6,
+			"ë…’ë…“ë…–ë…—ë…™ë…šë…›ë…ë…žë…Ÿë…¡",
+			22,
+			"ë…ºë…»ë…½ë…¾ë…¿ë†ë†ƒ",
+			4,
+			"ë†Šë†Œë†Žë†ë†ë†‘ë†•ë†–ë†—ë†™ë†šë†›ë†"
+		],
+		[
+			"8741",
+			"ë†ž",
+			9,
+			"ë†©",
+			15
+		],
+		[
+			"8761",
+			"ë†¹",
+			18,
+			"ë‡ë‡Žë‡ë‡‘ë‡’ë‡“ë‡•"
+		],
+		[
+			"8781",
+			"ë‡–",
+			5,
+			"ë‡žë‡ ",
+			7,
+			"ë‡ªë‡«ë‡­ë‡®ë‡¯ë‡±",
+			7,
+			"ë‡ºë‡¼ë‡¾",
+			5,
+			"ëˆ†ëˆ‡ëˆ‰ëˆŠëˆ",
+			6,
+			"ëˆ–ëˆ˜ëˆš",
+			5,
+			"ëˆ¡",
+			18,
+			"ëˆµ",
+			6,
+			"ëˆ½",
+			26,
+			"ë‰™ë‰šë‰›ë‰ë‰žë‰Ÿë‰¡",
+			6,
+			"ë‰ª",
+			4
+		],
+		[
+			"8841",
+			"ë‰¯",
+			4,
+			"ë‰¶",
+			5,
+			"ë‰½",
+			6,
+			"ëŠ†ëŠ‡ëŠˆëŠŠ",
+			4
+		],
+		[
+			"8861",
+			"ëŠëŠ’ëŠ“ëŠ•ëŠ–ëŠ—ëŠ›",
+			4,
+			"ëŠ¢ëŠ¤ëŠ§ëŠ¨ëŠ©ëŠ«ëŠ­ëŠ®ëŠ¯ëŠ±ëŠ²ëŠ³ëŠµëŠ¶ëŠ·"
+		],
+		[
+			"8881",
+			"ëŠ¸",
+			15,
+			"ë‹Šë‹‹ë‹ë‹Žë‹ë‹‘ë‹“",
+			4,
+			"ë‹šë‹œë‹žë‹Ÿë‹ ë‹¡ë‹£ë‹§ë‹©ë‹ªë‹°ë‹±ë‹²ë‹¶ë‹¼ë‹½ë‹¾ëŒ‚ëŒƒëŒ…ëŒ†ëŒ‡ëŒ‰",
+			6,
+			"ëŒ’ëŒ–",
+			5,
+			"ëŒ",
+			54,
+			"ë—ë™ëšëë ë¡ë¢ë£"
+		],
+		[
+			"8941",
+			"ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹",
+			6,
+			"ëŽ‚ëŽ†",
+			5,
+			"ëŽ"
+		],
+		[
+			"8961",
+			"ëŽŽëŽëŽ‘ëŽ’ëŽ“ëŽ•",
+			10,
+			"ëŽ¢",
+			5,
+			"ëŽ©ëŽªëŽ«ëŽ­"
+		],
+		[
+			"8981",
+			"ëŽ®",
+			21,
+			"ë†ë‡ë‰ëŠëëë‘ë’ë“ë–ë˜ëšëœëžëŸë¡ë¢ë£ë¥ë¦ë§ë©",
+			18,
+			"ë½",
+			18,
+			"ë‘",
+			6,
+			"ë™ëšë›ëëžëŸë¡",
+			6,
+			"ëªë¬",
+			7,
+			"ëµ",
+			15
+		],
+		[
+			"8a41",
+			"ë‘…",
+			10,
+			"ë‘’ë‘“ë‘•ë‘–ë‘—ë‘™",
+			6,
+			"ë‘¢ë‘¤ë‘¦"
+		],
+		[
+			"8a61",
+			"ë‘§",
+			4,
+			"ë‘­",
+			18,
+			"ë’ë’‚"
+		],
+		[
+			"8a81",
+			"ë’ƒ",
+			4,
+			"ë’‰",
+			19,
+			"ë’ž",
+			5,
+			"ë’¥ë’¦ë’§ë’©ë’ªë’«ë’­",
+			7,
+			"ë’¶ë’¸ë’º",
+			5,
+			"ë“ë“‚ë“ƒë“…ë“†ë“‡ë“‰",
+			6,
+			"ë“‘ë“’ë““ë“”ë“–",
+			5,
+			"ë“žë“Ÿë“¡ë“¢ë“¥ë“§",
+			4,
+			"ë“®ë“°ë“²",
+			5,
+			"ë“¹",
+			26,
+			"ë”–ë”—ë”™ë”šë”"
+		],
+		[
+			"8b41",
+			"ë”ž",
+			5,
+			"ë”¦ë”«",
+			4,
+			"ë”²ë”³ë”µë”¶ë”·ë”¹",
+			6,
+			"ë•‚ë•†"
+		],
+		[
+			"8b61",
+			"ë•‡ë•ˆë•‰ë•Šë•Žë•ë•‘ë•’ë•“ë••",
+			6,
+			"ë•žë•¢",
+			8
+		],
+		[
+			"8b81",
+			"ë•«",
+			52,
+			"ë–¢ë–£ë–¥ë–¦ë–§ë–©ë–¬ë–­ë–®ë–¯ë–²ë–¶",
+			4,
+			"ë–¾ë–¿ë—ë—‚ë—ƒë—…",
+			6,
+			"ë—Žë—’",
+			5,
+			"ë—™",
+			18,
+			"ë—­",
+			18
+		],
+		[
+			"8c41",
+			"ë˜€",
+			15,
+			"ë˜’ë˜“ë˜•ë˜–ë˜—ë˜™",
+			4
+		],
+		[
+			"8c61",
+			"ë˜ž",
+			6,
+			"ë˜¦",
+			5,
+			"ë˜­",
+			6,
+			"ë˜µ",
+			5
+		],
+		[
+			"8c81",
+			"ë˜»",
+			12,
+			"ë™‰",
+			26,
+			"ë™¥ë™¦ë™§ë™©",
+			50,
+			"ëšžëšŸëš¡ëš¢ëš£ëš¥",
+			5,
+			"ëš­ëš®ëš¯ëš°ëš²",
+			16
+		],
+		[
+			"8d41",
+			"ë›ƒ",
+			16,
+			"ë›•",
+			8
+		],
+		[
+			"8d61",
+			"ë›ž",
+			17,
+			"ë›±ë›²ë›³ë›µë›¶ë›·ë›¹ë›º"
+		],
+		[
+			"8d81",
+			"ë›»",
+			4,
+			"ëœ‚ëœƒëœ„ëœ†",
+			33,
+			"ëœªëœ«ëœ­ëœ®ëœ±",
+			6,
+			"ëœºëœ¼",
+			7,
+			"ë…ë†ë‡ë‰ëŠë‹ë",
+			6,
+			"ë–",
+			9,
+			"ë¡ë¢ë£ë¥ë¦ë§ë©",
+			6,
+			"ë²ë´ë¶",
+			5,
+			"ë¾ë¿ëžëž‚ëžƒëž…",
+			6,
+			"ëžŽëž“ëž”ëž•ëžšëž›ëžëžž"
+		],
+		[
+			"8e41",
+			"ëžŸëž¡",
+			6,
+			"ëžªëž®",
+			5,
+			"ëž¶ëž·ëž¹",
+			8
+		],
+		[
+			"8e61",
+			"ëŸ‚",
+			4,
+			"ëŸˆëŸŠ",
+			19
+		],
+		[
+			"8e81",
+			"ëŸž",
+			13,
+			"ëŸ®ëŸ¯ëŸ±ëŸ²ëŸ³ëŸµ",
+			6,
+			"ëŸ¾ë ‚",
+			4,
+			"ë Šë ‹ë ë Žë ë ‘",
+			6,
+			"ë šë œë ž",
+			5,
+			"ë ¦ë §ë ©ë ªë «ë ­",
+			6,
+			"ë ¶ë º",
+			5,
+			"ë¡ë¡‚ë¡ƒë¡…",
+			11,
+			"ë¡’ë¡”",
+			7,
+			"ë¡žë¡Ÿë¡¡ë¡¢ë¡£ë¡¥",
+			6,
+			"ë¡®ë¡°ë¡²",
+			5,
+			"ë¡¹ë¡ºë¡»ë¡½",
+			7
+		],
+		[
+			"8f41",
+			"ë¢…",
+			7,
+			"ë¢Ž",
+			17
+		],
+		[
+			"8f61",
+			"ë¢ ",
+			7,
+			"ë¢©",
+			6,
+			"ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹",
+			4
+		],
+		[
+			"8f81",
+			"ë¢¾ë¢¿ë£‚ë£„ë£†",
+			5,
+			"ë£ë£Žë£ë£‘ë£’ë£“ë£•",
+			7,
+			"ë£žë£ ë£¢",
+			5,
+			"ë£ªë£«ë£­ë£®ë£¯ë£±",
+			6,
+			"ë£ºë£¼ë£¾",
+			5,
+			"ë¤…",
+			18,
+			"ë¤™",
+			6,
+			"ë¤¡",
+			26,
+			"ë¤¾ë¤¿ë¥ë¥‚ë¥ƒë¥…",
+			6,
+			"ë¥ë¥Žë¥ë¥’",
+			5
+		],
+		[
+			"9041",
+			"ë¥šë¥›ë¥ë¥žë¥Ÿë¥¡",
+			6,
+			"ë¥ªë¥¬ë¥®",
+			5,
+			"ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"
+		],
+		[
+			"9061",
+			"ë¥¾",
+			5,
+			"ë¦†ë¦ˆë¦‹ë¦Œë¦",
+			15
+		],
+		[
+			"9081",
+			"ë¦Ÿ",
+			12,
+			"ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ",
+			6,
+			"ë¦¾ë§€ë§‚",
+			5,
+			"ë§Šë§‹ë§ë§“",
+			4,
+			"ë§šë§œë§Ÿë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­",
+			6,
+			"ë§¶ë§»",
+			4,
+			"ë¨‚",
+			5,
+			"ë¨‰",
+			11,
+			"ë¨–",
+			33,
+			"ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ƒë©„ë©…ë©†"
+		],
+		[
+			"9141",
+			"ë©‡ë©Šë©Œë©ë©ë©‘ë©’ë©–ë©—ë©™ë©šë©›ë©",
+			6,
+			"ë©¦ë©ª",
+			5
+		],
+		[
+			"9161",
+			"ë©²ë©³ë©µë©¶ë©·ë©¹",
+			9,
+			"ëª†ëªˆëª‰ëªŠëª‹ëª",
+			5
+		],
+		[
+			"9181",
+			"ëª“",
+			20,
+			"ëªªëª­ëª®ëª¯ëª±ëª³",
+			4,
+			"ëªºëª¼ëª¾",
+			5,
+			"ë«…ë«†ë«‡ë«‰",
+			14,
+			"ë«š",
+			33,
+			"ë«½ë«¾ë«¿ë¬ë¬‚ë¬ƒë¬…",
+			7,
+			"ë¬Žë¬ë¬’",
+			5,
+			"ë¬™ë¬šë¬›ë¬ë¬žë¬Ÿë¬¡",
+			6
+		],
+		[
+			"9241",
+			"ë¬¨ë¬ªë¬¬",
+			7,
+			"ë¬·ë¬¹ë¬ºë¬¿",
+			4,
+			"ë­†ë­ˆë­Šë­‹ë­Œë­Žë­‘ë­’"
+		],
+		[
+			"9261",
+			"ë­“ë­•ë­–ë­—ë­™",
+			7,
+			"ë­¢ë­¤",
+			7,
+			"ë­­",
+			4
+		],
+		[
+			"9281",
+			"ë­²",
+			21,
+			"ë®‰ë®Šë®‹ë®ë®Žë®ë®‘",
+			18,
+			"ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­",
+			6,
+			"ë®µë®¶ë®¸",
+			7,
+			"ë¯ë¯‚ë¯ƒë¯…ë¯†ë¯‡ë¯‰",
+			6,
+			"ë¯‘ë¯’ë¯”",
+			35,
+			"ë¯ºë¯»ë¯½ë¯¾ë°"
+		],
+		[
+			"9341",
+			"ë°ƒ",
+			4,
+			"ë°Šë°Žë°ë°’ë°“ë°™ë°šë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"
+		],
+		[
+			"9361",
+			"ë°¶ë°·ë°¹",
+			6,
+			"ë±‚ë±†ë±‡ë±ˆë±Šë±‹ë±Žë±ë±‘",
+			8
+		],
+		[
+			"9381",
+			"ë±šë±›ë±œë±ž",
+			37,
+			"ë²†ë²‡ë²‰ë²Šë²ë²",
+			4,
+			"ë²–ë²˜ë²›",
+			4,
+			"ë²¢ë²£ë²¥ë²¦ë²©",
+			6,
+			"ë²²ë²¶",
+			5,
+			"ë²¾ë²¿ë³ë³‚ë³ƒë³…",
+			7,
+			"ë³Žë³’ë³“ë³”ë³–ë³—ë³™ë³šë³›ë³",
+			22,
+			"ë³·ë³¹ë³ºë³»ë³½"
+		],
+		[
+			"9441",
+			"ë³¾",
+			5,
+			"ë´†ë´ˆë´Š",
+			5,
+			"ë´‘ë´’ë´“ë´•",
+			8
+		],
+		[
+			"9461",
+			"ë´ž",
+			5,
+			"ë´¥",
+			6,
+			"ë´­",
+			12
+		],
+		[
+			"9481",
+			"ë´º",
+			5,
+			"ëµ",
+			6,
+			"ëµŠëµ‹ëµëµŽëµëµ‘",
+			6,
+			"ëµš",
+			9,
+			"ëµ¥ëµ¦ëµ§ëµ©",
+			22,
+			"ë¶‚ë¶ƒë¶…ë¶†ë¶‹",
+			4,
+			"ë¶’ë¶”ë¶–ë¶—ë¶˜ë¶›ë¶",
+			6,
+			"ë¶¥",
+			10,
+			"ë¶±",
+			6,
+			"ë¶¹",
+			24
+		],
+		[
+			"9541",
+			"ë·’ë·“ë·–ë·—ë·™ë·šë·›ë·",
+			11,
+			"ë·ª",
+			5,
+			"ë·±"
+		],
+		[
+			"9561",
+			"ë·²ë·³ë·µë·¶ë··ë·¹",
+			6,
+			"ë¸ë¸‚ë¸„ë¸†",
+			5,
+			"ë¸Žë¸ë¸‘ë¸’ë¸“"
+		],
+		[
+			"9581",
+			"ë¸•",
+			6,
+			"ë¸žë¸ ",
+			35,
+			"ë¹†ë¹‡ë¹‰ë¹Šë¹‹ë¹ë¹",
+			4,
+			"ë¹–ë¹˜ë¹œë¹ë¹žë¹Ÿë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«",
+			4,
+			"ë¹²ë¹¶",
+			4,
+			"ë¹¾ë¹¿ëºëº‚ëºƒëº…",
+			6,
+			"ëºŽëº’",
+			5,
+			"ëºš",
+			13,
+			"ëº©",
+			14
+		],
+		[
+			"9641",
+			"ëº¸",
+			23,
+			"ë»’ë»“"
+		],
+		[
+			"9661",
+			"ë»•ë»–ë»™",
+			6,
+			"ë»¡ë»¢ë»¦",
+			5,
+			"ë»­",
+			8
+		],
+		[
+			"9681",
+			"ë»¶",
+			10,
+			"ë¼‚",
+			5,
+			"ë¼Š",
+			13,
+			"ë¼šë¼ž",
+			33,
+			"ë½‚ë½ƒë½…ë½†ë½‡ë½‰",
+			6,
+			"ë½’ë½“ë½”ë½–",
+			44
+		],
+		[
+			"9741",
+			"ë¾ƒ",
+			16,
+			"ë¾•",
+			8
+		],
+		[
+			"9761",
+			"ë¾ž",
+			17,
+			"ë¾±",
+			7
+		],
+		[
+			"9781",
+			"ë¾¹",
+			11,
+			"ë¿†",
+			5,
+			"ë¿Žë¿ë¿‘ë¿’ë¿“ë¿•",
+			6,
+			"ë¿ë¿žë¿ ë¿¢",
+			89,
+			"ì€½ì€¾ì€¿"
+		],
+		[
+			"9841",
+			"ì€",
+			16,
+			"ì’",
+			5,
+			"ì™ìšì›"
+		],
+		[
+			"9861",
+			"ììžìŸì¡",
+			6,
+			"ìª",
+			15
+		],
+		[
+			"9881",
+			"ìº",
+			21,
+			"ì‚’ì‚“ì‚•ì‚–ì‚—ì‚™",
+			6,
+			"ì‚¢ì‚¤ì‚¦",
+			5,
+			"ì‚®ì‚±ì‚²ì‚·",
+			4,
+			"ì‚¾ìƒ‚ìƒƒìƒ„ìƒ†ìƒ‡ìƒŠìƒ‹ìƒìƒŽìƒìƒ‘",
+			6,
+			"ìƒšìƒž",
+			5,
+			"ìƒ¦ìƒ§ìƒ©ìƒªìƒ«ìƒ­",
+			6,
+			"ìƒ¶ìƒ¸ìƒº",
+			5,
+			"ì„ì„‚ì„ƒì„…ì„†ì„‡ì„‰",
+			6,
+			"ì„‘ì„’ì„“ì„”ì„–",
+			5,
+			"ì„¡ì„¢ì„¥ì„¨ì„©ì„ªì„«ì„®"
+		],
+		[
+			"9941",
+			"ì„²ì„³ì„´ì„µì„·ì„ºì„»ì„½ì„¾ì„¿ì…",
+			6,
+			"ì…Šì…Ž",
+			5,
+			"ì…–ì…—"
+		],
+		[
+			"9961",
+			"ì…™ì…šì…›ì…",
+			6,
+			"ì…¦ì…ª",
+			5,
+			"ì…±ì…²ì…³ì…µì…¶ì…·ì…¹ì…ºì…»"
+		],
+		[
+			"9981",
+			"ì…¼",
+			8,
+			"ì††",
+			5,
+			"ì†ì†‘ì†’ì†“ì†•ì†—",
+			4,
+			"ì†žì† ì†¢ì†£ì†¤ì†¦ì†§ì†ªì†«ì†­ì†®ì†¯ì†±",
+			11,
+			"ì†¾",
+			5,
+			"ì‡…ì‡†ì‡‡ì‡‰ì‡Šì‡‹ì‡",
+			6,
+			"ì‡•ì‡–ì‡™",
+			6,
+			"ì‡¡ì‡¢ì‡£ì‡¥ì‡¦ì‡§ì‡©",
+			6,
+			"ì‡²ì‡´",
+			7,
+			"ì‡¾ì‡¿ìˆìˆ‚ìˆƒìˆ…",
+			6,
+			"ìˆŽìˆìˆ’",
+			5,
+			"ìˆšìˆ›ìˆìˆžìˆ¡ìˆ¢ìˆ£"
+		],
+		[
+			"9a41",
+			"ìˆ¤ìˆ¥ìˆ¦ìˆ§ìˆªìˆ¬ìˆ®ìˆ°ìˆ³ìˆµ",
+			16
+		],
+		[
+			"9a61",
+			"ì‰†ì‰‡ì‰‰",
+			6,
+			"ì‰’ì‰“ì‰•ì‰–ì‰—ì‰™",
+			6,
+			"ì‰¡ì‰¢ì‰£ì‰¤ì‰¦"
+		],
+		[
+			"9a81",
+			"ì‰§",
+			4,
+			"ì‰®ì‰¯ì‰±ì‰²ì‰³ì‰µ",
+			6,
+			"ì‰¾ìŠ€ìŠ‚",
+			5,
+			"ìŠŠ",
+			5,
+			"ìŠ‘",
+			6,
+			"ìŠ™ìŠšìŠœìŠž",
+			5,
+			"ìŠ¦ìŠ§ìŠ©ìŠªìŠ«ìŠ®",
+			5,
+			"ìŠ¶ìŠ¸ìŠº",
+			33,
+			"ì‹žì‹Ÿì‹¡ì‹¢ì‹¥",
+			5,
+			"ì‹®ì‹°ì‹²ì‹³ì‹´ì‹µì‹·ì‹ºì‹½ì‹¾ì‹¿ìŒ",
+			6,
+			"ìŒŠìŒ‹ìŒŽìŒ"
+		],
+		[
+			"9b41",
+			"ìŒìŒ‘ìŒ’ìŒ–ìŒ—ìŒ™ìŒšìŒ›ìŒ",
+			6,
+			"ìŒ¦ìŒ§ìŒª",
+			8
+		],
+		[
+			"9b61",
+			"ìŒ³",
+			17,
+			"ì†",
+			7
+		],
+		[
+			"9b81",
+			"ìŽ",
+			25,
+			"ìªì«ì­ì®ì¯ì±ì³",
+			4,
+			"ìºì»ì¾",
+			5,
+			"ìŽ…ìŽ†ìŽ‡ìŽ‰ìŽŠìŽ‹ìŽ",
+			50,
+			"ì",
+			22,
+			"ìš"
+		],
+		[
+			"9c41",
+			"ì›ììžì¡ì£",
+			4,
+			"ìªì«ì¬ì®",
+			5,
+			"ì¶ì·ì¹",
+			5
+		],
+		[
+			"9c61",
+			"ì¿",
+			8,
+			"ì‰",
+			6,
+			"ì‘",
+			9
+		],
+		[
+			"9c81",
+			"ì›",
+			8,
+			"ì¥",
+			6,
+			"ì­ì®ì¯ì±ì²ì³ìµ",
+			6,
+			"ì¾",
+			9,
+			"ì‘‰",
+			26,
+			"ì‘¦ì‘§ì‘©ì‘ªì‘«ì‘­",
+			6,
+			"ì‘¶ì‘·ì‘¸ì‘º",
+			5,
+			"ì’",
+			18,
+			"ì’•",
+			6,
+			"ì’",
+			12
+		],
+		[
+			"9d41",
+			"ì’ª",
+			13,
+			"ì’¹ì’ºì’»ì’½",
+			8
+		],
+		[
+			"9d61",
+			"ì“†",
+			25
+		],
+		[
+			"9d81",
+			"ì“ ",
+			8,
+			"ì“ª",
+			5,
+			"ì“²ì“³ì“µì“¶ì“·ì“¹ì“»ì“¼ì“½ì“¾ì”‚",
+			9,
+			"ì”ì”Žì”ì”‘ì”’ì”“ì”•",
+			6,
+			"ì”",
+			10,
+			"ì”ªì”«ì”­ì”®ì”¯ì”±",
+			6,
+			"ì”ºì”¼ì”¾",
+			5,
+			"ì•†ì•‡ì•‹ì•ì•ì•‘ì•’ì•–ì•šì•›ì•œì•Ÿì•¢ì•£ì•¥ì•¦ì•§ì•©",
+			6,
+			"ì•²ì•¶",
+			5,
+			"ì•¾ì•¿ì–ì–‚ì–ƒì–…ì–†ì–ˆì–‰ì–Šì–‹ì–Žì–ì–’ì–“ì–”"
+		],
+		[
+			"9e41",
+			"ì––ì–™ì–šì–›ì–ì–žì–Ÿì–¡",
+			7,
+			"ì–ª",
+			9,
+			"ì–¶"
+		],
+		[
+			"9e61",
+			"ì–·ì–ºì–¿",
+			4,
+			"ì—‹ì—ì—ì—’ì—“ì—•ì—–ì——ì—™",
+			6,
+			"ì—¢ì—¤ì—¦ì—§"
+		],
+		[
+			"9e81",
+			"ì—¨ì—©ì—ªì—«ì—¯ì—±ì—²ì—³ì—µì—¸ì—¹ì—ºì—»ì˜‚ì˜ƒì˜„ì˜‰ì˜Šì˜‹ì˜ì˜Žì˜ì˜‘",
+			6,
+			"ì˜šì˜",
+			6,
+			"ì˜¦ì˜§ì˜©ì˜ªì˜«ì˜¯ì˜±ì˜²ì˜¶ì˜¸ì˜ºì˜¼ì˜½ì˜¾ì˜¿ì™‚ì™ƒì™…ì™†ì™‡ì™‰",
+			6,
+			"ì™’ì™–",
+			5,
+			"ì™žì™Ÿì™¡",
+			10,
+			"ì™­ì™®ì™°ì™²",
+			5,
+			"ì™ºì™»ì™½ì™¾ì™¿ìš",
+			6,
+			"ìšŠìšŒìšŽ",
+			5,
+			"ìš–ìš—ìš™ìššìš›ìš",
+			6,
+			"ìš¦"
+		],
+		[
+			"9f41",
+			"ìš¨ìšª",
+			5,
+			"ìš²ìš³ìšµìš¶ìš·ìš»",
+			4,
+			"ì›‚ì›„ì›†",
+			5,
+			"ì›Ž"
+		],
+		[
+			"9f61",
+			"ì›ì›‘ì›’ì›“ì›•",
+			6,
+			"ì›žì›Ÿì›¢",
+			5,
+			"ì›ªì›«ì›­ì›®ì›¯ì›±ì›²"
+		],
+		[
+			"9f81",
+			"ì›³",
+			4,
+			"ì›ºì›»ì›¼ì›¾",
+			5,
+			"ìœ†ìœ‡ìœ‰ìœŠìœ‹ìœ",
+			6,
+			"ìœ–ìœ˜ìœš",
+			5,
+			"ìœ¢ìœ£ìœ¥ìœ¦ìœ§ìœ©",
+			6,
+			"ìœ²ìœ´ìœ¶ìœ¸ìœ¹ìœºìœ»ìœ¾ìœ¿ìì‚ìƒì…",
+			4,
+			"ì‹ìŽìì™ìšì›ììžìŸì¡",
+			6,
+			"ì©ìªì¬",
+			7,
+			"ì¶ì·ì¹ìºì»ì¿ìž€ìžìž‚ìž†ìž‹ìžŒìžìžìž’ìž“ìž•ìž™ìž›",
+			4,
+			"ìž¢ìž§",
+			4,
+			"ìž®ìž¯ìž±ìž²ìž³ìžµìž¶ìž·"
+		],
+		[
+			"a041",
+			"ìž¸ìž¹ìžºìž»ìž¾ìŸ‚",
+			5,
+			"ìŸŠìŸ‹ìŸìŸìŸ‘",
+			6,
+			"ìŸ™ìŸšìŸ›ìŸœ"
+		],
+		[
+			"a061",
+			"ìŸž",
+			5,
+			"ìŸ¥ìŸ¦ìŸ§ìŸ©ìŸªìŸ«ìŸ­",
+			13
+		],
+		[
+			"a081",
+			"ìŸ»",
+			4,
+			"ì ‚ì ƒì …ì †ì ‡ì ‰ì ‹",
+			4,
+			"ì ’ì ”ì —",
+			4,
+			"ì žì Ÿì ¡ì ¢ì £ì ¥",
+			6,
+			"ì ®ì °ì ²",
+			5,
+			"ì ¹ì ºì »ì ½ì ¾ì ¿ì¡",
+			6,
+			"ì¡Šì¡‹ì¡Ž",
+			5,
+			"ì¡•",
+			26,
+			"ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»",
+			4,
+			"ì¢‚ì¢„ì¢ˆì¢‰ì¢Šì¢Ž",
+			5,
+			"ì¢•",
+			7,
+			"ì¢žì¢ ì¢¢ì¢£ì¢¤"
+		],
+		[
+			"a141",
+			"ì¢¥ì¢¦ì¢§ì¢©",
+			18,
+			"ì¢¾ì¢¿ì£€ì£"
+		],
+		[
+			"a161",
+			"ì£‚ì£ƒì£…ì£†ì£‡ì£‰ì£Šì£‹ì£",
+			6,
+			"ì£–ì£˜ì£š",
+			5,
+			"ì£¢ì££ì£¥"
+		],
+		[
+			"a181",
+			"ì£¦",
+			14,
+			"ì£¶",
+			5,
+			"ì£¾ì£¿ì¤ì¤‚ì¤ƒì¤‡",
+			4,
+			"ì¤Žã€€ã€ã€‚Â·â€¥â€¦Â¨ã€ƒÂ­â€•âˆ¥ï¼¼âˆ¼â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
+			9,
+			"Â±Ã—Ã·â‰ â‰¤â‰¥âˆžâˆ´Â°â€²â€³â„ƒâ„«ï¿ ï¿¡ï¿¥â™‚â™€âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’Â§â€»â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â†’â†â†‘â†“â†”ã€“â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©âˆ§âˆ¨ï¿¢"
+		],
+		[
+			"a241",
+			"ì¤ì¤’",
+			5,
+			"ì¤™",
+			18
+		],
+		[
+			"a261",
+			"ì¤­",
+			6,
+			"ì¤µ",
+			18
+		],
+		[
+			"a281",
+			"ì¥ˆ",
+			7,
+			"ì¥’ì¥“ì¥•ì¥–ì¥—ì¥™",
+			6,
+			"ì¥¢ì¥¤",
+			7,
+			"ì¥­ì¥®ì¥¯â‡’â‡”âˆ€âˆƒÂ´ï½žË‡Ë˜ËËšË™Â¸Ë›Â¡Â¿Ëâˆ®âˆ‘âˆÂ¤â„‰â€°â—â—€â–·â–¶â™¤â™ â™¡â™¥â™§â™£âŠ™â—ˆâ–£â—â—‘â–’â–¤â–¥â–¨â–§â–¦â–©â™¨â˜â˜Žâ˜œâ˜žÂ¶â€ â€¡â†•â†—â†™â†–â†˜â™­â™©â™ªâ™¬ã‰¿ãˆœâ„–ã‡â„¢ã‚ã˜â„¡â‚¬Â®"
+		],
+		[
+			"a341",
+			"ì¥±ì¥²ì¥³ì¥µ",
+			6,
+			"ì¥½",
+			10,
+			"ì¦Šì¦‹ì¦ì¦Žì¦"
+		],
+		[
+			"a361",
+			"ì¦‘",
+			6,
+			"ì¦šì¦œì¦ž",
+			16
+		],
+		[
+			"a381",
+			"ì¦¯",
+			16,
+			"ì§‚ì§ƒì§…ì§†ì§‰ì§‹",
+			4,
+			"ì§’ì§”ì§—ì§˜ì§›ï¼",
+			58,
+			"ï¿¦ï¼½",
+			32,
+			"ï¿£"
+		],
+		[
+			"a441",
+			"ì§žì§Ÿì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²",
+			5,
+			"ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨‚ì¨ƒì¨„"
+		],
+		[
+			"a461",
+			"ì¨…ì¨†ì¨‡ì¨Šì¨Ž",
+			5,
+			"ì¨•ì¨–ì¨—ì¨™",
+			12
+		],
+		[
+			"a481",
+			"ì¨¦ì¨§ì¨¨ì¨ª",
+			28,
+			"ã„±",
+			93
+		],
+		[
+			"a541",
+			"ì©‡",
+			4,
+			"ì©Žì©ì©‘ì©’ì©“ì©•",
+			6,
+			"ì©žì©¢",
+			5,
+			"ì©©ì©ª"
+		],
+		[
+			"a561",
+			"ì©«",
+			17,
+			"ì©¾",
+			5,
+			"ìª…ìª†"
+		],
+		[
+			"a581",
+			"ìª‡",
+			16,
+			"ìª™",
+			14,
+			"â…°",
+			9
+		],
+		[
+			"a5b0",
+			"â… ",
+			9
+		],
+		[
+			"a5c1",
+			"Î‘",
+			16,
+			"Î£",
+			6
+		],
+		[
+			"a5e1",
+			"Î±",
+			16,
+			"Ïƒ",
+			6
+		],
+		[
+			"a641",
+			"ìª¨",
+			19,
+			"ìª¾ìª¿ì«ì«‚ì«ƒì«…"
+		],
+		[
+			"a661",
+			"ì«†",
+			5,
+			"ì«Žì«ì«’ì«”ì«•ì«–ì«—ì«š",
+			5,
+			"ì«¡",
+			6
+		],
+		[
+			"a681",
+			"ì«¨ì«©ì«ªì««ì«­",
+			6,
+			"ì«µ",
+			18,
+			"ì¬‰ì¬Šâ”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚â”’â”‘â”šâ”™â”–â”•â”Žâ”â”žâ”Ÿâ”¡â”¢â”¦â”§â”©â”ªâ”­â”®â”±â”²â”µâ”¶â”¹â”ºâ”½â”¾â•€â•â•ƒ",
+			7
+		],
+		[
+			"a741",
+			"ì¬‹",
+			4,
+			"ì¬‘ì¬’ì¬“ì¬•ì¬–ì¬—ì¬™",
+			6,
+			"ì¬¢",
+			7
+		],
+		[
+			"a761",
+			"ì¬ª",
+			22,
+			"ì­‚ì­ƒì­„"
+		],
+		[
+			"a781",
+			"ì­…ì­†ì­‡ì­Šì­‹ì­ì­Žì­ì­‘",
+			6,
+			"ì­šì­›ì­œì­ž",
+			5,
+			"ì­¥",
+			7,
+			"ãŽ•ãŽ–ãŽ—â„“ãŽ˜ã„ãŽ£ãŽ¤ãŽ¥ãŽ¦ãŽ™",
+			9,
+			"ãŠãŽãŽŽãŽããŽˆãŽ‰ãˆãŽ§ãŽ¨ãŽ°",
+			9,
+			"ãŽ€",
+			4,
+			"ãŽº",
+			5,
+			"ãŽ",
+			4,
+			"â„¦ã€ããŽŠãŽ‹ãŽŒã–ã…ãŽ­ãŽ®ãŽ¯ã›ãŽ©ãŽªãŽ«ãŽ¬ããã“ãƒã‰ãœã†"
+		],
+		[
+			"a841",
+			"ì­­",
+			10,
+			"ì­º",
+			14
+		],
+		[
+			"a861",
+			"ì®‰",
+			18,
+			"ì®",
+			6
+		],
+		[
+			"a881",
+			"ì®¤",
+			19,
+			"ì®¹",
+			11,
+			"Ã†ÃÂªÄ¦"
+		],
+		["a8a6", "Ä²"],
+		["a8a8", "Ä¿ÅÃ˜Å’ÂºÃžÅ¦ÅŠ"],
+		[
+			"a8b1",
+			"ã‰ ",
+			27,
+			"â“",
+			25,
+			"â‘ ",
+			14,
+			"Â½â…“â…”Â¼Â¾â…›â…œâ…â…ž"
+		],
+		[
+			"a941",
+			"ì¯…",
+			14,
+			"ì¯•",
+			10
+		],
+		[
+			"a961",
+			"ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª",
+			18
+		],
+		[
+			"a981",
+			"ì¯½",
+			14,
+			"ì°Žì°ì°‘ì°’ì°“ì°•",
+			6,
+			"ì°žì°Ÿì° ì°£ì°¤Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å€Å‚Ã¸Å“ÃŸÃ¾Å§Å‹Å‰ãˆ€",
+			27,
+			"â’œ",
+			25,
+			"â‘´",
+			14,
+			"Â¹Â²Â³â´â¿â‚â‚‚â‚ƒâ‚„"
+		],
+		[
+			"aa41",
+			"ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±",
+			6,
+			"ì°ºì°¿",
+			4,
+			"ì±†ì±‡ì±‰ì±Šì±‹ì±ì±Ž"
+		],
+		[
+			"aa61",
+			"ì±",
+			4,
+			"ì±–ì±š",
+			5,
+			"ì±¡ì±¢ì±£ì±¥ì±§ì±©",
+			6,
+			"ì±±ì±²"
+		],
+		[
+			"aa81",
+			"ì±³ì±´ì±¶",
+			29,
+			"ã",
+			82
+		],
+		[
+			"ab41",
+			"ì²”ì²•ì²–ì²—ì²šì²›ì²ì²žì²Ÿì²¡",
+			6,
+			"ì²ªì²®",
+			5,
+			"ì²¶ì²·ì²¹"
+		],
+		[
+			"ab61",
+			"ì²ºì²»ì²½",
+			6,
+			"ì³†ì³ˆì³Š",
+			5,
+			"ì³‘ì³’ì³“ì³•",
+			5
+		],
+		[
+			"ab81",
+			"ì³›",
+			8,
+			"ì³¥",
+			6,
+			"ì³­ì³®ì³¯ì³±",
+			12,
+			"ã‚¡",
+			85
+		],
+		[
+			"ac41",
+			"ì³¾ì³¿ì´€ì´‚",
+			5,
+			"ì´Šì´‹ì´ì´Žì´ì´‘",
+			6,
+			"ì´šì´œì´žì´Ÿì´ "
+		],
+		[
+			"ac61",
+			"ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­",
+			11,
+			"ì´º",
+			4
+		],
+		[
+			"ac81",
+			"ì´¿",
+			28,
+			"ìµìµžìµŸÐ",
+			5,
+			"ÐÐ–",
+			25
+		],
+		[
+			"acd1",
+			"Ð°",
+			5,
+			"Ñ‘Ð¶",
+			25
+		],
+		[
+			"ad41",
+			"ìµ¡ìµ¢ìµ£ìµ¥",
+			6,
+			"ìµ®ìµ°ìµ²",
+			5,
+			"ìµ¹",
+			7
+		],
+		[
+			"ad61",
+			"ì¶",
+			6,
+			"ì¶‰",
+			10,
+			"ì¶–ì¶—ì¶™ì¶šì¶›ì¶ì¶žì¶Ÿ"
+		],
+		[
+			"ad81",
+			"ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª",
+			5,
+			"ì¶±",
+			18,
+			"ì·…"
+		],
+		[
+			"ae41",
+			"ì·†",
+			5,
+			"ì·ì·Žì·ì·‘",
+			16
+		],
+		[
+			"ae61",
+			"ì·¢",
+			5,
+			"ì·©ì·ªì·«ì·­ì·®ì·¯ì·±",
+			6,
+			"ì·ºì·¼ì·¾",
+			4
+		],
+		[
+			"ae81",
+			"ì¸ƒì¸…ì¸†ì¸‡ì¸‰ì¸Šì¸‹ì¸",
+			6,
+			"ì¸•ì¸–ì¸—ì¸˜ì¸š",
+			5,
+			"ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"
+		],
+		[
+			"af41",
+			"ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶",
+			19
+		],
+		[
+			"af61",
+			"ì¹Š",
+			13,
+			"ì¹šì¹›ì¹ì¹žì¹¢",
+			5,
+			"ì¹ªì¹¬"
+		],
+		[
+			"af81",
+			"ì¹®",
+			5,
+			"ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½",
+			6,
+			"ìº†ìºˆìºŠ",
+			5,
+			"ìº’ìº“ìº•ìº–ìº—ìº™"
+		],
+		[
+			"b041",
+			"ìºš",
+			5,
+			"ìº¢ìº¦",
+			5,
+			"ìº®",
+			12
+		],
+		[
+			"b061",
+			"ìº»",
+			5,
+			"ì»‚",
+			19
+		],
+		[
+			"b081",
+			"ì»–",
+			13,
+			"ì»¦ì»§ì»©ì»ªì»­",
+			6,
+			"ì»¶ì»º",
+			5,
+			"ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°",
+			7,
+			"ê°™",
+			4,
+			"ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†"
+		],
+		[
+			"b141",
+			"ì¼‚ì¼ƒì¼…ì¼†ì¼‡ì¼‰",
+			6,
+			"ì¼’ì¼”ì¼–",
+			5,
+			"ì¼ì¼žì¼Ÿì¼¡ì¼¢ì¼£"
+		],
+		[
+			"b161",
+			"ì¼¥",
+			6,
+			"ì¼®ì¼²",
+			5,
+			"ì¼¹",
+			11
+		],
+		[
+			"b181",
+			"ì½…",
+			14,
+			"ì½–ì½—ì½™ì½šì½›ì½",
+			6,
+			"ì½¦ì½¨ì½ªì½«ì½¬ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹Žê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸"
+		],
+		[
+			"b241",
+			"ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹",
+			6,
+			"ì¾ì¾‚ì¾ƒì¾„ì¾†",
+			5,
+			"ì¾"
+		],
+		[
+			"b261",
+			"ì¾Ž",
+			18,
+			"ì¾¢",
+			5,
+			"ì¾©"
+		],
+		[
+			"b281",
+			"ì¾ª",
+			5,
+			"ì¾±",
+			18,
+			"ì¿…",
+			6,
+			"ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿Žê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëŽë“ë”ë•ë—ë™"
+		],
+		[
+			"b341",
+			"ì¿Œ",
+			19,
+			"ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"
+		],
+		[
+			"b361",
+			"ì¿ª",
+			5,
+			"ì¿²ì¿´ì¿¶",
+			5,
+			"ì¿½ì¿¾ì¿¿í€í€‚í€ƒí€…",
+			5
+		],
+		[
+			"b381",
+			"í€‹",
+			5,
+			"í€’",
+			5,
+			"í€™",
+			19,
+			"ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«",
+			4,
+			"ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡"
+		],
+		[
+			"b441",
+			"í€®",
+			5,
+			"í€¶í€·í€¹í€ºí€»í€½",
+			6,
+			"í†íˆíŠ",
+			5
+		],
+		[
+			"b461",
+			"í‘í’í“í•í–í—í™",
+			6,
+			"í¡",
+			10,
+			"í®í¯"
+		],
+		[
+			"b481",
+			"í±í²í³íµ",
+			6,
+			"í¾í¿í‚€í‚‚",
+			18,
+			"ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«",
+			4,
+			"ë‹³ë‹´ë‹µë‹·",
+			4,
+			"ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëžëŸë¤ë¥"
+		],
+		[
+			"b541",
+			"í‚•",
+			14,
+			"í‚¦í‚§í‚©í‚ªí‚«í‚­",
+			5
+		],
+		[
+			"b561",
+			"í‚³í‚¶í‚¸í‚º",
+			5,
+			"íƒ‚íƒƒíƒ…íƒ†íƒ‡íƒŠ",
+			5,
+			"íƒ’íƒ–",
+			4
+		],
+		[
+			"b581",
+			"íƒ›íƒžíƒŸíƒ¡íƒ¢íƒ£íƒ¥",
+			6,
+			"íƒ®íƒ²",
+			5,
+			"íƒ¹",
+			11,
+			"ë§ë©ë«ë®ë°ë±ë´ë¸ëŽ€ëŽëŽƒëŽ„ëŽ…ëŽŒëŽëŽ”ëŽ ëŽ¡ëŽ¨ëŽ¬ë„ë…ëˆë‹ëŒëŽëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸"
+		],
+		[
+			"b641",
+			"í„…",
+			7,
+			"í„Ž",
+			17
+		],
+		[
+			"b661",
+			"í„ ",
+			15,
+			"í„²í„³í„µí„¶í„·í„¹í„»í„¼í„½í„¾"
+		],
+		[
+			"b681",
+			"í„¿í…‚í…†",
+			5,
+			"í…Ží…í…‘í…’í…“í…•",
+			6,
+			"í…ží… í…¢",
+			5,
+			"í…©í…ªí…«í…­ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ëž€ëž„ëžŒëžëžëžëž‘ëž’ëž–ëž—"
+		],
+		[
+			"b741",
+			"í…®",
+			13,
+			"í…½",
+			6,
+			"í†…í††í†‡í†‰í†Š"
+		],
+		[
+			"b761",
+			"í†‹",
+			20,
+			"í†¢í†£í†¥í†¦í†§"
+		],
+		[
+			"b781",
+			"í†©",
+			6,
+			"í†²í†´í†¶í†·í†¸í†¹í†»í†½í†¾í†¿í‡",
+			14,
+			"ëž˜ëž™ëžœëž ëž¨ëž©ëž«ëž¬ëž­ëž´ëžµëž¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©"
+		],
+		[
+			"b841",
+			"í‡",
+			7,
+			"í‡™",
+			17
+		],
+		[
+			"b861",
+			"í‡«",
+			8,
+			"í‡µí‡¶í‡·í‡¹",
+			13
+		],
+		[
+			"b881",
+			"íˆˆíˆŠ",
+			5,
+			"íˆ‘",
+			24,
+			"ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦Žë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§Ž",
+			4,
+			"ë§˜ë§™ë§›ë§ë§žë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©Žë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼"
+		],
+		[
+			"b941",
+			"íˆªíˆ«íˆ®íˆ¯íˆ±íˆ²íˆ³íˆµ",
+			6,
+			"íˆ¾í‰€í‰‚",
+			5,
+			"í‰‰í‰Ší‰‹í‰Œ"
+		],
+		[
+			"b961",
+			"í‰",
+			14,
+			"í‰",
+			6,
+			"í‰¥í‰¦í‰§í‰¨"
+		],
+		[
+			"b981",
+			"í‰©",
+			22,
+			"íŠ‚íŠƒíŠ…íŠ†íŠ‡íŠ‰íŠŠíŠ‹íŠŒë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”",
+			4,
+			"ë°›",
+			4,
+			"ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²Žë²”ë²•ë²—"
+		],
+		[
+			"ba41",
+			"íŠíŠŽíŠíŠ’íŠ“íŠ”íŠ–",
+			5,
+			"íŠíŠžíŠŸíŠ¡íŠ¢íŠ£íŠ¥",
+			6,
+			"íŠ­"
+		],
+		[
+			"ba61",
+			"íŠ®íŠ¯íŠ°íŠ²",
+			5,
+			"íŠºíŠ»íŠ½íŠ¾í‹í‹ƒ",
+			4,
+			"í‹Ší‹Œ",
+			5
+		],
+		[
+			"ba81",
+			"í‹’í‹“í‹•í‹–í‹—í‹™í‹ší‹›í‹",
+			6,
+			"í‹¦",
+			9,
+			"í‹²í‹³í‹µí‹¶í‹·í‹¹í‹ºë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶‡ë¶ˆë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹Žë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤"
+		],
+		[
+			"bb41",
+			"í‹»",
+			4,
+			"íŒ‚íŒ„íŒ†",
+			5,
+			"íŒíŒ‘íŒ’íŒ“íŒ•íŒ—",
+			4,
+			"íŒžíŒ¢íŒ£"
+		],
+		[
+			"bb61",
+			"íŒ¤íŒ¦íŒ§íŒªíŒ«íŒ­íŒ®íŒ¯íŒ±",
+			6,
+			"íŒºíŒ¾",
+			5,
+			"í†í‡íˆí‰"
+		],
+		[
+			"bb81",
+			"íŠ",
+			31,
+			"ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤"
+		],
+		[
+			"bc41",
+			"íª",
+			17,
+			"í¾í¿íŽíŽ‚íŽƒíŽ…íŽ†íŽ‡"
+		],
+		[
+			"bc61",
+			"íŽˆíŽ‰íŽŠíŽ‹íŽŽíŽ’",
+			5,
+			"íŽšíŽ›íŽíŽžíŽŸíŽ¡",
+			6,
+			"íŽªíŽ¬íŽ®"
+		],
+		[
+			"bc81",
+			"íŽ¯",
+			4,
+			"íŽµíŽ¶íŽ·íŽ¹íŽºíŽ»íŽ½",
+			6,
+			"í†í‡íŠ",
+			5,
+			"í‘",
+			5,
+			"ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œ",
+			4,
+			"ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†Žì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­"
+		],
+		[
+			"bd41",
+			"í—í™",
+			7,
+			"í¢í¤",
+			7,
+			"í®í¯í±í²í³íµí¶í·"
+		],
+		[
+			"bd61",
+			"í¸í¹íºí»í¾í€í‚",
+			5,
+			"í‰",
+			13
+		],
+		[
+			"bd81",
+			"í—",
+			5,
+			"íž",
+			25,
+			"ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‹¼ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ìŽ„ìŽˆìŽŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°"
+		],
+		[
+			"be41",
+			"í¸",
+			7,
+			"í‘í‘‚í‘ƒí‘…",
+			14
+		],
+		[
+			"be61",
+			"í‘”",
+			7,
+			"í‘í‘ží‘Ÿí‘¡í‘¢í‘£í‘¥",
+			7,
+			"í‘®í‘°í‘±í‘²"
+		],
+		[
+			"be81",
+			"í‘³",
+			4,
+			"í‘ºí‘»í‘½í‘¾í’í’ƒ",
+			4,
+			"í’Ší’Œí’Ž",
+			5,
+			"í’•",
+			8,
+			"ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•Žì•“ì•”ì••ì•—ì•˜ì•™ì•ì•žì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„",
+			6,
+			"ì—Œì—Ž"
+		],
+		[
+			"bf41",
+			"í’ž",
+			10,
+			"í’ª",
+			14
+		],
+		[
+			"bf61",
+			"í’¹",
+			18,
+			"í“í“Ží“í“‘í“’í““í“•"
+		],
+		[
+			"bf81",
+			"í“–",
+			5,
+			"í“í“ží“ ",
+			7,
+			"í“©í“ªí“«í“­í“®í“¯í“±",
+			6,
+			"í“¹í“ºí“¼ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼",
+			5,
+			"ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜®ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨"
+		],
+		[
+			"c041",
+			"í“¾",
+			5,
+			"í”…í”†í”‡í”‰í”Ší”‹í”",
+			6,
+			"í”–í”˜",
+			5
+		],
+		[
+			"c061",
+			"í”ž",
+			25
+		],
+		[
+			"c081",
+			"í”¸í”¹í”ºí”»í”¾í”¿í•í•‚í•ƒí•…",
+			6,
+			"í•Ží•í•’",
+			5,
+			"í•ší•›í•í•ží•Ÿí•¡í•¢í•£ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘",
+			7,
+			"ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìžƒìž„ìž…ìž‡ìžˆìž‰ìžŠìžŽìžìž‘ìž”ìž–ìž—ìž˜ìžšìž ìž¡ìž£ìž¤ìž¥ìž¦ìž¬ìž­ìž°ìž´ìž¼ìž½ìž¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸŽìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Š"
+		],
+		[
+			"c141",
+			"í•¤í•¦í•§í•ªí•¬í•®",
+			5,
+			"í•¶í•·í•¹í•ºí•»í•½",
+			6,
+			"í–†í–Ší–‹"
+		],
+		[
+			"c161",
+			"í–Œí–í–Ží–í–‘",
+			19,
+			"í–¦í–§"
+		],
+		[
+			"c181",
+			"í–¨",
+			31,
+			"ì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“"
+		],
+		[
+			"c241",
+			"í—Ší—‹í—í—Ží—í—‘í—“",
+			4,
+			"í—ší—œí—ž",
+			5,
+			"í—¦í—§í—©í—ªí—«í—­í—®"
+		],
+		[
+			"c261",
+			"í—¯",
+			4,
+			"í—¶í—¸í—º",
+			5,
+			"í˜‚í˜ƒí˜…í˜†í˜‡í˜‰",
+			6,
+			"í˜’"
+		],
+		[
+			"c281",
+			"í˜–",
+			5,
+			"í˜í˜ží˜Ÿí˜¡í˜¢í˜£í˜¥",
+			7,
+			"í˜®",
+			9,
+			"í˜ºí˜»ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»"
+		],
+		[
+			"c341",
+			"í˜½í˜¾í˜¿í™í™‚í™ƒí™„í™†í™‡í™Ší™Œí™Ží™í™í™’í™“í™–í™—í™™í™ší™›í™",
+			4
+		],
+		[
+			"c361",
+			"í™¢",
+			4,
+			"í™¨í™ª",
+			5,
+			"í™²í™³í™µ",
+			11
+		],
+		[
+			"c381",
+			"íšíš‚íš„íš†",
+			5,
+			"íšŽíšíš‘íš’íš“íš•",
+			7,
+			"íšžíš íš¢",
+			5,
+			"íš©íšªì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ"
+		],
+		[
+			"c441",
+			"íš«íš­íš®íš¯íš±",
+			7,
+			"íšºíš¼",
+			7,
+			"í›†í›‡í›‰í›Ší›‹"
+		],
+		[
+			"c461",
+			"í›í›Ží›í›í›’í›“í›•í›–í›˜í›š",
+			5,
+			"í›¡í›¢í›£í›¥í›¦í›§í›©",
+			4
+		],
+		[
+			"c481",
+			"í›®í›¯í›±í›²í›³í›´í›¶",
+			5,
+			"í›¾í›¿íœíœ‚íœƒíœ…",
+			11,
+			"íœ’íœ“íœ”ì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼"
+		],
+		[
+			"c541",
+			"íœ•íœ–íœ—íœšíœ›íœíœžíœŸíœ¡",
+			6,
+			"íœªíœ¬íœ®",
+			5,
+			"íœ¶íœ·íœ¹"
+		],
+		[
+			"c561",
+			"íœºíœ»íœ½",
+			6,
+			"í…í†íˆíŠ",
+			5,
+			"í’í“í•íš",
+			4
+		],
+		[
+			"c581",
+			"íŸí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ",
+			6,
+			"í¾í¿íž€íž‚",
+			5,
+			"ížŠíž‹í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œ"
+		],
+		[
+			"c641",
+			"ížížŽížíž‘",
+			6,
+			"ížšížœížž",
+			5
+		],
+		["c6a1", "í‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒŽíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½íŽ€íŽ„íŽŒíŽíŽíŽíŽ‘íŽ˜íŽ™íŽœíŽ íŽ¨íŽ©íŽ«íŽ­íŽ´íŽ¸íŽ¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿í"],
+		["c7a1", "íˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ "],
+		["c8a1", "í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ížížˆíž‰ížŒížíž˜íž™íž›íž"],
+		["caa1", "ä¼½ä½³å‡åƒ¹åŠ å¯å‘µå“¥å˜‰å«å®¶æš‡æž¶æž·æŸ¯æ­Œç‚ç—‚ç¨¼è‹›èŒ„è¡—è¢ˆè¨¶è³ˆè·è»»è¿¦é§•åˆ»å´å„æªæ…¤æ®¼çè„šè¦ºè§’é–£ä¾ƒåˆŠå¢¾å¥¸å§¦å¹²å¹¹æ‡‡æ€æ†æŸ¬æ¡¿æ¾—ç™Žçœ‹ç£µç¨ˆç«¿ç°¡è‚è‰®è‰±è««é–“ä¹«å–æ›·æ¸´ç¢£ç«­è‘›è¤èŽéž¨å‹˜åŽå ªåµŒæ„Ÿæ†¾æˆ¡æ•¢æŸ‘æ©„æ¸›ç”˜ç–³ç›£çž°ç´ºé‚¯é‘‘é‘’é¾•"],
+		["cba1", "åŒ£å²¬ç”²èƒ›é‰€é–˜å‰›å ˆå§œå²¡å´—åº·å¼ºå½Šæ…·æ±Ÿç•ºç–†ç³ çµ³ç¶±ç¾Œè…”èˆ¡è–‘è¥è¬›é‹¼é™é±‡ä»‹ä»·å€‹å‡±å¡æ„·æ„¾æ…¨æ”¹æ§ªæ¼‘ç–¥çš†ç›–ç®‡èŠ¥è“‹ï¤€éŽ§é–‹å–€å®¢å‘ï¤ç²³ç¾¹é†µå€¨åŽ»å±…å·¨æ‹’æ®æ“šæ“§æ¸ ç‚¬ç¥›è·è¸žï¤‚é½é‰…é‹¸ä¹¾ä»¶å¥å·¾å»ºæ„†æ¥—è…±è™”è¹‡éµé¨«ä¹žå‚‘æ°æ¡€å„‰åŠåŠ’æª¢"],
+		["cca1", "çž¼éˆé»”åŠ«æ€¯è¿²åˆæ†©æ­æ“Šæ ¼æª„æ¿€è†ˆè¦¡éš”å …ç‰½çŠ¬ç”„çµ¹ç¹­è‚©è¦‹è­´é£éµ‘æŠ‰æ±ºæ½”çµç¼ºè¨£å…¼æ…Šç®è¬™é‰—éŽŒäº¬ä¿“å€žå‚¾å„†å‹å‹å¿å°å¢ƒåºšå¾‘æ…¶æ†¬æ“Žæ•¬æ™¯æš»æ›´æ¢—æ¶‡ç‚…çƒ±ç’Ÿç’¥ç“Šç—™ç¡¬ç£¬ç«Ÿç«¶çµ…ç¶“è€•è€¿è„›èŽ–è­¦è¼•é€•é¡é ƒé ¸é©šé¯¨ä¿‚å•“å ºå¥‘å­£å±†æ‚¸æˆ’æ¡‚æ¢°"],
+		["cda1", "æ£¨æºªç•Œç™¸ç£Žç¨½ç³»ç¹«ç¹¼è¨ˆèª¡è°¿éšŽé·„å¤å©å‘Šå‘±å›ºå§‘å­¤å°»åº«æ‹·æ”·æ•…æ•²æš æž¯æ§æ²½ç—¼çšç¾ç¨¿ç¾”è€ƒè‚¡è†è‹¦è‹½è°è—è ±è¢´èª¥ï¤ƒè¾œéŒ®é›‡é¡§é«˜é¼“å“­æ–›æ›²æ¢ç©€è°·éµ å›°å¤å´‘æ˜†æ¢±æ£æ»¾ç¨è¢žé¯¤æ±¨ï¤„éª¨ä¾›å…¬å…±åŠŸå­”å·¥ææ­æ‹±æŽ§æ”»ç™ç©ºèš£è²¢éžä¸²å¯¡æˆˆæžœç“œ"],
+		["cea1", "ç§‘è“èª‡èª²è·¨éŽé‹é¡†å»“æ§¨è—¿éƒ­ï¤…å† å®˜å¯¬æ…£æ£ºæ¬¾çŒç¯ç“˜ç®¡ç½è…è§€è²«é—œé¤¨åˆ®ææ‹¬é€‚ä¾Šå…‰åŒ¡å£™å»£æ› æ´¸ç‚šç‹‚ç–ç­èƒ±é‘›å¦æŽ›ç½«ä¹–å‚€å¡Šå£žæ€ªæ„§æ‹æ§é­å®ç´˜è‚±è½Ÿäº¤åƒ‘å’¬å–¬å¬Œå¶ å·§æ”ªæ•Žæ ¡æ©‹ç‹¡çšŽçŸ¯çµžç¿¹è† è•Žè›Ÿè¼ƒè½ŽéƒŠé¤ƒé©•é®«ä¸˜ä¹…ä¹ä»‡ä¿±å…·å‹¾"],
+		["cfa1", "å€å£å¥å’Žå˜”åµåž¢å¯‡å¶‡å»æ‡¼æ‹˜æ•‘æž¸æŸ©æ§‹æ­æ¯†æ¯¬æ±‚æºç¸ç‹—çŽ–çƒçž¿çŸ©ç©¶çµ¿è€‰è‡¼èˆ…èˆŠè‹Ÿè¡¢è¬³è³¼è»€é€‘é‚±é‰¤éŠ¶é§’é©…é³©é·—é¾œåœ‹å±€èŠéž éž«éº´å›çª˜ç¾¤è£™è»éƒ¡å €å±ˆæŽ˜çªŸå®®å¼“ç©¹çª®èŠŽèº¬å€¦åˆ¸å‹¸å·åœˆæ‹³æ²æ¬Šæ·ƒçœ·åŽ¥ç—è•¨è¹¶é—•æœºæ«ƒæ½°è©­è»Œé¥‹ï¤†æ™·æ­¸è²´"],
+		["d0a1", "é¬¼ï¤‡å«åœ­å¥Žæ†æ§»çªç¡…çªºç«…ç³¾è‘µè¦èµ³é€µé–¨å‹»å‡ç•‡ç­ èŒéˆžï¤ˆæ©˜å…‹å‰‹åŠ‡æˆŸæ£˜æ¥µéš™åƒ…åŠ¤å‹¤æ‡ƒæ–¤æ ¹æ§¿ç‘¾ç­‹èŠ¹è«è¦²è¬¹è¿‘é¥‰ï¤‰ä»Šå¦—æ“’æ˜‘æªŽç´ç¦ç¦½èŠ©è¡¾è¡¿è¥Ÿï¤ŠéŒ¦ä¼‹åŠæ€¥æ‰±æ±²ç´šçµ¦äº˜å…¢çŸœè‚¯ä¼ä¼Žå…¶å†€å—œå™¨åœ»åŸºåŸ¼å¤”å¥‡å¦“å¯„å²å´Žå·±å¹¾å¿ŒæŠ€æ——æ—£"],
+		[
+			"d1a1",
+			"æœžæœŸæžæ£‹æ£„æ©Ÿæ¬ºæ°£æ±½æ²‚æ·‡çŽ˜ç¦çªç’‚ç’£ç•¸ç•¿ç¢ç£¯ç¥ç¥‡ç¥ˆç¥ºç®•ç´€ç¶ºç¾ˆè€†è€­è‚Œè¨˜è­è±ˆèµ·éŒ¡éŒ¤é£¢é¥‘é¨Žé¨é©¥éº’ç·Šä½¶å‰æ‹®æ¡”é‡‘å–«å„ºï¤‹ï¤Œå¨œæ‡¦ï¤æ‹æ‹¿ï¤Ž",
+			5,
+			"é‚£ï¤”",
+			4,
+			"è«¾ï¤™ï¤šï¤›ï¤œæš–ï¤ç…–ï¤žï¤Ÿé›£ï¤ ææºå—ï¤¡æžæ¥ æ¹³ï¤¢ç”·ï¤£ï¤¤ï¤¥"
+		],
+		[
+			"d2a1",
+			"ç´ï¤¦ï¤§è¡²å›Šå¨˜ï¤¨",
+			4,
+			"ä¹ƒï¤­å…§å¥ˆæŸ°è€ï¤®å¥³å¹´æ’šç§Šå¿µæ¬æ‹ˆæ»å¯§å¯—åŠªï¤¯å¥´å¼©æ€’ï¤°ï¤±ï¤²ç‘™ï¤³",
+			5,
+			"é§‘ï¤¹",
+			10,
+			"æ¿ƒï¥„ï¥…è†¿è¾²æƒ±ï¥†ï¥‡è…¦ï¥ˆï¥‰å°¿ï¥Š",
+			7,
+			"å«©è¨¥æ»ç´ï¥’",
+			5,
+			"èƒ½ï¥˜ï¥™å°¼æ³¥åŒ¿æººå¤šèŒ¶"
+		],
+		["d3a1", "ä¸¹äº¶ä½†å–®åœ˜å£‡å½–æ–·æ—¦æª€æ®µæ¹çŸ­ç«¯ç°žç·žè›‹è¢’é„²é›æ’»æ¾¾çºç–¸é”å•–åæ†ºæ“”æ›‡æ·¡æ¹›æ½­æ¾¹ç—°èƒè†½è•è¦ƒè«‡è­šéŒŸæ²“ç•“ç­”è¸éå”å ‚å¡˜å¹¢æˆ‡æ’žæ£ ç•¶ç³–èž³é»¨ä»£åžˆå®å¤§å°å²±å¸¶å¾…æˆ´æ“¡çŽ³è‡ºè¢‹è²¸éšŠé»›å®…å¾·æ‚³å€’åˆ€åˆ°åœ–å µå¡—å°Žå± å³¶å¶‹åº¦å¾’æ‚¼æŒ‘æŽ‰æ—æ¡ƒ"],
+		["d4a1", "æ£¹æ«‚æ·˜æ¸¡æ»”æ¿¤ç‡¾ç›œç¹ç¦±ç¨»è„è¦©è³­è·³è¹ˆé€ƒé€”é“éƒ½éé™¶éŸœæ¯’ç€†ç‰˜çŠ¢ç¨ç£ç¦¿ç¯¤çº›è®€å¢©æƒ‡æ•¦æ—½æš¾æ²Œç„žç‡‰è±šé “ä¹­çªä»å†¬å‡å‹•åŒæ†§æ±æ¡æ£Ÿæ´žæ½¼ç–¼çž³ç«¥èƒ´è‘£éŠ…å…œæ–—æœæž“ç—˜ç«‡è³ï¥šè±†é€—é ­å±¯è‡€èŠšéé¯éˆå¾—å¶æ©™ç‡ˆç™»ç­‰è—¤è¬„é„§é¨°å–‡æ‡¶ï¥›ç™©ç¾…"],
+		["d5a1", "è˜¿èžºè£¸é‚ï¥œæ´›çƒ™çžçµ¡è½ï¥é…ªé§±ï¥žäº‚åµæ¬„æ¬’ç€¾çˆ›è˜­é¸žå‰Œè¾£åµæ“¥æ”¬æ¬–æ¿«ç±ƒçºœè—è¥¤è¦½æ‹‰è‡˜è Ÿå»Šæœ—æµªç‹¼ç…ç‘¯èž‚éƒžä¾†å´å¾ èŠå†·æŽ ç•¥äº®å€†å…©å‡‰æ¢æ¨‘ç²®ç²±ç³§è‰¯è«’è¼›é‡ä¾¶å„·å‹µå‘‚å»¬æ…®æˆ¾æ—…æ«šæ¿¾ç¤ªè—œè £é–­é©¢é©ªéº—é»ŽåŠ›æ›†æ­·ç€ç¤«è½¢é‚æ†æˆ€æ”£æ¼£"],
+		["d6a1", "ç…‰ç’‰ç·´è¯è“®è¼¦é€£éŠå†½åˆ—åŠ£æ´Œçƒˆè£‚å»‰æ–‚æ®®æ¿‚ç°¾çµä»¤ä¼¶å›¹ï¥Ÿå²ºå¶ºæ€œçŽ²ç¬­ç¾šç¿Žè†é€žéˆ´é›¶éˆé ˜é½¡ä¾‹æ¾§ç¦®é†´éš·å‹žï¥ æ’ˆæ“„æ«“æ½žç€˜çˆç›§è€è˜†è™œè·¯è¼…éœ²é­¯é·ºé¹µç¢Œç¥¿ç¶ è‰éŒ„é¹¿éº“è«–å£Ÿå¼„æœ§ç€§ç“ç± è¾å„¡ç€¨ç‰¢ç£Šè³‚è³šè³´é›·äº†åƒšå¯®å»–æ–™ç‡Žç™‚çž­èŠè“¼"],
+		["d7a1", "é¼é¬§é¾å£˜å©å±¢æ¨“æ·šæ¼ç˜»ç´¯ç¸·è”žè¤¸é¤é™‹åŠ‰æ—’æŸ³æ¦´æµæºœç€ç‰ç‘ ç•™ç˜¤ç¡«è¬¬é¡žå…­æˆ®é™¸ä¾–å€«å´™æ·ªç¶¸è¼ªå¾‹æ…„æ —ï¥¡éš†å‹’è‚‹å‡œå‡Œæ¥žç¨œç¶¾è±é™µä¿šåˆ©åŽ˜åå”Žå±¥æ‚§æŽæ¢¨æµ¬çŠç‹¸ç†ç’ƒï¥¢ç—¢ç±¬ç½¹ç¾¸èŽ‰è£è£¡é‡Œé‡é›¢é¯‰åæ½¾ç‡ç’˜è—ºèºªéš£é±—éºŸæž—æ·‹ç³è‡¨éœ–ç ¬"],
+		["d8a1", "ç«‹ç¬ ç²’æ‘©ç‘ªç—²ç¢¼ç£¨é¦¬é­”éº»å¯žå¹•æ¼ è†œèŽ«é‚ˆä¸‡åå¨©å·’å½Žæ…¢æŒ½æ™©æ›¼æ»¿æ¼«ç£çžžè¬è”“è »è¼“é¥…é°»å”œæŠ¹æœ«æ²«èŒ‰è¥ªéºäº¡å¦„å¿˜å¿™æœ›ç¶²ç½”èŠ’èŒ«èŽ½è¼žé‚™åŸ‹å¦¹åª’å¯æ˜§æžšæ¢…æ¯ç…¤ç½µè²·è³£é‚é­…è„ˆè²Šé™Œé©€éº¥å­Ÿæ°“çŒ›ç›²ç›ŸèŒå†ªè¦“å…å†•å‹‰æ£‰æ²”çœ„çœ ç¶¿ç·¬é¢éºµæ»…"],
+		["d9a1", "è”‘å†¥åå‘½æ˜Žæšæ¤§æºŸçš¿çž‘èŒ—è“‚èžŸé…©éŠ˜é³´è¢‚ä¾®å†’å‹Ÿå§†å¸½æ…•æ‘¸æ‘¹æš®æŸæ¨¡æ¯æ¯›ç‰Ÿç‰¡ç‘çœ¸çŸ›è€—èŠ¼èŒ…è¬€è¬¨è²Œæœ¨æ²ç‰§ç›®ç¦ç©†é¶©æ­¿æ²’å¤¢æœ¦è’™å¯å¢“å¦™å»Ÿææ˜´æ³æ¸ºçŒ«ç«—è‹—éŒ¨å‹™å·«æ†®æ‡‹æˆŠæ‹‡æ’«æ— æ¥™æ­¦æ¯‹ç„¡ç·ç•ç¹†èˆžèŒ‚è•ªèª£è²¿éœ§éµ¡å¢¨é»˜å€‘åˆŽå»å•æ–‡"],
+		["daa1", "æ±¶ç´Šç´‹èžèšŠé–€é›¯å‹¿æ²•ç‰©å‘³åªšå°¾åµ‹å½Œå¾®æœªæ¢¶æ¥£æ¸¼æ¹„çœ‰ç±³ç¾Žè–‡è¬Žè¿·é¡é»´å²·æ‚¶æ„æ†«æ•æ—»æ—¼æ°‘æ³¯çŽŸç‰ç·¡é–”å¯†èœœè¬å‰åšæ‹ææ’²æœ´æ¨¸æ³Šç€ç’žç®”ç²•ç¸›è†Šèˆ¶è–„è¿«é›¹é§ä¼´åŠåå›æ‹Œæ¬æ”€æ–‘æ§ƒæ³®æ½˜ç­ç•”ç˜¢ç›¤ç›¼ç£ç£»ç¤¬çµ†èˆ¬èŸ è¿”é ’é£¯å‹ƒæ‹”æ’¥æ¸¤æ½‘"],
+		["dba1", "ç™¼è·‹é†±é‰¢é«®é­ƒå€£å‚åŠå¦¨å°¨å¹‡å½·æˆ¿æ”¾æ–¹æ—æ˜‰æž‹æ¦œæ»‚ç£…ç´¡è‚ªè†€èˆ«èŠ³è’¡èšŒè¨ªè¬—é‚¦é˜²é¾å€ä¿³ï¥£åŸ¹å¾˜æ‹œæŽ’æ¯æ¹ƒç„™ç›ƒèƒŒèƒšè£´è£µè¤™è³ è¼©é…é™ªä¼¯ä½°å¸›æŸæ ¢ç™½ç™¾é­„å¹¡æ¨Šç…©ç‡”ç•ªï¥¤ç¹è•ƒè—©é£œä¼ç­ç½°é–¥å‡¡å¸†æ¢µæ°¾æ±Žæ³›çŠ¯ç¯„èŒƒæ³•çºåƒ»åŠˆå£æ“˜æª—ç’§ç™–"],
+		["dca1", "ç¢§è˜—é—¢éœ¹ï¥¥åžå¼è®Šè¾¨è¾¯é‚Šåˆ¥çž¥é±‰é¼ˆä¸™å€‚å…µå±›å¹·æ˜žæ˜ºæŸ„æ£…ç‚³ç”ç—…ç§‰ç«è¼§é¤ é¨ˆä¿å ¡å ±å¯¶æ™®æ­¥æ´‘æ¹ºæ½½ç¤ç”«è©è£œè¤“è­œè¼”ä¼åƒ•åŒåœå®“å¾©æœç¦è…¹èŒ¯è””è¤‡è¦†è¼¹è¼»é¦¥é°’æœ¬ä¹¶ä¿¸å¥‰å°å³¯å³°æ§æ£’çƒ½ç†¢ç«ç¸«è“¬èœ‚é€¢é‹’é³³ä¸ä»˜ä¿¯å‚…å‰–å‰¯å¦å’åŸ å¤«å©¦"],
+		["dda1", "å­šå­µå¯Œåºœï¥¦æ‰¶æ•·æ–§æµ®æº¥çˆ¶ç¬¦ç°¿ç¼¶è…è…‘è†šè‰€èŠ™èŽ©è¨ƒè² è³¦è³»èµ´è¶ºéƒ¨é‡œé˜œé™„é§™é³§åŒ—åˆ†å©å™´å¢³å¥”å¥®å¿¿æ†¤æ‰®æ˜æ±¾ç„šç›†ç²‰ç³žç´›èŠ¬è³é›°ï¥§ä½›å¼—å½¿æ‹‚å´©æœ‹æ£šç¡¼ç¹ƒéµ¬ä¸•å‚™åŒ•åŒªå‘å¦ƒå©¢åº‡æ‚²æ†Šæ‰‰æ‰¹æ–æž‡æ¦§æ¯”æ¯–æ¯—æ¯˜æ²¸ï¥¨çµç—ºç ’ç¢‘ç§•ç§˜ç²ƒç·‹ç¿¡è‚¥"],
+		["dea1", "è„¾è‡‚è²èœšè£¨èª¹è­¬è²»é„™éžé£›é¼»åš¬å¬ªå½¬æ–Œæª³æ®¯æµœæ¿±ç€•ç‰çŽ­è²§è³“é »æ†‘æ°·è˜é¨ä¹äº‹äº›ä»•ä¼ºä¼¼ä½¿ä¿Ÿåƒ¿å²å¸å”†å—£å››å£«å¥¢å¨‘å¯«å¯ºå°„å·³å¸«å¾™æ€æ¨æ–œæ–¯æŸ¶æŸ»æ¢­æ­»æ²™æ³—æ¸£ç€‰ç…ç ‚ç¤¾ç¥€ç¥ ç§ç¯©ç´—çµ²è‚†èˆèŽŽè“‘è›‡è£Ÿè©è©žè¬è³œèµ¦è¾­é‚ªé£¼é§Ÿéºå‰Šï¥©æœ”ï¥ª"],
+		["dfa1", "å‚˜åˆªå±±æ•£æ±•çŠç”£ç–ç®—è’œé…¸éœ°ä¹·æ’’æ®ºç…žè–©ä¸‰ï¥«æ‰æ£®æ¸—èŠŸè”˜è¡«æ·æ¾éˆ’é¢¯ä¸Šå‚·åƒå„Ÿå•†å–ªå˜—å­€å°™å³ å¸¸åºŠåº å»‚æƒ³æ¡‘æ©¡æ¹˜çˆ½ç‰€ç‹€ç›¸ç¥¥ç®±ç¿”è£³è§´è©³è±¡è³žéœœå¡žç’½è³½å—‡ï¥¬ç©¡ç´¢è‰²ç‰²ç”Ÿç”¥ï¥­ç¬™å¢…å£»å¶¼åºåº¶å¾æ•æŠ’æ¿æ•æš‘æ›™æ›¸æ –æ£²çŠ€ç‘žç­®çµ®ç·–ç½²"],
+		["e0a1", "èƒ¥èˆ’è–¯è¥¿èª“é€é‹¤é»é¼ å¤•å¥­å¸­æƒœæ˜”æ™³æžæ±æ·…æ½ŸçŸ³ç¢©è“†é‡‹éŒ«ä»™åƒŠå…ˆå–„å¬‹å®£æ‰‡æ•¾æ—‹æ¸²ç…½çç‘„ç’‡ç’¿ç™¬ç¦ªç·šç¹•ç¾¨è…ºè†³èˆ¹è˜šèŸ¬è©µè·£é¸éŠ‘é¥é¥é®®å¨å±‘æ¥”æ³„æ´©æ¸«èˆŒè–›è¤»è¨­èªªé›ªé½§å‰¡æš¹æ®²çº–èŸ¾è´é–ƒé™æ”æ¶‰ç‡®ï¥®åŸŽå§“å®¬æ€§æƒºæˆæ˜Ÿæ™ŸçŒ©ç¹ç››çœç­¬"],
+		["e1a1", "è–è²è…¥èª é†’ä¸–å‹¢æ­²æ´—ç¨…ç¬¹ç´°ï¥¯è²°å¬å˜¯å¡‘å®µå°å°‘å·¢æ‰€æŽƒæ”æ˜­æ¢³æ²¼æ¶ˆæº¯ç€Ÿç‚¤ç‡’ç”¦ç–ç–Žç˜™ç¬‘ç¯ ç°«ç´ ç´¹è”¬è•­è˜‡è¨´é€é¡é‚µéŠ·éŸ¶é¨·ä¿—å±¬æŸæ¶‘ç²ŸçºŒè¬–è´–é€Ÿå­«å·½æè“€éœé£¡çŽ‡å®‹æ‚šæ¾æ·žè¨Ÿèª¦é€é Œåˆ·ï¥°ç‘ç¢ŽéŽ–è¡°é‡—ä¿®å—å—½å›šåž‚å£½å«‚å®ˆå²«å³€å¸¥æ„"],
+		["e2a1", "æˆæ‰‹æŽˆæœæ”¶æ•¸æ¨¹æ®Šæ°´æ´™æ¼±ç‡§ç‹©ç¸ç‡ç’²ç˜¦ç¡ç§€ç©—ç«ªç²¹ç¶ç¶¬ç¹¡ç¾žè„©èŒ±è’è“šè—ªè¢–èª°è®è¼¸é‚é‚ƒé…¬éŠ–éŠ¹éš‹éš§éš¨é›–éœ€é ˆé¦–é«“é¬šå”å¡¾å¤™å­°å®¿æ·‘æ½šç†Ÿç¡ç’¹è‚…è½å·¡å¾‡å¾ªæ‚æ—¬æ ’æ¥¯æ©“æ®‰æ´µæ·³ç£ç›¾çž¬ç­ç´”è„£èˆœè€è“´è•£è©¢è«„é†‡éŒžé †é¦´æˆŒè¡“è¿°é‰¥å´‡å´§"],
+		["e3a1", "åµ©ç‘Ÿè†è¨æ¿•æ‹¾ç¿’è¤¶è¥²ä¸žä¹˜åƒ§å‹å‡æ‰¿æ˜‡ç¹©è …é™žä¾åŒ™å˜¶å§‹åª¤å°¸å±Žå±å¸‚å¼‘æƒæ–½æ˜¯æ™‚æž¾æŸ´çŒœçŸ¢ç¤ºç¿…è’”è“è¦–è©¦è©©è«¡è±•è±ºåŸ´å¯”å¼æ¯æ‹­æ¤æ®–æ¹œç†„ç¯’è•è­˜è»¾é£Ÿé£¾ä¼¸ä¾ä¿¡å‘»å¨ å®¸æ„¼æ–°æ™¨ç‡¼ç”³ç¥žç´³è…Žè‡£èŽ˜è–ªè—Žèœƒè¨Šèº«è¾›ï¥±è¿…å¤±å®¤å¯¦æ‚‰å¯©å°‹å¿ƒæ²"],
+		["e4a1", "ï¥²æ·±ç€‹ç”šèŠ¯è«¶ä»€åï¥³é›™æ°äºžä¿„å…’å•žå¨¥å³¨æˆ‘ç‰™èŠ½èŽªè›¾è¡™è¨é˜¿é›…é¤“é´‰éµå Šå²³å¶½å¹„æƒ¡æ„•æ¡æ¨‚æ¸¥é„‚é”é¡Žé°é½·å®‰å²¸æŒ‰æ™æ¡ˆçœ¼é›éžé¡”é®Ÿæ–¡è¬è»‹é–¼å”µå²©å·–åºµæš—ç™Œè´é—‡å£“æŠ¼ç‹Žé´¨ä»°å¤®æ€æ˜»æ®ƒç§§é´¦åŽ“å“€åŸƒå´–æ„›æ›–æ¶¯ç¢è‰¾éš˜é„åŽ„æ‰¼æŽ–æ¶²ç¸Šè…‹é¡"],
+		["e5a1", "æ«»ç½Œé¶¯é¸šä¹Ÿå€»å†¶å¤œæƒ¹æ¶æ¤°çˆºè€¶ï¥´é‡Žå¼±ï¥µï¥¶ç´„è‹¥è‘¯è’»è—¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ƒæ™æšæ”˜æ•­æš˜ï¥ºæ¥Šæ¨£æ´‹ç€ç…¬ç—’ç˜ç¦³ç©°ï¥»ç¾Šï¥¼è¥„ï¥½è®“é‡€é™½ï¥¾é¤Šåœ„å¾¡æ–¼æ¼ç˜€ç¦¦èªžé¦­é­šé½¬å„„æ†¶æŠ‘æªè‡†åƒå °å½¦ç„‰è¨€è«ºå­¼è˜–ä¿ºå„¼åš´å¥„æŽ©æ·¹å¶ªæ¥­å††äºˆä½™ï¥¿ï¦€ï¦å¦‚ï¦‚"],
+		["e6a1", "ï¦ƒæ­Ÿæ±ï¦„ç’µç¤–ï¦…èˆ‡è‰…èŒ¹è¼¿è½ï¦†é¤˜ï¦‡ï¦ˆï¦‰äº¦ï¦ŠåŸŸå½¹æ˜“ï¦‹ï¦Œç–«ç¹¹è­¯ï¦é€†é©›åš¥å §å§¸å¨Ÿå®´ï¦Žå»¶ï¦ï¦ææŒ»ï¦‘æ¤½æ²‡æ²¿æ¶Žæ¶“æ·µæ¼”ï¦’çƒŸç„¶ç…™ï¦“ç‡ƒç‡•ï¦”ç¡ç¡¯ï¦•ç­µç·£ï¦–ç¸¯ï¦—è¡è»Ÿï¦˜ï¦™ï¦šé‰›ï¦›é³¶ï¦œï¦ï¦žæ‚…æ¶…ï¦Ÿç†±ï¦ ï¦¡é–±åŽ­ï¦¢ï¦£ï¦¤æŸ“ï¦¥ç‚Žç„°ç°è‰¶è‹’"],
+		["e7a1", "ï¦¦é–»é«¥é¹½æ›„ï¦§ç‡è‘‰ï¦¨ï¦©å¡‹ï¦ªï¦«å¶¸å½±ï¦¬æ˜ æšŽæ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿šç€›ç€¯ç…ç‡Ÿç°ï¦­ç‘›ï¦®ç“”ç›ˆç©Žçº“ï¦¯ï¦°è‹±è© è¿Žï¦±éˆï¦²éœ™ï¦³ï¦´ä¹‚å€ªï¦µåˆˆå¡æ›³æ±­æ¿ŠçŒŠç¿ç©¢èŠ®è—è˜‚ï¦¶è£”è©£è­½è±«ï¦·éŠ³ï¦¸éœ“é äº”ä¼ä¿‰å‚²åˆå¾å³å—šå¡¢å¢ºå¥§å¨›å¯¤æ‚Ÿï¦¹æ‡Šæ•–æ—¿æ™¤æ¢§æ±šæ¾³"],
+		["e8a1", "çƒç†¬ç’ç­½èœˆèª¤é°²é¼‡å±‹æ²ƒç„çŽ‰éˆºæº«ç‘¥ç˜Ÿç©©ç¸•è˜Šå…€å£…æ“ç“®ç”•ç™°ç¿é‚•é›é¥”æ¸¦ç“¦çª©çªªè‡¥è›™è¸è¨›å©‰å®Œå®›æ¢¡æ¤€æµ£çŽ©ç“ç¬ç¢—ç·©ç¿«è„˜è…•èŽžè±Œé˜®é ‘æ›°å¾€æ—ºæž‰æ±ªçŽ‹å€­å¨ƒæ­ªçŸ®å¤–åµ¬å·çŒ¥ç•ï¦ºï¦»åƒ¥å‡¹å ¯å¤­å¦–å§šå¯¥ï¦¼ï¦½å¶¢æ‹—æ–æ’“æ“¾ï¦¾æ›œï¦¿æ©ˆï§€ç‡¿ç‘¤ï§"],
+		["e9a1", "çªˆçª¯ç¹‡ç¹žè€€è…°ï§‚èŸ¯è¦è¬ é™ï§ƒé‚€é¥’æ…¾æ¬²æµ´ç¸Ÿè¤¥è¾±ä¿‘å‚­å†—å‹‡åŸ‡å¢‰å®¹åº¸æ…‚æ¦•æ¶Œæ¹§æº¶ç†”ç‘¢ç”¨ç”¬è³èŒ¸è“‰è¸ŠéŽ”éžï§„äºŽä½‘å¶å„ªåˆå‹å³å®‡å¯“å°¤æ„šæ†‚æ—´ç‰›çŽ—ç‘€ç›‚ç¥ç¦‘ç¦¹ç´†ç¾½èŠ‹è—•è™žè¿‚é‡éƒµé‡ªéš…é›¨é›©å‹–å½§æ—­æ˜±æ ¯ç…œç¨¶éƒé Šäº‘ï§…æ©’æ®žæ¾ç†‰è€˜èŠ¸è•“"],
+		["eaa1", "é‹éš•é›²éŸ»è”šé¬±äºç†Šé›„å…ƒåŽŸå“¡åœ“åœ’åž£åª›å«„å¯ƒæ€¨æ„¿æ´æ²…æ´¹æ¹²æºçˆ°çŒ¿ç‘—è‹‘è¢è½…é ï§†é™¢é¡˜é´›æœˆè¶Šé‰žä½å‰åƒžå±åœå§”å¨å°‰æ…°æšæ¸­çˆ²ç‘‹ç·¯èƒƒèŽè‘¦è”¿èŸè¡›è¤˜è¬‚é•éŸ‹é­ä¹³ä¾‘å„’å…ªï§‡å”¯å–©å­ºå®¥å¹¼å¹½åº¾æ‚ æƒŸæ„ˆæ„‰æ„æ”¸æœ‰ï§ˆæŸ”æŸšï§‰æ¥¡æ¥¢æ²¹æ´§ï§Šæ¸¸ï§‹"],
+		["eba1", "æ¿¡çŒ¶çŒ·ï§Œç‘œç”±ï§ç™’ï§Žï§ç¶­è‡¾è¸è£•èª˜è«›è«­è¸°è¹‚éŠé€¾éºé…‰é‡‰é®ï§ï§‘å ‰ï§’æ¯“è‚‰è‚²ï§“ï§”å…å¥«å°¹ï§•ï§–æ½¤çŽ§èƒ¤è´‡ï§—éˆ—é–ï§˜ï§™ï§šï§›è¿æˆŽç€œçµ¨èžï§œåž æ©æ…‡æ®·èª¾éŠ€éš±ä¹™åŸæ·«è”­é™°éŸ³é£®æ–æ³£é‚‘å‡æ‡‰è†ºé·¹ä¾å€šå„€å®œæ„æ‡¿æ“¬æ¤…æ¯…ç–‘çŸ£ç¾©è‰¤è–èŸ»è¡£èª¼"],
+		["eca1", "è­°é†«äºŒä»¥ä¼Šï§ï§žå¤·å§¨ï§Ÿå·²å¼›å½›æ€¡ï§ ï§¡ï§¢ï§£çˆ¾ç¥ï§¤ç•°ç—ï§¥ç§»ï§¦è€Œè€³è‚„è‹¡è‘ï§§ï§¨è²½è²³é‚‡ï§©ï§ªé£´é¤Œï§«ï§¬ç€·ç›Šç¿Šç¿Œç¿¼è¬šäººä»åˆƒå°ï§­å’½å› å§»å¯…å¼•å¿æ¹®ï§®ï§¯çµªèŒµï§°èš“èªï§±é­é·ï§²ï§³ä¸€ä½šä½¾å£¹æ—¥æº¢é€¸éŽ°é¦¹ä»»å£¬å¦Šå§™æï§´ï§µç¨”ï§¶èè³ƒå…¥å„"],
+		["eda1", "ï§·ï§¸ï§¹ä»å‰©å­•èŠ¿ä»”åˆºå’¨å§‰å§¿å­å­—å­œæ£æ…ˆæ»‹ç‚™ç…®çŽ†ç“·ç–µç£ç´«è€…è‡ªèŒ¨è”—è—‰è«®è³‡é›Œä½œå‹ºåš¼æ–«æ˜¨ç¼ç‚¸çˆµç¶½èŠé…Œé›€éµ²å­±æ£§æ®˜æ½ºç›žå²‘æš«æ½›ç®´ç°ªè ¶é›œä¸ˆä»—åŒ å ´å¢»å£¯å¥¬å°‡å¸³åº„å¼µæŽŒæš²æ–æ¨Ÿæª£æ¬Œæ¼¿ç‰†ï§ºçç’‹ç« ç²§è…¸è‡Ÿè‡§èŽŠè‘¬è”£è–”è—è£è´“é†¬é•·"],
+		["eea1", "éšœå†å“‰åœ¨å®°æ‰ææ ½æ¢“æ¸½æ»“ç½ç¸¡è£è²¡è¼‰é½‹é½Žçˆ­ç®è«éŒšä½‡ä½Žå„²å’€å§åº•æŠµæµæ¥®æ¨—æ²®æ¸šç‹™çŒªç–½ç®¸ç´µè‹§è¹è‘—è—·è©›è²¯èº‡é€™é‚¸é›Žé½Ÿå‹£åŠå«¡å¯‚æ‘˜æ•µæ»´ç‹„ï§»çš„ç©ç¬›ç±ç¸¾ç¿Ÿè»è¬«è³Šèµ¤è·¡è¹Ÿè¿ªè¿¹é©é‘ä½ƒä½ºå‚³å…¨å…¸å‰å‰ªå¡¡å¡¼å¥ å°ˆå±•å»›æ‚›æˆ°æ “æ®¿æ°ˆæ¾±"],
+		["efa1", "ç…Žç ç”°ç”¸ç•‘ç™²ç­Œç®‹ç®­ç¯†çºè©®è¼¾è½‰éˆ¿éŠ“éŒ¢é«é›»é¡šé¡«é¤žåˆ‡æˆªæŠ˜æµ™ç™¤ç«Šç¯€çµ¶å å²¾åº—æ¼¸ç‚¹ç²˜éœ‘é®Žé»žæŽ¥æ‘ºè¶ä¸äº•äº­åœåµå‘ˆå§ƒå®šå¹€åº­å»·å¾æƒ…æŒºæ”¿æ•´æ—Œæ™¶æ™¸æŸ¾æ¥¨æª‰æ­£æ±€æ·€æ·¨æ¸Ÿæ¹žç€žç‚¡çŽŽç½ç”ºç›ç¢‡ç¦Žç¨‹ç©½ç²¾ç¶Žè‰‡è¨‚è«ªè²žé„­é…Šé‡˜é‰¦é‹ŒéŒ éœ†é–"],
+		["f0a1", "éœé ‚é¼Žåˆ¶åŠ‘å•¼å ¤å¸å¼Ÿæ‚Œææ¢¯æ¿Ÿç¥­ç¬¬è‡è–ºè£½è«¸è¹„é†é™¤éš›éœ½é¡Œé½Šä¿Žå…†å‡‹åŠ©å˜²å¼”å½«æŽªæ“æ—©æ™æ›ºæ›¹æœæ¢æ£—æ§½æ¼•æ½®ç…§ç‡¥çˆªç’ªçœºç¥–ç¥šç§Ÿç¨ çª•ç²—ç³Ÿçµ„ç¹°è‚‡è—»èš¤è©”èª¿è¶™èºé€ é­é‡£é˜»é›•é³¥æ—ç°‡è¶³éƒå­˜å°Šå’æ‹™çŒå€§å®—å¾žæ‚°æ…«æ£•æ·™ç®ç¨®çµ‚ç¶œç¸±è…«"],
+		["f1a1", "è¸ªè¸µé¾é˜ä½åå·¦åº§æŒ«ç½ªä¸»ä½ä¾åšå§èƒ„å‘ªå‘¨å—¾å¥å®™å·žå»šæ™æœ±æŸ±æ ªæ³¨æ´²æ¹Šæ¾ç‚·ç ç–‡ç±Œç´‚ç´¬ç¶¢èˆŸè››è¨»èª…èµ°èºŠè¼³é€±é…Žé…’é‘„é§ç«¹ç²¥ä¿Šå„å‡†åŸˆå¯¯å³»æ™™æ¨½æµšæº–æ¿¬ç„Œç•¯ç«£è ¢é€¡éµé›‹é§¿èŒä¸­ä»²è¡†é‡å½æ«›æ¥«æ±è‘ºå¢žæ†Žæ›¾æ‹¯çƒç”‘ç—‡ç¹’è’¸è­‰è´ˆä¹‹åª"],
+		["f2a1", "å’«åœ°å€å¿—æŒæŒ‡æ‘¯æ”¯æ—¨æ™ºæžæž³æ­¢æ± æ²šæ¼¬çŸ¥ç ¥ç¥‰ç¥—ç´™è‚¢è„‚è‡³èŠèŠ·èœ˜èªŒï§¼è´„è¶¾é²ç›´ç¨™ç¨·ç¹”è·å”‡å—”å¡µæŒ¯æ¢æ™‰æ™‹æ¡­æ¦›æ®„æ´¥æº±çç‘¨ç’¡ç•›ç–¹ç›¡çœžçž‹ç§¦ç¸‰ç¸è‡»è”¯è¢—è¨ºè³‘è»«è¾°é€²éŽ­é™£é™³éœ‡ä¾„å±å§ªå«‰å¸™æ¡Žç“†ç–¾ç§©çª’è†£è›­è³ªè·Œè¿­æ–Ÿæœ•ï§½åŸ·æ½—ç·è¼¯"],
+		["f3a1", "é¶é›†å¾µæ‡²æ¾„ä¸”ä¾˜å€Ÿå‰å—Ÿåµ¯å·®æ¬¡æ­¤ç£‹ç®šï§¾è¹‰è»Šé®æ‰æ¾ç€çª„éŒ¯é‘¿é½ªæ’°æ¾¯ç‡¦ç’¨ç“šç«„ç°’çº‚ç²²çº˜è®šè´Šé‘½é¤é¥Œåˆ¹å¯Ÿæ“¦æœ­ç´®åƒ­åƒå¡¹æ…˜æ…™æ‡ºæ–¬ç«™è®’è®–å€‰å€¡å‰µå”±å¨¼å» å½°æ„´æ•žæ˜Œæ˜¶æš¢æ§æ»„æ¼²çŒ–ç˜¡çª“è„¹è‰™è–è’¼å‚µåŸ°å¯€å¯¨å½©æŽ¡ç ¦ç¶µèœè”¡é‡‡é‡µå†ŠæŸµç­–"],
+		["f4a1", "è²¬å‡„å¦»æ‚½è™•å€œï§¿å‰”å°ºæ…½æˆšæ‹“æ“²æ–¥æ»Œç˜ è„Šè¹ é™Ÿéš»ä»Ÿåƒå–˜å¤©å·æ“…æ³‰æ·ºçŽ”ç©¿èˆ›è–¦è³¤è¸é·é‡§é—¡é˜¡éŸ†å‡¸å“²å–†å¾¹æ’¤æ¾ˆç¶´è¼Ÿè½éµåƒ‰å°–æ²¾æ·»ç”›çž»ç°½ç±¤è©¹è«‚å žå¦¾å¸–æ·ç‰’ç–Šç«è«œè²¼è¼’å»³æ™´æ·¸è½èè«‹é‘é¯–ï¨€å‰ƒæ›¿æ¶•æ»¯ç· è«¦é€®éžé«”åˆå‰¿å“¨æ†”æŠ„æ‹›æ¢¢"],
+		["f5a1", "æ¤’æ¥šæ¨µç‚’ç„¦ç¡ç¤ç¤Žç§’ç¨è‚–è‰¸è‹•è‰è•‰è²‚è¶…é…¢é†‹é†®ä¿ƒå›‘ç‡­çŸ—èœ€è§¸å¯¸å¿–æ‘é‚¨å¢å¡šå¯µæ‚¤æ†æ‘ ç¸½è°è”¥éŠƒæ’®å‚¬å´”æœ€å¢œæŠ½æŽ¨æ¤Žæ¥¸æ¨žæ¹«çšºç§‹èŠ»è©è«è¶¨è¿½é„’é…‹é†œéŒéŒ˜éŽšé››é¨¶é°ä¸‘ç•œç¥ç«ºç­‘ç¯‰ç¸®è“„è¹™è¹´è»¸é€æ˜¥æ¤¿ç‘ƒå‡ºæœ®é»œå……å¿ æ²–èŸ²è¡è¡·æ‚´è†µèƒ"],
+		["f6a1", "è´…å–å¹å˜´å¨¶å°±ç‚Šç¿ èšè„†è‡­è¶£é†‰é©Ÿé·²å´ä»„åŽ æƒ»æ¸¬å±¤ä¾ˆå€¤å—¤å³™å¹Ÿæ¥æ¢”æ²»æ·„ç†¾ç—”ç—´ç™¡ç¨šç©‰ç·‡ç·»ç½®è‡´èš©è¼œé›‰é¦³é½’å‰‡å‹…é£­è¦ªä¸ƒæŸ’æ¼†ä¾µå¯¢æž•æ²ˆæµ¸ç›ç §é‡é¼èŸ„ç§¤ç¨±å¿«ä»–å’¤å”¾å¢®å¦¥æƒ°æ‰“æ‹–æœ¶æ¥•èˆµé™€é¦±é§å€¬å“å•„å¼ï¨æ‰˜ï¨‚æ“¢æ™«æŸæ¿æ¿¯ç¢ç¸è¨—"],
+		["f7a1", "é¸å‘‘å˜†å¦å½ˆæ†šæ­Žç˜ç‚­ç¶»èª•å¥ªè„«æŽ¢çœˆè€½è²ªå¡”æ­æ¦»å®•å¸‘æ¹¯ï¨ƒè•©å…Œå°å¤ªæ€ æ…‹æ®†æ±°æ³°ç¬žèƒŽè‹”è·†é‚°é¢±ï¨„æ“‡æ¾¤æ’‘æ”„å…ŽååœŸè¨Žæ…Ÿæ¡¶ï¨…ç—›ç­’çµ±é€šå †æ§Œè…¿è¤ªé€€é ¹å¸å¥—å¦¬æŠ•é€é¬ªæ…ç‰¹é—–å¡å©†å·´æŠŠæ’­æ“ºæ·æ³¢æ´¾çˆ¬ç¶ç ´ç½·èŠ­è·›é —åˆ¤å‚æ¿ç‰ˆç“£è²©è¾¦éˆ‘"],
+		["f8a1", "é˜ªå…«å­æŒä½©å”„æ‚–æ•—æ²›æµ¿ç‰Œç‹½ç¨—è¦‡è²å½­æ¾Žçƒ¹è†¨æ„Žä¾¿åæ‰ç‰‡ç¯‡ç·¨ç¿©ééž­é¨™è²¶åªå¹³æž°èè©•å å¬–å¹£å»¢å¼Šæ–ƒè‚ºè”½é–‰é™›ä½ˆåŒ…åŒåŒå’†å“ºåœƒå¸ƒæ€–æŠ›æŠ±æ•ï¨†æ³¡æµ¦ç–±ç ²èƒžè„¯è‹žè‘¡è’²è¢è¤’é€‹é‹ªé£½é®‘å¹…æš´æ›ç€‘çˆ†ï¨‡ä¿µå‰½å½ªæ…“æ“æ¨™æ¼‚ç“¢ç¥¨è¡¨è±¹é£‡é£„é©ƒ"],
+		["f9a1", "å“ç¨Ÿæ¥“è«·è±Šé¢¨é¦®å½¼æŠ«ç–²çš®è¢«é¿é™‚åŒ¹å¼¼å¿…æ³ŒçŒç•¢ç–‹ç­†è‹¾é¦ä¹é€¼ä¸‹ä½•åŽ¦å¤å»ˆæ˜°æ²³ç‘•è·è¦è³€ééœžé°•å£‘å­¸è™è¬”é¶´å¯’æ¨æ‚æ—±æ±—æ¼¢æ¾£ç€šç½•ç¿°é–‘é–’é™éŸ“å‰²è½„å‡½å«å’¸å•£å–Šæª»æ¶µç·˜è‰¦éŠœé™·é¹¹åˆå“ˆç›’è›¤é–¤é—”é™œäº¢ä¼‰å§®å«¦å··æ’æŠ—æ­æ¡æ²†æ¸¯ç¼¸è‚›èˆª"],
+		["faa1", "ï¨ˆï¨‰é …äº¥å•å’³åž“å¥šå­©å®³æ‡ˆæ¥·æµ·ç€£èŸ¹è§£è©²è«§é‚‚é§­éª¸åŠ¾æ ¸å€–å¹¸æè‡è¡Œäº«å‘åš®ç¦é„•éŸ¿é¤‰é¥—é¦™å™“å¢Ÿè™›è¨±æ†²æ«¶ç»è»’æ­‡éšªé©—å¥•çˆ€èµ«é©ä¿”å³´å¼¦æ‡¸æ™›æ³«ç‚«çŽ„çŽ¹ç¾çœ©ççµƒçµ¢ç¸£èˆ·è¡’ï¨Šè³¢é‰‰é¡¯å­‘ç©´è¡€é å«Œä¿ å”å¤¾å³½æŒ¾æµ¹ç‹¹è„…è„‡èŽ¢é‹é °äº¨å…„åˆ‘åž‹"],
+		["fba1", "å½¢æ³‚æ»Žç€…çç‚¯ç†’ç©ç‘©èŠèž¢è¡¡é€ˆé‚¢éŽ£é¦¨å…®å½—æƒ æ…§æš³è•™è¹Šé†¯éž‹ä¹Žäº’å‘¼å£•å£ºå¥½å²µå¼§æˆ¶æ‰ˆæ˜Šæ™§æ¯«æµ©æ·æ¹–æ»¸æ¾”æ¿ æ¿©çç‹ç¥ç‘šç“ çš“ç¥œç³Šç¸žèƒ¡èŠ¦è‘«è’¿è™Žè™Ÿè´è­·è±ªéŽ¬é €é¡¥æƒ‘æˆ–é…·å©šæ˜æ··æ¸¾ç¿é­‚å¿½æƒšç¬å“„å¼˜æ±žæ³“æ´ªçƒ˜ç´…è™¹è¨Œé´»åŒ–å’Œå¬…æ¨ºç«ç•µ"],
+		["fca1", "ç¦ç¦¾èŠ±è¯è©±è­è²¨é´ï¨‹æ“´æ”«ç¢ºç¢»ç©«ä¸¸å–šå¥å®¦å¹»æ‚£æ›æ­¡æ™¥æ¡“æ¸™ç…¥ç’°ç´ˆé‚„é©©é°¥æ´»æ»‘çŒ¾è±é—Šå‡°å¹Œå¾¨ææƒ¶æ„°æ…Œæ™ƒæ™„æ¦¥æ³æ¹Ÿæ»‰æ½¢ç…Œç’œçš‡ç¯ç°§è’è—é‘éšé»ƒåŒ¯å›žå»»å¾Šæ¢æ‚”æ‡·æ™¦æœƒæªœæ·®æ¾®ç°çªç¹ªè†¾èŒ´è›”èª¨è³„åŠƒç²å®–æ©«é„å“®åš†å­æ•ˆæ–…æ›‰æ¢Ÿæ¶æ·†"],
+		["fda1", "çˆ»è‚´é…µé©ä¾¯å€™åŽšåŽå¼å–‰å—…å¸¿å¾Œæœ½ç…¦çé€…å‹›å‹³å¡¤å£Žç„„ç†ç‡»è–°è¨“æšˆè–¨å–§æš„ç…Šè±å‰å–™æ¯å½™å¾½æ®æš‰ç…‡è«±è¼éº¾ä¼‘æºçƒ‹ç•¦è™§æ¤è­Žé·¸å…‡å‡¶åŒˆæ´¶èƒ¸é»‘æ˜•æ¬£ç‚˜ç—•åƒå±¹ç´‡è¨–æ¬ æ¬½æ­†å¸æ°æ´½ç¿•èˆˆåƒ–å‡žå–œå™«å›å§¬å¬‰å¸Œæ†™æ†˜æˆ±æ™žæ›¦ç†™ç†¹ç†ºçŠ§ç¦§ç¨€ç¾²è©°"]
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json
+var require_cp950 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json": ((exports, module) => {
+	module.exports = [
+		[
+			"0",
+			"\0",
+			127
+		],
+		["a140", "ã€€ï¼Œã€ã€‚ï¼Žâ€§ï¼›ï¼šï¼Ÿï¼ï¸°â€¦â€¥ï¹ï¹‘ï¹’Â·ï¹”ï¹•ï¹–ï¹—ï½œâ€“ï¸±â€”ï¸³â•´ï¸´ï¹ï¼ˆï¼‰ï¸µï¸¶ï½›ï½ï¸·ï¸¸ã€”ã€•ï¸¹ï¸ºã€ã€‘ï¸»ï¸¼ã€Šã€‹ï¸½ï¸¾ã€ˆã€‰ï¸¿ï¹€ã€Œã€ï¹ï¹‚ã€Žã€ï¹ƒï¹„ï¹™ï¹š"],
+		[
+			"a1a1",
+			"ï¹›ï¹œï¹ï¹žâ€˜â€™â€œâ€ã€ã€žâ€µâ€²ï¼ƒï¼†ï¼Šâ€»Â§ã€ƒâ—‹â—â–³â–²â—Žâ˜†â˜…â—‡â—†â–¡â– â–½â–¼ãŠ£â„…Â¯ï¿£ï¼¿Ëï¹‰ï¹Šï¹ï¹Žï¹‹ï¹Œï¹Ÿï¹ ï¹¡ï¼‹ï¼Ã—Ã·Â±âˆšï¼œï¼žï¼â‰¦â‰§â‰ âˆžâ‰’â‰¡ï¹¢",
+			4,
+			"ï½žâˆ©âˆªâŠ¥âˆ âˆŸâŠ¿ã’ã‘âˆ«âˆ®âˆµâˆ´â™€â™‚âŠ•âŠ™â†‘â†“â†â†’â†–â†—â†™â†˜âˆ¥âˆ£ï¼"
+		],
+		[
+			"a240",
+			"ï¼¼âˆ•ï¹¨ï¼„ï¿¥ã€’ï¿ ï¿¡ï¼…ï¼ â„ƒâ„‰ï¹©ï¹ªï¹«ã•ãŽœãŽãŽžãŽãŽ¡ãŽŽãŽã„Â°å…™å…›å…žå…å…¡å…£å—§ç“©ç³Žâ–",
+			7,
+			"â–â–Žâ–â–Œâ–‹â–Šâ–‰â”¼â”´â”¬â”¤â”œâ–”â”€â”‚â–•â”Œâ”â””â”˜â•­"
+		],
+		[
+			"a2a1",
+			"â•®â•°â•¯â•â•žâ•ªâ•¡â—¢â—£â—¥â—¤â•±â•²â•³ï¼",
+			9,
+			"â… ",
+			9,
+			"ã€¡",
+			8,
+			"åå„å…ï¼¡",
+			25,
+			"ï½",
+			21
+		],
+		[
+			"a340",
+			"ï½—ï½˜ï½™ï½šÎ‘",
+			16,
+			"Î£",
+			6,
+			"Î±",
+			16,
+			"Ïƒ",
+			6,
+			"ã„…",
+			10
+		],
+		[
+			"a3a1",
+			"ã„",
+			25,
+			"Ë™Ë‰ËŠË‡Ë‹"
+		],
+		["a3e1", "â‚¬"],
+		["a440", "ä¸€ä¹™ä¸ä¸ƒä¹ƒä¹äº†äºŒäººå„¿å…¥å…«å‡ åˆ€åˆåŠ›åŒ•ååœåˆä¸‰ä¸‹ä¸ˆä¸Šä¸«ä¸¸å‡¡ä¹…ä¹ˆä¹Ÿä¹žäºŽäº¡å…€åˆƒå‹ºåƒå‰å£åœŸå£«å¤•å¤§å¥³å­å­‘å­“å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼‹å¼“æ‰"],
+		["a4a1", "ä¸‘ä¸ä¸ä¸­ä¸°ä¸¹ä¹‹å°¹äºˆäº‘äº•äº’äº”äº¢ä»ä»€ä»ƒä»†ä»‡ä»ä»Šä»‹ä»„å…ƒå…å…§å…­å…®å…¬å†—å‡¶åˆ†åˆ‡åˆˆå‹»å‹¾å‹¿åŒ–åŒ¹åˆå‡å…åžåŽ„å‹åŠåå£¬å¤©å¤«å¤ªå¤­å­”å°‘å°¤å°ºå±¯å·´å¹»å»¿å¼”å¼•å¿ƒæˆˆæˆ¶æ‰‹æ‰Žæ”¯æ–‡æ–—æ–¤æ–¹æ—¥æ›°æœˆæœ¨æ¬ æ­¢æ­¹æ¯‹æ¯”æ¯›æ°æ°´ç«çˆªçˆ¶çˆ»ç‰‡ç‰™ç‰›çŠ¬çŽ‹ä¸™"],
+		["a540", "ä¸–ä¸•ä¸”ä¸˜ä¸»ä¹ä¹ä¹Žä»¥ä»˜ä»”ä»•ä»–ä»—ä»£ä»¤ä»™ä»žå……å…„å†‰å†Šå†¬å‡¹å‡ºå‡¸åˆŠåŠ åŠŸåŒ…åŒ†åŒ—åŒä»ŸåŠå‰å¡å å¯å®åŽ»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»å››å›šå¤–"],
+		["a5a1", "å¤®å¤±å¥´å¥¶å­•å®ƒå°¼å·¨å·§å·¦å¸‚å¸ƒå¹³å¹¼å¼å¼˜å¼—å¿…æˆŠæ‰“æ‰”æ‰’æ‰‘æ–¥æ—¦æœ®æœ¬æœªæœ«æœ­æ­£æ¯æ°‘æ°æ°¸æ±æ±€æ°¾çŠ¯çŽ„çŽ‰ç“œç“¦ç”˜ç”Ÿç”¨ç”©ç”°ç”±ç”²ç”³ç–‹ç™½çš®çš¿ç›®çŸ›çŸ¢çŸ³ç¤ºç¦¾ç©´ç«‹ä¸žä¸Ÿä¹’ä¹“ä¹©äº™äº¤äº¦äº¥ä»¿ä¼‰ä¼™ä¼Šä¼•ä¼ä¼ä¼‘ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼‹å…‰å…‡å…†å…ˆå…¨"],
+		["a640", "å…±å†å†°åˆ—åˆ‘åˆ’åˆŽåˆ–åŠ£åŒˆåŒ¡åŒ å°å±å‰ååŒåŠååå‹å„å‘ååˆåƒåŽå†å’å› å›žå›åœ³åœ°åœ¨åœ­åœ¬åœ¯åœ©å¤™å¤šå¤·å¤¸å¦„å¥¸å¦ƒå¥½å¥¹å¦‚å¦å­—å­˜å®‡å®ˆå®…å®‰å¯ºå°–å±¹å·žå¸†å¹¶å¹´"],
+		["a6a1", "å¼å¼›å¿™å¿–æˆŽæˆŒæˆæˆæ‰£æ‰›æ‰˜æ”¶æ—©æ—¨æ—¬æ—­æ›²æ›³æœ‰æœ½æœ´æœ±æœµæ¬¡æ­¤æ­»æ°–æ±æ±—æ±™æ±Ÿæ± æ±æ±•æ±¡æ±›æ±æ±Žç°ç‰Ÿç‰ç™¾ç«¹ç±³ç³¸ç¼¶ç¾Šç¾½è€è€ƒè€Œè€’è€³è¿è‚‰è‚‹è‚Œè‡£è‡ªè‡³è‡¼èˆŒèˆ›èˆŸè‰®è‰²è‰¾è™«è¡€è¡Œè¡£è¥¿é˜¡ä¸²äº¨ä½ä½ä½‡ä½—ä½žä¼´ä½›ä½•ä¼°ä½ä½‘ä¼½ä¼ºä¼¸ä½ƒä½”ä¼¼ä½†ä½£"],
+		["a740", "ä½œä½ ä¼¯ä½Žä¼¶ä½™ä½ä½ˆä½šå…Œå…‹å…å…µå†¶å†·åˆ¥åˆ¤åˆ©åˆªåˆ¨åŠ«åŠ©åŠªåŠ¬åŒ£å³åµåå­åžå¾å¦å‘Žå§å‘†å‘ƒå³å‘ˆå‘‚å›å©å‘Šå¹å»å¸å®åµå¶å å¼å‘€å±å«åŸå¬å›ªå›°å›¤å›«åŠå‘å€å"],
+		["a7a1", "å‡åŽåœ¾åååœ»å£¯å¤¾å¦å¦’å¦¨å¦žå¦£å¦™å¦–å¦å¦¤å¦“å¦Šå¦¥å­å­œå­šå­›å®Œå®‹å®å°¬å±€å±å°¿å°¾å²å²‘å²”å²Œå·«å¸Œåºåº‡åºŠå»·å¼„å¼Ÿå½¤å½¢å½·å½¹å¿˜å¿Œå¿—å¿å¿±å¿«å¿¸å¿ªæˆ’æˆ‘æŠ„æŠ—æŠ–æŠ€æ‰¶æŠ‰æ‰­æŠŠæ‰¼æ‰¾æ‰¹æ‰³æŠ’æ‰¯æŠ˜æ‰®æŠ•æŠ“æŠ‘æŠ†æ”¹æ”»æ”¸æ—±æ›´æŸæŽæææ‘æœæ–æžæ‰æ†æ "],
+		["a840", "æ“æ—æ­¥æ¯æ±‚æ±žæ²™æ²æ²ˆæ²‰æ²…æ²›æ±ªæ±ºæ²æ±°æ²Œæ±¨æ²–æ²’æ±½æ²ƒæ±²æ±¾æ±´æ²†æ±¶æ²æ²”æ²˜æ²‚ç¶ç¼ç½ç¸ç‰¢ç‰¡ç‰ ç‹„ç‹‚çŽ–ç”¬ç”«ç”·ç”¸çš‚ç›¯çŸ£ç§ç§€ç¦¿ç©¶ç³»ç½•è‚–è‚“è‚è‚˜è‚›è‚šè‚²è‰¯èŠ’"],
+		["a8a1", "èŠ‹èŠè¦‹è§’è¨€è°·è±†è±•è²èµ¤èµ°è¶³èº«è»Šè¾›è¾°è¿‚è¿†è¿…è¿„å·¡é‚‘é‚¢é‚ªé‚¦é‚£é…‰é‡†é‡Œé˜²é˜®é˜±é˜ªé˜¬ä¸¦ä¹–ä¹³äº‹äº›äºžäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾›ä¾‹ä¾†ä¾ƒä½°ä½µä¾ˆä½©ä½»ä¾–ä½¾ä¾ä¾‘ä½ºå…”å…’å…•å…©å…·å…¶å…¸å†½å‡½åˆ»åˆ¸åˆ·åˆºåˆ°åˆ®åˆ¶å‰åŠ¾åŠ»å’å”å“å‘å¦å·å¸å¹å–å”å—å‘³å‘µ"],
+		["a940", "å’–å‘¸å’•å’€å‘»å‘·å’„å’’å’†å‘¼å’å‘±å‘¶å’Œå’šå‘¢å‘¨å’‹å‘½å’Žå›ºåžƒå·åªå©å¡å¦å¤å¼å¤œå¥‰å¥‡å¥ˆå¥„å¥”å¦¾å¦»å§”å¦¹å¦®å§‘å§†å§å§å§‹å§“å§Šå¦¯å¦³å§’å§…å­Ÿå­¤å­£å®—å®šå®˜å®œå®™å®›å°šå±ˆå±…"],
+		["a9a1", "å±†å²·å²¡å²¸å²©å²«å²±å²³å¸˜å¸šå¸–å¸•å¸›å¸‘å¹¸åºšåº—åºœåº•åº–å»¶å¼¦å¼§å¼©å¾€å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æ€æ€”æ€¯æ€µæ€–æ€ªæ€•æ€¡æ€§æ€©æ€«æ€›æˆ–æˆ•æˆ¿æˆ¾æ‰€æ‰¿æ‹‰æ‹Œæ‹„æŠ¿æ‹‚æŠ¹æ‹’æ‹›æŠ«æ‹“æ‹”æ‹‹æ‹ˆæŠ¨æŠ½æŠ¼æ‹æ‹™æ‹‡æ‹æŠµæ‹šæŠ±æ‹˜æ‹–æ‹—æ‹†æŠ¬æ‹Žæ”¾æ–§æ–¼æ—ºæ˜”æ˜“æ˜Œæ˜†æ˜‚æ˜Žæ˜€æ˜æ˜•æ˜Š"],
+		["aa40", "æ˜‡æœæœ‹æ­æž‹æž•æ±æžœæ³æ·æž‡æžæž—æ¯æ°æ¿æž‰æ¾æžæµæžšæž“æ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°“æ°›æ³£æ³¨æ³³æ²±æ³Œæ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³•æ³“æ²¸æ³„æ²¹æ³æ²®æ³—æ³…æ³±æ²¿æ²»æ³¡æ³›æ³Šæ²¬æ³¯æ³œæ³–æ³ "],
+		["aaa1", "ç‚•ç‚Žç‚’ç‚Šç‚™çˆ¬çˆ­çˆ¸ç‰ˆç‰§ç‰©ç‹€ç‹Žç‹™ç‹—ç‹çŽ©çŽ¨çŽŸçŽ«çŽ¥ç”½ç–ç–™ç–šçš„ç›‚ç›²ç›´çŸ¥çŸ½ç¤¾ç¥€ç¥ç§‰ç§ˆç©ºç©¹ç«ºç³¾ç½”ç¾Œç¾‹è€…è‚ºè‚¥è‚¢è‚±è‚¡è‚«è‚©è‚´è‚ªè‚¯è‡¥è‡¾èˆèŠ³èŠèŠ™èŠ­èŠ½èŠŸèŠ¹èŠ±èŠ¬èŠ¥èŠ¯èŠ¸èŠ£èŠ°èŠ¾èŠ·è™Žè™±åˆè¡¨è»‹è¿Žè¿”è¿‘é‚µé‚¸é‚±é‚¶é‡‡é‡‘é•·é–€é˜œé™€é˜¿é˜»é™„"],
+		["ab40", "é™‚éš¹é›¨é’éžäºŸäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿‘ä¿ä¿ä¿ƒä¾¶ä¿˜ä¿Ÿä¿Šä¿—ä¾®ä¿ä¿„ä¿‚ä¿šä¿Žä¿žä¾·å…—å†’å†‘å† å‰Žå‰ƒå‰Šå‰å‰Œå‰‹å‰‡å‹‡å‹‰å‹ƒå‹åŒå—å»åŽšå›å’¬å“€å’¨å“Žå“‰å’¸å’¦å’³å“‡å“‚å’½å’ªå“"],
+		["aba1", "å“„å“ˆå’¯å’«å’±å’»å’©å’§å’¿å›¿åž‚åž‹åž åž£åž¢åŸŽåž®åž“å¥•å¥‘å¥å¥Žå¥å§œå§˜å§¿å§£å§¨å¨ƒå§¥å§ªå§šå§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±Žå±å±å±‹å³™å³’å··å¸å¸¥å¸Ÿå¹½åº åº¦å»ºå¼ˆå¼­å½¥å¾ˆå¾…å¾Šå¾‹å¾‡å¾Œå¾‰æ€’æ€æ€ æ€¥æ€Žæ€¨ææ°æ¨æ¢æ†æƒæ¬æ«æªæ¤æ‰æ‹œæŒ–æŒ‰æ‹¼æ‹­æŒæ‹®æ‹½æŒ‡æ‹±æ‹·"],
+		["ac40", "æ‹¯æ‹¬æ‹¾æ‹´æŒ‘æŒ‚æ”¿æ•…æ–«æ–½æ—¢æ˜¥æ˜­æ˜ æ˜§æ˜¯æ˜Ÿæ˜¨æ˜±æ˜¤æ›·æŸ¿æŸ“æŸ±æŸ”æŸæŸ¬æž¶æž¯æŸµæŸ©æŸ¯æŸ„æŸ‘æž´æŸšæŸ¥æž¸æŸæŸžæŸ³æž°æŸ™æŸ¢æŸæŸ’æ­ªæ®ƒæ®†æ®µæ¯’æ¯—æ°Ÿæ³‰æ´‹æ´²æ´ªæµæ´¥æ´Œæ´±æ´žæ´—"],
+		["aca1", "æ´»æ´½æ´¾æ´¶æ´›æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´Žæ´«ç‚«ç‚ºç‚³ç‚¬ç‚¯ç‚­ç‚¸ç‚®ç‚¤çˆ°ç‰²ç‰¯ç‰´ç‹©ç‹ ç‹¡çŽ·çŠçŽ»çŽ²çç€çŽ³ç”šç”­ç•ç•Œç•Žç•‹ç–«ç–¤ç–¥ç–¢ç–£ç™¸çš†çš‡çšˆç›ˆç›†ç›ƒç›…çœç›¹ç›¸çœ‰çœ‹ç›¾ç›¼çœ‡çŸœç ‚ç ”ç Œç ç¥†ç¥‰ç¥ˆç¥‡ç¦¹ç¦ºç§‘ç§’ç§‹ç©¿çªç«¿ç«½ç±½ç´‚ç´…ç´€ç´‰ç´‡ç´„ç´†ç¼¸ç¾Žç¾¿è€„"],
+		["ad40", "è€è€è€‘è€¶èƒ–èƒ¥èƒšèƒƒèƒ„èƒŒèƒ¡èƒ›èƒŽèƒžèƒ¤èƒè‡´èˆ¢è‹§èŒƒèŒ…è‹£è‹›è‹¦èŒ„è‹¥èŒ‚èŒ‰è‹’è‹—è‹±èŒè‹œè‹”è‹‘è‹žè‹“è‹Ÿè‹¯èŒ†è™è™¹è™»è™ºè¡è¡«è¦è§”è¨ˆè¨‚è¨ƒè²žè² èµ´èµ³è¶´è»è»Œè¿°è¿¦è¿¢è¿ªè¿¥"],
+		["ada1", "è¿­è¿«è¿¤è¿¨éƒŠéƒŽéƒéƒƒé…‹é…Šé‡é–‚é™é™‹é™Œé™é¢é©éŸ‹éŸ­éŸ³é é¢¨é£›é£Ÿé¦–é¦™ä¹˜äº³å€Œå€å€£ä¿¯å€¦å€¥ä¿¸å€©å€–å€†å€¼å€Ÿå€šå€’å€‘ä¿ºå€€å€”å€¨ä¿±å€¡å€‹å€™å€˜ä¿³ä¿®å€­å€ªä¿¾å€«å€‰å…¼å†¤å†¥å†¢å‡å‡Œå‡†å‡‹å‰–å‰œå‰”å‰›å‰åŒªå¿åŽŸåŽåŸå“¨å”å”å”·å“¼å“¥å“²å”†å“ºå””å“©å“­å“¡å”‰å“®å“ª"],
+		["ae40", "å“¦å”§å”‡å“½å”åœƒåœ„åŸ‚åŸ”åŸ‹åŸƒå ‰å¤å¥—å¥˜å¥šå¨‘å¨˜å¨œå¨Ÿå¨›å¨“å§¬å¨ å¨£å¨©å¨¥å¨Œå¨‰å­«å±˜å®°å®³å®¶å®´å®®å®µå®¹å®¸å°„å±‘å±•å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾’å¾‘å¾æ™"],
+		["aea1", "æ£æ¥ææ•æ­æ©æ¯æ‚„æ‚Ÿæ‚šæ‚æ‚”æ‚Œæ‚…æ‚–æ‰‡æ‹³æŒˆæ‹¿æŽæŒ¾æŒ¯æ•æ‚æ†ææ‰æŒºææŒ½æŒªæŒ«æŒ¨ææŒæ•ˆæ•‰æ–™æ—æ—…æ™‚æ™‰æ™æ™ƒæ™’æ™Œæ™…æ™æ›¸æœ”æœ•æœ—æ ¡æ ¸æ¡ˆæ¡†æ¡“æ ¹æ¡‚æ¡”æ ©æ¢³æ —æ¡Œæ¡‘æ ½æŸ´æ¡æ¡€æ ¼æ¡ƒæ ªæ¡…æ “æ ˜æ¡æ®Šæ®‰æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶•æ¶ˆæ¶‡æµ¦æµ¸æµ·æµ™æ¶“"],
+		["af40", "æµ¬æ¶‰æµ®æµšæµ´æµ©æ¶Œæ¶Šæµ¹æ¶…æµ¥æ¶”çƒŠçƒ˜çƒ¤çƒ™çƒˆçƒçˆ¹ç‰¹ç‹¼ç‹¹ç‹½ç‹¸ç‹·çŽ†ç­ç‰ç®ç çªçžç•”ç•ç•œç•šç•™ç–¾ç—…ç—‡ç–²ç–³ç–½ç–¼ç–¹ç—‚ç–¸çš‹çš°ç›Šç›ç›Žçœ©çœŸçœ çœ¨çŸ©ç °ç §ç ¸ç ç ´ç ·"],
+		["afa1", "ç ¥ç ­ç  ç Ÿç ²ç¥•ç¥ç¥ ç¥Ÿç¥–ç¥žç¥ç¥—ç¥šç§¤ç§£ç§§ç§Ÿç§¦ç§©ç§˜çª„çªˆç«™ç¬†ç¬‘ç²‰ç´¡ç´—ç´‹ç´Šç´ ç´¢ç´”ç´ç´•ç´šç´œç´ç´™ç´›ç¼ºç½Ÿç¾”ç¿…ç¿è€†è€˜è€•è€™è€—è€½è€¿èƒ±è„‚èƒ°è„…èƒ­èƒ´è„†èƒ¸èƒ³è„ˆèƒ½è„Šèƒ¼èƒ¯è‡­è‡¬èˆ€èˆèˆªèˆ«èˆ¨èˆ¬èŠ»èŒ«è’è”èŠèŒ¸èè‰èŒµèŒ´èèŒ²èŒ¹èŒ¶èŒ—è€èŒ±èŒ¨èƒ"],
+		["b040", "è™”èšŠèšªèš“èš¤èš©èšŒèš£èšœè¡°è¡·è¢è¢‚è¡½è¡¹è¨˜è¨è¨Žè¨Œè¨•è¨Šè¨—è¨“è¨–è¨è¨‘è±ˆè±ºè±¹è²¡è²¢èµ·èº¬è»’è»”è»è¾±é€é€†è¿·é€€è¿ºè¿´é€ƒè¿½é€…è¿¸é‚•éƒ¡éƒéƒ¢é…’é…é…Œé‡˜é‡é‡—é‡œé‡™é–ƒé™¢é™£é™¡"],
+		["b0a1", "é™›é™é™¤é™˜é™žéš»é£¢é¦¬éª¨é«˜é¬¥é¬²é¬¼ä¹¾åºå½åœå‡åƒåŒåšå‰å¥å¶åŽå•åµå´å·åå€å¯å­å…œå†•å‡°å‰ªå‰¯å‹’å‹™å‹˜å‹•åŒåŒåŒ™åŒ¿å€åŒ¾åƒæ›¼å•†å•ªå•¦å•„å•žå•¡å•ƒå•Šå”±å•–å•å••å”¯å•¤å”¸å”®å•œå”¬å•£å”³å•å•—åœˆåœ‹åœ‰åŸŸå …å Šå †åŸ åŸ¤åŸºå ‚å µåŸ·åŸ¹å¤ å¥¢å¨¶å©å©‰å©¦å©ªå©€"],
+		["b140", "å¨¼å©¢å©šå©†å©Šå­°å¯‡å¯…å¯„å¯‚å®¿å¯†å°‰å°ˆå°‡å± å±œå±å´‡å´†å´Žå´›å´–å´¢å´‘å´©å´”å´™å´¤å´§å´—å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½—å½¬å½©å½«å¾—å¾™å¾žå¾˜å¾¡å¾ å¾œæ¿æ‚£æ‚‰æ‚ æ‚¨æƒ‹æ‚´æƒ¦æ‚½"],
+		["b1a1", "æƒ…æ‚»æ‚µæƒœæ‚¼æƒ˜æƒ•æƒ†æƒŸæ‚¸æƒšæƒ‡æˆšæˆ›æ‰ˆæŽ æŽ§æ²æŽ–æŽ¢æŽ¥æ·æ§æŽ˜æŽªæ±æŽ©æŽ‰æŽƒæŽ›æ«æŽ¨æŽ„æŽˆæŽ™æŽ¡æŽ¬æŽ’æŽæŽ€æ»æ©æ¨æºæ•æ•–æ•‘æ•™æ•—å•Ÿæ•æ•˜æ••æ•”æ–œæ–›æ–¬æ—æ—‹æ—Œæ—Žæ™æ™šæ™¤æ™¨æ™¦æ™žæ›¹å‹—æœ›æ¢æ¢¯æ¢¢æ¢“æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢—æ¢°æ¢ƒæ£„æ¢­æ¢†æ¢…æ¢”æ¢æ¢¨æ¢Ÿæ¢¡æ¢‚æ¬²æ®º"],
+		["b240", "æ¯«æ¯¬æ°«æ¶Žæ¶¼æ·³æ·™æ¶²æ·¡æ·Œæ·¤æ·»æ·ºæ¸…æ·‡æ·‹æ¶¯æ·‘æ¶®æ·žæ·¹æ¶¸æ··æ·µæ·…æ·’æ¸šæ¶µæ·šæ·«æ·˜æ·ªæ·±æ·®æ·¨æ·†æ·„æ¶ªæ·¬æ¶¿æ·¦çƒ¹ç„‰ç„Šçƒ½çƒ¯çˆ½ç‰½çŠçŒœçŒ›çŒ–çŒ“çŒ™çŽ‡ç…çŠçƒç†ç¾çç“ ç“¶"],
+		["b2a1", "ç“·ç”œç”¢ç•¥ç•¦ç•¢ç•°ç–ç—”ç—•ç–µç—Šç—çšŽç›”ç›’ç››çœ·çœ¾çœ¼çœ¶çœ¸çœºç¡«ç¡ƒç¡Žç¥¥ç¥¨ç¥­ç§»çª’çª•ç¬ ç¬¨ç¬›ç¬¬ç¬¦ç¬™ç¬žç¬®ç²’ç²—ç²•çµ†çµƒçµ±ç´®ç´¹ç´¼çµ€ç´°ç´³çµ„ç´¯çµ‚ç´²ç´±ç¼½ç¾žç¾šç¿Œç¿Žç¿’è€œèŠè†è„¯è„–è„£è„«è„©è„°è„¤èˆ‚èˆµèˆ·èˆ¶èˆ¹èŽŽèŽžèŽ˜è¸èŽ¢èŽ–èŽ½èŽ«èŽ’èŽŠèŽ“èŽ‰èŽ è·è»è¼"],
+		["b340", "èŽ†èŽ§è™•å½ªè›‡è›€èš¶è›„èšµè›†è›‹èš±èš¯è›‰è¡“è¢žè¢ˆè¢«è¢’è¢–è¢è¢‹è¦“è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨Ÿè¨›è¨¢è±‰è±šè²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»›è»Ÿé€™é€é€šé€—é€£é€Ÿé€é€é€•é€žé€ é€é€¢é€–é€›é€”"],
+		["b3a1", "éƒ¨éƒ­éƒ½é…—é‡Žé‡µé‡¦é‡£é‡§é‡­é‡©é–‰é™ªé™µé™³é™¸é™°é™´é™¶é™·é™¬é›€é›ªé›©ç« ç«Ÿé ‚é ƒé­šé³¥é¹µé¹¿éº¥éº»å‚¢å‚å‚…å‚™å‚‘å‚€å‚–å‚˜å‚šæœ€å‡±å‰²å‰´å‰µå‰©å‹žå‹å‹›åšåŽ¥å•»å–€å–§å•¼å–Šå–å–˜å–‚å–œå–ªå–”å–‡å–‹å–ƒå–³å–®å–Ÿå”¾å–²å–šå–»å–¬å–±å•¾å–‰å–«å–™åœå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ "],
+		["b440", "å©·åªšå©¿åª’åª›åª§å­³å­±å¯’å¯Œå¯“å¯å°Šå°‹å°±åµŒåµå´´åµ‡å·½å¹…å¸½å¹€å¹ƒå¹¾å»Šå»å»‚å»„å¼¼å½­å¾©å¾ªå¾¨æƒ‘æƒ¡æ‚²æ‚¶æƒ æ„œæ„£æƒºæ„•æƒ°æƒ»æƒ´æ…¨æƒ±æ„Žæƒ¶æ„‰æ„€æ„’æˆŸæ‰‰æŽ£æŽŒææ€æ©æ‰æ†æ"],
+		["b4a1", "æ’æ£ææ¡æ–æ­æ®æ¶æ´æªæ›æ‘’æšæ¹æ•žæ•¦æ•¢æ•£æ–‘æ–æ–¯æ™®æ™°æ™´æ™¶æ™¯æš‘æ™ºæ™¾æ™·æ›¾æ›¿æœŸæœæ£ºæ£•æ£ æ£˜æ£—æ¤…æ£Ÿæ£µæ£®æ£§æ£¹æ£’æ£²æ££æ£‹æ£æ¤æ¤’æ¤Žæ£‰æ£šæ¥®æ£»æ¬¾æ¬ºæ¬½æ®˜æ®–æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹”æ¸¡æ¸²æ¹§æ¹Šæ¸ æ¸¥æ¸£æ¸›æ¹›æ¹˜æ¸¤æ¹–æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹ƒæ¸æ¸¾æ»‹"],
+		["b540", "æº‰æ¸™æ¹Žæ¹£æ¹„æ¹²æ¹©æ¹Ÿç„™ç„šç„¦ç„°ç„¡ç„¶ç…®ç„œç‰ŒçŠ„çŠ€çŒ¶çŒ¥çŒ´çŒ©çºçªç³ç¢ç¥çµç¶ç´ç¯ç›ç¦ç¨ç”¥ç”¦ç•«ç•ªç—¢ç—›ç—£ç—™ç—˜ç—žç— ç™»ç™¼çš–çš“çš´ç›œççŸ­ç¡ç¡¬ç¡¯ç¨ç¨ˆç¨‹ç¨…ç¨€çª˜"],
+		["b5a1", "çª—çª–ç«¥ç«£ç­‰ç­–ç­†ç­ç­’ç­”ç­ç­‹ç­ç­‘ç²Ÿç²¥çµžçµçµ¨çµ•ç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³å–„ç¿”ç¿•è€‹è’è‚…è…•è…”è…‹è…‘è…Žè„¹è…†è„¾è…Œè…“è…´èˆ’èˆœè©èƒè¸èè è…è‹èè¯è±è´è‘—èŠè°èŒèŒè½è²èŠè¸èŽè„èœè‡è”èŸè™›è›Ÿè›™è›­è›”è››è›¤è›è›žè¡—è£è£‚è¢±è¦ƒè¦–è¨»è© è©•è©žè¨¼è©"],
+		["b640", "è©”è©›è©è©†è¨´è¨ºè¨¶è©–è±¡è²‚è²¯è²¼è²³è²½è³è²»è³€è²´è²·è²¶è²¿è²¸è¶Šè¶…è¶è·Žè·è·‹è·šè·‘è·Œè·›è·†è»»è»¸è»¼è¾œé€®é€µé€±é€¸é€²é€¶é„‚éƒµé„‰éƒ¾é…£é…¥é‡éˆ”éˆ•éˆ£éˆ‰éˆžéˆéˆéˆ‡éˆ‘é–”é–é–‹é–‘"],
+		["b6a1", "é–“é–’é–ŽéšŠéšŽéš‹é™½éš…éš†éšé™²éš„é›é›…é›„é›†é›‡é›¯é›²éŸŒé …é †é ˆé£§é£ªé£¯é£©é£²é£­é¦®é¦­é»ƒé»é»‘äº‚å‚­å‚µå‚²å‚³åƒ…å‚¾å‚¬å‚·å‚»å‚¯åƒ‡å‰¿å‰·å‰½å‹Ÿå‹¦å‹¤å‹¢å‹£åŒ¯å—Ÿå—¨å—“å—¦å—Žå—œå—‡å—‘å—£å—¤å—¯å—šå—¡å—…å—†å—¥å—‰åœ’åœ“å¡žå¡‘å¡˜å¡—å¡šå¡”å¡«å¡Œå¡­å¡Šå¡¢å¡’å¡‹å¥§å«å«‰å«Œåª¾åª½åª¼"],
+		["b740", "åª³å«‚åª²åµ©åµ¯å¹Œå¹¹å»‰å»ˆå¼’å½™å¾¬å¾®æ„šæ„æ…ˆæ„Ÿæƒ³æ„›æƒ¹æ„æ„ˆæ…Žæ…Œæ…„æ…æ„¾æ„´æ„§æ„æ„†æ„·æˆ¡æˆ¢æ“æ¾æžæªæ­æ½æ¬ææœæ”ææ¶æ–æ—æ†æ•¬æ–Ÿæ–°æš—æš‰æš‡æšˆæš–æš„æš˜æšæœƒæ¦”æ¥­"],
+		["b7a1", "æ¥šæ¥·æ¥ æ¥”æ¥µæ¤°æ¦‚æ¥Šæ¥¨æ¥«æ¥žæ¥“æ¥¹æ¦†æ¥æ¥£æ¥›æ­‡æ­²æ¯€æ®¿æ¯“æ¯½æº¢æº¯æ»“æº¶æ»‚æºæºæ»‡æ»…æº¥æº˜æº¼æººæº«æ»‘æº–æºœæ»„æ»”æºªæº§æº´ç…Žç…™ç…©ç…¤ç…‰ç…§ç…œç…¬ç…¦ç…Œç…¥ç…žç…†ç…¨ç…–çˆºç‰’çŒ·ç…çŒ¿çŒ¾ç‘¯ç‘šç‘•ç‘Ÿç‘žç‘ç¿ç‘™ç‘›ç‘œç•¶ç•¸ç˜€ç—°ç˜ç—²ç—±ç—ºç—¿ç—´ç—³ç›žç›Ÿç›ç«ç¦çžç£"],
+		["b840", "ç¹çªç¬çœç¥ç¨ç¢çŸ®ç¢Žç¢°ç¢—ç¢˜ç¢Œç¢‰ç¡¼ç¢‘ç¢“ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨œç¨šç¨ ç¨”ç¨Ÿç¨žçªŸçª ç­·ç¯€ç­ ç­®ç­§ç²±ç²³ç²µç¶“çµ¹ç¶‘ç¶ç¶çµ›ç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤è–è˜è‚†è‚„è…±è…°è…¸è…¥è…®è…³è…«"],
+		["b8a1", "è…¹è…ºè…¦èˆ…è‰‡è’‚è‘·è½è±è‘µè‘¦è‘«è‘‰è‘¬è‘›è¼èµè‘¡è‘£è‘©è‘­è‘†è™žè™œè™Ÿè›¹èœ“èœˆèœ‡èœ€è›¾è›»èœ‚èœƒèœ†èœŠè¡™è£Ÿè£”è£™è£œè£˜è£è£¡è£Šè£•è£’è¦œè§£è©«è©²è©³è©¦è©©è©°èª‡è©¼è©£èª è©±èª…è©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²Šè²‰è³Šè³‡è³ˆè³„è²²è³ƒè³‚è³…è·¡è·Ÿè·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼ƒè¼‰è»¾è¼Š"],
+		["b940", "è¾Ÿè¾²é‹éŠé“é‚é”é€¼é•éé‡ééŽéé‘é€¾éé„’é„—é…¬é…ªé…©é‡‰éˆ·é‰—éˆ¸éˆ½é‰€éˆ¾é‰›é‰‹é‰¤é‰‘éˆ´é‰‰é‰é‰…éˆ¹éˆ¿é‰šé–˜éš˜éš”éš•é›é›‹é›‰é›Šé›·é›»é›¹é›¶é–é´é¶é é ‘é “é Šé ’é Œé£¼é£´"],
+		["b9a1", "é£½é£¾é¦³é¦±é¦´é«¡é³©éº‚é¼Žé¼“é¼ åƒ§åƒ®åƒ¥åƒ–åƒ­åƒšåƒ•åƒåƒ‘åƒ±åƒŽåƒ©å…¢å‡³åŠƒåŠ‚åŒ±åŽ­å—¾å˜€å˜›å˜—å—½å˜”å˜†å˜‰å˜å˜Žå—·å˜–å˜Ÿå˜ˆå˜å—¶åœ˜åœ–å¡µå¡¾å¢ƒå¢“å¢Šå¡¹å¢…å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«—å«–å«˜å«£å­µå¯žå¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯Ÿå°å±¢å¶„å¶‡å¹›å¹£å¹•å¹—å¹”å»“å»–å¼Šå½†å½°å¾¹æ…‡"],
+		["ba40", "æ„¿æ…‹æ…·æ…¢æ…£æ…Ÿæ…šæ…˜æ…µæˆªæ’‡æ‘˜æ‘”æ’¤æ‘¸æ‘Ÿæ‘ºæ‘‘æ‘§æ´æ‘­æ‘»æ•²æ–¡æ——æ—–æš¢æš¨æšæ¦œæ¦¨æ¦•æ§æ¦®æ§“æ§‹æ¦›æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§Œæ¦¦æ§ƒæ¦£æ­‰æ­Œæ°³æ¼³æ¼”æ»¾æ¼“æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼‚æ¼¢"],
+		["baa1", "æ»¿æ»¯æ¼†æ¼±æ¼¸æ¼²æ¼£æ¼•æ¼«æ¼¯æ¾ˆæ¼ªæ»¬æ¼æ»²æ»Œæ»·ç†”ç†™ç…½ç†Šç†„ç†’çˆ¾çŠ’çŠ–ç„çç‘¤ç‘£ç‘ªç‘°ç‘­ç”„ç–‘ç˜§ç˜ç˜‹ç˜‰ç˜“ç›¡ç›£çž„ç½ç¿ç¡ç£ç¢Ÿç¢§ç¢³ç¢©ç¢£ç¦Žç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®•ç®‹ç­µç®—ç®ç®”ç®ç®¸ç®‡ç®„ç²¹ç²½ç²¾ç¶»ç¶°ç¶œç¶½ç¶¾ç¶ ç·Šç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·’ç·‡ç¶¬"],
+		["bb40", "ç½°ç¿ ç¿¡ç¿Ÿèžèšè‚‡è…è†€è†è†ˆè†Šè…¿è†‚è‡§è‡ºèˆ‡èˆ”èˆžè‰‹è“‰è’¿è“†è“„è’™è’žè’²è’œè“‹è’¸è“€è““è’è’¼è“‘è“Šèœ¿èœœèœ»èœ¢èœ¥èœ´èœ˜è•èœ·èœ©è£³è¤‚è£´è£¹è£¸è£½è£¨è¤šè£¯èª¦èªŒèªžèª£èªèª¡èª“èª¤"],
+		["bba1", "èªªèª¥èª¨èª˜èª‘èªšèª§è±ªè²è²Œè³“è³‘è³’èµ«è¶™è¶•è·¼è¼”è¼’è¼•è¼“è¾£é é˜éœé£é™éžé¢éé›é„™é„˜é„žé…µé…¸é…·é…´é‰¸éŠ€éŠ…éŠ˜éŠ–é‰»éŠ“éŠœéŠ¨é‰¼éŠ‘é–¡é–¨é–©é–£é–¥é–¤éš™éšœéš›é›Œé›’éœ€é¼éž…éŸ¶é —é ˜é¢¯é¢±é¤ƒé¤…é¤Œé¤‰é§éª¯éª°é«¦é­é­‚é³´é³¶é³³éº¼é¼»é½Šå„„å„€åƒ»åƒµåƒ¹å„‚å„ˆå„‰å„…å‡œ"],
+		["bc40", "åŠ‡åŠˆåŠ‰åŠåŠŠå‹°åŽ²å˜®å˜»å˜¹å˜²å˜¿å˜´å˜©å™“å™Žå™—å™´å˜¶å˜¯å˜°å¢€å¢Ÿå¢žå¢³å¢œå¢®å¢©å¢¦å¥­å¬‰å«»å¬‹å«µå¬Œå¬ˆå¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶”å¹¢å¹Ÿå¹¡å»¢å»šå»Ÿå»å»£å» å½ˆå½±å¾·å¾µæ…¶æ…§æ…®æ…æ…•æ†‚"],
+		["bca1", "æ…¼æ…°æ…«æ…¾æ†§æ†æ†«æ†Žæ†¬æ†šæ†¤æ†”æ†®æˆ®æ‘©æ‘¯æ‘¹æ’žæ’²æ’ˆæ’æ’°æ’¥æ’“æ’•æ’©æ’’æ’®æ’­æ’«æ’šæ’¬æ’™æ’¢æ’³æ•µæ•·æ•¸æš®æš«æš´æš±æ¨£æ¨Ÿæ§¨æ¨æ¨žæ¨™æ§½æ¨¡æ¨“æ¨Šæ§³æ¨‚æ¨…æ§­æ¨‘æ­æ­Žæ®¤æ¯…æ¯†æ¼¿æ½¼æ¾„æ½‘æ½¦æ½”æ¾†æ½­æ½›æ½¸æ½®æ¾Žæ½ºæ½°æ½¤æ¾—æ½˜æ»•æ½¯æ½ æ½Ÿç†Ÿç†¬ç†±ç†¨ç‰–çŠ›çŽç—ç‘©ç’‹ç’ƒ"],
+		["bd40", "ç‘¾ç’€ç•¿ç˜ ç˜©ç˜Ÿç˜¤ç˜¦ç˜¡ç˜¢çššçšºç›¤çžŽçž‡çžŒçž‘çž‹ç£‹ç£…ç¢ºç£Šç¢¾ç£•ç¢¼ç£ç¨¿ç¨¼ç©€ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯„ç®´ç¯†ç¯‡ç¯ç® ç¯Œç³Šç· ç·´ç·¯ç·»ç·˜ç·¬ç·ç·¨ç·£ç·šç·žç·©ç¶žç·™ç·²ç·¹ç½µç½·ç¾¯"],
+		["bda1", "ç¿©è€¦è†›è†œè†è† è†šè†˜è”—è”½è”šè“®è”¬è”­è”“è”‘è”£è”¡è””è“¬è”¥è“¿è”†èž‚è´è¶è è¦è¸è¨è™è—èŒè“è¡›è¡è¤è¤‡è¤’è¤“è¤•è¤Šèª¼è«’è«‡è«„èª•è«‹è«¸èª²è«‰è«‚èª¿èª°è«–è«èª¶èª¹è«›è±Œè±Žè±¬è³ è³žè³¦è³¤è³¬è³­è³¢è³£è³œè³ªè³¡èµ­è¶Ÿè¶£è¸«è¸è¸è¸¢è¸è¸©è¸Ÿè¸¡è¸žèººè¼è¼›è¼Ÿè¼©è¼¦è¼ªè¼œè¼ž"],
+		["be40", "è¼¥é©é®é¨é­é·é„°é„­é„§é„±é†‡é†‰é†‹é†ƒé‹…éŠ»éŠ·é‹ªéŠ¬é‹¤é‹éŠ³éŠ¼é‹’é‹‡é‹°éŠ²é–­é–±éœ„éœ†éœ‡éœ‰é éžéž‹éžé ¡é «é œé¢³é¤Šé¤“é¤’é¤˜é§é§é§Ÿé§›é§‘é§•é§’é§™éª·é«®é«¯é¬§é­…é­„é­·é­¯é´†é´‰"],
+		["bea1", "é´ƒéº©éº¾é»Žå¢¨é½’å„’å„˜å„”å„å„•å†€å†ªå‡åŠ‘åŠ“å‹³å™™å™«å™¹å™©å™¤å™¸å™ªå™¨å™¥å™±å™¯å™¬å™¢å™¶å£å¢¾å£‡å£…å¥®å¬å¬´å­¸å¯°å°Žå½Šæ†²æ†‘æ†©æ†Šæ‡æ†¶æ†¾æ‡Šæ‡ˆæˆ°æ“…æ“æ“‹æ’»æ’¼æ“šæ“„æ“‡æ“‚æ“æ’¿æ“’æ“”æ’¾æ•´æ›†æ›‰æš¹æ›„æ›‡æš¸æ¨½æ¨¸æ¨ºæ©™æ©«æ©˜æ¨¹æ©„æ©¢æ©¡æ©‹æ©‡æ¨µæ©Ÿæ©ˆæ­™æ­·æ°…æ¿‚æ¾±æ¾¡"],
+		["bf40", "æ¿ƒæ¾¤æ¿æ¾§æ¾³æ¿€æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç†¾ç‡‰ç‡ç‡’ç‡ˆç‡•ç†¹ç‡Žç‡™ç‡œç‡ƒç‡„ç¨ç’œç’£ç’˜ç’Ÿç’žç“¢ç”Œç”ç˜´ç˜¸ç˜ºç›§ç›¥çž çžžçžŸçž¥ç£¨ç£šç£¬ç£§ç¦¦ç©ç©Žç©†ç©Œç©‹çªºç¯™ç°‘ç¯‰ç¯¤ç¯›ç¯¡ç¯©ç¯¦ç³•ç³–ç¸Š"],
+		["bfa1", "ç¸‘ç¸ˆç¸›ç¸£ç¸žç¸ç¸‰ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è€¨è†³è†©è†¨è‡»èˆˆè‰˜è‰™è•Šè•™è•ˆè•¨è•©è•ƒè•‰è•­è•ªè•žèžƒèžŸèžžèž¢èžè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬€è«œè«§è«®è«¾è¬è¬‚è«·è«­è«³è«¶è«¼è±«è±­è²“è³´è¹„è¸±è¸´è¹‚è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé„´é†’éŒ éŒ¶é‹¸éŒ³éŒ¯éŒ¢é‹¼éŒ«éŒ„éŒš"],
+		["c040", "éŒéŒ¦éŒ¡éŒ•éŒ®éŒ™é–»éš§éš¨éšªé›•éœŽéœ‘éœ–éœéœ“éœé›éœé¦éž˜é °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤žé¤›é¤¡é¤šé§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®‘é´•é´£é´¦é´¨é´’é´›é»˜é»”é¾é¾œå„ªå„Ÿå„¡å„²å‹µåšŽåš€åšåš…åš‡"],
+		["c0a1", "åšå£•å£“å£‘å£Žå¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½Œå¾½æ‡‰æ‡‚æ‡‡æ‡¦æ‡‹æˆ²æˆ´æ“Žæ“Šæ“˜æ“ æ“°æ“¦æ“¬æ“±æ“¢æ“­æ–‚æ–ƒæ›™æ›–æª€æª”æª„æª¢æªœæ«›æª£æ©¾æª—æªæª æ­œæ®®æ¯šæ°ˆæ¿˜æ¿±æ¿Ÿæ¿ æ¿›æ¿¤æ¿«æ¿¯æ¾€æ¿¬æ¿¡æ¿©æ¿•æ¿®æ¿°ç‡§ç‡Ÿç‡®ç‡¦ç‡¥ç‡­ç‡¬ç‡´ç‡ çˆµç‰†ç°ç²ç’©ç’°ç’¦ç’¨ç™†ç™‚ç™Œç›ªçž³çžªçž°çž¬"],
+		["c140", "çž§çž­çŸ¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©—çª¿ç°‡ç°ç¯¾ç¯·ç°Œç¯ ç³ ç³œç³žç³¢ç³Ÿç³™ç³ç¸®ç¸¾ç¹†ç¸·ç¸²ç¹ƒç¸«ç¸½ç¸±ç¹…ç¹ç¸´ç¸¹ç¹ˆç¸µç¸¿ç¸¯ç½„ç¿³ç¿¼è±è²è°è¯è³è‡†è‡ƒè†ºè‡‚è‡€è†¿è†½è‡‰è†¾è‡¨èˆ‰è‰±è–ª"],
+		["c1a1", "è–„è•¾è–œè–‘è–”è–¯è–›è–‡è–¨è–Šè™§èŸ€èŸ‘èž³èŸ’èŸ†èž«èž»èžºèŸˆèŸ‹è¤»è¤¶è¥„è¤¸è¤½è¦¬è¬Žè¬—è¬™è¬›è¬Šè¬ è¬è¬„è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹‰è¹‹è¹ˆè¹Šè½„è¼¾è½‚è½…è¼¿é¿é½é‚„é‚é‚‚é‚€é„¹é†£é†žé†œééŽ‚éŒ¨éµéŠé¥é‹éŒ˜é¾é¬é›é°éšé”é—Šé—‹é—Œé—ˆé—†éš±éš¸é›–éœœéœžéž éŸ“é¡†é¢¶é¤µé¨"],
+		["c240", "é§¿é®®é®«é®ªé®­é´»é´¿éº‹é»é»žé»œé»é»›é¼¾é½‹å¢åš•åš®å£™å£˜å¬¸å½æ‡£æˆ³æ“´æ“²æ“¾æ”†æ“ºæ“»æ“·æ–·æ›œæœ¦æª³æª¬æ«ƒæª»æª¸æ«‚æª®æª¯æ­Ÿæ­¸æ®¯ç€‰ç€‹æ¿¾ç€†æ¿ºç€‘ç€ç‡»ç‡¼ç‡¾ç‡¸ç·çµç’§ç’¿ç”•ç™–ç™˜"],
+		["c2a1", "ç™’çž½çž¿çž»çž¼ç¤Žç¦®ç©¡ç©¢ç© ç«„ç«…ç°«ç°§ç°ªç°žç°£ç°¡ç³§ç¹”ç¹•ç¹žç¹šç¹¡ç¹’ç¹™ç½ˆç¿¹ç¿»è·è¶è‡è‡èˆŠè—è–©è—è—è—‰è–°è–ºè–¹è–¦èŸ¯èŸ¬èŸ²èŸ è¦†è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´…è¹™è¹£è¹¦è¹¤è¹Ÿè¹•è»€è½‰è½é‚‡é‚ƒé‚ˆé†«é†¬é‡éŽ”éŽŠéŽ–éŽ¢éŽ³éŽ®éŽ¬éŽ°éŽ˜éŽšéŽ—é—”é—–é—é—•é›¢é›œé›™é››é›žéœ¤éž£éž¦"],
+		["c340", "éž­éŸ¹é¡é¡é¡Œé¡Žé¡“é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨Žé«é¬ƒé¬†é­é­Žé­é¯Šé¯‰é¯½é¯ˆé¯€éµ‘éµéµ é» é¼•é¼¬å„³åš¥å£žå£Ÿå£¢å¯µé¾å»¬æ‡²æ‡·æ‡¶æ‡µæ”€æ”æ› æ›æ«¥æ«æ«šæ«“ç€›ç€Ÿç€¨ç€šç€ç€•ç€˜çˆ†çˆç‰˜çŠ¢ç¸"],
+		["c3a1", "çºç’½ç“Šç“£ç–‡ç–†ç™Ÿç™¡çŸ‡ç¤™ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±€ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾…ç¹³ç¾¶ç¾¹ç¾¸è‡˜è—©è—è—ªè—•è—¤è—¥è—·èŸ»è …è èŸ¹èŸ¾è¥ è¥Ÿè¥–è¥žè­è­œè­˜è­‰è­šè­Žè­è­†è­™è´ˆè´Šè¹¼è¹²èº‡è¹¶è¹¬è¹ºè¹´è½”è½Žè¾­é‚Šé‚‹é†±é†®é¡é‘éŸéƒéˆéœéé–é¢éé˜é¤é—é¨é—œéš´é›£éœªéœ§é¡éŸœéŸ»é¡ž"],
+		["c440", "é¡˜é¡›é¢¼é¥…é¥‰é¨–é¨™é¬é¯¨é¯§é¯–é¯›é¶‰éµ¡éµ²éµªéµ¬éº’éº—éº“éº´å‹¸åš¨åš·åš¶åš´åš¼å£¤å­€å­ƒå­½å¯¶å·‰æ‡¸æ‡ºæ”˜æ””æ”™æ›¦æœ§æ«¬ç€¾ç€°ç€²çˆç»ç“ç™¢ç™¥ç¤¦ç¤ªç¤¬ç¤«ç«‡ç«¶ç±Œç±ƒç±ç³¯ç³°è¾®ç¹½ç¹¼"],
+		["c4a1", "çº‚ç½Œè€€è‡šè‰¦è—»è—¹è˜‘è—ºè˜†è˜‹è˜‡è˜Šè ”è •è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­Ÿè­«è´è´èº‰èºèº…èº‚é†´é‡‹é˜éƒé½é—¡éœ°é£„é¥’é¥‘é¦¨é¨«é¨°é¨·é¨µé°“é°é¹¹éºµé»¨é¼¯é½Ÿé½£é½¡å„·å„¸å›å›€å›‚å¤”å±¬å·æ‡¼æ‡¾æ”æ”œæ–•æ›©æ«»æ¬„æ«ºæ®²çŒçˆ›çŠ§ç“–ç“”ç™©çŸ“ç±çºçºŒç¾¼è˜—è˜­è˜šè £è ¢è ¡è Ÿè¥ªè¥¬è¦½è­´"],
+		["c540", "è­·è­½è´“èºŠèºèº‹è½Ÿè¾¯é†ºé®é³éµéºé¸é²é«é—¢éœ¸éœ¹éœ²éŸ¿é¡§é¡¥é¥—é©…é©ƒé©€é¨¾é«é­”é­‘é°­é°¥é¶¯é¶´é·‚é¶¸éºé»¯é¼™é½œé½¦é½§å„¼å„»å›ˆå›Šå›‰å­¿å·”å·’å½Žæ‡¿æ”¤æ¬Šæ­¡ç‘ç˜çŽ€ç“¤ç–Šç™®ç™¬"],
+		["c5a1", "ç¦³ç± ç±Ÿè¾è½è‡Ÿè¥²è¥¯è§¼è®€è´–è´—èº‘èº“è½¡é…ˆé‘„é‘‘é‘’éœ½éœ¾éŸƒéŸé¡«é¥•é©•é©é«’é¬šé±‰é°±é°¾é°»é·“é·—é¼´é½¬é½ªé¾”å›Œå·–æˆ€æ”£æ”«æ”ªæ›¬æ¬ç“šç«Šç±¤ç±£ç±¥çº“çº–çº”è‡¢è˜¸è˜¿è ±è®Šé‚é‚é‘£é‘ é‘¤é¨é¡¯é¥œé©šé©›é©—é«“é«”é«‘é±”é±—é±–é·¥éºŸé»´å›‘å£©æ”¬çžç™±ç™²çŸ—ç½ç¾ˆè ¶è ¹è¡¢è®“è®’"],
+		["c640", "è®–è‰·è´›é‡€é‘ªé‚éˆé„éŸ†é¡°é©Ÿé¬¢é­˜é±Ÿé·¹é·ºé¹¼é¹½é¼‡é½·é½²å»³æ¬–ç£ç±¬ç±®è »è§€èº¡é‡é‘²é‘°é¡±é¥žé«–é¬£é»Œç¤çŸšè®šé‘·éŸ‰é©¢é©¥çºœè®œèºªé‡…é‘½é‘¾é‘¼é±·é±¸é»·è±”é‘¿é¸šçˆ¨é©ªé¬±é¸›é¸žç±²"],
+		["c940", "ä¹‚ä¹œå‡µåŒšåŽ‚ä¸‡ä¸Œä¹‡äºå›—ï¨Œå±®å½³ä¸å†‡ä¸Žä¸®äº“ä»‚ä»‰ä»ˆå†˜å‹¼å¬åŽ¹åœ å¤ƒå¤¬å°å·¿æ—¡æ®³æ¯Œæ°”çˆ¿ä¸±ä¸¼ä»¨ä»œä»©ä»¡ä»ä»šåˆŒåŒœåŒåœ¢åœ£å¤—å¤¯å®å®„å°’å°»å±´å±³å¸„åº€åº‚å¿‰æˆ‰æ‰æ°•"],
+		["c9a1", "æ°¶æ±ƒæ°¿æ°»çŠ®çŠ°çŽŠç¦¸è‚Šé˜žä¼Žä¼˜ä¼¬ä»µä¼”ä»±ä¼€ä»·ä¼ˆä¼ä¼‚ä¼…ä¼¢ä¼“ä¼„ä»´ä¼’å†±åˆ“åˆ‰åˆåŠ¦åŒ¢åŒŸååŽŠå‡å›¡å›Ÿåœ®åœªåœ´å¤¼å¦€å¥¼å¦…å¥»å¥¾å¥·å¥¿å­–å°•å°¥å±¼å±ºå±»å±¾å·Ÿå¹µåº„å¼‚å¼šå½´å¿•å¿”å¿æ‰œæ‰žæ‰¤æ‰¡æ‰¦æ‰¢æ‰™æ‰ æ‰šæ‰¥æ—¯æ—®æœ¾æœ¹æœ¸æœ»æœºæœ¿æœ¼æœ³æ°˜æ±†æ±’æ±œæ±æ±Šæ±”æ±‹"],
+		["ca40", "æ±Œç±ç‰žçŠ´çŠµçŽŽç”ªç™¿ç©µç½‘è‰¸è‰¼èŠ€è‰½è‰¿è™è¥¾é‚™é‚—é‚˜é‚›é‚”é˜¢é˜¤é˜ é˜£ä½–ä¼»ä½¢ä½‰ä½“ä½¤ä¼¾ä½§ä½’ä½Ÿä½ä½˜ä¼­ä¼³ä¼¿ä½¡å†å†¹åˆœåˆžåˆ¡åŠ­åŠ®åŒ‰å£å²åŽŽåŽå°å·åªå‘”å‘…å™åœå¥å˜"],
+		["caa1", "å½å‘å‘å¨å¤å‘‡å›®å›§å›¥åå…åŒå‰å‹å’å¤†å¥€å¦¦å¦˜å¦ å¦—å¦Žå¦¢å¦å¦å¦§å¦¡å®Žå®’å°¨å°ªå²å²å²ˆå²‹å²‰å²’å²Šå²†å²“å²•å· å¸Šå¸Žåº‹åº‰åºŒåºˆåºå¼…å¼å½¸å½¶å¿’å¿‘å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æ€€å¿´æˆºæŠƒæŠŒæŠŽæŠæŠ”æŠ‡æ‰±æ‰»æ‰ºæ‰°æŠæŠˆæ‰·æ‰½æ‰²æ‰´æ”·æ—°æ—´æ—³æ—²æ—µæ…æ‡"],
+		["cb40", "æ™æ•æŒæˆæææšæ‹æ¯æ°™æ°šæ±¸æ±§æ±«æ²„æ²‹æ²æ±±æ±¯æ±©æ²šæ±­æ²‡æ²•æ²œæ±¦æ±³æ±¥æ±»æ²Žç´çºç‰£çŠ¿çŠ½ç‹ƒç‹†ç‹çŠºç‹…çŽ•çŽ—çŽ“çŽ”çŽ’ç”ºç”¹ç–”ç–•çšç¤½è€´è‚•è‚™è‚è‚’è‚œèŠèŠèŠ…èŠŽèŠ‘èŠ“"],
+		["cba1", "èŠŠèŠƒèŠ„è±¸è¿‰è¾¿é‚Ÿé‚¡é‚¥é‚žé‚§é‚ é˜°é˜¨é˜¯é˜­ä¸³ä¾˜ä½¼ä¾…ä½½ä¾€ä¾‡ä½¶ä½´ä¾‰ä¾„ä½·ä½Œä¾—ä½ªä¾šä½¹ä¾ä½¸ä¾ä¾œä¾”ä¾žä¾’ä¾‚ä¾•ä½«ä½®å†žå†¼å†¾åˆµåˆ²åˆ³å‰†åˆ±åŠ¼åŒŠåŒ‹åŒ¼åŽ’åŽ”å’‡å‘¿å’å’‘å’‚å’ˆå‘«å‘ºå‘¾å‘¥å‘¬å‘´å‘¦å’å‘¯å‘¡å‘ å’˜å‘£å‘§å‘¤å›·å›¹å¯å²å­å«å±å°å¶åž€åµå»å³å´å¢"],
+		["cc40", "å¨å½å¤Œå¥…å¦µå¦ºå§å§Žå¦²å§Œå§å¦¶å¦¼å§ƒå§–å¦±å¦½å§€å§ˆå¦´å§‡å­¢å­¥å®“å®•å±„å±‡å²®å²¤å² å²µå²¯å²¨å²¬å²Ÿå²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸—å¸”å¸™å¼¨å¼¢å¼£å¼¤å½”å¾‚å½¾å½½å¿žå¿¥æ€­æ€¦æ€™æ€²æ€‹"],
+		["cca1", "æ€´æ€Šæ€—æ€³æ€šæ€žæ€¬æ€¢æ€æ€æ€®æ€“æ€‘æ€Œæ€‰æ€œæˆ”æˆ½æŠ­æŠ´æ‹‘æŠ¾æŠªæŠ¶æ‹ŠæŠ®æŠ³æŠ¯æŠ»æŠ©æŠ°æŠ¸æ”½æ–¨æ–»æ˜‰æ—¼æ˜„æ˜’æ˜ˆæ—»æ˜ƒæ˜‹æ˜æ˜…æ—½æ˜‘æ˜æ›¶æœŠæž…æ¬æžŽæž’æ¶æ»æž˜æž†æž„æ´æžæžŒæºæžŸæž‘æž™æžƒæ½æžæ¸æ¹æž”æ¬¥æ®€æ­¾æ¯žæ°æ²“æ³¬æ³«æ³®æ³™æ²¶æ³”æ²­æ³§æ²·æ³æ³‚æ²ºæ³ƒæ³†æ³­æ³²"],
+		["cd40", "æ³’æ³æ²´æ²Šæ²æ²€æ³žæ³€æ´°æ³æ³‡æ²°æ³¹æ³æ³©æ³‘ç‚”ç‚˜ç‚…ç‚“ç‚†ç‚„ç‚‘ç‚–ç‚‚ç‚šç‚ƒç‰ªç‹–ç‹‹ç‹˜ç‹‰ç‹œç‹’ç‹”ç‹šç‹Œç‹‘çŽ¤çŽ¡çŽ­çŽ¦çŽ¢çŽ çŽ¬çŽç“ç“¨ç”¿ç•€ç”¾ç–Œç–˜çš¯ç›³ç›±ç›°ç›µçŸ¸çŸ¼çŸ¹çŸ»çŸº"],
+		["cda1", "çŸ·ç¥‚ç¤¿ç§…ç©¸ç©»ç«»ç±µç³½è€µè‚è‚®è‚£è‚¸è‚µè‚­èˆ èŠ è‹€èŠ«èŠšèŠ˜èŠ›èŠµèŠ§èŠ®èŠ¼èŠžèŠºèŠ´èŠ¨èŠ¡èŠ©è‹‚èŠ¤è‹ƒèŠ¶èŠ¢è™°è™¯è™­è™®è±–è¿’è¿‹è¿“è¿è¿–è¿•è¿—é‚²é‚´é‚¯é‚³é‚°é˜¹é˜½é˜¼é˜ºé™ƒä¿ä¿…ä¿“ä¾²ä¿‰ä¿‹ä¿ä¿”ä¿œä¿™ä¾»ä¾³ä¿›ä¿‡ä¿–ä¾ºä¿€ä¾¹ä¿¬å‰„å‰‰å‹€å‹‚åŒ½å¼åŽ—åŽ–åŽ™åŽ˜å’ºå’¡å’­å’¥å“"],
+		["ce40", "å“ƒèŒå’·å’®å“–å’¶å“…å“†å’ å‘°å’¼å’¢å’¾å‘²å“žå’°åžµåžžåžŸåž¤åžŒåž—åžåž›åž”åž˜åžåž™åž¥åžšåž•å£´å¤å¥“å§¡å§žå§®å¨€å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§›å§©å§³å§µå§ å§¾å§´å§­å®¨å±Œå³å³˜å³Œå³—å³‹å³›"],
+		["cea1", "å³žå³šå³‰å³‡å³Šå³–å³“å³”å³å³ˆå³†å³Žå³Ÿå³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åº›åº£åº¥å¼‡å¼®å½–å¾†æ€·æ€¹æ”æ²æžæ…æ“æ‡æ‰æ›æŒæ€æ‚æŸæ€¤æ„æ˜æ¦æ®æ‰‚æ‰ƒæ‹æŒæŒ‹æ‹µæŒŽæŒƒæ‹«æ‹¹æŒæŒŒæ‹¸æ‹¶æŒ€æŒ“æŒ”æ‹ºæŒ•æ‹»æ‹°æ•æ•ƒæ–ªæ–¿æ˜¶æ˜¡æ˜²æ˜µæ˜œæ˜¦æ˜¢æ˜³æ˜«æ˜ºæ˜æ˜´æ˜¹æ˜®æœæœæŸæŸ²æŸˆæžº"],
+		["cf40", "æŸœæž»æŸ¸æŸ˜æŸ€æž·æŸ…æŸ«æŸ¤æŸŸæžµæŸæž³æŸ·æŸ¶æŸ®æŸ£æŸ‚æž¹æŸŽæŸ§æŸ°æž²æŸ¼æŸ†æŸ­æŸŒæž®æŸ¦æŸ›æŸºæŸ‰æŸŠæŸƒæŸªæŸ‹æ¬¨æ®‚æ®„æ®¶æ¯–æ¯˜æ¯ æ° æ°¡æ´¨æ´´æ´­æ´Ÿæ´¼æ´¿æ´’æ´Šæ³šæ´³æ´„æ´™æ´ºæ´šæ´‘æ´€æ´æµ‚"],
+		["cfa1", "æ´æ´˜æ´·æ´ƒæ´æµ€æ´‡æ´ æ´¬æ´ˆæ´¢æ´‰æ´ç‚·ç‚Ÿç‚¾ç‚±ç‚°ç‚¡ç‚´ç‚µç‚©ç‰ç‰‰ç‰Šç‰¬ç‰°ç‰³ç‰®ç‹Šç‹¤ç‹¨ç‹«ç‹Ÿç‹ªç‹¦ç‹£çŽ…çŒç‚çˆç…çŽ¹çŽ¶çŽµçŽ´ç«çŽ¿ç‡çŽ¾çƒç†çŽ¸ç‹ç“¬ç“®ç”®ç•‡ç•ˆç–§ç–ªç™¹ç›„çœˆçœƒçœ„çœ…çœŠç›·ç›»ç›ºçŸ§çŸ¨ç †ç ‘ç ’ç …ç ç ç Žç ‰ç ƒç “ç¥Šç¥Œç¥‹ç¥…ç¥„ç§•ç§ç§ç§–ç§Žçª€"],
+		["d040", "ç©¾ç«‘ç¬€ç¬ç±ºç±¸ç±¹ç±¿ç²€ç²ç´ƒç´ˆç´ç½˜ç¾‘ç¾ç¾¾è€‡è€Žè€è€”è€·èƒ˜èƒ‡èƒ èƒ‘èƒˆèƒ‚èƒèƒ…èƒ£èƒ™èƒœèƒŠèƒ•èƒ‰èƒèƒ—èƒ¦èƒè‡¿èˆ¡èŠ”è‹™è‹¾è‹¹èŒ‡è‹¨èŒ€è‹•èŒºè‹«è‹–è‹´è‹¬è‹¡è‹²è‹µèŒŒè‹»è‹¶è‹°è‹ª"],
+		["d0a1", "è‹¤è‹ è‹ºè‹³è‹­è™·è™´è™¼è™³è¡è¡Žè¡§è¡ªè¡©è§“è¨„è¨‡èµ²è¿£è¿¡è¿®è¿ éƒ±é‚½é‚¿éƒ•éƒ…é‚¾éƒ‡éƒ‹éƒˆé‡”é‡“é™”é™é™‘é™“é™Šé™Žå€žå€…å€‡å€“å€¢å€°å€›ä¿µä¿´å€³å€·å€¬ä¿¶ä¿·å€—å€œå€ å€§å€µå€¯å€±å€Žå…šå†”å†“å‡Šå‡„å‡…å‡ˆå‡Žå‰¡å‰šå‰’å‰žå‰Ÿå‰•å‰¢å‹åŒŽåŽžå”¦å“¢å”—å”’å“§å“³å“¤å”šå“¿å”„å”ˆå“«å”‘å”…å“±"],
+		["d140", "å”Šå“»å“·å“¸å“ å”Žå”ƒå”‹åœåœ‚åŸŒå ²åŸ•åŸ’åžºåŸ†åž½åž¼åž¸åž¶åž¿åŸ‡åŸåž¹åŸå¤Žå¥Šå¨™å¨–å¨­å¨®å¨•å¨å¨—å¨Šå¨žå¨³å­¬å®§å®­å®¬å°ƒå±–å±”å³¬å³¿å³®å³±å³·å´€å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§ææšæ§"],
+		["d1a1", "ææ‚¢æ‚ˆæ‚€æ‚’æ‚æ‚æ‚ƒæ‚•æ‚›æ‚—æ‚‡æ‚œæ‚Žæˆ™æ‰†æ‹²æŒæ–æŒ¬æ„æ…æŒ¶æƒæ¤æŒ¹æ‹æŠæŒ¼æŒ©ææŒ´æ˜æ”æ™æŒ­æ‡æŒ³æšæ‘æŒ¸æ—æ€æˆæ•Šæ•†æ—†æ—ƒæ—„æ—‚æ™Šæ™Ÿæ™‡æ™‘æœ’æœ“æ Ÿæ šæ¡‰æ ²æ ³æ »æ¡‹æ¡æ –æ ±æ œæ µæ «æ ­æ ¯æ¡Žæ¡„æ ´æ æ ’æ ”æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­è‚‚æ®ˆæ¯¦æ¯¤"],
+		["d240", "æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶’æµ˜æµ¢æµ­æµ¯æ¶‘æ¶æ·¯æµ¿æ¶†æµžæµ§æµ æ¶—æµ°æµ¼æµŸæ¶‚æ¶˜æ´¯æµ¨æ¶‹æµ¾æ¶€æ¶„æ´–æ¶ƒæµ»æµ½æµµæ¶çƒœçƒ“çƒ‘çƒçƒ‹ç¼¹çƒ¢çƒ—çƒ’çƒžçƒ çƒ”çƒçƒ…çƒ†çƒ‡çƒšçƒŽçƒ¡ç‰‚ç‰¸"],
+		["d2a1", "ç‰·ç‰¶çŒ€ç‹ºç‹´ç‹¾ç‹¶ç‹³ç‹»çŒç“ç™ç¥ç–çŽ¼ç§ç£ç©çœç’ç›ç”ççšç—ç˜ç¨ç“žç“Ÿç“´ç“µç”¡ç•›ç•Ÿç–°ç—ç–»ç—„ç—€ç–¿ç–¶ç–ºçšŠç›‰çœçœ›çœçœ“çœ’çœ£çœ‘çœ•çœ™çœšçœ¢çœ§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥”ç¥›ç¥ç¥œç¥“ç¥’ç¥‘ç§«ç§¬ç§ ç§®ç§­ç§ªç§œç§žç§çª†çª‰çª…çª‹çªŒçªŠçª‡ç«˜ç¬"],
+		["d340", "ç¬„ç¬“ç¬…ç¬ç¬ˆç¬Šç¬Žç¬‰ç¬’ç²„ç²‘ç²Šç²Œç²ˆç²ç²…ç´žç´ç´‘ç´Žç´˜ç´–ç´“ç´Ÿç´’ç´ç´Œç½œç½¡ç½žç½ ç½ç½›ç¾–ç¾’ç¿ƒç¿‚ç¿€è€–è€¾è€¹èƒºèƒ²èƒ¹èƒµè„èƒ»è„€èˆèˆ¯èˆ¥èŒ³èŒ­è„èŒ™è‘èŒ¥è–èŒ¿èèŒ¦èŒœèŒ¢"],
+		["d3a1", "è‚èŽèŒ›èŒªèŒˆèŒ¼èèŒ–èŒ¤èŒ èŒ·èŒ¯èŒ©è‡è…èŒè“èŒžèŒ¬è‹èŒ§èˆè™“è™’èš¢èš¨èš–èšèš‘èšžèš‡èš—èš†èš‹èššèš…èš¥èš™èš¡èš§èš•èš˜èšŽèšèšèš”è¡ƒè¡„è¡­è¡µè¡¶è¡²è¢€è¡±è¡¿è¡¯è¢ƒè¡¾è¡´è¡¼è¨’è±‡è±—è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»‘è»“è¿¾è¿µé€‚è¿¿è¿»é€„è¿¼è¿¶éƒ–éƒ éƒ™éƒšéƒ£éƒŸéƒ¥éƒ˜éƒ›éƒ—éƒœéƒ¤é…"],
+		["d440", "é…Žé…é‡•é‡¢é‡šé™œé™Ÿéš¼é££é«Ÿé¬¯ä¹¿å°åªå¡åžå å“å‹åå²åˆååå›åŠå¢å€•å…åŸå©å«å£å¤å†å€å®å³å—å‘å‡å‰«å‰­å‰¬å‰®å‹–å‹“åŒ­åŽœå•µå•¶å”¼å•å•å”´å”ªå•‘å•¢å”¶å”µå”°å•’å•…"],
+		["d4a1", "å”Œå”²å•¥å•Žå”¹å•ˆå”­å”»å•€å•‹åœŠåœ‡åŸ»å ”åŸ¢åŸ¶åŸœåŸ´å €åŸ­åŸ½å ˆåŸ¸å ‹åŸ³åŸå ‡åŸ®åŸ£åŸ²åŸ¥åŸ¬åŸ¡å ŽåŸ¼å åŸ§å å ŒåŸ±åŸ©åŸ°å å „å¥œå© å©˜å©•å©§å©žå¨¸å¨µå©­å©å©Ÿå©¥å©¬å©“å©¤å©—å©ƒå©å©’å©„å©›å©ˆåªŽå¨¾å©å¨¹å©Œå©°å©©å©‡å©‘å©–å©‚å©œå­²å­®å¯å¯€å±™å´žå´‹å´å´šå´ å´Œå´¨å´å´¦å´¥å´"],
+		["d540", "å´°å´’å´£å´Ÿå´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾›å¾–å¾Ÿæ‚Šæ‚æ‚†æ‚¾æ‚°æ‚ºæƒ“æƒ”æƒæƒ¤æƒ™æƒæƒˆæ‚±æƒ›æ‚·æƒŠæ‚¿æƒƒæƒæƒ€æŒ²æ¥æŽŠæŽ‚æ½æŽ½æŽžæŽ­æŽæŽ—æŽ«æŽŽæ¯æŽ‡æŽæ®æŽ¯æµæŽœæ­æŽ®æ¼æŽ¤æŒ»æŽŸ"],
+		["d5a1", "æ¸æŽ…æŽæŽ‘æŽæ°æ•“æ—æ™¥æ™¡æ™›æ™™æ™œæ™¢æœ˜æ¡¹æ¢‡æ¢æ¢œæ¡­æ¡®æ¢®æ¢«æ¥–æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢’æ¡¼æ¡«æ¡²æ¢ªæ¢€æ¡±æ¡¾æ¢›æ¢–æ¢‹æ¢ æ¢‰æ¢¤æ¡¸æ¡»æ¢‘æ¢Œæ¢Šæ¡½æ¬¶æ¬³æ¬·æ¬¸æ®‘æ®æ®æ®Žæ®Œæ°ªæ·€æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·”æ¸€æ·ˆæ· æ·Ÿæ·–æ¶¾æ·¥æ·œæ·æ·›æ·´æ·Šæ¶½æ·­æ·°æ¶ºæ·•æ·‚æ·æ·‰"],
+		["d640", "æ·æ·²æ·“æ·½æ·—æ·æ·£æ¶»çƒºç„çƒ·ç„—çƒ´ç„Œçƒ°ç„„çƒ³ç„çƒ¼çƒ¿ç„†ç„“ç„€çƒ¸çƒ¶ç„‹ç„‚ç„Žç‰¾ç‰»ç‰¼ç‰¿çŒçŒ—çŒ‡çŒ‘çŒ˜çŒŠçŒˆç‹¿çŒçŒžçŽˆç¶ç¸çµç„çç½ç‡ç€çºç¼ç¿çŒç‹ç´çˆç•¤ç•£ç—Žç—’ç—"],
+		["d6a1", "ç—‹ç—Œç—‘ç—çšçš‰ç›“çœ¹çœ¯çœ­çœ±çœ²çœ´çœ³çœ½çœ¥çœ»çœµç¡ˆç¡’ç¡‰ç¡ç¡Šç¡Œç ¦ç¡…ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçª”çªç¬µç­‡ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬˜ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬šç¬£ç²”ç²˜ç²–ç²£ç´µç´½ç´¸ç´¶ç´ºçµ…ç´¬ç´©çµçµ‡ç´¾ç´¿çµŠç´»ç´¨ç½£ç¾•ç¾œç¾ç¾›ç¿Šç¿‹ç¿ç¿ç¿‘ç¿‡ç¿ç¿‰è€Ÿ"],
+		["d740", "è€žè€›è‡èƒèˆè„˜è„¥è„™è„›è„­è„Ÿè„¬è„žè„¡è„•è„§è„è„¢èˆ‘èˆ¸èˆ³èˆºèˆ´èˆ²è‰´èŽèŽ£èŽ¨èŽèºè³èŽ¤è´èŽèŽèŽ•èŽ™èµèŽ”èŽ©è½èŽƒèŽŒèŽèŽ›èŽªèŽ‹è¾èŽ¥èŽ¯èŽˆèŽ—èŽ°è¿èŽ¦èŽ‡èŽ®è¶èŽšè™™è™–èš¿èš·"],
+		["d7a1", "è›‚è›è›…èšºèš°è›ˆèš¹èš³èš¸è›Œèš´èš»èš¼è›ƒèš½èš¾è¡’è¢‰è¢•è¢¨è¢¢è¢ªè¢šè¢‘è¢¡è¢Ÿè¢˜è¢§è¢™è¢›è¢—è¢¤è¢¬è¢Œè¢“è¢Žè¦‚è§–è§™è§•è¨°è¨§è¨¬è¨žè°¹è°»è±œè±è±½è²¥èµ½èµ»èµ¹è¶¼è·‚è¶¹è¶¿è·è»˜è»žè»è»œè»—è» è»¡é€¤é€‹é€‘é€œé€Œé€¡éƒ¯éƒªéƒ°éƒ´éƒ²éƒ³éƒ”éƒ«éƒ¬éƒ©é…–é…˜é…šé…“é…•é‡¬é‡´é‡±é‡³é‡¸é‡¤é‡¹é‡ª"],
+		["d840", "é‡«é‡·é‡¨é‡®é•ºé–†é–ˆé™¼é™­é™«é™±é™¯éš¿éªé „é£¥é¦—å‚›å‚•å‚”å‚žå‚‹å‚£å‚ƒå‚Œå‚Žå‚å¨å‚œå‚’å‚‚å‚‡å…Ÿå‡”åŒ’åŒ‘åŽ¤åŽ§å–‘å–¨å–¥å–­å•·å™…å–¢å–“å–ˆå–å–µå–å–£å–’å–¤å•½å–Œå–¦å•¿å–•å–¡å–ŽåœŒå ©å ·"],
+		["d8a1", "å ™å žå §å £å ¨åŸµå¡ˆå ¥å œå ›å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åª”åªŸå©ºåª¢åªžå©¸åª¦å©¼åª¥åª¬åª•åª®å¨·åª„åªŠåª—åªƒåª‹åª©å©»å©½åªŒåªœåªåª“åªå¯ªå¯å¯‹å¯”å¯‘å¯Šå¯Žå°Œå°°å´·åµƒåµ«åµåµ‹å´¿å´µåµ‘åµŽåµ•å´³å´ºåµ’å´½å´±åµ™åµ‚å´¹åµ‰å´¸å´¼å´²å´¶åµ€åµ…å¹„å¹å½˜å¾¦å¾¥å¾«æƒ‰æ‚¹æƒŒæƒ¢æƒŽæƒ„æ„”"],
+		["d940", "æƒ²æ„Šæ„–æ„…æƒµæ„“æƒ¸æƒ¼æƒ¾æƒæ„ƒæ„˜æ„æ„æƒ¿æ„„æ„‹æ‰ŠæŽ”æŽ±æŽ°æŽæ¥æ¨æ¯æƒæ’æ³æŠæ æ¶æ•æ²æµæ‘¡æŸæŽ¾ææœæ„æ˜æ“æ‚æ‡æŒæ‹æˆæ°æ—æ™æ”²æ•§æ•ªæ•¤æ•œæ•¨æ•¥æ–Œæ–æ–žæ–®æ—æ—’"],
+		["d9a1", "æ™¼æ™¬æ™»æš€æ™±æ™¹æ™ªæ™²æœæ¤Œæ£“æ¤„æ£œæ¤ªæ£¬æ£ªæ£±æ¤æ£–æ£·æ£«æ£¤æ£¶æ¤“æ¤æ£³æ£¡æ¤‡æ£Œæ¤ˆæ¥°æ¢´æ¤‘æ£¯æ£†æ¤”æ£¸æ£æ£½æ£¼æ£¨æ¤‹æ¤Šæ¤—æ£Žæ£ˆæ£æ£žæ£¦æ£´æ£‘æ¤†æ£”æ£©æ¤•æ¤¥æ£‡æ¬¹æ¬»æ¬¿æ¬¼æ®”æ®—æ®™æ®•æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹†æ¹‡æ¸Ÿæ¹‰æºˆæ¸¼æ¸½æ¹…æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸œæ¸³æ¹‹æ¹€æ¹‘æ¸»æ¸ƒæ¸®æ¹ž"],
+		["da40", "æ¹¨æ¹œæ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹“æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹•æ¹¹æ¹’æ¹¦æ¸µæ¸¶æ¹šç„ ç„žç„¯çƒ»ç„®ç„±ç„£ç„¥ç„¢ç„²ç„Ÿç„¨ç„ºç„›ç‰‹ç‰šçŠˆçŠ‰çŠ†çŠ…çŠ‹çŒ’çŒ‹çŒ°çŒ¢çŒ±çŒ³çŒ§çŒ²çŒ­çŒ¦çŒ£çŒµçŒŒç®ç¬ç°ç«ç–"],
+		["daa1", "çšç¡ç­ç±ç¤ç£çç©ç ç²ç“»ç”¯ç•¯ç•¬ç—§ç—šç—¡ç—¦ç—ç—Ÿç—¤ç——çš•çš’ç›šç†ç‡ç„çç…çŠçŽç‹çŒçŸžçŸ¬ç¡ ç¡¤ç¡¥ç¡œç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡žç¡¢ç¥´ç¥³ç¥²ç¥°ç¨‚ç¨Šç¨ƒç¨Œç¨„çª™ç«¦ç«¤ç­Šç¬»ç­„ç­ˆç­Œç­Žç­€ç­˜ç­…ç²¢ç²žç²¨ç²¡çµ˜çµ¯çµ£çµ“çµ–çµ§çµªçµçµ­çµœçµ«çµ’çµ”çµ©çµ‘çµŸçµŽç¼¾ç¼¿ç½¥"],
+		["db40", "ç½¦ç¾¢ç¾ ç¾¡ç¿—è‘èèèƒ¾èƒ”è…ƒè…Šè…’è…è…‡è„½è…è„ºè‡¦è‡®è‡·è‡¸è‡¹èˆ„èˆ¼èˆ½èˆ¿è‰µèŒ»èè¹è£è€è¨è’è§è¤è¼è¶èè†èˆè«è£èŽ¿èèè¥è˜è¿è¡è‹èŽè–èµè‰è‰èèžè‘è†è‚è³"],
+		["dba1", "è•èºè‡è‘èªè“èƒè¬è®è„è»è—è¢è›è›è¾è›˜è›¢è›¦è›“è›£è›šè›ªè›è›«è›œè›¬è›©è›—è›¨è›‘è¡ˆè¡–è¡•è¢ºè£—è¢¹è¢¸è£€è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£‰è¦•è¦˜è¦—è§è§šè§›è©Žè©è¨¹è©™è©€è©—è©˜è©„è©…è©’è©ˆè©‘è©Šè©Œè©è±Ÿè²è²€è²ºè²¾è²°è²¹è²µè¶„è¶€è¶‰è·˜è·“è·è·‡è·–è·œè·è·•è·™è·ˆè·—è·…è»¯è»·è»º"],
+		["dc40", "è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é€­é€´é€¯é„†é„¬é„„éƒ¿éƒ¼é„ˆéƒ¹éƒ»é„é„€é„‡é„…é„ƒé…¡é…¤é…Ÿé…¢é… éˆéˆŠéˆ¥éˆƒéˆšéˆ¦éˆéˆŒéˆ€éˆ’é‡¿é‡½éˆ†éˆ„éˆ§éˆ‚éˆœéˆ¤éˆ™éˆ—éˆ…éˆ–é•»é–é–Œé–éš‡é™¾éšˆ"],
+		["dca1", "éš‰éšƒéš€é›‚é›ˆé›ƒé›±é›°é¬é°é®é ‡é¢©é£«é³¦é»¹äºƒäº„äº¶å‚½å‚¿åƒ†å‚®åƒ„åƒŠå‚´åƒˆåƒ‚å‚°åƒå‚ºå‚±åƒ‹åƒ‰å‚¶å‚¸å‡—å‰ºå‰¸å‰»å‰¼å—ƒå—›å—Œå—å—‹å—Šå—å—€å—”å—„å—©å–¿å—’å–å—å—•å—¢å—–å—ˆå—²å—å—™å—‚åœ”å¡“å¡¨å¡¤å¡å¡å¡‰å¡¯å¡•å¡Žå¡å¡™å¡¥å¡›å ½å¡£å¡±å£¼å«‡å«„å«‹åªºåª¸åª±åªµåª°åª¿å«ˆåª»å«†"],
+		["dd40", "åª·å«€å«Šåª´åª¶å«åª¹åªå¯–å¯˜å¯™å°Ÿå°³åµ±åµ£åµŠåµ¥åµ²åµ¬åµžåµ¨åµ§åµ¢å·°å¹å¹Žå¹Šå¹å¹‹å»…å»Œå»†å»‹å»‡å½€å¾¯å¾­æƒ·æ…‰æ…Šæ„«æ……æ„¶æ„²æ„®æ…†æ„¯æ…æ„©æ…€æˆ é…¨æˆ£æˆ¥æˆ¤æ…æ±æ«ææ’æ‰æ æ¤"],
+		["dda1", "æ³æ‘ƒæŸæ•æ˜æ¹æ·æ¢æ£æŒæ¦æ°æ¨æ‘æµæ¯æŠæšæ‘€æ¥æ§æ‹æ§æ›æ®æ¡æŽæ•¯æ–’æ—“æš†æšŒæš•æšæš‹æšŠæš™æš”æ™¸æœ æ¥¦æ¥Ÿæ¤¸æ¥Žæ¥¢æ¥±æ¤¿æ¥…æ¥ªæ¤¹æ¥‚æ¥—æ¥™æ¥ºæ¥ˆæ¥‰æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥€æ¥¯æ¥„æ¥¶æ¥˜æ¥æ¥´æ¥Œæ¤»æ¥‹æ¤·æ¥œæ¥æ¥‘æ¤²æ¥’æ¤¯æ¥»æ¤¼æ­†æ­…æ­ƒæ­‚æ­ˆæ­æ®›ï¨æ¯»æ¯¼"],
+		["de40", "æ¯¹æ¯·æ¯¸æº›æ»–æ»ˆæºæ»€æºŸæº“æº”æº æº±æº¹æ»†æ»’æº½æ»æºžæ»‰æº·æº°æ»æº¦æ»æº²æº¾æ»ƒæ»œæ»˜æº™æº’æºŽæºæº¤æº¡æº¿æº³æ»æ»Šæº—æº®æº£ç…‡ç…”ç…’ç…£ç… ç…ç…ç…¢ç…²ç…¸ç…ªç…¡ç…‚ç…˜ç…ƒç…‹ç…°ç…Ÿç…ç…“"],
+		["dea1", "ç…„ç…ç…šç‰çŠçŠŒçŠ‘çŠçŠŽçŒ¼ç‚çŒ»çŒºç€çŠç‰ç‘„ç‘Šç‘‹ç‘’ç‘‘ç‘—ç‘€ç‘ç‘ç‘Žç‘‚ç‘†ç‘ç‘”ç“¡ç“¿ç“¾ç“½ç”ç•¹ç•·æ¦ƒç—¯ç˜ç˜ƒç—·ç—¾ç—¼ç—¹ç—¸ç˜ç—»ç—¶ç—­ç—µç—½çš™çšµç›ç•çŸç ç’ç–çšç©ç§ç”ç™ç­çŸ ç¢‡ç¢šç¢”ç¢ç¢„ç¢•ç¢…ç¢†ç¢¡ç¢ƒç¡¹ç¢™ç¢€ç¢–ç¡»ç¥¼ç¦‚ç¥½ç¥¹ç¨‘ç¨˜ç¨™ç¨’ç¨—ç¨•ç¨¢ç¨“"],
+		["df40", "ç¨›ç¨çª£çª¢çªžç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ˆç¶†ç¶€ç¶çµ¿ç¶…çµºç¶Žçµ»ç¶ƒçµ¼ç¶Œç¶”ç¶„çµ½ç¶’ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿›ç¿œè€¡è…¤è… è…·è…œè…©è…›è…¢è…²æœ¡è…žè…¶è…§è…¯"],
+		["dfa1", "è…„è…¡èˆè‰‰è‰„è‰€è‰‚è‰…è“±è¿è‘–è‘¶è‘¹è’è’è‘¥è‘‘è‘€è’†è‘§è°è‘è‘½è‘šè‘™è‘´è‘³è‘è”‡è‘žè·èºè´è‘ºè‘ƒè‘¸è²è‘…è©è™è‘‹è¯è‘‚è­è‘Ÿè‘°è¹è‘Žè‘Œè‘’è‘¯è“…è’Žè»è‘‡è¶è³è‘¨è‘¾è‘„è«è‘ è‘”è‘®è‘èœ‹èœ„è›·èœŒè›ºè›–è›µèè›¸èœŽèœ‰èœè›¶èœèœ…è£–è£‹è£è£Žè£žè£›è£šè£Œè£è¦…è¦›è§Ÿè§¥è§¤"],
+		["e040", "è§¡è§ è§¢è§œè§¦è©¶èª†è©¿è©¡è¨¿è©·èª‚èª„è©µèªƒèªè©´è©ºè°¼è±‹è±Šè±¥è±¤è±¦è²†è²„è²…è³Œèµ¨èµ©è¶‘è¶Œè¶Žè¶è¶è¶“è¶”è¶è¶’è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼†è»¿è¼è¼€è¼…è¼‡è¼ˆè¼‚è¼‹é’é€¿"],
+		["e0a1", "é„é‰é€½é„é„é„é„‘é„–é„”é„‹é„Žé…®é…¯é‰ˆé‰’éˆ°éˆºé‰¦éˆ³é‰¥é‰žéŠƒéˆ®é‰Šé‰†é‰­é‰¬é‰é‰ é‰§é‰¯éˆ¶é‰¡é‰°éˆ±é‰”é‰£é‰é‰²é‰Žé‰“é‰Œé‰–éˆ²é–Ÿé–œé–žé–›éš’éš“éš‘éš—é›Žé›ºé›½é›¸é›µé³é·é¸é²é é é Žé¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­›é³ªé³­é³§éº€é»½åƒ¦åƒ”åƒ—åƒ¨åƒ³åƒ›åƒªåƒåƒ¤åƒ“åƒ¬åƒ°åƒ¯åƒ£åƒ "],
+		["e140", "å‡˜åŠ€åŠå‹©å‹«åŒ°åŽ¬å˜§å˜•å˜Œå˜’å—¼å˜å˜œå˜å˜“å˜‚å—ºå˜å˜„å—¿å—¹å¢‰å¡¼å¢å¢˜å¢†å¢å¡¿å¡´å¢‹å¡ºå¢‡å¢‘å¢Žå¡¶å¢‚å¢ˆå¡»å¢”å¢å£¾å¥«å«œå«®å«¥å«•å«ªå«šå«­å««å«³å«¢å« å«›å«¬å«žå«å«™å«¨å«Ÿå­·å¯ "],
+		["e1a1", "å¯£å±£å¶‚å¶€åµ½å¶†åµºå¶åµ·å¶Šå¶‰å¶ˆåµ¾åµ¼å¶åµ¹åµ¿å¹˜å¹™å¹“å»˜å»‘å»—å»Žå»œå»•å»™å»’å»”å½„å½ƒå½¯å¾¶æ„¬æ„¨æ…æ…žæ…±æ…³æ…’æ…“æ…²æ…¬æ†€æ…´æ…”æ…ºæ…›æ…¥æ„»æ…ªæ…¡æ…–æˆ©æˆ§æˆ«æ«æ‘æ‘›æ‘æ‘´æ‘¶æ‘²æ‘³æ‘½æ‘µæ‘¦æ’¦æ‘Žæ’‚æ‘žæ‘œæ‘‹æ‘“æ‘ æ‘æ‘¿æ¿æ‘¬æ‘«æ‘™æ‘¥æ‘·æ•³æ– æš¡æš æšŸæœ…æœ„æœ¢æ¦±æ¦¶æ§‰"],
+		["e240", "æ¦ æ§Žæ¦–æ¦°æ¦¬æ¦¼æ¦‘æ¦™æ¦Žæ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§„æ¦½æ¦¤æ§”æ¦¹æ§Šæ¦šæ§æ¦³æ¦“æ¦ªæ¦¡æ¦žæ§™æ¦—æ¦æ§‚æ¦µæ¦¥æ§†æ­Šæ­æ­‹æ®žæ®Ÿæ® æ¯ƒæ¯„æ¯¾æ»Žæ»µæ»±æ¼ƒæ¼¥æ»¸æ¼·æ»»æ¼®æ¼‰æ½Žæ¼™æ¼šæ¼§æ¼˜æ¼»æ¼’æ»­æ¼Š"],
+		["e2a1", "æ¼¶æ½³æ»¹æ»®æ¼­æ½€æ¼°æ¼¼æ¼µæ»«æ¼‡æ¼Žæ½ƒæ¼…æ»½æ»¶æ¼¹æ¼œæ»¼æ¼ºæ¼Ÿæ¼æ¼žæ¼ˆæ¼¡ç†‡ç†ç†‰ç†€ç†…ç†‚ç†ç…»ç††ç†ç†—ç‰„ç‰“çŠ—çŠ•çŠ“çƒçç‘çŒç‘¢ç‘³ç‘±ç‘µç‘²ç‘§ç‘®ç”€ç”‚ç”ƒç•½ç–ç˜–ç˜ˆç˜Œç˜•ç˜‘ç˜Šç˜”çš¸çžç¼çž…çž‚ç®çž€ç¯ç¾çžƒç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢žç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦˜ç¦Šç¦‹ç¦–ç¦•ç¦”ç¦“"],
+		["e340", "ç¦—ç¦ˆç¦’ç¦ç¨«ç©Šç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ˆç®œç®Šç®‘ç®ç®–ç®ç®Œç®›ç®Žç®…ç®˜åŠ„ç®™ç®¤ç®‚ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·‚ç¶£ç¶ªç·ç·€ç·…ç¶ç·Žç·„ç·†ç·‹ç·Œç¶¯ç¶¹ç¶–ç¶¼ç¶Ÿç¶¦ç¶®ç¶©ç¶¡ç·‰ç½³ç¿¢ç¿£ç¿¥ç¿ž"],
+		["e3a1", "è€¤èèœè†‰è††è†ƒè†‡è†è†Œè†‹èˆ•è’—è’¤è’¡è’Ÿè’ºè“Žè“‚è’¬è’®è’«è’¹è’´è“è“è’ªè’šè’±è“è’è’§è’»è’¢è’”è“‡è“Œè’›è’©è’¯è’¨è“–è’˜è’¶è“è’ è“—è“”è“’è“›è’°è’‘è™¡èœ³èœ£èœ¨è«è€èœ®èœžèœ¡èœ™èœ›èƒèœ¬èèœ¾è†èœ èœ²èœªèœ­èœ¼èœ’èœºèœ±èœµè‚èœ¦èœ§èœ¸èœ¤èœšèœ°èœ‘è£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»"],
+		["e440", "è£°è£¬è£«è¦è¦¡è¦Ÿè¦žè§©è§«è§¨èª«èª™èª‹èª’èªèª–è°½è±¨è±©è³•è³è³—è¶–è¸‰è¸‚è·¿è¸è·½è¸Šè¸ƒè¸‡è¸†è¸…è·¾è¸€è¸„è¼è¼‘è¼Žè¼é„£é„œé„ é„¢é„Ÿé„é„šé„¤é„¡é„›é…ºé…²é…¹é…³éŠ¥éŠ¤é‰¶éŠ›é‰ºéŠ éŠ”éŠªéŠ"],
+		["e4a1", "éŠ¦éŠšéŠ«é‰¹éŠ—é‰¿éŠ£é‹®éŠŽéŠ‚éŠ•éŠ¢é‰½éŠˆéŠ¡éŠŠéŠ†éŠŒéŠ™éŠ§é‰¾éŠ‡éŠ©éŠéŠ‹éˆ­éšžéš¡é›¿é˜é½éºé¾éžƒéž€éž‚é»éž„éžé¿éŸŽéŸé –é¢­é¢®é¤‚é¤€é¤‡é¦é¦œé§ƒé¦¹é¦»é¦ºé§‚é¦½é§‡éª±é«£é«§é¬¾é¬¿é­ é­¡é­Ÿé³±é³²é³µéº§åƒ¿å„ƒå„°åƒ¸å„†å„‡åƒ¶åƒ¾å„‹å„Œåƒ½å„ŠåŠ‹åŠŒå‹±å‹¯å™ˆå™‚å™Œå˜µå™å™Šå™‰å™†å™˜"],
+		["e540", "å™šå™€å˜³å˜½å˜¬å˜¾å˜¸å˜ªå˜ºåœšå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬ƒå«¸å¬‚å«¹å¬å¬‡å¬…å¬å±§å¶™å¶—å¶Ÿå¶’å¶¢å¶“å¶•å¶ å¶œå¶¡å¶šå¶žå¹©å¹å¹ å¹œç·³å»›å»žå»¡å½‰å¾²æ†‹æ†ƒæ…¹æ†±æ†°æ†¢æ†‰"],
+		["e5a1", "æ†›æ†“æ†¯æ†­æ†Ÿæ†’æ†ªæ†¡æ†æ…¦æ†³æˆ­æ‘®æ‘°æ’–æ’ æ’…æ’—æ’œæ’æ’‹æ’Šæ’Œæ’£æ’Ÿæ‘¨æ’±æ’˜æ•¶æ•ºæ•¹æ•»æ–²æ–³æšµæš°æš©æš²æš·æšªæš¯æ¨€æ¨†æ¨—æ§¥æ§¸æ¨•æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨›æ¨æ§¾æ¨§æ§²æ§®æ¨”æ§·æ§§æ©€æ¨ˆæ§¦æ§»æ¨æ§¼æ§«æ¨‰æ¨„æ¨˜æ¨¥æ¨æ§¶æ¨¦æ¨‡æ§´æ¨–æ­‘æ®¥æ®£æ®¢æ®¦æ°æ°€æ¯¿æ°‚æ½æ¼¦æ½¾æ¾‡æ¿†æ¾’"],
+		["e640", "æ¾æ¾‰æ¾Œæ½¢æ½æ¾…æ½šæ¾–æ½¶æ½¬æ¾‚æ½•æ½²æ½’æ½æ½—æ¾”æ¾“æ½æ¼€æ½¡æ½«æ½½æ½§æ¾æ½“æ¾‹æ½©æ½¿æ¾•æ½£æ½·æ½ªæ½»ç†²ç†¯ç†›ç†°ç† ç†šç†©ç†µç†ç†¥ç†žç†¤ç†¡ç†ªç†œç†§ç†³çŠ˜çŠšç˜ç’çžçŸç çç›ç¡çšç™"],
+		["e6a1", "ç¢ç’‡ç’‰ç’Šç’†ç’ç‘½ç’…ç’ˆç‘¼ç‘¹ç”ˆç”‡ç•¾ç˜¥ç˜žç˜™ç˜ç˜œç˜£ç˜šç˜¨ç˜›çšœçšçšžçš›çžçžçž‰çžˆç£ç¢»ç£ç£Œç£‘ç£Žç£”ç£ˆç£ƒç£„ç£‰ç¦šç¦¡ç¦ ç¦œç¦¢ç¦›æ­¶ç¨¹çª²çª´çª³ç®·ç¯‹ç®¾ç®¬ç¯Žç®¯ç®¹ç¯Šç®µç³…ç³ˆç³Œç³‹ç··ç·›ç·ªç·§ç·—ç·¡ç¸ƒç·ºç·¦ç·¶ç·±ç·°ç·®ç·Ÿç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è†£è†Ÿ"],
+		["e740", "è†žè†•è†¢è†™è†—èˆ–è‰è‰“è‰’è‰è‰Žè‰‘è”¤è”»è”è”€è”©è”Žè”‰è”è”Ÿè”Šè”§è”œè“»è”«è“ºè”ˆè”Œè“´è”ªè“²è”•è“·è“«è“³è“¼è”’è“ªè“©è”–è“¾è”¨è”è”®è”‚è“½è”žè“¶è”±è”¦è“§è“¨è“°è“¯è“¹è”˜è” è”°è”‹è”™è”¯è™¢"],
+		["e7a1", "è–è£è¤è·èŸ¡è³è˜è”è›è’è¡èšè‘èžè­èªèèŽèŸèè¯è¬èºè®èœè¥èè»èµè¢è§è©è¡šè¤…è¤Œè¤”è¤‹è¤—è¤˜è¤™è¤†è¤–è¤‘è¤Žè¤‰è¦¢è¦¤è¦£è§­è§°è§¬è«è«†èª¸è«“è«‘è«”è«•èª»è«—èª¾è«€è«…è«˜è«ƒèªºèª½è«™è°¾è±è²è³¥è³Ÿè³™è³¨è³šè³è³§è¶ è¶œè¶¡è¶›è¸ è¸£è¸¥è¸¤è¸®è¸•è¸›è¸–è¸‘è¸™è¸¦è¸§"],
+		["e840", "è¸”è¸’è¸˜è¸“è¸œè¸—è¸šè¼¬è¼¤è¼˜è¼šè¼ è¼£è¼–è¼—é³é°é¯é§é«é„¯é„«é„©é„ªé„²é„¦é„®é†…é††é†Šé†é†‚é†„é†€é‹é‹ƒé‹„é‹€é‹™éŠ¶é‹é‹±é‹Ÿé‹˜é‹©é‹—é‹é‹Œé‹¯é‹‚é‹¨é‹Šé‹ˆé‹Žé‹¦é‹é‹•é‹‰é‹ é‹žé‹§é‹‘é‹“"],
+		["e8a1", "éŠµé‹¡é‹†éŠ´é•¼é–¬é–«é–®é–°éš¤éš¢é›“éœ…éœˆéœ‚éšéžŠéžŽéžˆéŸéŸé žé é ¦é ©é ¨é  é ›é §é¢²é¤ˆé£ºé¤‘é¤”é¤–é¤—é¤•é§œé§é§é§“é§”é§Žé§‰é§–é§˜é§‹é§—é§Œéª³é«¬é««é«³é«²é«±é­†é­ƒé­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´‡é´€é³¹é³»é´ˆé´…é´„éºƒé»“é¼é¼å„œå„“å„—å„šå„‘å‡žåŒ´å¡å™°å™ å™®"],
+		["e940", "å™³å™¦å™£å™­å™²å™žå™·åœœåœ›å£ˆå¢½å£‰å¢¿å¢ºå£‚å¢¼å£†å¬—å¬™å¬›å¬¡å¬”å¬“å¬å¬–å¬¨å¬šå¬ å¬žå¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½‹å¾¼æ†æ†¨æ†–æ‡…æ†´æ‡†æ‡æ‡Œæ†º"],
+		["e9a1", "æ†¿æ†¸æ†Œæ“—æ“–æ“æ“æ“‰æ’½æ’‰æ“ƒæ“›æ“³æ“™æ”³æ•¿æ•¼æ–¢æ›ˆæš¾æ›€æ›Šæ›‹æ›æš½æš»æšºæ›Œæœ£æ¨´æ©¦æ©‰æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©›æ©‘æ¨¨æ©šæ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©”æ©¯æ©©æ© æ¨¼æ©žæ©–æ©•æ©æ©Žæ©†æ­•æ­”æ­–æ®§æ®ªæ®«æ¯ˆæ¯‡æ°„æ°ƒæ°†æ¾­æ¿‹æ¾£æ¿‡æ¾¼æ¿Žæ¿ˆæ½žæ¿„æ¾½æ¾žæ¿Šæ¾¨ç€„æ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸"],
+		["ea40", "æ¾¢æ¿‰æ¾«æ¿æ¾¯æ¾²æ¾°ç‡…ç‡‚ç†¿ç†¸ç‡–ç‡€ç‡ç‡‹ç‡”ç‡Šç‡‡ç‡ç†½ç‡˜ç†¼ç‡†ç‡šç‡›çŠçŠžç©ç¦ç§ç¬ç¥ç«çªç‘¿ç’šç’ ç’”ç’’ç’•ç’¡ç”‹ç–€ç˜¯ç˜­ç˜±ç˜½ç˜³ç˜¼ç˜µç˜²ç˜°çš»ç›¦çžšçžçž¡çžœçž›çž¢çž£çž•çž™"],
+		["eaa1", "çž—ç£ç£©ç£¥ç£ªç£žç££ç£›ç£¡ç£¢ç£­ç£Ÿç£ ç¦¤ç©„ç©ˆç©‡çª¶çª¸çªµçª±çª·ç¯žç¯£ç¯§ç¯ç¯•ç¯¥ç¯šç¯¨ç¯¹ç¯”ç¯ªç¯¢ç¯œç¯«ç¯˜ç¯Ÿç³’ç³”ç³—ç³ç³‘ç¸’ç¸¡ç¸—ç¸Œç¸Ÿç¸ ç¸“ç¸Žç¸œç¸•ç¸šç¸¢ç¸‹ç¸ç¸–ç¸ç¸”ç¸¥ç¸¤ç½ƒç½»ç½¼ç½ºç¾±ç¿¯è€ªè€©è¬è†±è†¦è†®è†¹è†µè†«è†°è†¬è†´è†²è†·è†§è‡²è‰•è‰–è‰—è•–è•…è•«è•è•“è•¡è•˜"],
+		["eb40", "è•€è•†è•¤è•è•¢è•„è•‘è•‡è•£è”¾è•›è•±è•Žè•®è•µè••è•§è• è–Œè•¦è•è•”è•¥è•¬è™£è™¥è™¤èž›èžèž—èž“èž’èžˆèžèž–èž˜è¹èž‡èž£èž…èžèž‘èžèž„èž”èžœèžšèž‰è¤žè¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤Ÿè§±è« "],
+		["eba1", "è«¢è«²è«´è«µè«è¬”è«¤è«Ÿè«°è«ˆè«žè«¡è«¨è«¿è«¯è«»è²‘è²’è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹€è¹…è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»é‚†éƒºé„³é„µé„¶é†“é†é†‘é†é†éŒ§éŒžéŒˆéŒŸéŒ†éŒéºéŒ¸éŒ¼éŒ›éŒ£éŒ’éŒé†éŒ­éŒŽéŒé‹‹éŒé‹ºéŒ¥éŒ“é‹¹é‹·éŒ´éŒ‚éŒ¤é‹¿éŒ©éŒ¹éŒµéŒªéŒ”éŒŒ"],
+		["ec40", "éŒ‹é‹¾éŒ‰éŒ€é‹»éŒ–é–¼é—é–¾é–¹é–ºé–¶é–¿é–µé–½éš©é›”éœ‹éœ’éœéž™éž—éž”éŸ°éŸ¸é µé ¯é ²é¤¤é¤Ÿé¤§é¤©é¦žé§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®€é®…é®‡é­¼é­¾é­»é®‚é®“é®’é®é­ºé®•"],
+		["eca1", "é­½é®ˆé´¥é´—é´ é´žé´”é´©é´é´˜é´¢é´é´™é´Ÿéºˆéº†éº‡éº®éº­é»•é»–é»ºé¼’é¼½å„¦å„¥å„¢å„¤å„ å„©å‹´åš“åšŒåšåš†åš„åšƒå™¾åš‚å™¿åšå£–å£”å£å£’å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»æ‡ƒæ†µæ†¼æ‡§æ‡ æ‡¥æ‡¤æ‡¨æ‡žæ“¯æ“©æ“£æ“«æ“¤æ“¨æ–æ–€æ–¶æ—šæ›’æªæª–æªæª¥æª‰æªŸæª›æª¡æªžæª‡æª“æªŽ"],
+		["ed40", "æª•æªƒæª¨æª¤æª‘æ©¿æª¦æªšæª…æªŒæª’æ­›æ®­æ°‰æ¿Œæ¾©æ¿´æ¿”æ¿£æ¿œæ¿­æ¿§æ¿¦æ¿žæ¿²æ¿æ¿¢æ¿¨ç‡¡ç‡±ç‡¨ç‡²ç‡¤ç‡°ç‡¢ç³ç®ç¯ç’—ç’²ç’«ç’ç’ªç’­ç’±ç’¥ç’¯ç”ç”‘ç”’ç”ç–„ç™ƒç™ˆç™‰ç™‡çš¤ç›©çžµçž«çž²çž·çž¶"],
+		["eda1", "çž´çž±çž¨çŸ°ç£³ç£½ç¤‚ç£»ç£¼ç£²ç¤…ç£¹ç£¾ç¤„ç¦«ç¦¨ç©œç©›ç©–ç©˜ç©”ç©šçª¾ç«€ç«ç°…ç°ç¯²ç°€ç¯¿ç¯»ç°Žç¯´ç°‹ç¯³ç°‚ç°‰ç°ƒç°ç¯¸ç¯½ç°†ç¯°ç¯±ç°ç°Šç³¨ç¸­ç¸¼ç¹‚ç¸³é¡ˆç¸¸ç¸ªç¹‰ç¹€ç¹‡ç¸©ç¹Œç¸°ç¸»ç¸¶ç¹„ç¸ºç½…ç½¿ç½¾ç½½ç¿´ç¿²è€¬è†»è‡„è‡Œè‡Šè‡…è‡‡è†¼è‡©è‰›è‰šè‰œè–ƒè–€è–è–§è–•è– è–‹è–£è•»è–¤è–šè–ž"],
+		["ee40", "è•·è•¼è–‰è–¡è•ºè•¸è•—è–Žè––è–†è–è–™è–è–è–¢è–‚è–ˆè–…è•¹è•¶è–˜è–è–Ÿè™¨èž¾èžªèž­èŸ…èž°èž¬èž¹èžµèž¼èž®èŸ‰èŸƒèŸ‚èŸŒèž·èž¯èŸ„èŸŠèž´èž¶èž¿èž¸èž½èŸžèž²è¤µè¤³è¤¼è¤¾è¥è¥’è¤·è¥‚è¦­è¦¯è¦®è§²è§³è¬ž"],
+		["eea1", "è¬˜è¬–è¬‘è¬…è¬‹è¬¢è¬è¬’è¬•è¬‡è¬è¬ˆè¬†è¬œè¬“è¬šè±è±°è±²è±±è±¯è²•è²”è³¹èµ¯è¹Žè¹è¹“è¹è¹Œè¹‡è½ƒè½€é‚…é¾é„¸é†šé†¢é†›é†™é†Ÿé†¡é†é† éŽ¡éŽƒéŽ¯é¤é–é‡é¼é˜éœé¶é‰éé‘é é­éŽéŒéªé¹é—é•é’éé±é·é»é¡éžé£é§éŽ€éŽé™é—‡é—€é—‰é—ƒé—…é–·éš®éš°éš¬éœ éœŸéœ˜éœéœ™éžšéž¡éžœ"],
+		["ef40", "éžžéžéŸ•éŸ”éŸ±é¡é¡„é¡Šé¡‰é¡…é¡ƒé¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦˜é¦£é¦¡é¨‚é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨ƒéª¾é«¾é«½é¬é«¼é­ˆé®šé®¨é®žé®›é®¦é®¡é®¥é®¤é®†é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°"],
+		["efa1", "éµ…éµ‚éµƒé´¾é´·éµ€é´½ç¿µé´­éºŠéº‰éºéº°é»ˆé»šé»»é»¿é¼¤é¼£é¼¢é½”é¾ å„±å„­å„®åš˜åšœåš—åššåšåš™å¥°å¬¼å±©å±ªå·€å¹­å¹®æ‡˜æ‡Ÿæ‡­æ‡®æ‡±æ‡ªæ‡°æ‡«æ‡–æ‡©æ“¿æ”„æ“½æ“¸æ”æ”ƒæ“¼æ–”æ—›æ›šæ››æ›˜æ«…æª¹æª½æ«¡æ«†æªºæª¶æª·æ«‡æª´æª­æ­žæ¯‰æ°‹ç€‡ç€Œç€ç€ç€…ç€”ç€Žæ¿¿ç€€æ¿»ç€¦æ¿¼æ¿·ç€Šçˆç‡¿ç‡¹çˆƒç‡½ç¶"],
+		["f040", "ç’¸ç“€ç’µç“ç’¾ç’¶ç’»ç“‚ç””ç”“ç™œç™¤ç™™ç™ç™“ç™—ç™šçš¦çš½ç›¬çŸ‚çžºç£¿ç¤Œç¤“ç¤”ç¤‰ç¤ç¤’ç¤‘ç¦­ç¦¬ç©Ÿç°œç°©ç°™ç° ç°Ÿç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹œç¹ç¹–ç¹£ç¹˜ç¹¢ç¹Ÿç¹‘ç¹ ç¹—ç¹“ç¾µç¾³ç¿·ç¿¸èµè‡‘è‡’"],
+		["f0a1", "è‡è‰Ÿè‰žè–´è—†è—€è—ƒè—‚è–³è–µè–½è—‡è—„è–¿è—‹è—Žè—ˆè—…è–±è–¶è—’è˜¤è–¸è–·è–¾è™©èŸ§èŸ¦èŸ¢èŸ›èŸ«èŸªèŸ¥èŸŸèŸ³èŸ¤èŸ”èŸœèŸ“èŸ­èŸ˜èŸ£èž¤èŸ—èŸ™è èŸ´èŸ¨èŸè¥“è¥‹è¥è¥Œè¥†è¥è¥‘è¥‰è¬ªè¬§è¬£è¬³è¬°è¬µè­‡è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±‚è±µè²™è²˜è²—è³¾è´„è´‚è´€è¹œè¹¢è¹ è¹—è¹–è¹žè¹¥è¹§"],
+		["f140", "è¹›è¹šè¹¡è¹è¹©è¹”è½†è½‡è½ˆè½‹é„¨é„ºé„»é„¾é†¨é†¥é†§é†¯é†ªéŽµéŽŒéŽ’éŽ·éŽ›éŽéŽ‰éŽ§éŽŽéŽªéŽžéŽ¦éŽ•éŽˆéŽ™éŽŸéŽéŽ±éŽ‘éŽ²éŽ¤éŽ¨éŽ´éŽ£éŽ¥é—’é—“é—‘éš³é›—é›šå·‚é›Ÿé›˜é›éœ£éœ¢éœ¥éž¬éž®éž¨éž«éž¤éžª"],
+		["f1a1", "éž¢éž¥éŸ—éŸ™éŸ–éŸ˜éŸºé¡é¡‘é¡’é¢¸é¥é¤¼é¤ºé¨é¨‹é¨‰é¨é¨„é¨‘é¨Šé¨…é¨‡é¨†é«€é«œé¬ˆé¬„é¬…é¬©é¬µé­Šé­Œé­‹é¯‡é¯†é¯ƒé®¿é¯é®µé®¸é¯“é®¶é¯„é®¹é®½éµœéµ“éµéµŠéµ›éµ‹éµ™éµ–éµŒéµ—éµ’éµ”éµŸéµ˜éµšéºŽéºŒé»Ÿé¼é¼€é¼–é¼¥é¼«é¼ªé¼©é¼¨é½Œé½•å„´å„µåŠ–å‹·åŽ´åš«åš­åš¦åš§åšªåš¬å£šå£å£›å¤’å¬½å¬¾å¬¿å·ƒå¹°"],
+		["f240", "å¾¿æ‡»æ”‡æ”æ”æ”‰æ”Œæ”Žæ–„æ—žæ—æ›žæ«§æ« æ«Œæ«‘æ«™æ«‹æ«Ÿæ«œæ«æ««æ«æ«æ«žæ­ æ®°æ°Œç€™ç€§ç€ ç€–ç€«ç€¡ç€¢ç€£ç€©ç€—ç€¤ç€œç€ªçˆŒçˆŠçˆ‡çˆ‚çˆ…çŠ¥çŠ¦çŠ¤çŠ£çŠ¡ç“‹ç“…ç’·ç“ƒç”–ç™ çŸ‰çŸŠçŸ„çŸ±ç¤ç¤›"],
+		["f2a1", "ç¤¡ç¤œç¤—ç¤žç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½‹ç½Šç¾ƒç¾†ç¾·ç¿½ç¿¾è¸è‡—è‡•è‰¤è‰¡è‰£è—«è—±è—­è—™è—¡è—¨è—šè——è—¬è—²è—¸è—˜è—Ÿè—£è—œè—‘è—°è—¦è—¯è—žè—¢è €èŸºè ƒèŸ¶èŸ·è ‰è Œè ‹è †èŸ¼è ˆèŸ¿è Šè ‚è¥¢è¥šè¥›è¥—è¥¡è¥œè¥˜è¥è¥™è¦ˆè¦·è¦¶è§¶è­è­ˆè­Šè­€è­“è­–è­”è­‹è­•"],
+		["f340", "è­‘è­‚è­’è­—è±ƒè±·è±¶è²šè´†è´‡è´‰è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»‚è½’è½‘è½è½è½“è¾´é…€é„¿é†°é†­éžé‡éé‚éšéé¹é¬éŒé™éŽ©é¦éŠé”é®é£é•é„éŽé€é’é§é•½é—šé—›é›¡éœ©éœ«éœ¬éœ¨éœ¦"],
+		["f3a1", "éž³éž·éž¶éŸéŸžéŸŸé¡œé¡™é¡é¡—é¢¿é¢½é¢»é¢¾é¥ˆé¥‡é¥ƒé¦¦é¦§é¨šé¨•é¨¥é¨é¨¤é¨›é¨¢é¨ é¨§é¨£é¨žé¨œé¨”é«‚é¬‹é¬Šé¬Žé¬Œé¬·é¯ªé¯«é¯ é¯žé¯¤é¯¦é¯¢é¯°é¯”é¯—é¯¬é¯œé¯™é¯¥é¯•é¯¡é¯šéµ·é¶é¶Šé¶„é¶ˆéµ±é¶€éµ¸é¶†é¶‹é¶Œéµ½éµ«éµ´éµµéµ°éµ©é¶…éµ³éµ»é¶‚éµ¯éµ¹éµ¿é¶‡éµ¨éº”éº‘é»€é»¼é¼­é½€é½é½é½–é½—é½˜åŒ·åš²"],
+		["f440", "åšµåš³å££å­…å·†å·‡å»®å»¯å¿€å¿æ‡¹æ”—æ”–æ”•æ”“æ—Ÿæ›¨æ›£æ›¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç€¼ç€µç€¯ç€·ç€´ç€±ç‚ç€¸ç€¿ç€ºç€¹ç€ç€»ç€³ççˆ“çˆ”çŠ¨ç½ç¼ç’ºçš«çšªçš¾ç›­çŸŒçŸŽçŸçŸçŸ²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©"],
+		["f4a1", "ç¦²ç©®ç©¬ç©­ç«·ç±‰ç±ˆç±Šç±‡ç±…ç³®ç¹»ç¹¾çºçº€ç¾ºç¿¿è¹è‡›è‡™èˆ‹è‰¨è‰©è˜¢è—¿è˜è—¾è˜›è˜€è—¶è˜„è˜‰è˜…è˜Œè—½è ™è è ‘è —è “è –è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èº†èºˆèº„è½™è½–è½—è½•è½˜è½šé‚é…ƒé…é†·é†µé†²é†³é‹é“é»é éé”é¾é•éé¨é™ééµé€é·é‡éŽé–é’éºé‰é¸éŠé¿"],
+		["f540", "é¼éŒé¶é‘é†é—žé— é—Ÿéœ®éœ¯éž¹éž»éŸ½éŸ¾é¡ é¡¢é¡£é¡Ÿé£é£‚é¥é¥Žé¥™é¥Œé¥‹é¥“é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«‡é«Šé«†é¬é¬’é¬‘é°‹é°ˆé¯·é°…é°’é¯¸é±€é°‡é°Žé°†é°—é°”é°‰é¶Ÿé¶™é¶¤é¶é¶’é¶˜é¶é¶›"],
+		["f5a1", "é¶ é¶”é¶œé¶ªé¶—é¶¡é¶šé¶¢é¶¨é¶žé¶£é¶¿é¶©é¶–é¶¦é¶§éº™éº›éºšé»¥é»¤é»§é»¦é¼°é¼®é½›é½ é½žé½é½™é¾‘å„ºå„¹åŠ˜åŠ—å›ƒåš½åš¾å­ˆå­‡å·‹å·å»±æ‡½æ”›æ¬‚æ«¼æ¬ƒæ«¸æ¬€çƒç„çŠçˆç‰ç…ç†çˆçˆšçˆ™ç¾ç”—ç™ªçŸç¤­ç¤±ç¤¯ç±”ç±“ç³²çºŠçº‡çºˆçº‹çº†çºç½ç¾»è€°è‡è˜˜è˜ªè˜¦è˜Ÿè˜£è˜œè˜™è˜§è˜®è˜¡è˜ è˜©è˜žè˜¥"],
+		["f640", "è ©è è ›è  è ¤è œè «è¡Šè¥­è¥©è¥®è¥«è§ºè­¹è­¸è­…è­ºè­»è´è´”è¶¯èºŽèºŒè½žè½›è½é…†é…„é……é†¹é¿é»é¶é©é½é¼é°é¹éªé·é¬é‘€é±é—¥é—¤é—£éœµéœºéž¿éŸ¡é¡¤é£‰é£†é£€é¥˜é¥–é¨¹é¨½é©†é©„é©‚é©é¨º"],
+		["f6a1", "é¨¿é«é¬•é¬—é¬˜é¬–é¬ºé­’é°«é°é°œé°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·‡é·Šé·é¶¾é·…é·ƒé¶»é¶µé·Žé¶¹é¶ºé¶¬é·ˆé¶±é¶­é·Œé¶³é·é¶²é¹ºéºœé»«é»®é»­é¼›é¼˜é¼šé¼±é½Žé½¥é½¤é¾’äº¹å›†å›…å›‹å¥±å­‹å­Œå·•å·‘å»²æ”¡æ” æ”¦æ”¢æ¬‹æ¬ˆæ¬‰æ°ç•ç–ç—ç’çˆžçˆŸçŠ©ç¿ç“˜ç“•ç“™ç“—ç™­çš­ç¤µç¦´ç©°ç©±ç±—ç±œç±™ç±›ç±š"],
+		["f740", "ç³´ç³±çº‘ç½ç¾‡è‡žè‰«è˜´è˜µè˜³è˜¬è˜²è˜¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®„è®‚è®†è®…è­¿è´•èº•èº”èºšèº’èºèº–èº—è½ è½¢é…‡é‘Œé‘é‘Šé‘‹é‘é‘‡é‘…é‘ˆé‘‰é‘†éœ¿éŸ£é¡ªé¡©é£‹é¥”é¥›é©Žé©“é©”é©Œé©é©ˆé©Š"],
+		["f7a1", "é©‰é©’é©é«é¬™é¬«é¬»é­–é­•é±†é±ˆé°¿é±„é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·›é·’é·žé·šé·‹é·é·œé·‘é·Ÿé·©é·™é·˜é·–é·µé·•é·éº¶é»°é¼µé¼³é¼²é½‚é½«é¾•é¾¢å„½åŠ™å£¨å£§å¥²å­å·˜è ¯å½æˆæˆƒæˆ„æ”©æ”¥æ––æ›«æ¬‘æ¬’æ¬æ¯Šç›çšçˆ¢çŽ‚çŽçŽƒç™°çŸ”ç±§ç±¦çº•è‰¬è˜ºè™€è˜¹è˜¼è˜±è˜»è˜¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾"],
+		["f840", "è®Œè®Žè®‹è®ˆè±…è´™èº˜è½¤è½£é†¼é‘¢é‘•é‘é‘—é‘žéŸ„éŸ…é €é©–é©™é¬žé¬Ÿé¬ é±’é±˜é±é±Šé±é±‹é±•é±™é±Œé±Žé·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»‚é»é»²é»³é¼†é¼œé¼¸é¼·é¼¶é½ƒé½"],
+		["f8a1", "é½±é½°é½®é½¯å›“å›å­Žå±­æ”­æ›­æ›®æ¬“çŸç¡çç çˆ£ç“›ç“¥çŸ•ç¤¸ç¦·ç¦¶ç±ªçº—ç¾‰è‰­è™ƒè ¸è ·è µè¡‹è®”è®•èºžèºŸèº èºé†¾é†½é‡‚é‘«é‘¨é‘©é›¥é†éƒé‡éŸ‡éŸ¥é©žé«•é­™é±£é±§é±¦é±¢é±žé± é¸‚é·¾é¸‡é¸ƒé¸†é¸…é¸€é¸é¸‰é·¿é·½é¸„éº é¼žé½†é½´é½µé½¶å›”æ”®æ–¸æ¬˜æ¬™æ¬—æ¬šç¢çˆ¦çŠªçŸ˜çŸ™ç¤¹ç±©ç±«ç³¶çºš"],
+		["f940", "çº˜çº›çº™è‡ è‡¡è™†è™‡è™ˆè¥¹è¥ºè¥¼è¥»è§¿è®˜è®™èº¥èº¤èº£é‘®é‘­é‘¯é‘±é‘³é‰é¡²é¥Ÿé±¨é±®é±­é¸‹é¸é¸é¸é¸’é¸‘éº¡é»µé¼‰é½‡é½¸é½»é½ºé½¹åœžç¦ç±¯è ¼è¶²èº¦é‡ƒé‘´é‘¸é‘¶é‘µé© é±´é±³é±±é±µé¸”é¸“é»¶é¼Š"],
+		["f9a1", "é¾¤ç¨ç¥ç³·è™ªè ¾è ½è ¿è®žè²œèº©è»‰é‹é¡³é¡´é£Œé¥¡é¦«é©¤é©¦é©§é¬¤é¸•é¸—é½ˆæˆ‡æ¬žçˆ§è™Œèº¨é’‚é’€é’é©©é©¨é¬®é¸™çˆ©è™‹è®Ÿé’ƒé±¹éº·ç™µé©«é±ºé¸ç©çªéº¤é½¾é½‰é¾˜ç¢éŠ¹è£å¢»æ’ç²§å«ºâ•”â•¦â•—â• â•¬â•£â•šâ•©â•â•’â•¤â••â•žâ•ªâ•¡â•˜â•§â•›â•“â•¥â•–â•Ÿâ•«â•¢â•™â•¨â•œâ•‘â•â•­â•®â•°â•¯â–“"]
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/big5-added.json
+var require_big5_added = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/big5-added.json": ((exports, module) => {
+	module.exports = [
+		["8740", "ä°ä°²ä˜ƒä–¦ä•¸ð§‰§äµ·ä–³ð§²±ä³¢ð§³…ã®•äœ¶ä„ä±‡ä±€ð¤Š¿ð£˜—ð§’ð¦º‹ð§ƒ’ä±—ðª‘ää—šä²…ð§±¬ä´‡äª¤äš¡ð¦¬£çˆ¥ð¥©”ð¡©£ð£¸†ð£½¡æ™å›»"],
+		["8767", "ç¶•å¤ð¨®¹ã·´éœ´ð§¯¯å¯›ð¡µžåª¤ã˜¥ð©º°å«‘å®·å³¼æ®è–“ð©¥…ç‘¡ç’ã¡µð¡µ“ð£šžð¦€¡ã»¬"],
+		["87a1", "ð¥£žã«µç«¼é¾—ð¤…¡ð¨¤ð£‡ªð ªŠð£‰žäŒŠè’„é¾–é¯ä¤°è˜“å¢–éŠéˆ˜ç§ç¨²æ™ æ¨©è¢ç‘Œç¯…æž‚ç¨¬å‰é†ã“¦ç„ð¥¶¹ç“†é¿‡åž³ä¤¯å‘Œä„±ð£šŽå ˜ç©²ð§­¥è®äš®ð¦ºˆä†ð¥¶™ç®®ð¢’¼é¿ˆð¢“ð¢“‰ð¢“Œé¿‰è”„ð£–»ä‚´é¿Šä“¡ðª·¿æ‹ç®é¿‹"],
+		[
+			"8840",
+			"ã‡€",
+			4,
+			"ð „Œã‡…ð ƒ‘ð ƒã‡†ã‡‡ð ƒ‹ð¡¿¨ã‡ˆð ƒŠã‡‰ã‡Šã‡‹ã‡Œð „Žã‡ã‡ŽÄ€ÃÇÃ€Ä’Ã‰ÄšÃˆÅŒÃ“Ç‘Ã’à¿¿ÃŠÌ„áº¾à¿¿ÃŠÌŒá»€ÃŠÄÃ¡ÇŽÃ É‘Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜Çš"
+		],
+		["88a1", "ÇœÃ¼à¿¿ÃªÌ„áº¿à¿¿ÃªÌŒá»ÃªÉ¡âšâ›"],
+		["8940", "ðªŽ©ð¡……"],
+		["8943", "æ”Š"],
+		["8946", "ä¸½æ»éµŽé‡Ÿ"],
+		["894c", "ð§œµæ’‘ä¼šä¼¨ä¾¨å…–å…´å†œå‡¤åŠ¡åŠ¨åŒ»åŽå‘å˜å›¢å£°å¤„å¤‡å¤²å¤´å­¦å®žå®Ÿå²šåº†æ€»æ–‰æŸ¾æ „æ¡¥æµŽç‚¼ç”µçº¤çº¬çººç»‡ç»ç»Ÿç¼†ç¼·è‰ºè‹è¯è§†è®¾è¯¢è½¦è½§è½®"],
+		["89a1", "ç‘ç³¼ç·æ¥†ç«‰åˆ§"],
+		["89ab", "é†Œç¢¸é…žè‚¼"],
+		["89b0", "è´‹èƒ¶ð §§"],
+		["89b5", "è‚Ÿé»‡ä³é·‰é¸Œä°¾ð©·¶ð§€Žé¸Šðª„³ã—"],
+		["89c1", "æºšèˆ¾ç”™"],
+		["89c5", "ä¤‘é©¬éªé¾™ç¦‡ð¨‘¬ð¡·Šð —ð¢«¦ä¸¤äºäº€äº‡äº¿ä»«ä¼·ã‘Œä¾½ã¹ˆå€ƒå‚ˆã‘½ã’“ã’¥å††å¤…å‡›å‡¼åˆ…äº‰å‰¹åŠåŒ§ã—‡åŽ©ã•‘åŽ°ã•“å‚å£ã•­ã•²ãšå’“å’£å’´å’¹å“å“¯å”˜å”£å”¨ã–˜å”¿ã–¥ã–¿å——ã—…"],
+		["8a40", "ð§¶„å”¥"],
+		["8a43", "ð ±‚ð ´•ð¥„«å–ð¢³†ã§¬ð è¹†ð¤¶¸ð©“¥ä“ð¨‚¾çºð¢°¸ã¨´äŸ•ð¨…ð¦§²ð¤·ªæ“ð µ¼ð ¾´ð ³•ð¡ƒ´æ’è¹¾ð º–ð °‹ð ½¤ð¢²©ð¨‰–ð¤““"],
+		["8a64", "ð µ†ð©©ð¨ƒ©äŸ´ð¤º§ð¢³‚éª²ã©§ð©—´ã¿­ã”†ð¥‹‡ð©Ÿ”ð§£ˆð¢µ„éµ®é •"],
+		["8a76", "ä™ð¦‚¥æ’´å“£ð¢µŒð¢¯Šð¡·ã§»ð¡¯"],
+		["8aa1", "ð¦›šð¦œ–ð§¦ æ“ªð¥’ð ±ƒè¹¨ð¢†¡ð¨­Œð œ±"],
+		["8aac", "ä ‹ð †©ã¿ºå¡³ð¢¶"],
+		["8ab2", "ð¤—ˆð “¼ð¦‚—ð ½Œð ¶–å•¹ä‚»äŽº"],
+		["8abb", "äª´ð¢©¦ð¡‚è†ªé£µð ¶œæ¹ã§¾ð¢µè·€åš¡æ‘¼ã¹ƒ"],
+		["8ac9", "ðª˜ð ¸‰ð¢«ð¢³‰"],
+		["8ace", "ð¡ƒˆð£§‚ã¦’ã¨†ð¨Š›ã•¸ð¥¹‰ð¢ƒ‡å™’ð ¼±ð¢²²ð©œ ã’¼æ°½ð¤¸»"],
+		["8adf", "ð§•´ð¢º‹ð¢ˆˆðª™›ð¨³ð ¹ºð °´ð¦ œç¾“ð¡ƒð¢ ƒð¢¤¹ã—»ð¥‡£ð ºŒð ¾ð ºªã¾“ð ¼°ð µ‡ð¡…ð ¹Œ"],
+		["8af6", "ð º«ð ®©ð µˆð¡ƒ€ð¡„½ã¿¹ð¢š–æ²ð ¾­"],
+		["8b40", "ð£´ð§˜¹ð¢¯Žð µ¾ð µ¿ð¢±‘ð¢±•ã¨˜ð º˜ð¡ƒ‡ð ¼®ðª˜²ð¦­ð¨³’ð¨¶™ð¨³Šé–ªå“Œè‹„å–¹"],
+		["8b55", "ð©»ƒé°¦éª¶ð§žð¢·®ç…€è…­èƒ¬å°œð¦•²è„´ãž—åŸð¨‚½é†¶ð »ºð ¸ð ¹·ð »»ã—ð¤·«ã˜‰ð ³–åš¯ð¢žµð¡ƒ‰ð ¸ð ¹¸ð¡¸ð¡…ˆð¨ˆ‡ð¡‘•ð ¹¹ð¤¹ð¢¶¤å©”ð¡€ð¡€žð¡ƒµð¡ƒ¶åžœð ¸‘"],
+		["8ba1", "ð§š”ð¨‹ð ¾µð ¹»ð¥…¾ãœƒð ¾¶ð¡†€ð¥‹˜ðªŠ½ð¤§šð¡ ºð¤…·ð¨‰¼å¢™å‰¨ã˜šð¥œ½ç®²å­¨ä €ä¬¬é¼§ä§§é°Ÿé®ð¥­´ð£„½å—»ã—²åš‰ä¸¨å¤‚ð¡¯ð¯¡¸é‘ð ‚†ä¹›äº»ã”¾å°£å½‘å¿„ã£ºæ‰Œæ”µæ­ºæ°µæ°ºç¬çˆ«ä¸¬çŠ­ð¤£©ç½’ç¤»ç³¹ç½“ð¦‰ªã“"],
+		["8bde", "ð¦‹è€‚è‚€ð¦˜’ð¦¥‘åè¡¤è§ð§¢²è® è´é’…é•¸é•¿é—¨ð¨¸éŸ¦é¡µé£Žé£žé¥£ð© é±¼é¸Ÿé»„æ­¯ï¤‡ä¸·ð ‚‡é˜æˆ·é’¢"],
+		["8c40", "å€»æ·¾ð©±³é¾¦ã·‰è¢ð¤…Žç·å³µä¬ ð¥‡ã•™ð¥´°æ„¢ð¨¨²è¾§é‡¶ç†‘æœ™çŽºð£Šðª„‡ã²‹ð¡¦€ä¬ç£¤ç‚å†®ð¨œä€‰æ©£ðªŠºäˆ£è˜ð ©¯ç¨ªð©¥‡ð¨«ªé•çåŒ¤ð¢¾é´ç›™ð¨§£é¾§çŸäº£ä¿°å‚¼ä¸¯ä¼—é¾¨å´ç¶‹å¢’å£ð¡¶¶åº’åº™å¿‚ð¢œ’æ–‹"],
+		["8ca1", "ð£¹æ¤™æ©ƒð£±£æ³¿"],
+		["8ca7", "çˆ€ð¤”…çŽŒã»›ð¤¨“å¬•ç’¹è®ƒð¥²¤ð¥š•çª“ç¯¬ç³ƒç¹¬è‹¸è–—é¾©è¢é¾ªèº¹é¾«è¿è•Ÿé§ éˆ¡é¾¬ð¨¶¹ð¡¿ä±äŠ¢å¨š"],
+		["8cc9", "é¡¨æ«ä‰¶åœ½"],
+		["8cce", "è—–ð¤¥»èŠ¿ð§„ä²ð¦µ´åµ»ð¦¬•ð¦¾¾é¾­é¾®å®–é¾¯æ›§ç¹›æ¹—ç§Šã¶ˆä“ƒð£‰–ð¢ž–äŽšä”¶"],
+		["8ce6", "å³•ð£¬šè«¹å±¸ã´’ð£•‘åµ¸é¾²ç…—ä•˜ð¤ƒ¬ð¡¸£ä±·ã¥¸ã‘Šð †¤ð¦±è«Œä¾´ð ˆ¹å¦¿è…¬é¡–ð©£ºå¼»"],
+		["8d40", "ð ®Ÿ"],
+		["8d42", "ð¢‡ð¨¥­ä„‚äš»ð©¹ã¼‡é¾³ðª†µäƒ¸ãŸ–ä›·ð¦±†ä…¼ð¨š²ð§¿ä•­ã£”ð¥’šä•¡ä”›ä¶‰ä±»äµ¶ä—ªã¿ˆð¤¬ã™¡ä“žä’½ä‡­å´¾åµˆåµ–ã·¼ã å¶¤å¶¹ã  ã ¸å¹‚åº½å¼¥å¾ƒã¤ˆã¤”ã¤¿ã¥æƒ—æ„½å³¥ã¦‰æ†·æ†¹æ‡ã¦¸æˆ¬æŠæ‹¥æŒ˜ã§¸åš±"],
+		["8da1", "ã¨ƒæ¢æ»æ‡æ‘šã©‹æ“€å´•å˜¡é¾Ÿãª—æ–†ãª½æ—¿æ™“ã«²æš’ã¬¢æœ–ã­‚æž¤æ €ã­˜æ¡Šæ¢„ã­²ã­±ã­»æ¤‰æ¥ƒç‰œæ¥¤æ¦Ÿæ¦…ã®¼æ§–ã¯æ©¥æ©´æ©±æª‚ã¯¬æª™ã¯²æª«æªµæ«”æ«¶æ®æ¯æ¯ªæ±µæ²ªã³‹æ´‚æ´†æ´¦æ¶ã³¯æ¶¤æ¶±æ¸•æ¸˜æ¸©æº†ð¨§€æº»æ»¢æ»šé½¿æ»¨æ»©æ¼¤æ¼´ãµ†ð£½æ¾æ¾¾ãµªãµµç†·å²™ã¶Šç€¬ã¶‘çç”ç¯ç¿ç‚‰ð Œ¥äã—±ð »˜"],
+		["8e40", "ð£»—åž¾ð¦»“ç„¾ð¥Ÿ ã™Žæ¦¢ð¨¯©å­´ç©‰ð¥£¡ð©“™ç©¥ç©½ð¥¦¬çª»çª°ç«‚ç«ƒç‡‘ð¦’ä‡Šç«šç«ç«ªä‡¯å’²ð¥°ç¬‹ç­•ç¬©ð¥ŒŽð¥³¾ç®¢ç­¯èŽœð¥®´ð¦±¿ç¯è¡ç®’ç®¸ð¥´ ã¶­ð¥±¥è’’ç¯ºç°†ç°µð¥³ç±„ç²ƒð¤¢‚ç²¦æ™½ð¤•¸ç³‰ç³‡ç³¦ç±´ç³³ç³µç³Ž"],
+		["8ea1", "ç¹§ä”ð¦¹„çµð¦»–ç’ç¶‰ç¶«ç„µç¶³ç·’ð¤—ð¦€©ç·¤ã´“ç·µð¡Ÿ¹ç·¥ð¨­ç¸ð¦„¡ð¦…šç¹®çº’äŒ«é‘¬ç¸§ç½€ç½ç½‡ç¤¶ð¦‹é§¡ç¾—ð¦‘ç¾£ð¡™¡ð ¨ä•œð£¦ä”ƒð¨Œºç¿ºð¦’‰è€…è€ˆè€è€¨è€¯ðª‚‡ð¦³ƒè€»è€¼è¡ð¢œ”ä¦‰ð¦˜¦ð£·£ð¦›¨æœ¥è‚§ð¨©ˆè„‡è„šå¢°ð¢›¶æ±¿ð¦’˜ð¤¾¸æ“§ð¡’Šèˆ˜ð¡¡žæ©“ð¤©¥ð¤ª•ä‘ºèˆ©ð ¬ð¦©’ð£µ¾ä¿¹ð¡“½è“¢è¢ð¦¬Šð¤¦§ð£”°ð¡³ð£·¸èŠªæ¤›ð¯¦”ä‡›"],
+		["8f40", "è•‹è‹èŒšð ¸–ð¡ž´ã›ð£…½ð£•šè‰»è‹¢èŒ˜ð£º‹ð¦¶£ð¦¬…ð¦®—ð£—Žã¶¿èŒå—¬èŽ…ä”‹ð¦¶¥èŽ¬èè“ã‘¾ð¦»”æ©—è•šã’–ð¦¹‚ð¢»¯è‘˜ð¥¯¤è‘±ã·“ä“¤æª§è‘Šð£²µç¥˜è’¨ð¦®–ð¦¹·ð¦¹ƒè“žèèŽ‘ä’ è’“è“¤ð¥²‘ä‰€ð¥³€ä•ƒè”´å«²ð¦º™ä”§è•³ä”–æž¿è˜–"],
+		["8fa1", "ð¨˜¥ð¨˜»è—ð§‚ˆè˜‚ð¡–‚ð§ƒð¯¦²ä•ªè˜¨ã™ˆð¡¢¢å·ð§Žšè™¾è±ðªƒ¸èŸ®ð¢°§èž±èŸšè å™¡è™¬æ¡–ä˜è¡…è¡†ð§— ð£¶¹ð§—¤è¡žè¢œä™›è¢´è¢µæè£…ç·ð§œè¦‡è¦Šè¦¦è¦©è¦§è¦¼ð¨¨¥è§§ð§¤¤ð§ª½èªœçž“é‡¾èªð§©™ç«©ð§¬ºð£¾äœ“ð§¬¸ç…¼è¬Œè¬Ÿð¥°ð¥•¥è¬¿è­Œè­èª©ð¤©ºè®è®›èª¯ð¡›Ÿä˜•è¡è²›ð§µ”ð§¶ð¯§”ãœ¥ð§µ“è³–ð§¶˜ð§¶½è´’è´ƒð¡¤è³›çœè´‘ð¤³‰ã»èµ·"],
+		["9040", "è¶©ð¨€‚ð¡€”ð¤¦Šã­¼ð¨†¼ð§„Œç«§èº­èº¶è»ƒé‹”è¼™è¼­ð¨¥ð¨’è¾¥éŒƒðªŠŸð ©è¾³ä¤ªð¨§žð¨”½ð£¶»å»¸ð£‰¢è¿¹ðª€”ð¨š¼ð¨”ð¢Œ¥ã¦€ð¦»—é€·ð¨”¼ð§ª¾é¡ð¨•¬ð¨˜‹é‚¨ð¨œ“éƒ„ð¨›¦é‚®éƒ½é…§ã«°é†©é‡„ç²¬ð¨¤³ð¡º‰éˆŽæ²Ÿé‰é‰¢ð¥–¹éŠ¹ð¨«†ð£²›ð¨¬Œð¥—›"],
+		["90a1", "ð ´±éŒ¬é«ð¨«¡ð¨¯«ç‚å«ƒð¨«¢ð¨«¥ä¥¥é‰„ð¨¯¬ð¨°¹ð¨¯¿é³é‘›èº¼é–…é–¦é¦é– æ¿¶äŠ¹ð¢™ºð¨›˜ð¡‰¼ð£¸®ä§Ÿæ°œé™»éš–ä…¬éš£ð¦»•æ‡šéš¶ç£µð¨« éš½åŒä¦¡ð¦²¸ð ‰´ð¦ð©‚¯ð©ƒ¥ð¤«‘ð¡¤•ð£ŒŠéœ±è™‚éœ¶ä¨ä”½ä–…ð¤«©çµå­éœ›éœð©‡•é—å­Šð©‡«éŸé¥åƒð£‚·ð£‚¼éž‰éžŸéž±éž¾éŸ€éŸ’éŸ ð¥‘¬éŸ®çœð©³éŸ¿éŸµð©ð§¥ºä«‘é ´é ³é¡‹é¡¦ã¬Žð§…µãµ‘ð ˜°ð¤…œ"],
+		["9140", "ð¥œ†é£Šé¢·é£ˆé£‡ä«¿ð¦´§ð¡›“å–°é£¡é£¦é£¬é¸é¤¹ð¤¨©ä­²ð©¡—ð©¤…é§µé¨Œé¨»é¨é©˜ð¥œ¥ã›„ð©‚±ð©¯•é« é«¢ð©¬…é«´ä°Žé¬”é¬­ð¨˜€å€´é¬´ð¦¦¨ã£ƒð£½é­é­€ð©´¾å©…ð¡¡£é®Žð¤‰‹é°‚é¯¿é°Œð©¹¨é·”ð©¾·ðª†’ðª†«ðªƒ¡ðª„£ðª‡Ÿéµ¾é¶ƒðª„´é¸Žæ¢ˆ"],
+		["91a1", "é·„ð¢…›ðª†“ðªˆ ð¡¤»ðªˆ³é´¹ðª‚¹ðªŠ´éºéº•éºžéº¢ä´´éºªéº¯ð¤¤é»ã­ ã§¥ã´ä¼²ãž¾ð¨°«é¼‚é¼ˆä®–é¤ð¦¶¢é¼—é¼–é¼¹åšŸåšŠé½…é¦¸ð©‚‹éŸ²è‘¿é½¢é½©ç«œé¾Žçˆ–ä®¾ð¤¥µð¤¦»ç…·ð¤§¸ð¤ˆð¤©‘çŽžð¨¯šð¡£ºç¦Ÿð¨¥¾ð¨¸¶é©é³ð¨©„é‹¬éŽé‹ð¨¥¬ð¤’¹çˆ—ã»«ç²ç©ƒçƒð¤‘³ð¤¸ç…¾ð¡Ÿ¯ç‚£ð¡¢¾ð£–™ã»‡ð¡¢…ð¥¯ð¡Ÿ¸ãœ¢ð¡›»ð¡ ¹ã›¡ð¡´ð¡£‘ð¥½‹ãœ£ð¡›€å›ð¤¨¥ð¡¾ð¡Š¨"],
+		["9240", "ð¡†ð¡’¶è”ƒð£š¦è”ƒè‘•ð¤¦”ð§…¥ð£¸±ð¥•œð£»»ð§’ä“´ð£›®ð©¦ð¦¼¦æŸ¹ãœ³ã°•ã·§å¡¬ð¡¤¢æ ä—ð£œ¿ð¤ƒ¡ð¤‚‹ð¤„ð¦°¡å“‹åšžð¦š±åš’ð ¿Ÿð ®¨ð ¸é†ð¨¬“éŽœä»¸å„«ã ™ð¤¶äº¼ð ‘¥ð ¿ä½‹ä¾Šð¥™‘å©¨ð †«ð ‹ã¦™ð ŒŠð ”ãµä¼©ð ‹€ð¨º³ð ‰µè«šð ˆŒäº˜"],
+		["92a1", "åƒå„ä¾¢ä¼ƒð¤¨Žð£ºŠä½‚å€®å¬å‚ä¿Œä¿¥å˜åƒ¼å…™å…›å…å…žæ¹¶ð£–•ð£¸¹ð£º¿æµ²ð¡¢„ð£º‰å†¨å‡ƒð — ä“ð ’£ð ’’ð ’‘èµºð¨ªœð œŽå‰™åŠ¤ð ¡³å‹¡é®ä™ºç†Œð¤ŽŒð ° ð¤¦¬ð¡ƒ¤æ§‘ð ¸ç‘¹ã»žç’™ç”ç‘–çŽ˜ä®Žð¤ª¼ð¤‚åã–„çˆð¤ƒ‰å–´ð …å“ð ¯†åœé‰é›´é¦åŸåžå¿ã˜¾å£‹åª™ð¨©†ð¡›ºð¡¯ð¡œå¨¬å¦¸éŠå©¾å«å¨’ð¥¥†ð¡§³ð¡¡¡ð¤Š•ã›µæ´…ç‘ƒå¨¡ð¥ºƒ"],
+		["9340", "åªð¨¯—ð “é ç’Œð¡Œƒç„…ä¥²éˆð¨§»éŽ½ãž å°žå²žå¹žå¹ˆð¡¦–ð¡¥¼ð£«®å»å­ð¡¤ƒð¡¤„ãœð¡¢ ã›ð¡›¾ã›“è„ªð¨©‡ð¡¶ºð£‘²ð¨¦¨å¼Œå¼Žð¡¤§ð¡ž«å©«ð¡œ»å­„è˜”ð§—½è¡ æ¾ð¢¡ ð¢˜«å¿›ãº¸ð¢–¯ð¢–¾ð©‚ˆð¦½³æ‡€ð €¾ð †ð¢˜›æ†™æ†˜æµð¢²›ð¢´‡ð¤›”ð©…"],
+		["93a1", "æ‘±ð¤™¥ð¢­ªã¨©ð¢¬¢ð£‘ð©£ªð¢¹¸æŒ·ðª‘›æ’¶æŒ±æ‘ð¤§£ð¢µ§æŠ¤ð¢²¡æ»æ•«æ¥²ã¯´ð£‚Žð£Š­ð¤¦‰ð£Š«å”ð£‹ ð¡£™ð©¿æ›Žð£Š‰ð£†³ã« ä†ð¥–„ð¨¬¢ð¥–ð¡›¼ð¥•›ð¥¥ç£®ð£„ƒð¡ ªð£ˆ´ã‘¤ð£ˆð£†‚ð¤‹‰æšŽð¦´¤æ™«ä®“æ˜°ð§¡°ð¡·«æ™£ð£‹’ð£‹¡æ˜žð¥¡²ã£‘ð£ ºð£ž¼ã®™ð£ž¢ð£¾ç“ã®–æžð¤˜ªæ¢¶æ žã¯„æª¾ã¡£ð£Ÿ•ð¤’‡æ¨³æ©’æ«‰æ¬…ð¡¤’æ”‘æ¢˜æ©Œã¯—æ©ºæ­—ð£¿€ð£²šéŽ é‹²ð¨¯ªð¨«‹"],
+		["9440", "éŠ‰ð¨€žð¨§œé‘§æ¶¥æ¼‹ð¤§¬æµ§ð£½¿ã¶æ¸„ð¤€¼å¨½æ¸Šå¡‡æ´¤ç¡‚ç„»ð¤Œšð¤‰¶çƒ±ç‰çŠ‡çŠ”ð¤žð¤œ¥å…¹ð¤ª¤ð —«ç‘ºð£»¸ð£™Ÿð¤©Šð¤¤—ð¥¿¡ã¼†ãº±ð¤«Ÿð¨°£ð£¼µæ‚§ã»³ç“Œç¼éŽ‡ç·ä’Ÿð¦·ªä•‘ç–ƒã½£ð¤³™ð¤´†ã½˜ç••ç™³ðª—†ã¬™ç‘¨ð¨«Œð¤¦«ð¤¦Žã«»"],
+		["94a1", "ã·ð¤©Žã»¿ð¤§…ð¤£³é‡ºåœ²é‚ð¨«£ð¡¡¤åƒŸð¥ˆ¡ð¥‡§ç¸ð£ˆ²çœŽçœç»ð¤š—ð£žã©žð¤£°ç¸ç’›ãº¿ð¤ªºð¤«‡äƒˆð¤ª–ð¦†®éŒ‡ð¥–ç žç¢ç¢ˆç£’çç¥™ð§ð¥›£ä„Žç¦›è’–ç¦¥æ¨­ð£»ºç¨ºç§´ä…®ð¡›¦ä„²éˆµç§±ð µŒð¤¦Œð Š™ð£¶ºð¡®ã–—å•«ã•°ãšªð ‡”ð °ç«¢å©™ð¢›µð¥ª¯ð¥ªœå¨ð ‰›ç£°å¨ªð¥¯†ç«¾ä‡¹ç±ç±­äˆ‘ð¥®³ð¥º¼ð¥º¦ç³ð¤§¹ð¡ž°ç²Žç±¼ç²®æª²ç·œç¸‡ç·“ç½Žð¦‰¡"],
+		["9540", "ð¦…œð§­ˆç¶—ð¥º‚ä‰ªð¦­µð ¤–æŸ–ð Žð£—åŸ„ð¦’ð¦¸ð¤¥¢ç¿ç¬§ð  ¬ð¥«©ð¥µƒç¬Œð¥¸Žé§¦è™…é©£æ¨œð£¿ã§¢ð¤§·ð¦–­é¨Ÿð¦– è’€ð§„§ð¦³‘ä“ªè„·ä‚èƒ†è„‰è…‚ð¦ž´é£ƒð¦©‚è‰¢è‰¥ð¦©‘è‘“ð¦¶§è˜ð§ˆ›åª†ä…¿ð¡¡€å¬«ð¡¢¡å«¤ð¡£˜èš ð¯¦¼ð£¶è ­ð§¢å¨‚"],
+		["95a1", "è¡®ä½…è¢‡è¢¿è£¦è¥¥è¥ð¥šƒè¥”ð§ž…ð§ž„ð¨¯µð¨¯™ð¨®œð¨§¹ãº­è’£ä›µä›ãŸ²è¨½è¨œð©‘ˆå½éˆ«ð¤Š„æ—”ç„©çƒ„ð¡¡…éµ­è²Ÿè³©ð§·œå¦šçŸƒå§°ä®ã›”è¸ªèº§ð¤°‰è¼°è½Šä‹´æ±˜æ¾»ð¢Œ¡ä¢›æ½¹æº‹ð¡Ÿšé¯©ãšµð¤¤¯é‚»é‚—å•±ä¤†é†»é„ð¨©‹ä¢ð¨«¼é§ð¨°ð¨°»è“¥è¨«é–™é–§é–—é––ð¨´´ç‘…ã»‚ð¤£¿ð¤©‚ð¤ªã»§ð£ˆ¥éšð¨»§ð¨¹¦ð¨¹¥ã»Œð¤§­ð¤©¸ð£¿®ç’ç‘«ã»¼éð©‚°"],
+		["9640", "æ¡‡ä¨ð©‚“ð¥ŸŸéé¨ð¨¦‰ð¨°¦ð¨¬¯ð¦Ž¾éŠºå¬‘è­©ä¤¼ç¹ð¤ˆ›éž›é±é¤¸ð ¼¦å·ð¨¯…ð¤ª²é Ÿð©“šé‹¶ð©——é‡¥ä“€ð¨­ð¤©§ð¨­¤é£œð¨©…ã¼€éˆªä¤¥è”é¤»é¥ð§¬†ã·½é¦›ä­¯é¦ªé©œð¨­¥ð¥£ˆæªé¨¡å«¾é¨¯ð©£±ä®ð©¥ˆé¦¼ä®½ä®—é½å¡²ð¡Œ‚å ¢ð¤¦¸"],
+		["96a1", "ð¡“¨ç¡„ð¢œŸð£¶¸æ£…ãµ½é‘˜ã¤§æ…ð¢žð¢¥«æ„‡é±é±“é±»é°µé°é­¿é¯ð©¸­é®Ÿðª‡µðªƒ¾é´¡ä²®ð¤„„é¸˜ä²°é´Œðª†´ðªƒ­ðªƒ³ð©¤¯é¶¥è’½ð¦¸’ð¦¿Ÿð¦®‚è—¼ä”³ð¦¶¤ð¦º„ð¦·°è è—®ð¦¸€ð£Ÿ—ð¦¤ç§¢ð£–œð£™€ä¤­ð¤§žãµ¢é›éŠ¾éˆð Š¿ç¢¹é‰·é‘ä¿¤ã‘€é¤ð¥•ç ½ç¡”ç¢¶ç¡‹ð¡—ð£‡‰ð¤¥ãššä½²æ¿šæ¿™ç€žç€žå”ð¤†µåž»å£³åžŠé´–åŸ—ç„´ã’¯ð¤†¬ç‡«ð¦±€ð¤¾—å¬¨ð¡žµð¨©‰"],
+		["9740", "æ„Œå«Žå¨‹äŠ¼ð¤’ˆãœ¬ä­»ð¨§¼éŽ»éŽ¸ð¡£–ð ¼è‘²ð¦³€ð¡“ð¤‹ºð¢°¦ð¤å¦”ð£¶·ð¦ç¶¨ð¦…›ð¦‚¤ð¤¦¹ð¤¦‹ð¨§ºé‹¥ç¢ã»©ç’´ð¨­£ð¡¢Ÿã»¡ð¤ª³æ«˜ç³ç»ã»–ð¤¨¾ð¤ª”ð¡Ÿ™ð¤©¦ð Ž§ð¡¤ð¤§¥ç‘ˆð¤¤–ç‚¥ð¤¥¶éŠ„ç¦éŸð “¾éŒ±ð¨«Žð¨¨–éŽ†ð¨¯§ð¥—•ä¤µð¨ª‚ç…«"],
+		["97a1", "ð¤¥ƒð ³¿åš¤ð ˜šð ¯«ð ²¸å”‚ç§„ð¡Ÿºç·¾ð¡›‚ð¤©ð¡¡’ä”®éãœŠð¨«€ð¤¦­å¦°ð¡¢¿ð¡¢ƒð§’„åª¡ã›¢ð£µ›ãš°é‰Ÿå©¹ð¨ªð¡¡¢é´ã³ð ª´äª–ã¦Šåƒ´ãµ©ãµŒð¡Žœç…µä‹»ð¨ˆ˜æ¸ð©ƒ¤ä“«æµ—ð§¹ç§æ²¯ã³–ð£¿­ð£¸­æ¸‚æ¼Œãµ¯ð µç•‘ãš¼ã“ˆäš€ã»šä¡±å§„é‰®ä¤¾è½ð¨°œð¦¯€å ’åŸˆã›–ð¡‘’çƒ¾ð¤¢ð¤©±ð¢¿£ð¡Š°ð¢Ž½æ¢¹æ¥§ð¡Ž˜ð£“¥ð§¯´ð£›Ÿð¨ªƒð£Ÿ–ð£ºð¤²Ÿæ¨šð£š­ð¦²·è¾ä“Ÿä“Ž"],
+		["9840", "ð¦´¦ð¦µ‘ð¦²‚ð¦¿žæ¼—ð§„‰èŒ½ð¡œºè­ð¦²€ð§“ð¡Ÿ›å¦‰åª‚ð¡ž³å©¡å©±ð¡¤…ð¤‡¼ãœ­å§¯ð¡œ¼ã›‡ç†ŽéŽæššð¤Š¥å©®å¨«ð¤Š“æ¨«ð£»¹ð§œ¶ð¤‘›ð¤‹Šç„ð¤‰™ð¨§¡ä¾°ð¦´¨å³‚ð¤“Žð§¹ð¤Ž½æ¨Œð¤‰–ð¡Œ„ç‚¦ç„³ð¤©ã¶¥æ³Ÿð¯ ¥ð¤©ç¹¥å§«å´¯ã·³å½œð¤©ð¡ŸŸç¶¤è¦"],
+		["98a1", "å’…ð£«ºð£Œ€ð ˆ”å¾ð £•ð ˜™ã¿¥ð¡¾žðªŠ¶ç€ƒð©…›åµ°çŽç³“ð¨©™ð© ä¿ˆç¿§ç‹çŒð§«´çŒ¸çŒ¹ð¥›¶ççˆãº©ð§¬˜é¬ç‡µð¤£²ç¡è‡¶ã»ŠçœŒã»‘æ²¢å›½ç™çžçŸã»¢ã»°ã»´ã»ºç““ã¼Žã½“ç•‚ç•­ç•²ç–ã½¼ç—ˆç—œã¿€ç™ã¿—ç™´ã¿œç™ºð¤½œç†ˆå˜£è¦€å¡©ä€çƒä€¹æ¡ä…ã—›çž˜äªä¯å±žçž¾çŸ‹å£²ç ˜ç‚¹ç œä‚¨ç ¹ç¡‡ç¡‘ç¡¦è‘ˆð¥”µç¤³æ ƒç¤²ä„ƒ"],
+		["9940", "ä„‰ç¦‘ç¦™è¾»ç¨†è¾¼ä…§çª‘ä†²çª¼è‰¹ä‡„ç«ç«›ä‡ä¸¡ç­¢ç­¬ç­»ç°’ç°›ä‰ ä‰ºç±»ç²œäŠŒç²¸äŠ”ç³­è¾“çƒ€ð ³ç·ç·”ç·ç·½ç¾®ç¾´çŠŸäŽ—è€ è€¥ç¬¹è€®è€±è”ã·Œåž´ç‚ è‚·èƒ©ä­è„ŒçŒªè„Žè„’ç• è„”äã¬¹è…–è…™è…š"],
+		["99a1", "ä“å ºè…¼è†„ä¥è†“ä­è†¥åŸ¯è‡è‡¤è‰”ä’èŠ¦è‰¶è‹Šè‹˜è‹¿ä’°è—é™©æ¦Šè…çƒµè‘¤æƒ£è’ˆä”„è’¾è“¡è“¸è”è”¸è•’ä”»è•¯è•°è— ä•·è™²èš’èš²è›¯é™…èž‹ä˜†ä˜—è¢®è£¿è¤¤è¥‡è¦‘ð§¥§è¨©è¨¸èª”èª´è±‘è³”è³²è´œäž˜å¡Ÿè·ƒäŸ­ä»®è¸ºå—˜å”è¹±å—µèº°ä ·è»Žè»¢è»¤è»­è»²è¾·è¿è¿Šè¿Œé€³é§„ä¢­é£ éˆ“ä¤žéˆ¨é‰˜é‰«éŠ±éŠ®éŠ¿"],
+		["9a40", "é‹£é‹«é‹³é‹´é‹½éƒéŽ„éŽ­ä¥…ä¥‘éº¿é—åŒéé­é¾ä¥ªé‘”é‘¹é”­é–¢ä¦§é—´é˜³ä§¥æž ä¨¤é€ä¨µéž²éŸ‚å™”ä«¤æƒ¨é¢¹ä¬™é£±å¡„é¤Žé¤™å†´é¤œé¤·é¥‚é¥é¥¢ä­°é§…ä®é¨¼é¬çªƒé­©é®é¯é¯±é¯´ä±­é° ã¯ð¡¯‚éµ‰é°º"],
+		["9aa1", "é»¾å™é¶“é¶½é·€é·¼é“¶è¾¶é¹»éº¬éº±éº½é»†é“œé»¢é»±é»¸ç«ˆé½„ð ‚”ð Š·ð Ž æ¤šé“ƒå¦¬ð “—å¡€é“ãž¹ð —•ð ˜•ð ™¶ð¡šºå—ç…³ð «‚ð «ð ®¿å‘ªð¯ »ð ¯‹å’žð ¯»ð °»ð ±“ð ±¥ð ±¼æƒ§ð ²å™ºð ²µð ³ð ³­ð µ¯ð ¶²ð ·ˆæ¥•é°¯èž¥ð ¸„ð ¸Žð »—ð ¾ð ¼­ð ¹³å° ð ¾¼å¸‹ð¡œð¡ð¡¶æœžð¡»ð¡‚ˆð¡‚–ã™‡ð¡‚¿ð¡ƒ“ð¡„¯ð¡„»å¤è’­ð¡‹£ð¡µð¡Œ¶è®ð¡•·ð¡˜™ð¡Ÿƒð¡Ÿ‡ä¹¸ç‚»ð¡ ­ð¡¥ª"],
+		["9b40", "ð¡¨­ð¡©…ð¡°ªð¡±°ð¡²¬ð¡»ˆæ‹ƒð¡»•ð¡¼•ç†˜æ¡•ð¢…æ§©ã›ˆð¢‰¼ð¢—ð¢ºð¢œªð¢¡±ð¢¥è‹½ð¢¥§ð¢¦“ð¢«•è¦¥ð¢«¨è¾ ð¢¬Žéž¸ð¢¬¿é¡‡éª½ð¢±Œ"],
+		["9b62", "ð¢²ˆð¢²·ð¥¯¨ð¢´ˆð¢´’ð¢¶·ð¢¶•ð¢¹‚ð¢½´ð¢¿Œð£€³ð£¦ð£ŒŸð£žå¾±æ™ˆæš¿ð§©¹ð£•§ð£—³çˆð¤¦ºçŸ—ð£˜šð£œ–çº‡ð †å¢µæœŽ"],
+		["9ba1", "æ¤˜ð£ª§ð§™—ð¥¿¢ð£¸‘ð£º¹ð§—¾ð¢‚šä£äª¸ð¤„™ð¨ªšð¤‹®ð¤Œð¤€»ð¤Œ´ð¤Ž–ð¤©…ð —Šå‡’ð ˜‘å¦Ÿð¡º¨ã®¾ð£³¿ð¤„ð¤“–åžˆð¤™´ã¦›ð¤œ¯ð¨—¨ð©§‰ã¢ð¢‡ƒè­žð¨­Žé§–ð¤ ’ð¤£»ð¤¨•çˆ‰ð¤«€ð ±¸å¥¥ð¤º¥ð¤¾†ð ¹è»šð¥€¬åŠåœ¿ç…±ð¥Š™ð¥™ð£½Šð¤ª§å–¼ð¥‘†ð¥‘®ð¦­’é‡”ã‘³ð¥”¿ð§˜²ð¥•žäœ˜ð¥•¢ð¥•¦ð¥Ÿ‡ð¤¤¿ð¥¡å¦ã“»ð£Œæƒžð¥¤ƒä¼ð¨¥ˆð¥ª®ð¥®‰ð¥°†ð¡¶åž¡ç…‘æ¾¶ð¦„‚ð§°’é–ð¦†²ð¤¾šè­¢ð¦‚ð¦‘Š"],
+		["9c40", "åµ›ð¦¯·è¼¶ð¦’„ð¡¤œè«ªð¤§¶ð¦’ˆð£¿¯ð¦”’ä¯€ð¦–¿ð¦šµð¢œ›é‘¥ð¥Ÿ¡æ†•å¨§ð¯£ä¾»åš¹ð¤”¡ð¦›¼ä¹ªð¤¤´é™–æ¶ð¦²½ã˜˜è¥·ð¦ž™ð¦¡®ð¦‘ð¦¡žç‡Ÿð¦£‡ç­‚ð©ƒ€ð ¨‘ð¦¤¦é„„ð¦¤¹ç©…é·°ð¦§ºé¨¦ð¦¨­ã™Ÿð¦‘©ð €¡ç¦ƒð¦¨´ð¦­›å´¬ð£”™èð¦®ä›ð¦²¤ç”»è¡¥ð¦¶®å¢¶"],
+		["9ca1", "ãœœð¢–ð§‹ð§‡ã±”ð§Š€ð§Š…éŠð¢…ºð§Š‹éŒ°ð§‹¦ð¤§æ°¹é’Ÿð§‘ð »¸è §è£µð¢¤¦ð¨‘³ð¡ž±æº¸ð¤¨ªð¡  ã¦¤ãš¹å°ç§£ä”¿æš¶ð©²­ð©¢¤è¥ƒð§ŸŒð§¡˜å›–äƒŸð¡˜Šã¦¡ð£œ¯ð¨ƒ¨ð¡…ç†­è¦ð§§ð©†¨å©§ä²·ð§‚¯ð¨¦«ð§§½ð§¨Šð§¬‹ð§µ¦ð¤…ºç­ƒç¥¾ð¨€‰æ¾µðª‹Ÿæ¨ƒð¨Œ˜åŽ¢ð¦¸‡éŽ¿æ ¶éð¨…¯ð¨€£ð¦¦µð¡­ð£ˆ¯ð¨ˆå¶…ð¨°°ð¨‚ƒåœ•é £ð¨¥‰å¶«ð¤¦ˆæ–¾æ§•å’ð¤ª¥ð£¾ã°‘æœ¶ð¨‚ð¨ƒ´ð¨„®ð¡¾¡ð¨…"],
+		["9d40", "ð¨†‰ð¨†¯ð¨ˆšð¨Œ†ð¨Œ¯ð¨ŽŠã—Šð¨‘¨ð¨šªä£ºæ¦ð¨¥–ç ˆé‰•ð¨¦¸ä²ð¨§§äŸð¨§¨ð¨­†ð¨¯”å§¸ð¨°‰è¼‹ð¨¿…ð©ƒ¬ç­‘ð©„ð©„¼ã··ð©…žð¤«Šè¿çŠåš‹ð©“§ð©—©ð©–°ð©–¸ð©œ²ð©£‘ð©¥‰ð©¥ªð©§ƒð©¨¨ð©¬Žð©µšð©¶›çºŸð©»¸ð©¼£ä²¤é•‡ðªŠ“ç†¢ðª‹¿ä¶‘é€’ðª—‹ä¶œð ²œè¾¾å—"],
+		["9da1", "è¾ºð¢’°è¾¹ð¤ª“ä”‰ç¹¿æ½–æª±ä»ªã“¤ð¨¬¬ð§¢ãœºèº€ð¡Ÿµð¨€¤ð¨­¬ð¨®™ð§¨¾ð¦š¯ã·«ð§™•ð£²·ð¥˜µð¥¥–äºšð¥ºð¦‰˜åš¿ð ¹­è¸Žå­­ð£ºˆð¤²žæžæ‹ð¡Ÿ¶ð¡¡»æ”°å˜­ð¥±Šåšð¥Œ‘ã·†ð©¶˜ä±½å˜¢å˜žç½‰ð¥»˜å¥µð£µ€è°ä¸œð ¿ªð µ‰ð£šºè„—éµžè´˜ç˜»é±…ç™Žçž¹é…å²è…ˆè‹·å˜¥è„²è˜è‚½å—ªç¥¢å™ƒå–ð ºã—Žå˜…å—±æ›±ð¨‹¢ã˜­ç”´å—°å–ºå’—å•²ð ±ð ²–å»ð¥…ˆð ¹¶ð¢±¢"],
+		["9e40", "ð º¢éº«çµšå—žð¡µæŠé­å’”è³ç‡¶é…¶æ¼æŽ¹æ¾å•©ð¢­ƒé±²ð¢º³å†šã“Ÿð ¶§å†§å‘å”žå”“ç™¦è¸­ð¦¢Šç–±è‚¶è „èž†è£‡è†¶èœð¡ƒä“¬çŒ„ð¤œ†å®èŒ‹ð¦¢“å™»ð¢›´ð§´¯ð¤†£ð§µ³ð¦»ð§Š¶é…°ð¡‡™éˆˆð£³¼ðªš©ð º¬ð »¹ç‰¦ð¡²¢äŽð¤¿‚ð§¿¹ð ¿«äƒº"],
+		["9ea1", "é±æ”Ÿð¢¶ ä£³ð¤Ÿ ð©µ¼ð ¿¬ð ¸Šæ¢ð§–£ð ¿­"],
+		["9ead", "ð¦ˆð¡†‡ç†£çºŽéµä¸šä¸„ã•·å¬æ²²å§ãš¬ã§œå½ãš¥ð¤˜˜å¢šð¤­®èˆ­å‘‹åžªð¥ª•ð ¥¹"],
+		["9ec5", "ã©’ð¢‘¥ç´ð©º¬ä´‰é¯­ð£³¾ð©¼°ä±›ð¤¾©ð©–žð©¿žè‘œð£¶¶ð§Š²ð¦ž³ð£œ æŒ®ç´¥ð£»·ð£¸¬ã¨ªé€ˆå‹Œã¹´ã™ºä—©ð ’Žç™€å«°ð º¶ç¡ºð§¼®å¢§ä‚¿å™¼é®‹åµ´ç™”ðª´éº…ä³¡ç—¹ãŸ»æ„™ð£ƒšð¤²"],
+		["9ef5", "å™ð¡Š©åž§ð¤¥£ð©¸†åˆ´ð§‚®ã–­æ±Šéµ¼"],
+		["9f40", "ç±–é¬¹åŸžð¡¬å±“æ““ð©“ð¦Œµð§…¤èš­ð ´¨ð¦´¢ð¤«¢ð µ±"],
+		["9f4f", "å‡¾ð¡¼å¶Žéœƒð¡·‘éºéŒç¬Ÿé¬‚å³‘ç®£æ‰¨æŒµé«¿ç¯é¬ªç±¾é¬®ç±‚ç²†é°•ç¯¼é¬‰é¼—é°›ð¤¤¾é½šå•³å¯ƒä¿½éº˜ä¿²å‰ ã¸†å‹‘å§å–å¦·å¸’éŸˆé¶«è½œå‘©éž´é¥€éžºåŒ¬æ„°"],
+		["9fa1", "æ¤¬åšé°Šé´‚ä°»é™æ¦€å‚¦ç•†ð¡­é§šå‰³"],
+		["9fae", "é…™éšé…œ"],
+		["9fb2", "é…‘ð¨º—æ¿ð¦´£æ«Šå˜‘é†Žç•ºæŠ…ð ¼çç±°ð¥°¡ð£³½"],
+		["9fc1", "ð¤¤™ç›–é®ä¸ªð ³”èŽ¾è¡‚"],
+		["9fc9", "å±Šæ§€åƒ­åºåˆŸå·µä»Žæ°±ð ‡²ä¼¹å’œå“šåŠšè¶‚ã—¾å¼Œã—³"],
+		["9fdb", "æ­’é…¼é¾¥é®—é ®é¢´éªºéº¨éº„ç…ºç¬”"],
+		["9fe7", "æ¯ºè ˜ç½¸"],
+		["9feb", "å˜ ðª™Šè¹·é½“"],
+		["9ff0", "è·”è¹é¸œè¸æŠ‚ð¨½è¸¨è¹µç«“ð¤©·ç¨¾ç£˜æ³ªè©§ç˜‡"],
+		["a040", "ð¨©šé¼¦æ³ŽèŸ–ç—ƒðªŠ²ç¡“ð¯¡€è´Œç‹¢ç±è¬­çŒ‚ç“±è³«ð¤ª»è˜¯å¾ºè¢ ä’·"],
+		["a055", "ð¡ »ð¦¸…"],
+		["a058", "è©¾ð¢”›"],
+		["a05b", "æƒ½ç™§é«—éµ„é®é®èŸµ"],
+		["a063", "è è³·çŒ¬éœ¡é®°ã—–çŠ²ä°‡ç±‘é¥Šð¦…™æ…™ä°„éº–æ…½"],
+		["a073", "åŸæ…¯æŠ¦æˆ¹æ‹Žã©œæ‡¢åŽªð£µæ¤æ ‚ã—’"],
+		["a0a1", "åµ—ð¨¯‚è¿šð¨¸¹"],
+		["a0a6", "åƒ™ð¡µ†ç¤†åŒ²é˜¸ð ¼»ä¥"],
+		["a0ae", "çŸ¾"],
+		["a0b0", "ç³‚ð¥¼šç³šç¨­è¦è£çµç”…ç“²è¦”èˆšæœŒè¢ð§’†è›ç“°è„ƒçœ¤è¦‰ð¦ŸŒç•“ð¦»‘èž©èŸŽè‡ˆèžŒè©‰è²­è­ƒçœ«ç“¸è“šã˜µæ¦²è¶¦"],
+		["a0d4", "è¦©ç‘¨æ¶¹èŸð¤€‘ç“§ã·›ç…¶æ‚¤æ†œã³‘ç…¢æ·"],
+		["a0e2", "ç½±ð¨¬­ç‰æƒ©ä­¾åˆ ã°˜ð£³‡ð¥»—ð§™–ð¥”±ð¡¥„ð¡‹¾ð©¤ƒð¦·œð§‚­å³ð¦†­ð¨¨ð£™·ð ƒ®ð¦¡†ð¤¼Žä•¢å¬Ÿð¦Œé½éº¦ð¦‰«"],
+		[
+			"a3c0",
+			"â€",
+			31,
+			"â¡"
+		],
+		[
+			"c6a1",
+			"â‘ ",
+			9,
+			"â‘´",
+			9,
+			"â…°",
+			9,
+			"ä¸¶ä¸¿äº…äº å†‚å†–å†«å‹¹åŒ¸å©åŽ¶å¤Šå®€å·›â¼³å¹¿å»´å½å½¡æ”´æ— ç–’ç™¶è¾µéš¶Â¨Ë†ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼ï¼»ï¼½âœ½ã",
+			23
+		],
+		[
+			"c740",
+			"ã™",
+			58,
+			"ã‚¡ã‚¢ã‚£ã‚¤"
+		],
+		[
+			"c7a1",
+			"ã‚¥",
+			81,
+			"Ð",
+			5,
+			"ÐÐ–",
+			4
+		],
+		[
+			"c840",
+			"Ð›",
+			26,
+			"Ñ‘Ð¶",
+			25,
+			"â‡§â†¸â†¹ã‡ð ƒŒä¹šð ‚Šåˆ‚ä’‘"
+		],
+		["c8a1", "é¾°å†ˆé¾±ð§˜‡"],
+		["c8cd", "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡ã‚›ã‚œâº€âº„âº†âº‡âºˆâºŠâºŒâºâº•âºœâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»†â»Šâ»Œâ»â»â»–â»—â»žâ»£"],
+		["c8f5", "ÊƒÉÉ›É”ÉµÅ“Ã¸Å‹ÊŠÉª"],
+		["f9fe", "ï¿­"],
+		["fa40", "ð •‡é‹›ð —Ÿð£¿…è•ŒäŠµç¯å†µã™‰ð¤¥‚ð¨§¤é„ð¡§›è‹®ð£³ˆç ¼æ„æ‹Ÿð¤¤³ð¨¦ªð Š ð¦®³ð¡Œ…ä¾«ð¢“­å€ˆð¦´©ð§ª„ð£˜€ð¤ª±ð¢”“å€©ð ¾å¾¤ð Ž€ð ‡æ»›ð Ÿå½å„ã‘ºå„Žé¡¬ãƒè–ð¤¦¤ð ’‡å… ð£Ž´å…ªð ¯¿ð¢ƒ¼ð ‹¥ð¢”°ð –Žð£ˆ³ð¡¦ƒå®‚è½ð –³ð£²™å†²å†¸"],
+		["faa1", "é´´å‡‰å‡å‡‘ã³œå‡“ð¤ª¦å†³å‡¢å‚å‡­èæ¤¾ð£œ­å½»åˆ‹åˆ¦åˆ¼åŠµå‰—åŠ”åŠ¹å‹…ç°•è•‚å‹ è˜ð¦¬“åŒ…ð¨«žå•‰æ»™ð£¾€ð ¥”ð£¿¬åŒ³å„ð ¯¢æ³‹ð¡œ¦æ ›ç•æŠãºªã£Œð¡›¨ç‡ä’¢å­å´ð¨š«å¾å¿ð¡––ð¡˜“çŸ¦åŽ“ð¨ª›åŽ åŽ«åŽ®çŽ§ð¥²ã½™çŽœåå…æ±‰ä¹‰åŸ¾å™ãª«ð ®å ð£¿«ð¢¶£å¶ð ±·å“ç¹å”«æ™—æµ›å‘­ð¦­“ð µ´å•å’å’¤äž¦ð¡œð »ã¶´ð µ"],
+		["fb40", "ð¨¦¼ð¢š˜å•‡ä³­å¯ç—å–†å–©å˜…ð¡£—ð¤€ºä•’ð¤µæš³ð¡‚´å˜·æ›ð£ŠŠæš¤æš­å™å™ç£±å›±éž‡å¾åœ€å›¯å›­ð¨­¦ã˜£ð¡‰å†ð¤†¥æ±®ç‚‹å‚ãš±ð¦±¾åŸ¦ð¡–å ƒð¡‘”ð¤£å ¦ð¤¯µå¡œå¢ªã•¡å£ å£œð¡ˆ¼å£»å¯¿åƒðª…ð¤‰¸é“ã–¡å¤Ÿæ¢¦ã›ƒæ¹™"],
+		["fba1", "ð¡˜¾å¨¤å•“ð¡š’è”…å§‰ð µŽð¦²ð¦´ªð¡Ÿœå§™ð¡Ÿ»ð¡ž²ð¦¶¦æµ±ð¡ ¨ð¡›•å§¹ð¦¹…åª«å©£ã›¦ð¤¦©å©·ãœˆåª–ç‘¥å«“ð¦¾¡ð¢•”ã¶…ð¡¤‘ãœ²ð¡š¸åºƒå‹å­¶æ–ˆå­¼ð§¨Žä€„ä¡ð ˆ„å¯•æ… ð¡¨´ð¥§Œð –¥å¯³å®ä´å°…ð¡­„å°“çŽå°”ð¡²¥ð¦¬¨å±‰ä£å²…å³©å³¯å¶‹ð¡·¹ð¡¸·å´å´˜åµ†ð¡º¤å²ºå·—è‹¼ã ­ð¤¤ð¢‰ð¢…³èŠ‡ã ¶ã¯‚å¸®æªŠå¹µå¹ºð¤’¼ð ³“åŽ¦äº·å»åŽ¨ð¡±å¸‰å»´ð¨’‚"],
+		["fc40", "å»¹å»»ã¢ å»¼æ ¾é›å¼ð ‡ð¯¢”ã«žä¢®ð¡Œºå¼ºð¦¢ˆð¢å½˜ð¢‘±å½£éž½ð¦¹®å½²é€ð¨¨¶å¾§å¶¶ãµŸð¥‰ð¡½ªð§ƒ¸ð¢™¨é‡–ð Šžð¨¨©æ€±æš…ð¡¡·ã¥£ã·‡ã˜¹åžð¢ž´ç¥±ã¹€æ‚žæ‚¤æ‚³ð¤¦‚ð¤¦ð§©“ç’¤åƒ¡åª æ…¤è¤æ…‚ð¯¢¦ð¦»’æ†å‡´ð ™–æ†‡å®ªð£¾·"],
+		["fca1", "ð¢¡Ÿæ‡“ð¨®ð©¥æ‡ã¤²ð¢¦€ð¢£æ€£æ…œæ”žæŽ‹ð „˜æ‹…ð¡°æ‹•ð¢¸æ¬ð¤§Ÿã¨—æ¸æ¸ð¡ŽŽð¡Ÿ¼æ’æ¾Šð¢¸¶é ”ð¤‚Œð¥œæ“¡æ“¥é‘»ã©¦æºã©—æ•æ¼–ð¤¨¨ð¤¨£æ–…æ•­æ•Ÿð£¾æ–µð¤¥€ä¬·æ—‘äƒ˜ð¡ ©æ— æ—£å¿Ÿð£€æ˜˜ð£‡·ð£‡¸æ™„ð£†¤ð£†¥æ™‹ð ¹µæ™§ð¥‡¦æ™³æ™´ð¡¸½ð£ˆ±ð¨—´ð£‡ˆð¥Œ“çŸ…ð¢£·é¦¤æœ‚ð¤Žœð¤¨¡ã¬«æ§ºð£Ÿ‚æžæ§æ¢ð¤‡ð©ƒ­æŸ—ä“©æ ¢æ¹éˆ¼æ ð£¦ð¦¶ æ¡"],
+		["fd40", "ð£‘¯æ§¡æ¨‹ð¨«Ÿæ¥³æ£ƒð£—æ¤æ¤€ã´²ã¨ð£˜¼ã®€æž¬æ¥¡ð¨©Šä‹¼æ¤¶æ¦˜ã®¡ð ‰è£å‚æ§¹ð£™™ð¢„ªæ©…ð£œƒæªã¯³æž±æ«ˆð©†œã°æ¬ð ¤£æƒžæ¬µæ­´ð¢Ÿæºµð£«›ð Žµð¡¥˜ã€å¡ð£­šæ¯¡ð£»¼æ¯œæ°·ð¢’‹ð¤£±ð¦­‘æ±šèˆ¦æ±¹ð£¶¼ä“…ð£¶½ð¤†¤ð¤¤Œð¤¤€"],
+		["fda1", "ð£³‰ã›¥ã³«ð ´²é®ƒð£‡¹ð¢’‘ç¾æ ·ð¦´¥ð¦¶¡ð¦·«æ¶–æµœæ¹¼æ¼„ð¤¥¿ð¤‚…ð¦¹²è”³ð¦½´å‡‡æ²œæ¸è®ð¨¬¡æ¸¯ð£¸¯ç‘“ð£¾‚ç§Œæ¹åª‘ð£‹æ¿¸ãœæ¾ð£¸°æ»ºð¡’—ð¤€½ä••é°æ½„æ½œãµŽæ½´ð©…°ã´»æ¾Ÿð¤…„æ¿“ð¤‚‘ð¤…•ð¤€¹ð£¿°ð£¾´ð¤„¿å‡Ÿð¤…–ð¤…—ð¤…€ð¦‡ç‹ç¾ç‚§ç‚çƒŒçƒ•çƒ–çƒŸä„„ã·¨ç†´ç†–ð¤‰·ç„«ç……åªˆç…Šç…®å²œð¤¥ç…é¢ð¤‹ç„¬ð¤‘šð¤¨§ð¤¨¢ç†ºð¨¯¨ç‚½çˆŽ"],
+		["fe40", "é‘‚çˆ•å¤‘é‘ƒçˆ¤éð¥˜…çˆ®ç‰€ð¤¥´æ¢½ç‰•ç‰—ã¹•ð£„æ æ¼½çŠ‚çŒªçŒ«ð¤ £ð¨ «ä£­ð¨ „çŒ¨çŒ®ççŽªð °ºð¦¨®ç‰ç‘‰ð¤‡¢ð¡›§ð¤¨¤æ˜£ã›…ð¤¦·ð¤¦ð¤§»ç·ç•æ¤ƒð¤¨¦ç¹ð —ƒã»—ç‘œð¢¢­ç‘ ð¨º²ç‘‡ç¤ç‘¶èŽ¹ç‘¬ãœ°ç‘´é±æ¨¬ç’‚ä¥“ð¤ªŒ"],
+		["fea1", "ð¤…Ÿð¤©¹ð¨®å­†ð¨°ƒð¡¢žç“ˆð¡¦ˆç”Žç“©ç”žð¨»™ð¡©‹å¯—ð¨º¬éŽ…ç•ç•Šç•§ç•®ð¤¾‚ã¼„ð¤´“ç–Žç‘ç–žç–´ç˜‚ç˜¬ç™‘ç™ç™¯ç™¶ð¦µçšè‡¯ãŸ¸ð¦¤‘ð¦¤Žçš¡çš¥çš·ç›Œð¦¾Ÿè‘¢ð¥‚ð¥…½ð¡¸œçœžçœ¦ç€æ’¯ð¥ˆ ç˜ð£Š¬çž¯ð¨¥¤ð¨¥¨ð¡›çŸ´ç ‰ð¡¶ð¤¨’æ£Šç¢¯ç£‡ç£“éš¥ç¤®ð¥— ç£—ç¤´ç¢±ð§˜Œè¾¸è¢„ð¨¬«ð¦‚ƒð¢˜œç¦†è¤€æ¤‚ç¦€ð¥¡—ç¦ð§¬¹ç¤¼ç¦©æ¸ªð§„¦ãº¨ç§†ð©„ç§”"]
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-data.js
+var require_dbcs_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-data.js": ((exports, module) => {
+	module.exports = {
+		shiftjis: {
+			type: "_dbcs",
+			table: function() {
+				return require_shiftjis();
+			},
+			encodeAdd: {
+				"Â¥": 92,
+				"â€¾": 126
+			},
+			encodeSkipVals: [{
+				from: 60736,
+				to: 63808
+			}]
+		},
+		csshiftjis: "shiftjis",
+		mskanji: "shiftjis",
+		sjis: "shiftjis",
+		windows31j: "shiftjis",
+		ms31j: "shiftjis",
+		xsjis: "shiftjis",
+		windows932: "shiftjis",
+		ms932: "shiftjis",
+		932: "shiftjis",
+		cp932: "shiftjis",
+		eucjp: {
+			type: "_dbcs",
+			table: function() {
+				return require_eucjp();
+			},
+			encodeAdd: {
+				"Â¥": 92,
+				"â€¾": 126
+			}
+		},
+		gb2312: "cp936",
+		gb231280: "cp936",
+		gb23121980: "cp936",
+		csgb2312: "cp936",
+		csiso58gb231280: "cp936",
+		euccn: "cp936",
+		windows936: "cp936",
+		ms936: "cp936",
+		936: "cp936",
+		cp936: {
+			type: "_dbcs",
+			table: function() {
+				return require_cp936();
+			}
+		},
+		gbk: {
+			type: "_dbcs",
+			table: function() {
+				return require_cp936().concat(require_gbk_added());
+			}
+		},
+		xgbk: "gbk",
+		isoir58: "gbk",
+		gb18030: {
+			type: "_dbcs",
+			table: function() {
+				return require_cp936().concat(require_gbk_added());
+			},
+			gb18030: function() {
+				return require_gb18030_ranges();
+			},
+			encodeSkipVals: [128],
+			encodeAdd: { "â‚¬": 41699 }
+		},
+		chinese: "gb18030",
+		windows949: "cp949",
+		ms949: "cp949",
+		949: "cp949",
+		cp949: {
+			type: "_dbcs",
+			table: function() {
+				return require_cp949();
+			}
+		},
+		cseuckr: "cp949",
+		csksc56011987: "cp949",
+		euckr: "cp949",
+		isoir149: "cp949",
+		korean: "cp949",
+		ksc56011987: "cp949",
+		ksc56011989: "cp949",
+		ksc5601: "cp949",
+		windows950: "cp950",
+		ms950: "cp950",
+		950: "cp950",
+		cp950: {
+			type: "_dbcs",
+			table: function() {
+				return require_cp950();
+			}
+		},
+		big5: "big5hkscs",
+		big5hkscs: {
+			type: "_dbcs",
+			table: function() {
+				return require_cp950().concat(require_big5_added());
+			},
+			encodeSkipVals: [
+				36457,
+				36463,
+				36478,
+				36523,
+				36532,
+				36557,
+				36560,
+				36695,
+				36713,
+				36718,
+				36811,
+				36862,
+				36973,
+				36986,
+				37060,
+				37084,
+				37105,
+				37311,
+				37551,
+				37552,
+				37553,
+				37554,
+				37585,
+				37959,
+				38090,
+				38361,
+				38652,
+				39285,
+				39798,
+				39800,
+				39803,
+				39878,
+				39902,
+				39916,
+				39926,
+				40002,
+				40019,
+				40034,
+				40040,
+				40043,
+				40055,
+				40124,
+				40125,
+				40144,
+				40279,
+				40282,
+				40388,
+				40431,
+				40443,
+				40617,
+				40687,
+				40701,
+				40800,
+				40907,
+				41079,
+				41180,
+				41183,
+				36812,
+				37576,
+				38468,
+				38637,
+				41636,
+				41637,
+				41639,
+				41638,
+				41676,
+				41678
+			]
+		},
+		cnbig5: "big5hkscs",
+		csbig5: "big5hkscs",
+		xxbig5: "big5hkscs"
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/index.js
+var require_encodings = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/index.js": ((exports) => {
+	var mergeModules$1 = require_merge_exports();
+	var modules = [
+		require_internal(),
+		require_utf32(),
+		require_utf16(),
+		require_utf7(),
+		require_sbcs_codec(),
+		require_sbcs_data(),
+		require_sbcs_data_generated(),
+		require_dbcs_codec(),
+		require_dbcs_data()
+	];
+	for (var i$1 = 0; i$1 < modules.length; i$1++) {
+		var module$1 = modules[i$1];
+		mergeModules$1(exports, module$1);
+	}
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/streams.js
+var require_streams = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/streams.js": ((exports, module) => {
+	var Buffer$2 = require_safer().Buffer;
+	module.exports = function(streamModule$1) {
+		var Transform = streamModule$1.Transform;
+		function IconvLiteEncoderStream(conv, options) {
+			this.conv = conv;
+			options = options || {};
+			options.decodeStrings = false;
+			Transform.call(this, options);
+		}
+		IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteEncoderStream } });
+		IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
+			if (typeof chunk !== "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
+			try {
+				var res = this.conv.write(chunk);
+				if (res && res.length) this.push(res);
+				done();
+			} catch (e) {
+				done(e);
+			}
+		};
+		IconvLiteEncoderStream.prototype._flush = function(done) {
+			try {
+				var res = this.conv.end();
+				if (res && res.length) this.push(res);
+				done();
+			} catch (e) {
+				done(e);
+			}
+		};
+		IconvLiteEncoderStream.prototype.collect = function(cb) {
+			var chunks = [];
+			this.on("error", cb);
+			this.on("data", function(chunk) {
+				chunks.push(chunk);
+			});
+			this.on("end", function() {
+				cb(null, Buffer$2.concat(chunks));
+			});
+			return this;
+		};
+		function IconvLiteDecoderStream(conv, options) {
+			this.conv = conv;
+			options = options || {};
+			options.encoding = this.encoding = "utf8";
+			Transform.call(this, options);
+		}
+		IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteDecoderStream } });
+		IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
+			if (!Buffer$2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
+			try {
+				var res = this.conv.write(chunk);
+				if (res && res.length) this.push(res, this.encoding);
+				done();
+			} catch (e) {
+				done(e);
+			}
+		};
+		IconvLiteDecoderStream.prototype._flush = function(done) {
+			try {
+				var res = this.conv.end();
+				if (res && res.length) this.push(res, this.encoding);
+				done();
+			} catch (e) {
+				done(e);
+			}
+		};
+		IconvLiteDecoderStream.prototype.collect = function(cb) {
+			var res = "";
+			this.on("error", cb);
+			this.on("data", function(chunk) {
+				res += chunk;
+			});
+			this.on("end", function() {
+				cb(null, res);
+			});
+			return this;
+		};
+		return {
+			IconvLiteEncoderStream,
+			IconvLiteDecoderStream
+		};
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js
+var require_lib$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js": ((exports, module) => {
+	var Buffer$1 = require_safer().Buffer;
+	var bomHandling = require_bom_handling();
+	var mergeModules = require_merge_exports();
+	var iconv = module.exports;
+	iconv.encodings = null;
+	iconv.defaultCharUnicode = "ï¿½";
+	iconv.defaultCharSingleByte = "?";
+	iconv.encode = function encode(str, encoding, options) {
+		str = "" + (str || "");
+		var encoder = iconv.getEncoder(encoding, options);
+		var res = encoder.write(str);
+		var trail = encoder.end();
+		return trail && trail.length > 0 ? Buffer$1.concat([res, trail]) : res;
+	};
+	iconv.decode = function decode(buf, encoding, options) {
+		if (typeof buf === "string") {
+			if (!iconv.skipDecodeWarning) {
+				console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
+				iconv.skipDecodeWarning = true;
+			}
+			buf = Buffer$1.from("" + (buf || ""), "binary");
+		}
+		var decoder = iconv.getDecoder(encoding, options);
+		var res = decoder.write(buf);
+		var trail = decoder.end();
+		return trail ? res + trail : res;
+	};
+	iconv.encodingExists = function encodingExists(enc) {
+		try {
+			iconv.getCodec(enc);
+			return true;
+		} catch (e) {
+			return false;
+		}
+	};
+	iconv.toEncoding = iconv.encode;
+	iconv.fromEncoding = iconv.decode;
+	iconv._codecDataCache = { __proto__: null };
+	iconv.getCodec = function getCodec(encoding) {
+		if (!iconv.encodings) {
+			var raw = require_encodings();
+			iconv.encodings = { __proto__: null };
+			mergeModules(iconv.encodings, raw);
+		}
+		var enc = iconv._canonicalizeEncoding(encoding);
+		var codecOptions = {};
+		while (true) {
+			var codec = iconv._codecDataCache[enc];
+			if (codec) return codec;
+			var codecDef = iconv.encodings[enc];
+			switch (typeof codecDef) {
+				case "string":
+					enc = codecDef;
+					break;
+				case "object":
+					for (var key$1 in codecDef) codecOptions[key$1] = codecDef[key$1];
+					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
+					enc = codecDef.type;
+					break;
+				case "function":
+					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
+					codec = new codecDef(codecOptions, iconv);
+					iconv._codecDataCache[codecOptions.encodingName] = codec;
+					return codec;
+				default: throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
+			}
+		}
+	};
+	iconv._canonicalizeEncoding = function(encoding) {
+		return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
+	};
+	iconv.getEncoder = function getEncoder(encoding, options) {
+		var codec = iconv.getCodec(encoding);
+		var encoder = new codec.encoder(options, codec);
+		if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
+		return encoder;
+	};
+	iconv.getDecoder = function getDecoder(encoding, options) {
+		var codec = iconv.getCodec(encoding);
+		var decoder = new codec.decoder(options, codec);
+		if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
+		return decoder;
+	};
+	iconv.enableStreamingAPI = function enableStreamingAPI(streamModule$1) {
+		if (iconv.supportsStreams) return;
+		var streams = require_streams()(streamModule$1);
+		iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
+		iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
+		iconv.encodeStream = function encodeStream(encoding, options) {
+			return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
+		};
+		iconv.decodeStream = function decodeStream(encoding, options) {
+			return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
+		};
+		iconv.supportsStreams = true;
+	};
+	var streamModule;
+	try {
+		streamModule = __require("stream");
+	} catch (e) {}
+	if (streamModule && streamModule.Transform) iconv.enableStreamingAPI(streamModule);
+	else iconv.encodeStream = iconv.decodeStream = function() {
+		throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/string.js
+var require_string = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/string.js": ((exports) => {
+	const Iconv = require_lib$1();
+	const { createLRU: createLRU$1 } = require_lib$2();
+	const decoderCache = createLRU$1({ max: 500 });
+	exports.decode = function(buffer$1, encoding, start, end, options) {
+		if (Buffer.isEncoding(encoding)) return buffer$1.toString(encoding, start, end);
+		let decoder;
+		if (!options) {
+			decoder = decoderCache.get(encoding);
+			if (!decoder) {
+				decoder = Iconv.getDecoder(encoding);
+				decoderCache.set(encoding, decoder);
+			}
+		} else {
+			const decoderArgs = {
+				encoding,
+				options
+			};
+			const decoderKey = JSON.stringify(decoderArgs);
+			decoder = decoderCache.get(decoderKey);
+			if (!decoder) {
+				decoder = Iconv.getDecoder(decoderArgs.encoding, decoderArgs.options);
+				decoderCache.set(decoderKey, decoder);
+			}
+		}
+		const res = decoder.write(buffer$1.slice(start, end));
+		const trail = decoder.end();
+		return trail ? res + trail : res;
+	};
+	exports.encode = function(string, encoding, options) {
+		if (Buffer.isEncoding(encoding)) return Buffer.from(string, encoding);
+		const encoder = Iconv.getEncoder(encoding, options || {});
+		const res = encoder.write(string);
+		const trail = encoder.end();
+		return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/types.js
+var require_types = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/types.js": ((exports, module) => {
+	module.exports = {
+		0: "DECIMAL",
+		1: "TINY",
+		2: "SHORT",
+		3: "LONG",
+		4: "FLOAT",
+		5: "DOUBLE",
+		6: "NULL",
+		7: "TIMESTAMP",
+		8: "LONGLONG",
+		9: "INT24",
+		10: "DATE",
+		11: "TIME",
+		12: "DATETIME",
+		13: "YEAR",
+		14: "NEWDATE",
+		15: "VARCHAR",
+		16: "BIT",
+		245: "JSON",
+		246: "NEWDECIMAL",
+		247: "ENUM",
+		248: "SET",
+		249: "TINY_BLOB",
+		250: "MEDIUM_BLOB",
+		251: "LONG_BLOB",
+		252: "BLOB",
+		253: "VAR_STRING",
+		254: "STRING",
+		255: "GEOMETRY"
+	};
+	module.exports.DECIMAL = 0;
+	module.exports.TINY = 1;
+	module.exports.SHORT = 2;
+	module.exports.LONG = 3;
+	module.exports.FLOAT = 4;
+	module.exports.DOUBLE = 5;
+	module.exports.NULL = 6;
+	module.exports.TIMESTAMP = 7;
+	module.exports.LONGLONG = 8;
+	module.exports.INT24 = 9;
+	module.exports.DATE = 10;
+	module.exports.TIME = 11;
+	module.exports.DATETIME = 12;
+	module.exports.YEAR = 13;
+	module.exports.NEWDATE = 14;
+	module.exports.VARCHAR = 15;
+	module.exports.BIT = 16;
+	module.exports.VECTOR = 242;
+	module.exports.JSON = 245;
+	module.exports.NEWDECIMAL = 246;
+	module.exports.ENUM = 247;
+	module.exports.SET = 248;
+	module.exports.TINY_BLOB = 249;
+	module.exports.MEDIUM_BLOB = 250;
+	module.exports.LONG_BLOB = 251;
+	module.exports.BLOB = 252;
+	module.exports.VAR_STRING = 253;
+	module.exports.STRING = 254;
+	module.exports.GEOMETRY = 255;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/packet.js
+var require_packet = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/packet.js": ((exports, module) => {
+	const ErrorCodeToName = require_errors();
+	const NativeBuffer = __require("buffer").Buffer;
+	const Long = require_umd();
+	const StringParser$3 = require_string();
+	const Types$6 = require_types();
+	const INVALID_DATE = /* @__PURE__ */ new Date(NaN);
+	const pad = "000000000000";
+	function leftPad(num, value) {
+		const s = value.toString();
+		if (s.length >= num) return s;
+		return (pad + s).slice(-num);
+	}
+	const minus = "-".charCodeAt(0);
+	const plus = "+".charCodeAt(0);
+	const dot = ".".charCodeAt(0);
+	const exponent = "e".charCodeAt(0);
+	const exponentCapital = "E".charCodeAt(0);
+	var Packet$22 = class Packet$22 {
+		constructor(id, buffer$1, start, end) {
+			this.sequenceId = id;
+			this.numPackets = 1;
+			this.buffer = buffer$1;
+			this.start = start;
+			this.offset = start + 4;
+			this.end = end;
+		}
+		reset() {
+			this.offset = this.start + 4;
+		}
+		length() {
+			return this.end - this.start;
+		}
+		slice() {
+			return this.buffer.slice(this.start, this.end);
+		}
+		dump() {
+			console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);
+		}
+		haveMoreData() {
+			return this.end > this.offset;
+		}
+		skip(num) {
+			this.offset += num;
+		}
+		readInt8() {
+			return this.buffer[this.offset++];
+		}
+		readInt16() {
+			this.offset += 2;
+			return this.buffer.readUInt16LE(this.offset - 2);
+		}
+		readInt24() {
+			return this.readInt16() + (this.readInt8() << 16);
+		}
+		readInt32() {
+			this.offset += 4;
+			return this.buffer.readUInt32LE(this.offset - 4);
+		}
+		readSInt8() {
+			return this.buffer.readInt8(this.offset++);
+		}
+		readSInt16() {
+			this.offset += 2;
+			return this.buffer.readInt16LE(this.offset - 2);
+		}
+		readSInt32() {
+			this.offset += 4;
+			return this.buffer.readInt32LE(this.offset - 4);
+		}
+		readInt64JSNumber() {
+			return new Long(this.readInt32(), this.readInt32(), true).toNumber();
+		}
+		readSInt64JSNumber() {
+			const word0 = this.readInt32();
+			const word1 = this.readInt32();
+			if (!(word1 & 2147483648)) return word0 + 4294967296 * word1;
+			return new Long(word0, word1, false).toNumber();
+		}
+		readInt64String() {
+			return new Long(this.readInt32(), this.readInt32(), true).toString();
+		}
+		readSInt64String() {
+			return new Long(this.readInt32(), this.readInt32(), false).toString();
+		}
+		readInt64() {
+			let res = new Long(this.readInt32(), this.readInt32(), true);
+			const resNumber = res.toNumber();
+			const resString = res.toString();
+			res = resNumber.toString() === resString ? resNumber : resString;
+			return res;
+		}
+		readSInt64() {
+			let res = new Long(this.readInt32(), this.readInt32(), false);
+			const resNumber = res.toNumber();
+			const resString = res.toString();
+			res = resNumber.toString() === resString ? resNumber : resString;
+			return res;
+		}
+		isEOF() {
+			return this.buffer[this.offset] === 254 && this.length() < 13;
+		}
+		eofStatusFlags() {
+			return this.buffer.readInt16LE(this.offset + 3);
+		}
+		eofWarningCount() {
+			return this.buffer.readInt16LE(this.offset + 1);
+		}
+		readLengthCodedNumber(bigNumberStrings, signed) {
+			const byte1 = this.buffer[this.offset++];
+			if (byte1 < 251) return byte1;
+			return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);
+		}
+		readLengthCodedNumberSigned(bigNumberStrings) {
+			return this.readLengthCodedNumber(bigNumberStrings, true);
+		}
+		readLengthCodedNumberExt(tag, bigNumberStrings, signed) {
+			let word0, word1;
+			let res;
+			if (tag === 251) return null;
+			if (tag === 252) return this.readInt8() + (this.readInt8() << 8);
+			if (tag === 253) return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);
+			if (tag === 254) {
+				word0 = this.readInt32();
+				word1 = this.readInt32();
+				if (word1 === 0) return word0;
+				if (word1 < 2097152) return word1 * 4294967296 + word0;
+				res = new Long(word0, word1, !signed);
+				const resNumber = res.toNumber();
+				const resString = res.toString();
+				res = resNumber.toString() === resString ? resNumber : resString;
+				return bigNumberStrings ? resString : res;
+			}
+			console.trace();
+			throw new Error(`Should not reach here: ${tag}`);
+		}
+		readFloat() {
+			const res = this.buffer.readFloatLE(this.offset);
+			this.offset += 4;
+			return res;
+		}
+		readDouble() {
+			const res = this.buffer.readDoubleLE(this.offset);
+			this.offset += 8;
+			return res;
+		}
+		readBuffer(len) {
+			if (typeof len === "undefined") len = this.end - this.offset;
+			this.offset += len;
+			return this.buffer.slice(this.offset - len, this.offset);
+		}
+		readDateTime(timezone) {
+			if (!timezone || timezone === "Z" || timezone === "local") {
+				const length = this.readInt8();
+				if (length === 251) return null;
+				let y = 0;
+				let m = 0;
+				let d = 0;
+				let H = 0;
+				let M = 0;
+				let S = 0;
+				let ms = 0;
+				if (length > 3) {
+					y = this.readInt16();
+					m = this.readInt8();
+					d = this.readInt8();
+				}
+				if (length > 6) {
+					H = this.readInt8();
+					M = this.readInt8();
+					S = this.readInt8();
+				}
+				if (length > 10) ms = this.readInt32() / 1e3;
+				if (y + m + d + H + M + S + ms === 0) return INVALID_DATE;
+				if (timezone === "Z") return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));
+				return new Date(y, m - 1, d, H, M, S, ms);
+			}
+			let str = this.readDateTimeString(6, "T", null);
+			if (str.length === 10) str += "T00:00:00";
+			return new Date(str + timezone);
+		}
+		readDateTimeString(decimals, timeSep, columnType) {
+			const length = this.readInt8();
+			let y = 0;
+			let m = 0;
+			let d = 0;
+			let H = 0;
+			let M = 0;
+			let S = 0;
+			let ms = 0;
+			let str;
+			if (length > 3) {
+				y = this.readInt16();
+				m = this.readInt8();
+				d = this.readInt8();
+				str = [
+					leftPad(4, y),
+					leftPad(2, m),
+					leftPad(2, d)
+				].join("-");
+			}
+			if (length > 6) {
+				H = this.readInt8();
+				M = this.readInt8();
+				S = this.readInt8();
+				str += `${timeSep || " "}${[
+					leftPad(2, H),
+					leftPad(2, M),
+					leftPad(2, S)
+				].join(":")}`;
+			} else if (columnType === Types$6.DATETIME) str += " 00:00:00";
+			if (length > 10) {
+				ms = this.readInt32();
+				str += ".";
+				if (decimals) {
+					ms = leftPad(6, ms);
+					if (ms.length > decimals) ms = ms.substring(0, decimals);
+				}
+				str += ms;
+			}
+			return str;
+		}
+		readTimeString(convertTtoMs) {
+			const length = this.readInt8();
+			if (length === 0) return "00:00:00";
+			const sign = this.readInt8() ? -1 : 1;
+			let d = 0;
+			let H = 0;
+			let M = 0;
+			let S = 0;
+			let ms = 0;
+			if (length > 6) {
+				d = this.readInt32();
+				H = this.readInt8();
+				M = this.readInt8();
+				S = this.readInt8();
+			}
+			if (length > 10) ms = this.readInt32();
+			if (convertTtoMs) {
+				H += d * 24;
+				M += H * 60;
+				S += M * 60;
+				ms += S * 1e3;
+				ms *= sign;
+				return ms;
+			}
+			return (sign === -1 ? "-" : "") + [
+				leftPad(2, d * 24 + H),
+				leftPad(2, M),
+				leftPad(2, S)
+			].join(":") + (ms ? `.${ms}`.replace(/0+$/, "") : "");
+		}
+		readLengthCodedString(encoding) {
+			const len = this.readLengthCodedNumber();
+			if (len === null) return null;
+			this.offset += len;
+			return StringParser$3.decode(this.buffer, encoding, this.offset - len, this.offset);
+		}
+		readLengthCodedBuffer() {
+			const len = this.readLengthCodedNumber();
+			if (len === null) return null;
+			return this.readBuffer(len);
+		}
+		readNullTerminatedString(encoding) {
+			const start = this.offset;
+			let end = this.offset;
+			while (this.buffer[end]) end = end + 1;
+			this.offset = end + 1;
+			return StringParser$3.decode(this.buffer, encoding, start, end);
+		}
+		readString(len, encoding) {
+			if (typeof len === "string" && typeof encoding === "undefined") {
+				encoding = len;
+				len = void 0;
+			}
+			if (typeof len === "undefined") len = this.end - this.offset;
+			this.offset += len;
+			return StringParser$3.decode(this.buffer, encoding, this.offset - len, this.offset);
+		}
+		parseInt(len, supportBigNumbers) {
+			if (len === null) return null;
+			if (len >= 14 && !supportBigNumbers) {
+				const s = this.buffer.toString("ascii", this.offset, this.offset + len);
+				this.offset += len;
+				return Number(s);
+			}
+			let result = 0;
+			const start = this.offset;
+			const end = this.offset + len;
+			let sign = 1;
+			if (len === 0) return 0;
+			if (this.buffer[this.offset] === minus) {
+				this.offset++;
+				sign = -1;
+			}
+			let str;
+			const numDigits = end - this.offset;
+			if (supportBigNumbers) {
+				if (numDigits >= 15) {
+					str = this.readString(end - this.offset, "binary");
+					result = parseInt(str, 10);
+					if (result.toString() === str) return sign * result;
+					return sign === -1 ? `-${str}` : str;
+				}
+				if (numDigits > 16) {
+					str = this.readString(end - this.offset);
+					return sign === -1 ? `-${str}` : str;
+				}
+			}
+			if (this.buffer[this.offset] === plus) this.offset++;
+			while (this.offset < end) {
+				result *= 10;
+				result += this.buffer[this.offset] - 48;
+				this.offset++;
+			}
+			const num = result * sign;
+			if (!supportBigNumbers) return num;
+			str = this.buffer.toString("ascii", start, end);
+			if (num.toString() === str) return num;
+			return str;
+		}
+		parseIntNoBigCheck(len) {
+			if (len === null) return null;
+			let result = 0;
+			const end = this.offset + len;
+			let sign = 1;
+			if (len === 0) return 0;
+			if (this.buffer[this.offset] === minus) {
+				this.offset++;
+				sign = -1;
+			}
+			if (this.buffer[this.offset] === plus) this.offset++;
+			while (this.offset < end) {
+				result *= 10;
+				result += this.buffer[this.offset] - 48;
+				this.offset++;
+			}
+			return result * sign;
+		}
+		parseGeometryValue() {
+			const buffer$1 = this.readLengthCodedBuffer();
+			let offset = 4;
+			if (buffer$1 === null || !buffer$1.length) return null;
+			function parseGeometry() {
+				let x, y, i$4, j, numPoints, line;
+				let result = null;
+				const byteOrder = buffer$1.readUInt8(offset);
+				offset += 1;
+				const wkbType = byteOrder ? buffer$1.readUInt32LE(offset) : buffer$1.readUInt32BE(offset);
+				offset += 4;
+				switch (wkbType) {
+					case 1:
+						x = byteOrder ? buffer$1.readDoubleLE(offset) : buffer$1.readDoubleBE(offset);
+						offset += 8;
+						y = byteOrder ? buffer$1.readDoubleLE(offset) : buffer$1.readDoubleBE(offset);
+						offset += 8;
+						result = {
+							x,
+							y
+						};
+						break;
+					case 2:
+						numPoints = byteOrder ? buffer$1.readUInt32LE(offset) : buffer$1.readUInt32BE(offset);
+						offset += 4;
+						result = [];
+						for (i$4 = numPoints; i$4 > 0; i$4--) {
+							x = byteOrder ? buffer$1.readDoubleLE(offset) : buffer$1.readDoubleBE(offset);
+							offset += 8;
+							y = byteOrder ? buffer$1.readDoubleLE(offset) : buffer$1.readDoubleBE(offset);
+							offset += 8;
+							result.push({
+								x,
+								y
+							});
+						}
+						break;
+					case 3:
+						const numRings = byteOrder ? buffer$1.readUInt32LE(offset) : buffer$1.readUInt32BE(offset);
+						offset += 4;
+						result = [];
+						for (i$4 = numRings; i$4 > 0; i$4--) {
+							numPoints = byteOrder ? buffer$1.readUInt32LE(offset) : buffer$1.readUInt32BE(offset);
+							offset += 4;
+							line = [];
+							for (j = numPoints; j > 0; j--) {
+								x = byteOrder ? buffer$1.readDoubleLE(offset) : buffer$1.readDoubleBE(offset);
+								offset += 8;
+								y = byteOrder ? buffer$1.readDoubleLE(offset) : buffer$1.readDoubleBE(offset);
+								offset += 8;
+								line.push({
+									x,
+									y
+								});
+							}
+							result.push(line);
+						}
+						break;
+					case 4:
+					case 5:
+					case 6:
+					case 7:
+						const num = byteOrder ? buffer$1.readUInt32LE(offset) : buffer$1.readUInt32BE(offset);
+						offset += 4;
+						result = [];
+						for (i$4 = num; i$4 > 0; i$4--) result.push(parseGeometry());
+						break;
+				}
+				return result;
+			}
+			return parseGeometry();
+		}
+		parseVector() {
+			const bufLen = this.readLengthCodedNumber();
+			const vectorEnd = this.offset + bufLen;
+			const result = [];
+			while (this.offset < vectorEnd && this.offset < this.end) result.push(this.readFloat());
+			return result;
+		}
+		parseDate(timezone) {
+			const strLen = this.readLengthCodedNumber();
+			if (strLen === null) return null;
+			if (strLen !== 10) return /* @__PURE__ */ new Date(NaN);
+			const y = this.parseInt(4);
+			this.offset++;
+			const m = this.parseInt(2);
+			this.offset++;
+			const d = this.parseInt(2);
+			if (!timezone || timezone === "local") return new Date(y, m - 1, d);
+			if (timezone === "Z") return new Date(Date.UTC(y, m - 1, d));
+			return /* @__PURE__ */ new Date(`${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`);
+		}
+		parseDateTime(timezone) {
+			const str = this.readLengthCodedString("binary");
+			if (str === null) return null;
+			if (!timezone || timezone === "local") return new Date(str);
+			return /* @__PURE__ */ new Date(`${str}${timezone}`);
+		}
+		parseFloat(len) {
+			if (len === null) return null;
+			let result = 0;
+			const end = this.offset + len;
+			let factor = 1;
+			let pastDot = false;
+			let charCode = 0;
+			if (len === 0) return 0;
+			if (this.buffer[this.offset] === minus) {
+				this.offset++;
+				factor = -1;
+			}
+			if (this.buffer[this.offset] === plus) this.offset++;
+			while (this.offset < end) {
+				charCode = this.buffer[this.offset];
+				if (charCode === dot) {
+					pastDot = true;
+					this.offset++;
+				} else if (charCode === exponent || charCode === exponentCapital) {
+					this.offset++;
+					const exponentValue = this.parseInt(end - this.offset);
+					return result / factor * Math.pow(10, exponentValue);
+				} else {
+					result *= 10;
+					result += this.buffer[this.offset] - 48;
+					this.offset++;
+					if (pastDot) factor = factor * 10;
+				}
+			}
+			return result / factor;
+		}
+		parseLengthCodedIntNoBigCheck() {
+			return this.parseIntNoBigCheck(this.readLengthCodedNumber());
+		}
+		parseLengthCodedInt(supportBigNumbers) {
+			return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);
+		}
+		parseLengthCodedIntString() {
+			return this.readLengthCodedString("binary");
+		}
+		parseLengthCodedFloat() {
+			return this.parseFloat(this.readLengthCodedNumber());
+		}
+		peekByte() {
+			return this.buffer[this.offset];
+		}
+		isAlt() {
+			return this.peekByte() === 254;
+		}
+		isError() {
+			return this.peekByte() === 255;
+		}
+		asError(encoding) {
+			this.reset();
+			this.readInt8();
+			const errorCode = this.readInt16();
+			let sqlState = "";
+			if (this.buffer[this.offset] === 35) {
+				this.skip(1);
+				sqlState = this.readBuffer(5).toString();
+			}
+			const message = this.readString(void 0, encoding);
+			const err = new Error(message);
+			err.code = ErrorCodeToName[errorCode];
+			err.errno = errorCode;
+			err.sqlState = sqlState;
+			err.sqlMessage = message;
+			return err;
+		}
+		writeInt32(n) {
+			this.buffer.writeUInt32LE(n, this.offset);
+			this.offset += 4;
+		}
+		writeInt24(n) {
+			this.writeInt8(n & 255);
+			this.writeInt16(n >> 8);
+		}
+		writeInt16(n) {
+			this.buffer.writeUInt16LE(n, this.offset);
+			this.offset += 2;
+		}
+		writeInt8(n) {
+			this.buffer.writeUInt8(n, this.offset);
+			this.offset++;
+		}
+		writeDouble(n) {
+			this.buffer.writeDoubleLE(n, this.offset);
+			this.offset += 8;
+		}
+		writeBuffer(b) {
+			b.copy(this.buffer, this.offset);
+			this.offset += b.length;
+		}
+		writeNull() {
+			this.buffer[this.offset] = 251;
+			this.offset++;
+		}
+		writeNullTerminatedString(s, encoding) {
+			const buf = StringParser$3.encode(s, encoding);
+			this.buffer.length && buf.copy(this.buffer, this.offset);
+			this.offset += buf.length;
+			this.writeInt8(0);
+		}
+		writeString(s, encoding) {
+			if (s === null) {
+				this.writeInt8(251);
+				return;
+			}
+			if (s.length === 0) return;
+			const buf = StringParser$3.encode(s, encoding);
+			this.buffer.length && buf.copy(this.buffer, this.offset);
+			this.offset += buf.length;
+		}
+		writeLengthCodedString(s, encoding) {
+			const buf = StringParser$3.encode(s, encoding);
+			this.writeLengthCodedNumber(buf.length);
+			this.buffer.length && buf.copy(this.buffer, this.offset);
+			this.offset += buf.length;
+		}
+		writeLengthCodedBuffer(b) {
+			this.writeLengthCodedNumber(b.length);
+			b.copy(this.buffer, this.offset);
+			this.offset += b.length;
+		}
+		writeLengthCodedNumber(n) {
+			if (n < 251) return this.writeInt8(n);
+			if (n < 65535) {
+				this.writeInt8(252);
+				return this.writeInt16(n);
+			}
+			if (n < 16777215) {
+				this.writeInt8(253);
+				return this.writeInt24(n);
+			}
+			if (n === null) return this.writeInt8(251);
+			this.writeInt8(254);
+			this.buffer.writeUInt32LE(n, this.offset);
+			this.offset += 4;
+			this.buffer.writeUInt32LE(n >> 32, this.offset);
+			this.offset += 4;
+			return this.offset;
+		}
+		writeDate(d, timezone) {
+			this.buffer.writeUInt8(11, this.offset);
+			if (!timezone || timezone === "local") {
+				this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);
+				this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);
+				this.buffer.writeUInt8(d.getDate(), this.offset + 4);
+				this.buffer.writeUInt8(d.getHours(), this.offset + 5);
+				this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);
+				this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);
+				this.buffer.writeUInt32LE(d.getMilliseconds() * 1e3, this.offset + 8);
+			} else {
+				if (timezone !== "Z") {
+					const offset = (timezone[0] === "-" ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));
+					if (offset !== 0) d = new Date(d.getTime() + 6e4 * offset);
+				}
+				this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);
+				this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);
+				this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);
+				this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);
+				this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);
+				this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);
+				this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1e3, this.offset + 8);
+			}
+			this.offset += 12;
+		}
+		writeHeader(sequenceId) {
+			const offset = this.offset;
+			this.offset = 0;
+			this.writeInt24(this.buffer.length - 4);
+			this.writeInt8(sequenceId);
+			this.offset = offset;
+		}
+		clone() {
+			return new Packet$22(this.sequenceId, this.buffer, this.start, this.end);
+		}
+		type() {
+			if (this.isEOF()) return "EOF";
+			if (this.isError()) return "Error";
+			if (this.buffer[this.offset] === 0) return "maybeOK";
+			return "";
+		}
+		static lengthCodedNumberLength(n) {
+			if (n < 251) return 1;
+			if (n < 65535) return 3;
+			if (n < 16777215) return 5;
+			return 9;
+		}
+		static lengthCodedStringLength(str, encoding) {
+			const slen = StringParser$3.encode(str, encoding).length;
+			return Packet$22.lengthCodedNumberLength(slen) + slen;
+		}
+		static MockBuffer() {
+			const noop = function() {};
+			const res = Buffer.alloc(0);
+			for (const op in NativeBuffer.prototype) if (typeof res[op] === "function") res[op] = noop;
+			return res;
+		}
+	};
+	module.exports = Packet$22;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packet_parser.js
+var require_packet_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packet_parser.js": ((exports, module) => {
+	const Packet$21 = require_packet();
+	const MAX_PACKET_LENGTH = 16777215;
+	function readPacketLength(b, off) {
+		const b0 = b[off];
+		const b1 = b[off + 1];
+		const b2 = b[off + 2];
+		if (b1 + b2 === 0) return b0;
+		return b0 + (b1 << 8) + (b2 << 16);
+	}
+	var PacketParser$2 = class PacketParser$2 {
+		constructor(onPacket, packetHeaderLength) {
+			if (typeof packetHeaderLength === "undefined") packetHeaderLength = 4;
+			this.buffer = [];
+			this.bufferLength = 0;
+			this.packetHeaderLength = packetHeaderLength;
+			this.headerLen = 0;
+			this.length = 0;
+			this.largePacketParts = [];
+			this.firstPacketSequenceId = 0;
+			this.onPacket = onPacket;
+			this.execute = PacketParser$2.prototype.executeStart;
+			this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;
+		}
+		_flushLargePacket4() {
+			const numPackets = this.largePacketParts.length;
+			this.largePacketParts.unshift(Buffer.from([
+				0,
+				0,
+				0,
+				0
+			]));
+			const body = Buffer.concat(this.largePacketParts);
+			const packet = new Packet$21(this.firstPacketSequenceId, body, 0, body.length);
+			this.largePacketParts.length = 0;
+			packet.numPackets = numPackets;
+			this.onPacket(packet);
+		}
+		_flushLargePacket7() {
+			const numPackets = this.largePacketParts.length;
+			this.largePacketParts.unshift(Buffer.from([
+				0,
+				0,
+				0,
+				0,
+				0,
+				0,
+				0
+			]));
+			const body = Buffer.concat(this.largePacketParts);
+			this.largePacketParts.length = 0;
+			const packet = new Packet$21(this.firstPacketSequenceId, body, 0, body.length);
+			packet.numPackets = numPackets;
+			this.onPacket(packet);
+		}
+		executeStart(chunk) {
+			let start = 0;
+			const end = chunk.length;
+			while (end - start >= 3) {
+				this.length = readPacketLength(chunk, start);
+				if (end - start >= this.length + this.packetHeaderLength) {
+					const sequenceId = chunk[start + 3];
+					if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) this.onPacket(new Packet$21(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));
+					else {
+						if (this.largePacketParts.length === 0) this.firstPacketSequenceId = sequenceId;
+						this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));
+						if (this.length < MAX_PACKET_LENGTH) this._flushLargePacket();
+					}
+					start += this.packetHeaderLength + this.length;
+				} else {
+					this.buffer = [chunk.slice(start + 3, end)];
+					this.bufferLength = end - start - 3;
+					this.execute = PacketParser$2.prototype.executePayload;
+					return;
+				}
+			}
+			if (end - start > 0) {
+				this.headerLen = end - start;
+				this.length = chunk[start];
+				if (this.headerLen === 2) {
+					this.length = chunk[start] + (chunk[start + 1] << 8);
+					this.execute = PacketParser$2.prototype.executeHeader3;
+				} else this.execute = PacketParser$2.prototype.executeHeader2;
+			}
+		}
+		executePayload(chunk) {
+			let start = 0;
+			const end = chunk.length;
+			const remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;
+			if (end - start >= remainingPayload) {
+				const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);
+				let offset = 3;
+				for (let i$4 = 0; i$4 < this.buffer.length; ++i$4) {
+					this.buffer[i$4].copy(payload, offset);
+					offset += this.buffer[i$4].length;
+				}
+				chunk.copy(payload, offset, start, start + remainingPayload);
+				const sequenceId = payload[3];
+				if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) this.onPacket(new Packet$21(sequenceId, payload, 0, this.length + this.packetHeaderLength));
+				else {
+					if (this.largePacketParts.length === 0) this.firstPacketSequenceId = sequenceId;
+					this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));
+					if (this.length < MAX_PACKET_LENGTH) this._flushLargePacket();
+				}
+				this.buffer = [];
+				this.bufferLength = 0;
+				this.execute = PacketParser$2.prototype.executeStart;
+				start += remainingPayload;
+				if (end - start > 0) return this.execute(chunk.slice(start, end));
+			} else {
+				this.buffer.push(chunk);
+				this.bufferLength += chunk.length;
+			}
+			return null;
+		}
+		executeHeader2(chunk) {
+			this.length += chunk[0] << 8;
+			if (chunk.length > 1) {
+				this.length += chunk[1] << 16;
+				this.execute = PacketParser$2.prototype.executePayload;
+				return this.executePayload(chunk.slice(2));
+			}
+			this.execute = PacketParser$2.prototype.executeHeader3;
+			return null;
+		}
+		executeHeader3(chunk) {
+			this.length += chunk[0] << 16;
+			this.execute = PacketParser$2.prototype.executePayload;
+			return this.executePayload(chunk.slice(1));
+		}
+	};
+	module.exports = PacketParser$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_next_factor.js
+var require_auth_next_factor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_next_factor.js": ((exports, module) => {
+	const Packet$20 = require_packet();
+	var AuthNextFactor = class AuthNextFactor {
+		constructor(opts) {
+			this.pluginName = opts.pluginName;
+			this.pluginData = opts.pluginData;
+		}
+		toPacket(encoding) {
+			const length = 6 + this.pluginName.length + this.pluginData.length;
+			const packet = new Packet$20(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(2);
+			packet.writeNullTerminatedString(this.pluginName, encoding);
+			packet.writeBuffer(this.pluginData);
+			return packet;
+		}
+		static fromPacket(packet, encoding) {
+			packet.readInt8();
+			return new AuthNextFactor({
+				pluginName: packet.readNullTerminatedString(encoding),
+				pluginData: packet.readBuffer()
+			});
+		}
+	};
+	module.exports = AuthNextFactor;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_switch_request.js
+var require_auth_switch_request = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_switch_request.js": ((exports, module) => {
+	const Packet$19 = require_packet();
+	var AuthSwitchRequest = class AuthSwitchRequest {
+		constructor(opts) {
+			this.pluginName = opts.pluginName;
+			this.pluginData = opts.pluginData;
+		}
+		toPacket() {
+			const length = 6 + this.pluginName.length + this.pluginData.length;
+			const packet = new Packet$19(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(254);
+			packet.writeNullTerminatedString(this.pluginName, "cesu8");
+			packet.writeBuffer(this.pluginData);
+			return packet;
+		}
+		static fromPacket(packet) {
+			packet.readInt8();
+			return new AuthSwitchRequest({
+				pluginName: packet.readNullTerminatedString("cesu8"),
+				pluginData: packet.readBuffer()
+			});
+		}
+	};
+	module.exports = AuthSwitchRequest;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_switch_request_more_data.js
+var require_auth_switch_request_more_data = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_switch_request_more_data.js": ((exports, module) => {
+	const Packet$18 = require_packet();
+	var AuthSwitchRequestMoreData = class AuthSwitchRequestMoreData {
+		constructor(data) {
+			this.data = data;
+		}
+		toPacket() {
+			const length = 5 + this.data.length;
+			const packet = new Packet$18(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(1);
+			packet.writeBuffer(this.data);
+			return packet;
+		}
+		static fromPacket(packet) {
+			packet.readInt8();
+			return new AuthSwitchRequestMoreData(packet.readBuffer());
+		}
+		static verifyMarker(packet) {
+			return packet.peekByte() === 1;
+		}
+	};
+	module.exports = AuthSwitchRequestMoreData;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_switch_response.js
+var require_auth_switch_response = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/auth_switch_response.js": ((exports, module) => {
+	const Packet$17 = require_packet();
+	var AuthSwitchResponse = class AuthSwitchResponse {
+		constructor(data) {
+			if (!Buffer.isBuffer(data)) data = Buffer.from(data);
+			this.data = data;
+		}
+		toPacket() {
+			const length = 4 + this.data.length;
+			const packet = new Packet$17(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeBuffer(this.data);
+			return packet;
+		}
+		static fromPacket(packet) {
+			return new AuthSwitchResponse(packet.readBuffer());
+		}
+	};
+	module.exports = AuthSwitchResponse;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/binary_row.js
+var require_binary_row = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/binary_row.js": ((exports, module) => {
+	const Types$5 = require_types();
+	const Packet$16 = require_packet();
+	const binaryReader = new Array(256);
+	var BinaryRow = class BinaryRow {
+		constructor(columns) {
+			this.columns = columns || [];
+		}
+		static toPacket(columns, encoding) {
+			const sequenceId = 0;
+			let length = 0;
+			columns.forEach((val) => {
+				if (val === null || typeof val === "undefined") {
+					++length;
+					return;
+				}
+				length += Packet$16.lengthCodedStringLength(val.toString(10), encoding);
+			});
+			length = length + 2;
+			const packet = new Packet$16(sequenceId, Buffer.allocUnsafe(length + 4), 0, length + 4);
+			packet.offset = 4;
+			packet.writeInt8(0);
+			let bitmap = 0;
+			let bitValue = 1;
+			columns.forEach((parameter) => {
+				if (parameter.type === Types$5.NULL) bitmap += bitValue;
+				bitValue *= 2;
+				if (bitValue === 256) {
+					packet.writeInt8(bitmap);
+					bitmap = 0;
+					bitValue = 1;
+				}
+			});
+			if (bitValue !== 1) packet.writeInt8(bitmap);
+			columns.forEach((val) => {
+				if (val === null) {
+					packet.writeNull();
+					return;
+				}
+				if (typeof val === "undefined") {
+					packet.writeInt8(0);
+					return;
+				}
+				packet.writeLengthCodedString(val.toString(10), encoding);
+			});
+			return packet;
+		}
+		static fromPacket(fields$1, packet) {
+			const columns = new Array(fields$1.length);
+			packet.readInt8();
+			const nullBitmapLength = Math.floor((fields$1.length + 7 + 2) / 8);
+			packet.skip(nullBitmapLength);
+			for (let i$4 = 0; i$4 < columns.length; ++i$4) columns[i$4] = binaryReader[fields$1[i$4].columnType].apply(packet);
+			return new BinaryRow(columns);
+		}
+	};
+	binaryReader[Types$5.DECIMAL] = Packet$16.prototype.readLengthCodedString;
+	binaryReader[1] = Packet$16.prototype.readInt8;
+	binaryReader[2] = Packet$16.prototype.readInt16;
+	binaryReader[3] = Packet$16.prototype.readInt32;
+	binaryReader[4] = Packet$16.prototype.readFloat;
+	binaryReader[5] = Packet$16.prototype.readDouble;
+	binaryReader[6] = Packet$16.prototype.assertInvalid;
+	binaryReader[7] = Packet$16.prototype.readTimestamp;
+	binaryReader[8] = Packet$16.prototype.readInt64;
+	binaryReader[9] = Packet$16.prototype.readInt32;
+	binaryReader[10] = Packet$16.prototype.readTimestamp;
+	binaryReader[11] = Packet$16.prototype.readTime;
+	binaryReader[12] = Packet$16.prototype.readDateTime;
+	binaryReader[13] = Packet$16.prototype.readInt16;
+	binaryReader[Types$5.VAR_STRING] = Packet$16.prototype.readLengthCodedString;
+	module.exports = BinaryRow;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/commands.js
+var require_commands$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/commands.js": ((exports, module) => {
+	module.exports = {
+		SLEEP: 0,
+		QUIT: 1,
+		INIT_DB: 2,
+		QUERY: 3,
+		FIELD_LIST: 4,
+		CREATE_DB: 5,
+		DROP_DB: 6,
+		REFRESH: 7,
+		SHUTDOWN: 8,
+		STATISTICS: 9,
+		PROCESS_INFO: 10,
+		CONNECT: 11,
+		PROCESS_KILL: 12,
+		DEBUG: 13,
+		PING: 14,
+		TIME: 15,
+		DELAYED_INSERT: 16,
+		CHANGE_USER: 17,
+		BINLOG_DUMP: 18,
+		TABLE_DUMP: 19,
+		CONNECT_OUT: 20,
+		REGISTER_SLAVE: 21,
+		STMT_PREPARE: 22,
+		STMT_EXECUTE: 23,
+		STMT_SEND_LONG_DATA: 24,
+		STMT_CLOSE: 25,
+		STMT_RESET: 26,
+		SET_OPTION: 27,
+		STMT_FETCH: 28,
+		DAEMON: 29,
+		BINLOG_DUMP_GTID: 30,
+		UNKNOWN: 255
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/binlog_dump.js
+var require_binlog_dump$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/binlog_dump.js": ((exports, module) => {
+	const Packet$15 = require_packet();
+	const CommandCodes$4 = require_commands$1();
+	var BinlogDump$2 = class {
+		constructor(opts) {
+			this.binlogPos = opts.binlogPos || 0;
+			this.serverId = opts.serverId || 0;
+			this.flags = opts.flags || 0;
+			this.filename = opts.filename || "";
+		}
+		toPacket() {
+			const length = 15 + Buffer.byteLength(this.filename, "utf8");
+			const packet = new Packet$15(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(CommandCodes$4.BINLOG_DUMP);
+			packet.writeInt32(this.binlogPos);
+			packet.writeInt16(this.flags);
+			packet.writeInt32(this.serverId);
+			packet.writeString(this.filename);
+			return packet;
+		}
+	};
+	module.exports = BinlogDump$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/client.js
+var require_client = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/client.js": ((exports) => {
+	exports.LONG_PASSWORD = 1;
+	exports.FOUND_ROWS = 2;
+	exports.LONG_FLAG = 4;
+	exports.CONNECT_WITH_DB = 8;
+	exports.NO_SCHEMA = 16;
+	exports.COMPRESS = 32;
+	exports.ODBC = 64;
+	exports.LOCAL_FILES = 128;
+	exports.IGNORE_SPACE = 256;
+	exports.PROTOCOL_41 = 512;
+	exports.INTERACTIVE = 1024;
+	exports.SSL = 2048;
+	exports.IGNORE_SIGPIPE = 4096;
+	exports.TRANSACTIONS = 8192;
+	exports.RESERVED = 16384;
+	exports.SECURE_CONNECTION = 32768;
+	exports.MULTI_STATEMENTS = 65536;
+	exports.MULTI_RESULTS = 131072;
+	exports.PS_MULTI_RESULTS = 262144;
+	exports.PLUGIN_AUTH = 524288;
+	exports.CONNECT_ATTRS = 1048576;
+	exports.PLUGIN_AUTH_LENENC_CLIENT_DATA = 2097152;
+	exports.CAN_HANDLE_EXPIRED_PASSWORDS = 4194304;
+	exports.SESSION_TRACK = 8388608;
+	exports.DEPRECATE_EOF = 16777216;
+	exports.SSL_VERIFY_SERVER_CERT = 1073741824;
+	exports.REMEMBER_OPTIONS = 2147483648;
+	exports.MULTI_FACTOR_AUTHENTICATION = 268435456;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_41.js
+var require_auth_41 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_41.js": ((exports) => {
+	const crypto$2 = __require("crypto");
+	function sha1(msg, msg1, msg2) {
+		const hash = crypto$2.createHash("sha1");
+		hash.update(msg);
+		if (msg1) hash.update(msg1);
+		if (msg2) hash.update(msg2);
+		return hash.digest();
+	}
+	function xor$1(a, b) {
+		const result = Buffer.allocUnsafe(a.length);
+		for (let i$4 = 0; i$4 < a.length; i$4++) result[i$4] = a[i$4] ^ b[i$4];
+		return result;
+	}
+	exports.xor = xor$1;
+	function token(password, scramble1, scramble2) {
+		if (!password) return Buffer.alloc(0);
+		const stage1 = sha1(password);
+		return exports.calculateTokenFromPasswordSha(stage1, scramble1, scramble2);
+	}
+	exports.calculateTokenFromPasswordSha = function(passwordSha, scramble1, scramble2) {
+		return xor$1(sha1(scramble1.slice(0, 8), scramble2.slice(0, 12), sha1(passwordSha)), passwordSha);
+	};
+	exports.calculateToken = token;
+	exports.verifyToken = function(publicSeed1, publicSeed2, token$1, doubleSha) {
+		return sha1(xor$1(token$1, sha1(publicSeed1, publicSeed2, doubleSha))).compare(doubleSha) === 0;
+	};
+	exports.doubleSha1 = function(password) {
+		return sha1(sha1(password));
+	};
+	function xorRotating$2(a, seed) {
+		const result = Buffer.allocUnsafe(a.length);
+		const seedLen = seed.length;
+		for (let i$4 = 0; i$4 < a.length; i$4++) result[i$4] = a[i$4] ^ seed[i$4 % seedLen];
+		return result;
+	}
+	exports.xorRotating = xorRotating$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/charset_encodings.js
+var require_charset_encodings = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/charset_encodings.js": ((exports, module) => {
+	module.exports = [
+		"utf8",
+		"big5",
+		"latin2",
+		"dec8",
+		"cp850",
+		"latin1",
+		"hp8",
+		"koi8r",
+		"latin1",
+		"latin2",
+		"swe7",
+		"ascii",
+		"eucjp",
+		"sjis",
+		"cp1251",
+		"latin1",
+		"hebrew",
+		"utf8",
+		"tis620",
+		"euckr",
+		"latin7",
+		"latin2",
+		"koi8u",
+		"cp1251",
+		"gb2312",
+		"greek",
+		"cp1250",
+		"latin2",
+		"gbk",
+		"cp1257",
+		"latin5",
+		"latin1",
+		"armscii8",
+		"cesu8",
+		"cp1250",
+		"ucs2",
+		"cp866",
+		"keybcs2",
+		"macintosh",
+		"macroman",
+		"cp852",
+		"latin7",
+		"latin7",
+		"macintosh",
+		"cp1250",
+		"utf8",
+		"utf8",
+		"latin1",
+		"latin1",
+		"latin1",
+		"cp1251",
+		"cp1251",
+		"cp1251",
+		"macroman",
+		"utf16",
+		"utf16",
+		"utf16-le",
+		"cp1256",
+		"cp1257",
+		"cp1257",
+		"utf32",
+		"utf32",
+		"utf16-le",
+		"binary",
+		"armscii8",
+		"ascii",
+		"cp1250",
+		"cp1256",
+		"cp866",
+		"dec8",
+		"greek",
+		"hebrew",
+		"hp8",
+		"keybcs2",
+		"koi8r",
+		"koi8u",
+		"cesu8",
+		"latin2",
+		"latin5",
+		"latin7",
+		"cp850",
+		"cp852",
+		"swe7",
+		"cesu8",
+		"big5",
+		"euckr",
+		"gb2312",
+		"gbk",
+		"sjis",
+		"tis620",
+		"ucs2",
+		"eucjp",
+		"geostd8",
+		"geostd8",
+		"latin1",
+		"cp932",
+		"cp932",
+		"eucjpms",
+		"eucjpms",
+		"cp1250",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf16",
+		"utf8",
+		"utf8",
+		"utf8",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"ucs2",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"ucs2",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf32",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"cesu8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"cesu8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"gb18030",
+		"gb18030",
+		"gb18030",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8",
+		"utf8"
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/change_user.js
+var require_change_user$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/change_user.js": ((exports, module) => {
+	const CommandCode$4 = require_commands$1();
+	const ClientConstants$7 = require_client();
+	const Packet$14 = require_packet();
+	const auth41$3 = require_auth_41();
+	const CharsetToEncoding$8 = require_charset_encodings();
+	var ChangeUser$2 = class {
+		constructor(opts) {
+			this.flags = opts.flags;
+			this.user = opts.user || "";
+			this.database = opts.database || "";
+			this.password = opts.password || "";
+			this.passwordSha1 = opts.passwordSha1;
+			this.authPluginData1 = opts.authPluginData1;
+			this.authPluginData2 = opts.authPluginData2;
+			this.connectAttributes = opts.connectAttrinutes || {};
+			let authToken;
+			if (this.passwordSha1) authToken = auth41$3.calculateTokenFromPasswordSha(this.passwordSha1, this.authPluginData1, this.authPluginData2);
+			else authToken = auth41$3.calculateToken(this.password, this.authPluginData1, this.authPluginData2);
+			this.authToken = authToken;
+			this.charsetNumber = opts.charsetNumber;
+		}
+		serializeToBuffer(buffer$1) {
+			const isSet = (flag) => this.flags & ClientConstants$7[flag];
+			const packet = new Packet$14(0, buffer$1, 0, buffer$1.length);
+			packet.offset = 4;
+			const encoding = CharsetToEncoding$8[this.charsetNumber];
+			packet.writeInt8(CommandCode$4.CHANGE_USER);
+			packet.writeNullTerminatedString(this.user, encoding);
+			if (isSet("SECURE_CONNECTION")) {
+				packet.writeInt8(this.authToken.length);
+				packet.writeBuffer(this.authToken);
+			} else {
+				packet.writeBuffer(this.authToken);
+				packet.writeInt8(0);
+			}
+			packet.writeNullTerminatedString(this.database, encoding);
+			packet.writeInt16(this.charsetNumber);
+			if (isSet("PLUGIN_AUTH")) packet.writeNullTerminatedString("mysql_native_password", "latin1");
+			if (isSet("CONNECT_ATTRS")) {
+				const connectAttributes = this.connectAttributes;
+				const attrNames = Object.keys(connectAttributes);
+				let keysLength = 0;
+				for (let k = 0; k < attrNames.length; ++k) {
+					keysLength += Packet$14.lengthCodedStringLength(attrNames[k], encoding);
+					keysLength += Packet$14.lengthCodedStringLength(connectAttributes[attrNames[k]], encoding);
+				}
+				packet.writeLengthCodedNumber(keysLength);
+				for (let k = 0; k < attrNames.length; ++k) {
+					packet.writeLengthCodedString(attrNames[k], encoding);
+					packet.writeLengthCodedString(connectAttributes[attrNames[k]], encoding);
+				}
+			}
+			return packet;
+		}
+		toPacket() {
+			if (typeof this.user !== "string") throw new Error("\"user\" connection config property must be a string");
+			if (typeof this.database !== "string") throw new Error("\"database\" connection config property must be a string");
+			const p = this.serializeToBuffer(Packet$14.MockBuffer());
+			return this.serializeToBuffer(Buffer.allocUnsafe(p.offset));
+		}
+	};
+	module.exports = ChangeUser$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/close_statement.js
+var require_close_statement$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/close_statement.js": ((exports, module) => {
+	const Packet$13 = require_packet();
+	const CommandCodes$3 = require_commands$1();
+	var CloseStatement$3 = class {
+		constructor(id) {
+			this.id = id;
+		}
+		toPacket() {
+			const packet = new Packet$13(0, Buffer.allocUnsafe(9), 0, 9);
+			packet.offset = 4;
+			packet.writeInt8(CommandCodes$3.STMT_CLOSE);
+			packet.writeInt32(this.id);
+			return packet;
+		}
+	};
+	module.exports = CloseStatement$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/field_flags.js
+var require_field_flags = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/field_flags.js": ((exports) => {
+	exports.NOT_NULL = 1;
+	exports.PRI_KEY = 2;
+	exports.UNIQUE_KEY = 4;
+	exports.MULTIPLE_KEY = 8;
+	exports.BLOB = 16;
+	exports.UNSIGNED = 32;
+	exports.ZEROFILL = 64;
+	exports.BINARY = 128;
+	exports.ENUM = 256;
+	exports.AUTO_INCREMENT = 512;
+	exports.TIMESTAMP = 1024;
+	exports.SET = 2048;
+	exports.NO_DEFAULT_VALUE = 4096;
+	exports.ON_UPDATE_NOW = 8192;
+	exports.NUM = 32768;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/column_definition.js
+var require_column_definition = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/column_definition.js": ((exports, module) => {
+	const Packet$12 = require_packet();
+	const StringParser$2 = require_string();
+	const CharsetToEncoding$7 = require_charset_encodings();
+	const fields = [
+		"catalog",
+		"schema",
+		"table",
+		"orgTable",
+		"name",
+		"orgName"
+	];
+	var ColumnDefinition = class {
+		constructor(packet, clientEncoding) {
+			this._buf = packet.buffer;
+			this._clientEncoding = clientEncoding;
+			this._catalogLength = packet.readLengthCodedNumber();
+			this._catalogStart = packet.offset;
+			packet.offset += this._catalogLength;
+			this._schemaLength = packet.readLengthCodedNumber();
+			this._schemaStart = packet.offset;
+			packet.offset += this._schemaLength;
+			this._tableLength = packet.readLengthCodedNumber();
+			this._tableStart = packet.offset;
+			packet.offset += this._tableLength;
+			this._orgTableLength = packet.readLengthCodedNumber();
+			this._orgTableStart = packet.offset;
+			packet.offset += this._orgTableLength;
+			const _nameLength = packet.readLengthCodedNumber();
+			const _nameStart = packet.offset;
+			packet.offset += _nameLength;
+			this._orgNameLength = packet.readLengthCodedNumber();
+			this._orgNameStart = packet.offset;
+			packet.offset += this._orgNameLength;
+			packet.skip(1);
+			this.characterSet = packet.readInt16();
+			this.encoding = CharsetToEncoding$7[this.characterSet];
+			this.name = StringParser$2.decode(this._buf, this.encoding === "binary" ? this._clientEncoding : this.encoding, _nameStart, _nameStart + _nameLength);
+			this.columnLength = packet.readInt32();
+			this.columnType = packet.readInt8();
+			this.type = this.columnType;
+			this.flags = packet.readInt16();
+			this.decimals = packet.readInt8();
+		}
+		inspect() {
+			return {
+				catalog: this.catalog,
+				schema: this.schema,
+				name: this.name,
+				orgName: this.orgName,
+				table: this.table,
+				orgTable: this.orgTable,
+				characterSet: this.characterSet,
+				encoding: this.encoding,
+				columnLength: this.columnLength,
+				type: this.columnType,
+				flags: this.flags,
+				decimals: this.decimals
+			};
+		}
+		[Symbol.for("nodejs.util.inspect.custom")](depth, inspectOptions, inspect) {
+			const Types$7 = require_types();
+			const typeNames$4 = [];
+			for (const t in Types$7) typeNames$4[Types$7[t]] = t;
+			const fiedFlags = require_field_flags();
+			const flagNames$1 = [];
+			const inspectFlags = this.flags;
+			for (const f in fiedFlags) if (inspectFlags & fiedFlags[f]) if (f === "PRI_KEY") flagNames$1.push("PRIMARY KEY");
+			else if (f === "NOT_NULL") flagNames$1.push("NOT NULL");
+			else if (f === "BINARY") {} else if (f === "MULTIPLE_KEY") {} else if (f === "NO_DEFAULT_VALUE") {} else if (f === "BLOB") {} else if (f === "UNSIGNED") {} else if (f === "TIMESTAMP") {} else if (f === "ON_UPDATE_NOW") flagNames$1.push("ON UPDATE CURRENT_TIMESTAMP");
+			else flagNames$1.push(f);
+			if (depth > 1) return inspect({
+				...this.inspect(),
+				typeName: typeNames$4[this.columnType],
+				flags: flagNames$1
+			});
+			const isUnsigned = this.flags & fiedFlags.UNSIGNED;
+			let typeName = typeNames$4[this.columnType];
+			if (typeName === "BLOB") if (this.columnLength === 4294967295) typeName = "LONGTEXT";
+			else if (this.columnLength === 67108860) typeName = "MEDIUMTEXT";
+			else if (this.columnLength === 262140) typeName = "TEXT";
+			else if (this.columnLength === 1020) typeName = "TINYTEXT";
+			else typeName = `BLOB(${this.columnLength})`;
+			else if (typeName === "VAR_STRING") typeName = `VARCHAR(${Math.ceil(this.columnLength / 4)})`;
+			else if (typeName === "TINY") if (this.columnLength === 3 && isUnsigned || this.columnLength === 4 && !isUnsigned) typeName = "TINYINT";
+			else typeName = `TINYINT(${this.columnLength})`;
+			else if (typeName === "LONGLONG") if (this.columnLength === 20) typeName = "BIGINT";
+			else typeName = `BIGINT(${this.columnLength})`;
+			else if (typeName === "SHORT") if (isUnsigned && this.columnLength === 5) typeName = "SMALLINT";
+			else if (!isUnsigned && this.columnLength === 6) typeName = "SMALLINT";
+			else typeName = `SMALLINT(${this.columnLength})`;
+			else if (typeName === "LONG") if (isUnsigned && this.columnLength === 10) typeName = "INT";
+			else if (!isUnsigned && this.columnLength === 11) typeName = "INT";
+			else typeName = `INT(${this.columnLength})`;
+			else if (typeName === "INT24") if (isUnsigned && this.columnLength === 8) typeName = "MEDIUMINT";
+			else if (!isUnsigned && this.columnLength === 9) typeName = "MEDIUMINT";
+			else typeName = `MEDIUMINT(${this.columnLength})`;
+			else if (typeName === "DOUBLE") if (this.columnLength === 22 && this.decimals === 31) typeName = "DOUBLE";
+			else typeName = `DOUBLE(${this.columnLength},${this.decimals})`;
+			else if (typeName === "FLOAT") if (this.columnLength === 12 && this.decimals === 31) typeName = "FLOAT";
+			else typeName = `FLOAT(${this.columnLength},${this.decimals})`;
+			else if (typeName === "NEWDECIMAL") if (this.columnLength === 11 && this.decimals === 0) typeName = "DECIMAL";
+			else if (this.decimals === 0) if (isUnsigned) typeName = `DECIMAL(${this.columnLength})`;
+			else typeName = `DECIMAL(${this.columnLength - 1})`;
+			else typeName = `DECIMAL(${this.columnLength - 2},${this.decimals})`;
+			else typeName = `${typeNames$4[this.columnType]}(${this.columnLength})`;
+			if (isUnsigned) typeName += " UNSIGNED";
+			return `\`${this.name}\` ${[typeName, ...flagNames$1].join(" ")}`;
+		}
+		static toPacket(column, sequenceId) {
+			let length = 17;
+			fields.forEach((field) => {
+				length += Packet$12.lengthCodedStringLength(column[field], CharsetToEncoding$7[column.characterSet]);
+			});
+			const packet = new Packet$12(sequenceId, Buffer.allocUnsafe(length), 0, length);
+			function writeField(name) {
+				packet.writeLengthCodedString(column[name], CharsetToEncoding$7[column.characterSet]);
+			}
+			packet.offset = 4;
+			fields.forEach(writeField);
+			packet.writeInt8(12);
+			packet.writeInt16(column.characterSet);
+			packet.writeInt32(column.columnLength);
+			packet.writeInt8(column.columnType);
+			packet.writeInt16(column.flags);
+			packet.writeInt8(column.decimals);
+			packet.writeInt16(0);
+			return packet;
+		}
+		get db() {
+			return this.schema;
+		}
+	};
+	const addString = function(name) {
+		Object.defineProperty(ColumnDefinition.prototype, name, { get: function() {
+			const start = this[`_${name}Start`];
+			const end = start + this[`_${name}Length`];
+			const val = StringParser$2.decode(this._buf, this.encoding === "binary" ? this._clientEncoding : this.encoding, start, end);
+			Object.defineProperty(this, name, {
+				value: val,
+				writable: false,
+				configurable: false,
+				enumerable: false
+			});
+			return val;
+		} });
+	};
+	addString("catalog");
+	addString("schema");
+	addString("table");
+	addString("orgTable");
+	addString("orgName");
+	module.exports = ColumnDefinition;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/cursor.js
+var require_cursor = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/cursor.js": ((exports, module) => {
+	module.exports = {
+		NO_CURSOR: 0,
+		READ_ONLY: 1,
+		FOR_UPDATE: 2,
+		SCROLLABLE: 3
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/execute.js
+var require_execute$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/execute.js": ((exports, module) => {
+	const CursorType = require_cursor();
+	const CommandCodes$2 = require_commands$1();
+	const Types$4 = require_types();
+	const Packet$11 = require_packet();
+	const CharsetToEncoding$6 = require_charset_encodings();
+	function isJSON(value) {
+		return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === "function" && !Buffer.isBuffer(value);
+	}
+	/**
+	* Converts a value to an object describing type, String/Buffer representation and length
+	* @param {*} value
+	*/
+	function toParameter(value, encoding, timezone) {
+		let type = Types$4.VAR_STRING;
+		let length;
+		let writer = function(value$1) {
+			return Packet$11.prototype.writeLengthCodedString.call(this, value$1, encoding);
+		};
+		if (value !== null) switch (typeof value) {
+			case "undefined": throw new TypeError("Bind parameters must not contain undefined");
+			case "number":
+				type = Types$4.DOUBLE;
+				length = 8;
+				writer = Packet$11.prototype.writeDouble;
+				break;
+			case "boolean":
+				value = value | 0;
+				type = Types$4.TINY;
+				length = 1;
+				writer = Packet$11.prototype.writeInt8;
+				break;
+			case "object":
+				if (Object.prototype.toString.call(value) === "[object Date]") {
+					type = Types$4.DATETIME;
+					length = 12;
+					writer = function(value$1) {
+						return Packet$11.prototype.writeDate.call(this, value$1, timezone);
+					};
+				} else if (isJSON(value)) {
+					value = JSON.stringify(value);
+					type = Types$4.JSON;
+				} else if (Buffer.isBuffer(value)) {
+					length = Packet$11.lengthCodedNumberLength(value.length) + value.length;
+					writer = Packet$11.prototype.writeLengthCodedBuffer;
+				}
+				break;
+			default: value = value.toString();
+		}
+		else {
+			value = "";
+			type = Types$4.NULL;
+		}
+		if (!length) length = Packet$11.lengthCodedStringLength(value, encoding);
+		return {
+			value,
+			type,
+			length,
+			writer
+		};
+	}
+	var Execute$3 = class {
+		constructor(id, parameters, charsetNumber, timezone) {
+			this.id = id;
+			this.parameters = parameters;
+			this.encoding = CharsetToEncoding$6[charsetNumber];
+			this.timezone = timezone;
+		}
+		static fromPacket(packet, encoding) {
+			const stmtId = packet.readInt32();
+			const flags = packet.readInt8();
+			const iterationCount = packet.readInt32();
+			let i$4 = packet.offset;
+			while (i$4 < packet.end - 1) {
+				if ((packet.buffer[i$4 + 1] === Types$4.VAR_STRING || packet.buffer[i$4 + 1] === Types$4.NULL || packet.buffer[i$4 + 1] === Types$4.DOUBLE || packet.buffer[i$4 + 1] === Types$4.TINY || packet.buffer[i$4 + 1] === Types$4.DATETIME || packet.buffer[i$4 + 1] === Types$4.JSON) && packet.buffer[i$4] === 1 && packet.buffer[i$4 + 2] === 0) break;
+				else packet.readInt8();
+				i$4++;
+			}
+			const types = [];
+			for (let i$5 = packet.offset + 1; i$5 < packet.end - 1; i$5++) if ((packet.buffer[i$5] === Types$4.VAR_STRING || packet.buffer[i$5] === Types$4.NULL || packet.buffer[i$5] === Types$4.DOUBLE || packet.buffer[i$5] === Types$4.TINY || packet.buffer[i$5] === Types$4.DATETIME || packet.buffer[i$5] === Types$4.JSON) && packet.buffer[i$5 + 1] === 0) {
+				types.push(packet.buffer[i$5]);
+				packet.skip(2);
+			}
+			packet.skip(1);
+			const values = [];
+			for (let i$5 = 0; i$5 < types.length; i$5++) {
+				if (types[i$5] === Types$4.VAR_STRING) values.push(packet.readLengthCodedString(encoding));
+				else if (types[i$5] === Types$4.DOUBLE) values.push(packet.readDouble());
+				else if (types[i$5] === Types$4.TINY) values.push(packet.readInt8());
+				else if (types[i$5] === Types$4.DATETIME) values.push(packet.readDateTime());
+				else if (types[i$5] === Types$4.JSON) values.push(JSON.parse(packet.readLengthCodedString(encoding)));
+				if (types[i$5] === Types$4.NULL) values.push(null);
+			}
+			return {
+				stmtId,
+				flags,
+				iterationCount,
+				values
+			};
+		}
+		toPacket() {
+			let length = 14;
+			let parameters;
+			if (this.parameters && this.parameters.length > 0) {
+				length += Math.floor((this.parameters.length + 7) / 8);
+				length += 1;
+				length += 2 * this.parameters.length;
+				parameters = this.parameters.map((value) => toParameter(value, this.encoding, this.timezone));
+				length += parameters.reduce((accumulator, parameter) => accumulator + parameter.length, 0);
+			}
+			const packet = new Packet$11(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(CommandCodes$2.STMT_EXECUTE);
+			packet.writeInt32(this.id);
+			packet.writeInt8(CursorType.NO_CURSOR);
+			packet.writeInt32(1);
+			if (parameters) {
+				let bitmap = 0;
+				let bitValue = 1;
+				parameters.forEach((parameter) => {
+					if (parameter.type === Types$4.NULL) bitmap += bitValue;
+					bitValue *= 2;
+					if (bitValue === 256) {
+						packet.writeInt8(bitmap);
+						bitmap = 0;
+						bitValue = 1;
+					}
+				});
+				if (bitValue !== 1) packet.writeInt8(bitmap);
+				packet.writeInt8(1);
+				parameters.forEach((parameter) => {
+					packet.writeInt8(parameter.type);
+					packet.writeInt8(0);
+				});
+				parameters.forEach((parameter) => {
+					if (parameter.type !== Types$4.NULL) parameter.writer.call(packet, parameter.value);
+				});
+			}
+			return packet;
+		}
+	};
+	module.exports = Execute$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/handshake.js
+var require_handshake = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/handshake.js": ((exports, module) => {
+	const Packet$10 = require_packet();
+	const ClientConstants$6 = require_client();
+	var Handshake = class Handshake {
+		constructor(args) {
+			this.protocolVersion = args.protocolVersion;
+			this.serverVersion = args.serverVersion;
+			this.capabilityFlags = args.capabilityFlags;
+			this.connectionId = args.connectionId;
+			this.authPluginData1 = args.authPluginData1;
+			this.authPluginData2 = args.authPluginData2;
+			this.characterSet = args.characterSet;
+			this.statusFlags = args.statusFlags;
+			this.authPluginName = args.authPluginName;
+		}
+		setScrambleData(cb) {
+			__require("crypto").randomBytes(20, (err, data) => {
+				if (err) {
+					cb(err);
+					return;
+				}
+				this.authPluginData1 = data.slice(0, 8);
+				this.authPluginData2 = data.slice(8, 20);
+				cb();
+			});
+		}
+		toPacket(sequenceId) {
+			const length = 68 + Buffer.byteLength(this.serverVersion, "utf8");
+			const packet = new Packet$10(sequenceId, Buffer.alloc(length + 4, 0), 0, length + 4);
+			packet.offset = 4;
+			packet.writeInt8(this.protocolVersion);
+			packet.writeString(this.serverVersion, "cesu8");
+			packet.writeInt8(0);
+			packet.writeInt32(this.connectionId);
+			packet.writeBuffer(this.authPluginData1);
+			packet.writeInt8(0);
+			const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
+			capabilityFlagsBuffer.writeUInt32LE(this.capabilityFlags, 0);
+			packet.writeBuffer(capabilityFlagsBuffer.slice(0, 2));
+			packet.writeInt8(this.characterSet);
+			packet.writeInt16(this.statusFlags);
+			packet.writeBuffer(capabilityFlagsBuffer.slice(2, 4));
+			packet.writeInt8(21);
+			packet.skip(10);
+			packet.writeBuffer(this.authPluginData2);
+			packet.writeInt8(0);
+			packet.writeString("mysql_native_password", "latin1");
+			packet.writeInt8(0);
+			return packet;
+		}
+		static fromPacket(packet) {
+			const args = {};
+			args.protocolVersion = packet.readInt8();
+			args.serverVersion = packet.readNullTerminatedString("cesu8");
+			args.connectionId = packet.readInt32();
+			args.authPluginData1 = packet.readBuffer(8);
+			packet.skip(1);
+			const capabilityFlagsBuffer = Buffer.allocUnsafe(4);
+			capabilityFlagsBuffer[0] = packet.readInt8();
+			capabilityFlagsBuffer[1] = packet.readInt8();
+			if (packet.haveMoreData()) {
+				args.characterSet = packet.readInt8();
+				args.statusFlags = packet.readInt16();
+				capabilityFlagsBuffer[2] = packet.readInt8();
+				capabilityFlagsBuffer[3] = packet.readInt8();
+				args.capabilityFlags = capabilityFlagsBuffer.readUInt32LE(0);
+				if (args.capabilityFlags & ClientConstants$6.PLUGIN_AUTH) args.authPluginDataLength = packet.readInt8();
+				else {
+					args.authPluginDataLength = 0;
+					packet.skip(1);
+				}
+				packet.skip(10);
+			} else args.capabilityFlags = capabilityFlagsBuffer.readUInt16LE(0);
+			if (args.capabilityFlags & ClientConstants$6.SECURE_CONNECTION) {
+				const authPluginDataLength = args.authPluginDataLength;
+				if (authPluginDataLength === 0) {
+					args.authPluginDataLength = 20;
+					args.authPluginData2 = packet.readBuffer(12);
+					packet.skip(1);
+				} else {
+					const len = Math.max(13, authPluginDataLength - 8);
+					args.authPluginData2 = packet.readBuffer(len);
+				}
+			}
+			if (args.capabilityFlags & ClientConstants$6.PLUGIN_AUTH) args.authPluginName = packet.readNullTerminatedString("ascii");
+			return new Handshake(args);
+		}
+	};
+	module.exports = Handshake;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/handshake_response.js
+var require_handshake_response = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/handshake_response.js": ((exports, module) => {
+	const ClientConstants$5 = require_client();
+	const CharsetToEncoding$5 = require_charset_encodings();
+	const Packet$9 = require_packet();
+	const auth41$2 = require_auth_41();
+	var HandshakeResponse = class {
+		constructor(handshake) {
+			this.user = handshake.user || "";
+			this.database = handshake.database || "";
+			this.password = handshake.password || "";
+			this.passwordSha1 = handshake.passwordSha1;
+			this.authPluginData1 = handshake.authPluginData1;
+			this.authPluginData2 = handshake.authPluginData2;
+			this.compress = handshake.compress;
+			this.clientFlags = handshake.flags;
+			let authToken;
+			if (this.passwordSha1) authToken = auth41$2.calculateTokenFromPasswordSha(this.passwordSha1, this.authPluginData1, this.authPluginData2);
+			else authToken = auth41$2.calculateToken(this.password, this.authPluginData1, this.authPluginData2);
+			this.authToken = authToken;
+			this.charsetNumber = handshake.charsetNumber;
+			this.encoding = CharsetToEncoding$5[handshake.charsetNumber];
+			this.connectAttributes = handshake.connectAttributes;
+		}
+		serializeResponse(buffer$1) {
+			const isSet = (flag) => this.clientFlags & ClientConstants$5[flag];
+			const packet = new Packet$9(0, buffer$1, 0, buffer$1.length);
+			packet.offset = 4;
+			packet.writeInt32(this.clientFlags);
+			packet.writeInt32(0);
+			packet.writeInt8(this.charsetNumber);
+			packet.skip(23);
+			const encoding = this.encoding;
+			packet.writeNullTerminatedString(this.user, encoding);
+			let k;
+			if (isSet("PLUGIN_AUTH_LENENC_CLIENT_DATA")) {
+				packet.writeLengthCodedNumber(this.authToken.length);
+				packet.writeBuffer(this.authToken);
+			} else if (isSet("SECURE_CONNECTION")) {
+				packet.writeInt8(this.authToken.length);
+				packet.writeBuffer(this.authToken);
+			} else {
+				packet.writeBuffer(this.authToken);
+				packet.writeInt8(0);
+			}
+			if (isSet("CONNECT_WITH_DB")) packet.writeNullTerminatedString(this.database, encoding);
+			if (isSet("PLUGIN_AUTH")) packet.writeNullTerminatedString("mysql_native_password", "latin1");
+			if (isSet("CONNECT_ATTRS")) {
+				const connectAttributes = this.connectAttributes || {};
+				const attrNames = Object.keys(connectAttributes);
+				let keysLength = 0;
+				for (k = 0; k < attrNames.length; ++k) {
+					keysLength += Packet$9.lengthCodedStringLength(attrNames[k], encoding);
+					keysLength += Packet$9.lengthCodedStringLength(connectAttributes[attrNames[k]], encoding);
+				}
+				packet.writeLengthCodedNumber(keysLength);
+				for (k = 0; k < attrNames.length; ++k) {
+					packet.writeLengthCodedString(attrNames[k], encoding);
+					packet.writeLengthCodedString(connectAttributes[attrNames[k]], encoding);
+				}
+			}
+			return packet;
+		}
+		toPacket() {
+			if (typeof this.user !== "string") throw new Error("\"user\" connection config property must be a string");
+			if (typeof this.database !== "string") throw new Error("\"database\" connection config property must be a string");
+			const p = this.serializeResponse(Packet$9.MockBuffer());
+			return this.serializeResponse(Buffer.alloc(p.offset));
+		}
+		static fromPacket(packet) {
+			const args = {};
+			args.clientFlags = packet.readInt32();
+			function isSet(flag) {
+				return args.clientFlags & ClientConstants$5[flag];
+			}
+			args.maxPacketSize = packet.readInt32();
+			args.charsetNumber = packet.readInt8();
+			const encoding = CharsetToEncoding$5[args.charsetNumber];
+			args.encoding = encoding;
+			packet.skip(23);
+			args.user = packet.readNullTerminatedString(encoding);
+			let authTokenLength;
+			if (isSet("PLUGIN_AUTH_LENENC_CLIENT_DATA")) {
+				authTokenLength = packet.readLengthCodedNumber(encoding);
+				args.authToken = packet.readBuffer(authTokenLength);
+			} else if (isSet("SECURE_CONNECTION")) {
+				authTokenLength = packet.readInt8();
+				args.authToken = packet.readBuffer(authTokenLength);
+			} else args.authToken = packet.readNullTerminatedString(encoding);
+			if (isSet("CONNECT_WITH_DB")) args.database = packet.readNullTerminatedString(encoding);
+			if (isSet("PLUGIN_AUTH")) args.authPluginName = packet.readNullTerminatedString(encoding);
+			if (isSet("CONNECT_ATTRS")) {
+				const keysLength = packet.readLengthCodedNumber(encoding);
+				const keysEnd = packet.offset + keysLength;
+				const attrs = {};
+				while (packet.offset < keysEnd) attrs[packet.readLengthCodedString(encoding)] = packet.readLengthCodedString(encoding);
+				args.connectAttributes = attrs;
+			}
+			return args;
+		}
+	};
+	module.exports = HandshakeResponse;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/prepare_statement.js
+var require_prepare_statement = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/prepare_statement.js": ((exports, module) => {
+	const Packet$8 = require_packet();
+	const CommandCodes$1 = require_commands$1();
+	const StringParser$1 = require_string();
+	const CharsetToEncoding$4 = require_charset_encodings();
+	var PrepareStatement = class {
+		constructor(sql, charsetNumber) {
+			this.query = sql;
+			this.charsetNumber = charsetNumber;
+			this.encoding = CharsetToEncoding$4[charsetNumber];
+		}
+		toPacket() {
+			const buf = StringParser$1.encode(this.query, this.encoding);
+			const length = 5 + buf.length;
+			const packet = new Packet$8(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(CommandCodes$1.STMT_PREPARE);
+			packet.writeBuffer(buf);
+			return packet;
+		}
+	};
+	module.exports = PrepareStatement;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/prepared_statement_header.js
+var require_prepared_statement_header = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/prepared_statement_header.js": ((exports, module) => {
+	var PreparedStatementHeader = class {
+		constructor(packet) {
+			packet.skip(1);
+			this.id = packet.readInt32();
+			this.fieldCount = packet.readInt16();
+			this.parameterCount = packet.readInt16();
+			packet.skip(1);
+			this.warningCount = packet.readInt16();
+		}
+	};
+	module.exports = PreparedStatementHeader;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/query.js
+var require_query$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/query.js": ((exports, module) => {
+	const Packet$7 = require_packet();
+	const CommandCode$3 = require_commands$1();
+	const StringParser = require_string();
+	const CharsetToEncoding$3 = require_charset_encodings();
+	var Query$3 = class {
+		constructor(sql, charsetNumber) {
+			this.query = sql;
+			this.charsetNumber = charsetNumber;
+			this.encoding = CharsetToEncoding$3[charsetNumber];
+		}
+		toPacket() {
+			const buf = StringParser.encode(this.query, this.encoding);
+			const length = 5 + buf.length;
+			const packet = new Packet$7(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(CommandCode$3.QUERY);
+			packet.writeBuffer(buf);
+			return packet;
+		}
+	};
+	module.exports = Query$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/register_slave.js
+var require_register_slave$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/register_slave.js": ((exports, module) => {
+	const Packet$6 = require_packet();
+	const CommandCodes = require_commands$1();
+	var RegisterSlave$2 = class {
+		constructor(opts) {
+			this.serverId = opts.serverId || 0;
+			this.slaveHostname = opts.slaveHostname || "";
+			this.slaveUser = opts.slaveUser || "";
+			this.slavePassword = opts.slavePassword || "";
+			this.slavePort = opts.slavePort || 0;
+			this.replicationRank = opts.replicationRank || 0;
+			this.masterId = opts.masterId || 0;
+		}
+		toPacket() {
+			const length = 15 + Buffer.byteLength(this.slaveHostname, "utf8") + Buffer.byteLength(this.slaveUser, "utf8") + Buffer.byteLength(this.slavePassword, "utf8") + 3 + 4;
+			const packet = new Packet$6(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(CommandCodes.REGISTER_SLAVE);
+			packet.writeInt32(this.serverId);
+			packet.writeInt8(Buffer.byteLength(this.slaveHostname, "utf8"));
+			packet.writeString(this.slaveHostname);
+			packet.writeInt8(Buffer.byteLength(this.slaveUser, "utf8"));
+			packet.writeString(this.slaveUser);
+			packet.writeInt8(Buffer.byteLength(this.slavePassword, "utf8"));
+			packet.writeString(this.slavePassword);
+			packet.writeInt16(this.slavePort);
+			packet.writeInt32(this.replicationRank);
+			packet.writeInt32(this.masterId);
+			return packet;
+		}
+	};
+	module.exports = RegisterSlave$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/server_status.js
+var require_server_status = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/server_status.js": ((exports) => {
+	/**
+	Is raised when a multi-statement transaction
+	has been started, either explicitly, by means
+	of BEGIN or COMMIT AND CHAIN, or
+	implicitly, by the first transactional
+	statement, when autocommit=off.
+	*/
+	exports.SERVER_STATUS_IN_TRANS = 1;
+	exports.SERVER_STATUS_AUTOCOMMIT = 2;
+	exports.SERVER_MORE_RESULTS_EXISTS = 8;
+	exports.SERVER_QUERY_NO_GOOD_INDEX_USED = 16;
+	exports.SERVER_QUERY_NO_INDEX_USED = 32;
+	/**
+	The server was able to fulfill the clients request and opened a
+	read-only non-scrollable cursor for a query. This flag comes
+	in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands.
+	*/
+	exports.SERVER_STATUS_CURSOR_EXISTS = 64;
+	/**
+	This flag is sent when a read-only cursor is exhausted, in reply to
+	COM_STMT_FETCH command.
+	*/
+	exports.SERVER_STATUS_LAST_ROW_SENT = 128;
+	exports.SERVER_STATUS_DB_DROPPED = 256;
+	exports.SERVER_STATUS_NO_BACKSLASH_ESCAPES = 512;
+	/**
+	Sent to the client if after a prepared statement reprepare
+	we discovered that the new statement returns a different
+	number of result set columns.
+	*/
+	exports.SERVER_STATUS_METADATA_CHANGED = 1024;
+	exports.SERVER_QUERY_WAS_SLOW = 2048;
+	/**
+	To mark ResultSet containing output parameter values.
+	*/
+	exports.SERVER_PS_OUT_PARAMS = 4096;
+	exports.SERVER_STATUS_IN_TRANS_READONLY = 8192;
+	exports.SERVER_SESSION_STATE_CHANGED = 16384;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/encoding_charset.js
+var require_encoding_charset = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/encoding_charset.js": ((exports, module) => {
+	module.exports = {
+		big5: 1,
+		latin2: 2,
+		dec8: 3,
+		cp850: 4,
+		latin1: 5,
+		hp8: 6,
+		koi8r: 7,
+		swe7: 10,
+		ascii: 11,
+		eucjp: 12,
+		sjis: 13,
+		cp1251: 14,
+		hebrew: 16,
+		tis620: 18,
+		euckr: 19,
+		latin7: 20,
+		koi8u: 22,
+		gb2312: 24,
+		greek: 25,
+		cp1250: 26,
+		gbk: 28,
+		cp1257: 29,
+		latin5: 30,
+		armscii8: 32,
+		cesu8: 33,
+		ucs2: 35,
+		cp866: 36,
+		keybcs2: 37,
+		macintosh: 38,
+		macroman: 39,
+		cp852: 40,
+		utf8: 45,
+		utf8mb4: 45,
+		utf16: 54,
+		utf16le: 56,
+		cp1256: 57,
+		utf32: 60,
+		binary: 63,
+		geostd8: 92,
+		cp932: 95,
+		eucjpms: 97,
+		gb18030: 248,
+		utf8mb3: 192
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/session_track.js
+var require_session_track = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/session_track.js": ((exports) => {
+	exports.SYSTEM_VARIABLES = 0;
+	exports.SCHEMA = 1;
+	exports.STATE_CHANGE = 2;
+	exports.STATE_GTIDS = 3;
+	exports.TRANSACTION_CHARACTERISTICS = 4;
+	exports.TRANSACTION_STATE = 5;
+	exports.FIRST_KEY = exports.SYSTEM_VARIABLES;
+	exports.LAST_KEY = exports.TRANSACTION_STATE;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/resultset_header.js
+var require_resultset_header = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/resultset_header.js": ((exports, module) => {
+	const Packet$5 = require_packet();
+	const ClientConstants$4 = require_client();
+	const ServerSatusFlags = require_server_status();
+	const EncodingToCharset = require_encoding_charset();
+	const sessionInfoTypes = require_session_track();
+	var ResultSetHeader = class {
+		constructor(packet, connection) {
+			const bigNumberStrings = connection.config.bigNumberStrings;
+			const encoding = connection.serverEncoding;
+			const flags = connection._handshakePacket.capabilityFlags;
+			const isSet = function(flag) {
+				return flags & ClientConstants$4[flag];
+			};
+			if (packet.buffer[packet.offset] !== 0) {
+				this.fieldCount = packet.readLengthCodedNumber();
+				if (this.fieldCount === null) this.infileName = packet.readString(void 0, encoding);
+				return;
+			}
+			this.fieldCount = packet.readInt8();
+			this.affectedRows = packet.readLengthCodedNumber(bigNumberStrings);
+			this.insertId = packet.readLengthCodedNumberSigned(bigNumberStrings);
+			this.info = "";
+			if (isSet("PROTOCOL_41")) {
+				this.serverStatus = packet.readInt16();
+				this.warningStatus = packet.readInt16();
+			} else if (isSet("TRANSACTIONS")) this.serverStatus = packet.readInt16();
+			let stateChanges = null;
+			if (isSet("SESSION_TRACK") && packet.offset < packet.end) {
+				this.info = packet.readLengthCodedString(encoding);
+				if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {
+					let len = packet.offset < packet.end ? packet.readLengthCodedNumber() : 0;
+					const end = packet.offset + len;
+					let type, key$1, stateEnd;
+					if (len > 0) stateChanges = {
+						systemVariables: {},
+						schema: null,
+						gtids: [],
+						trackStateChange: null
+					};
+					while (packet.offset < end) {
+						type = packet.readInt8();
+						len = packet.readLengthCodedNumber();
+						stateEnd = packet.offset + len;
+						if (type === sessionInfoTypes.SYSTEM_VARIABLES) {
+							key$1 = packet.readLengthCodedString(encoding);
+							const val = packet.readLengthCodedString(encoding);
+							stateChanges.systemVariables[key$1] = val;
+							if (key$1 === "character_set_client") {
+								const charsetNumber = EncodingToCharset[val];
+								if (typeof charsetNumber !== "undefined") connection.config.charsetNumber = charsetNumber;
+							}
+						} else if (type === sessionInfoTypes.SCHEMA) {
+							key$1 = packet.readLengthCodedString(encoding);
+							stateChanges.schema = key$1;
+						} else if (type === sessionInfoTypes.STATE_CHANGE) stateChanges.trackStateChange = packet.readLengthCodedString(encoding);
+						else if (type === sessionInfoTypes.STATE_GTIDS) {
+							packet.readLengthCodedString(encoding);
+							stateChanges.gtids = packet.readLengthCodedString(encoding).split(",");
+						}
+						packet.offset = stateEnd;
+					}
+				}
+			} else this.info = packet.readString(void 0, encoding);
+			if (stateChanges) this.stateChanges = stateChanges;
+			const m = this.info.match(/\schanged:\s*(\d+)/i);
+			if (m !== null) this.changedRows = parseInt(m[1], 10);
+			else this.changedRows = 0;
+		}
+		static toPacket(fieldCount, insertId) {
+			let length = 4 + Packet$5.lengthCodedNumberLength(fieldCount);
+			if (typeof insertId !== "undefined") length += Packet$5.lengthCodedNumberLength(insertId);
+			const packet = new Packet$5(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeLengthCodedNumber(fieldCount);
+			if (typeof insertId !== "undefined") packet.writeLengthCodedNumber(insertId);
+			return packet;
+		}
+	};
+	module.exports = ResultSetHeader;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/ssl_request.js
+var require_ssl_request = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/ssl_request.js": ((exports, module) => {
+	const ClientConstants$3 = require_client();
+	const Packet$4 = require_packet();
+	var SSLRequest = class {
+		constructor(flags, charset) {
+			this.clientFlags = flags | ClientConstants$3.SSL;
+			this.charset = charset;
+		}
+		toPacket() {
+			const length = 36;
+			const buffer$1 = Buffer.allocUnsafe(length);
+			const packet = new Packet$4(0, buffer$1, 0, length);
+			buffer$1.fill(0);
+			packet.offset = 4;
+			packet.writeInt32(this.clientFlags);
+			packet.writeInt32(0);
+			packet.writeInt8(this.charset);
+			return packet;
+		}
+	};
+	module.exports = SSLRequest;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/text_row.js
+var require_text_row = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/text_row.js": ((exports, module) => {
+	const Packet$3 = require_packet();
+	var TextRow = class TextRow {
+		constructor(columns) {
+			this.columns = columns || [];
+		}
+		static fromPacket(packet) {
+			const columns = [];
+			while (packet.haveMoreData()) columns.push(packet.readLengthCodedString());
+			return new TextRow(columns);
+		}
+		static toPacket(columns, encoding) {
+			const sequenceId = 0;
+			let length = 0;
+			columns.forEach((val) => {
+				if (val === null || typeof val === "undefined") {
+					++length;
+					return;
+				}
+				length += Packet$3.lengthCodedStringLength(val.toString(10), encoding);
+			});
+			const packet = new Packet$3(sequenceId, Buffer.allocUnsafe(length + 4), 0, length + 4);
+			packet.offset = 4;
+			columns.forEach((val) => {
+				if (val === null) {
+					packet.writeNull();
+					return;
+				}
+				if (typeof val === "undefined") {
+					packet.writeInt8(0);
+					return;
+				}
+				packet.writeLengthCodedString(val.toString(10), encoding);
+			});
+			return packet;
+		}
+	};
+	module.exports = TextRow;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/index.js
+var require_packets = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/index.js": ((exports, module) => {
+	const process$4 = __require("process");
+	const ctorMap = {
+		AuthNextFactor: require_auth_next_factor(),
+		AuthSwitchRequest: require_auth_switch_request(),
+		AuthSwitchRequestMoreData: require_auth_switch_request_more_data(),
+		AuthSwitchResponse: require_auth_switch_response(),
+		BinaryRow: require_binary_row(),
+		BinlogDump: require_binlog_dump$1(),
+		ChangeUser: require_change_user$1(),
+		CloseStatement: require_close_statement$1(),
+		ColumnDefinition: require_column_definition(),
+		Execute: require_execute$1(),
+		Handshake: require_handshake(),
+		HandshakeResponse: require_handshake_response(),
+		PrepareStatement: require_prepare_statement(),
+		PreparedStatementHeader: require_prepared_statement_header(),
+		Query: require_query$1(),
+		RegisterSlave: require_register_slave$1(),
+		ResultSetHeader: require_resultset_header(),
+		SSLRequest: require_ssl_request(),
+		TextRow: require_text_row()
+	};
+	Object.entries(ctorMap).forEach(([name, ctor]) => {
+		module.exports[name] = ctor;
+		if (process$4.env.NODE_DEBUG) {
+			if (ctor.prototype.toPacket) {
+				const old = ctor.prototype.toPacket;
+				ctor.prototype.toPacket = function() {
+					const p = old.call(this);
+					p._name = name;
+					return p;
+				};
+			}
+		}
+	});
+	const Packet$2 = require_packet();
+	exports.Packet = Packet$2;
+	var OK = class {
+		static toPacket(args, encoding) {
+			args = args || {};
+			const affectedRows = args.affectedRows || 0;
+			const insertId = args.insertId || 0;
+			const serverStatus = args.serverStatus || 0;
+			const warningCount = args.warningCount || 0;
+			const message = args.message || "";
+			let length = 9 + Packet$2.lengthCodedNumberLength(affectedRows);
+			length += Packet$2.lengthCodedNumberLength(insertId);
+			const packet = new Packet$2(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(0);
+			packet.writeLengthCodedNumber(affectedRows);
+			packet.writeLengthCodedNumber(insertId);
+			packet.writeInt16(serverStatus);
+			packet.writeInt16(warningCount);
+			packet.writeString(message, encoding);
+			packet._name = "OK";
+			return packet;
+		}
+	};
+	exports.OK = OK;
+	var EOF = class {
+		static toPacket(warnings, statusFlags) {
+			if (typeof warnings === "undefined") warnings = 0;
+			if (typeof statusFlags === "undefined") statusFlags = 0;
+			const packet = new Packet$2(0, Buffer.allocUnsafe(9), 0, 9);
+			packet.offset = 4;
+			packet.writeInt8(254);
+			packet.writeInt16(warnings);
+			packet.writeInt16(statusFlags);
+			packet._name = "EOF";
+			return packet;
+		}
+	};
+	exports.EOF = EOF;
+	var Error$1 = class Error$1 {
+		static toPacket(args, encoding) {
+			const length = 13 + Buffer.byteLength(args.message, "utf8");
+			const packet = new Packet$2(0, Buffer.allocUnsafe(length), 0, length);
+			packet.offset = 4;
+			packet.writeInt8(255);
+			packet.writeInt16(args.code);
+			packet.writeString("#_____", encoding);
+			packet.writeString(args.message, encoding);
+			packet._name = "Error";
+			return packet;
+		}
+		static fromPacket(packet) {
+			packet.readInt8();
+			const code = packet.readInt16();
+			packet.readString(1, "ascii");
+			packet.readString(5, "ascii");
+			const message = packet.readNullTerminatedString("utf8");
+			const error = new Error$1();
+			error.message = message;
+			error.code = code;
+			return error;
+		}
+	};
+	exports.Error = Error$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/command.js
+var require_command = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/command.js": ((exports, module) => {
+	const EventEmitter$7 = __require("events").EventEmitter;
+	const Timers$2 = __require("timers");
+	var Command$11 = class extends EventEmitter$7 {
+		constructor() {
+			super();
+			this.next = null;
+		}
+		stateName() {
+			const state = this.next;
+			for (const i$4 in this) if (this[i$4] === state && i$4 !== "next") return i$4;
+			return "unknown name";
+		}
+		execute(packet, connection) {
+			if (!this.next) {
+				this.next = this.start;
+				connection._resetSequenceId();
+			}
+			if (packet && packet.isError()) {
+				const err = packet.asError(connection.clientEncoding);
+				err.sql = this.sql || this.query;
+				if (this.queryTimeout) {
+					Timers$2.clearTimeout(this.queryTimeout);
+					this.queryTimeout = null;
+				}
+				if (this.onResult) {
+					this.onResult(err);
+					this.emit("end");
+				} else {
+					this.emit("error", err);
+					this.emit("end");
+				}
+				return true;
+			}
+			this.next = this.next(packet, connection);
+			if (this.next) return false;
+			this.emit("end");
+			return true;
+		}
+	};
+	module.exports = Command$11;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/sha256_password.js
+var require_sha256_password = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/sha256_password.js": ((exports, module) => {
+	const PLUGIN_NAME$1 = "sha256_password";
+	const crypto$1 = __require("crypto");
+	const { xorRotating: xorRotating$1 } = require_auth_41();
+	const REQUEST_SERVER_KEY_PACKET$1 = Buffer.from([1]);
+	const STATE_INITIAL$1 = 0;
+	const STATE_WAIT_SERVER_KEY$1 = 1;
+	const STATE_FINAL$1 = -1;
+	function encrypt$1(password, scramble, key$1) {
+		const stage1 = xorRotating$1(Buffer.from(`${password}\0`, "utf8"), scramble);
+		return crypto$1.publicEncrypt(key$1, stage1);
+	}
+	module.exports = (pluginOptions = {}) => ({ connection }) => {
+		let state = 0;
+		let scramble = null;
+		const password = connection.config.password;
+		const authWithKey = (serverKey) => {
+			const _password = encrypt$1(password, scramble, serverKey);
+			state = STATE_FINAL$1;
+			return _password;
+		};
+		return (data) => {
+			switch (state) {
+				case STATE_INITIAL$1:
+					scramble = data.slice(0, 20);
+					if (pluginOptions.serverPublicKey) return authWithKey(pluginOptions.serverPublicKey);
+					state = STATE_WAIT_SERVER_KEY$1;
+					return REQUEST_SERVER_KEY_PACKET$1;
+				case STATE_WAIT_SERVER_KEY$1:
+					if (pluginOptions.onServerPublicKey) pluginOptions.onServerPublicKey(data);
+					return authWithKey(data);
+				case STATE_FINAL$1: throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME$1} plugin in STATE_FINAL state.`);
+			}
+			throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME$1} plugin in state ${state}`);
+		};
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/caching_sha2_password.js
+var require_caching_sha2_password = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/caching_sha2_password.js": ((exports, module) => {
+	const PLUGIN_NAME = "caching_sha2_password";
+	const crypto = __require("crypto");
+	const { xor, xorRotating } = require_auth_41();
+	const REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);
+	const FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);
+	const PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);
+	const STATE_INITIAL = 0;
+	const STATE_TOKEN_SENT = 1;
+	const STATE_WAIT_SERVER_KEY = 2;
+	const STATE_FINAL = -1;
+	function sha256(msg) {
+		const hash = crypto.createHash("sha256");
+		hash.update(msg);
+		return hash.digest();
+	}
+	function calculateToken(password, scramble) {
+		if (!password) return Buffer.alloc(0);
+		const stage1 = sha256(Buffer.from(password));
+		const stage2 = sha256(stage1);
+		return xor(stage1, sha256(Buffer.concat([stage2, scramble])));
+	}
+	function encrypt(password, scramble, key$1) {
+		const stage1 = xorRotating(Buffer.from(`${password}\0`, "utf8"), scramble);
+		return crypto.publicEncrypt({
+			key: key$1,
+			padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
+		}, stage1);
+	}
+	module.exports = (pluginOptions = {}) => ({ connection }) => {
+		let state = 0;
+		let scramble = null;
+		const password = connection.config.password;
+		const authWithKey = (serverKey) => {
+			const _password = encrypt(password, scramble, serverKey);
+			state = STATE_FINAL;
+			return _password;
+		};
+		return (data) => {
+			switch (state) {
+				case STATE_INITIAL:
+					scramble = data.slice(0, 20);
+					state = STATE_TOKEN_SENT;
+					return calculateToken(password, scramble);
+				case STATE_TOKEN_SENT:
+					if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {
+						state = STATE_FINAL;
+						return null;
+					}
+					if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {
+						if (typeof pluginOptions.overrideIsSecure === "undefined" ? connection.config.ssl || connection.config.socketPath : pluginOptions.overrideIsSecure) {
+							state = STATE_FINAL;
+							return Buffer.from(`${password}\0`, "utf8");
+						}
+						if (pluginOptions.serverPublicKey) return authWithKey(pluginOptions.serverPublicKey);
+						state = STATE_WAIT_SERVER_KEY;
+						return REQUEST_SERVER_KEY_PACKET;
+					}
+					throw new Error(`Invalid AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_TOKEN_SENT state.`);
+				case STATE_WAIT_SERVER_KEY:
+					if (pluginOptions.onServerPublicKey) pluginOptions.onServerPublicKey(data);
+					return authWithKey(data);
+				case STATE_FINAL: throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in STATE_FINAL state.`);
+			}
+			throw new Error(`Unexpected data in AuthMoreData packet received by ${PLUGIN_NAME} plugin in state ${state}`);
+		};
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/mysql_native_password.js
+var require_mysql_native_password = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/mysql_native_password.js": ((exports, module) => {
+	const auth41$1 = require_auth_41();
+	module.exports = (pluginOptions) => ({ connection, command }) => {
+		const password = command.password || pluginOptions.password || connection.config.password;
+		const passwordSha1 = command.passwordSha1 || pluginOptions.passwordSha1 || connection.config.passwordSha1;
+		return (data) => {
+			const authPluginData1 = data.slice(0, 8);
+			const authPluginData2 = data.slice(8, 20);
+			let authToken;
+			if (passwordSha1) authToken = auth41$1.calculateTokenFromPasswordSha(passwordSha1, authPluginData1, authPluginData2);
+			else authToken = auth41$1.calculateToken(password, authPluginData1, authPluginData2);
+			return authToken;
+		};
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/mysql_clear_password.js
+var require_mysql_clear_password = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/auth_plugins/mysql_clear_password.js": ((exports, module) => {
+	function bufferFromStr(str) {
+		return Buffer.from(`${str}\0`);
+	}
+	const create_mysql_clear_password_plugin = (pluginOptions) => function mysql_clear_password_plugin({ connection, command }) {
+		const password = command.password || pluginOptions.password || connection.config.password;
+		return function() {
+			return bufferFromStr(password);
+		};
+	};
+	module.exports = create_mysql_clear_password_plugin;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/auth_switch.js
+var require_auth_switch = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/auth_switch.js": ((exports, module) => {
+	const Packets$10 = require_packets();
+	const sha256_password = require_sha256_password();
+	const caching_sha2_password = require_caching_sha2_password();
+	const mysql_native_password = require_mysql_native_password();
+	const mysql_clear_password = require_mysql_clear_password();
+	const standardAuthPlugins = {
+		sha256_password: sha256_password({}),
+		caching_sha2_password: caching_sha2_password({}),
+		mysql_native_password: mysql_native_password({}),
+		mysql_clear_password: mysql_clear_password({})
+	};
+	function warnLegacyAuthSwitch() {
+		console.warn("WARNING! authSwitchHandler api is deprecated, please use new authPlugins api");
+	}
+	function authSwitchPluginError(error, command) {
+		error.code = "AUTH_SWITCH_PLUGIN_ERROR";
+		error.fatal = true;
+		command.emit("error", error);
+	}
+	function authSwitchRequest(packet, connection, command) {
+		const { pluginName, pluginData } = Packets$10.AuthSwitchRequest.fromPacket(packet);
+		let authPlugin = connection.config.authPlugins && connection.config.authPlugins[pluginName];
+		if (connection.config.authSwitchHandler && pluginName !== "mysql_native_password") {
+			const legacySwitchHandler = connection.config.authSwitchHandler;
+			warnLegacyAuthSwitch();
+			legacySwitchHandler({
+				pluginName,
+				pluginData
+			}, (err, data) => {
+				if (err) return authSwitchPluginError(err, command);
+				connection.writePacket(new Packets$10.AuthSwitchResponse(data).toPacket());
+			});
+			return;
+		}
+		if (!authPlugin) authPlugin = standardAuthPlugins[pluginName];
+		if (!authPlugin) throw new Error(`Server requests authentication using unknown plugin ${pluginName}. See TODO: add plugins doco here on how to configure or author authentication plugins.`);
+		connection._authPlugin = authPlugin({
+			connection,
+			command
+		});
+		Promise.resolve(connection._authPlugin(pluginData)).then((data) => {
+			if (data) connection.writePacket(new Packets$10.AuthSwitchResponse(data).toPacket());
+		}).catch((err) => {
+			authSwitchPluginError(err, command);
+		});
+	}
+	function authSwitchRequestMoreData(packet, connection, command) {
+		const { data } = Packets$10.AuthSwitchRequestMoreData.fromPacket(packet);
+		if (connection.config.authSwitchHandler) {
+			const legacySwitchHandler = connection.config.authSwitchHandler;
+			warnLegacyAuthSwitch();
+			legacySwitchHandler({ pluginData: data }, (err, data$1) => {
+				if (err) return authSwitchPluginError(err, command);
+				connection.writePacket(new Packets$10.AuthSwitchResponse(data$1).toPacket());
+			});
+			return;
+		}
+		if (!connection._authPlugin) throw new Error("AuthPluginMoreData received but no auth plugin instance found");
+		Promise.resolve(connection._authPlugin(data)).then((data$1) => {
+			if (data$1) connection.writePacket(new Packets$10.AuthSwitchResponse(data$1).toPacket());
+		}).catch((err) => {
+			authSwitchPluginError(err, command);
+		});
+	}
+	module.exports = {
+		authSwitchRequest,
+		authSwitchRequestMoreData
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/seq-queue@0.0.5/node_modules/seq-queue/lib/seq-queue.js
+var require_seq_queue$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/seq-queue@0.0.5/node_modules/seq-queue/lib/seq-queue.js": ((exports, module) => {
+	var EventEmitter$6 = __require("events").EventEmitter;
+	var util$1 = __require("util");
+	var DEFAULT_TIMEOUT = 3e3;
+	var INIT_ID = 0;
+	var EVENT_CLOSED = "closed";
+	var EVENT_DRAINED = "drained";
+	/**
+	* Instance a new queue
+	*
+	* @param {Number} timeout a global timeout for new queue
+	* @class
+	* @constructor
+	*/
+	var SeqQueue = function(timeout) {
+		EventEmitter$6.call(this);
+		if (timeout && timeout > 0) this.timeout = timeout;
+		else this.timeout = DEFAULT_TIMEOUT;
+		this.status = SeqQueueManager.STATUS_IDLE;
+		this.curId = INIT_ID;
+		this.queue = [];
+	};
+	util$1.inherits(SeqQueue, EventEmitter$6);
+	/**
+	* Add a task into queue.
+	* 
+	* @param fn new request
+	* @param ontimeout callback when task timeout
+	* @param timeout timeout for current request. take the global timeout if this is invalid
+	* @returns true or false
+	*/
+	SeqQueue.prototype.push = function(fn, ontimeout, timeout) {
+		if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) return false;
+		if (typeof fn !== "function") throw new Error("fn should be a function.");
+		this.queue.push({
+			fn,
+			ontimeout,
+			timeout
+		});
+		if (this.status === SeqQueueManager.STATUS_IDLE) {
+			this.status = SeqQueueManager.STATUS_BUSY;
+			var self$1 = this;
+			process.nextTick(function() {
+				self$1._next(self$1.curId);
+			});
+		}
+		return true;
+	};
+	/**
+	* Close queue
+	* 
+	* @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue
+	*/
+	SeqQueue.prototype.close = function(force) {
+		if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) return;
+		if (force) {
+			this.status = SeqQueueManager.STATUS_DRAINED;
+			if (this.timerId) {
+				clearTimeout(this.timerId);
+				this.timerId = void 0;
+			}
+			this.emit(EVENT_DRAINED);
+		} else {
+			this.status = SeqQueueManager.STATUS_CLOSED;
+			this.emit(EVENT_CLOSED);
+		}
+	};
+	/**
+	* Invoke next task
+	* 
+	* @param {String|Number} tid last executed task id
+	* @api private
+	*/
+	SeqQueue.prototype._next = function(tid) {
+		if (tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) return;
+		if (this.timerId) {
+			clearTimeout(this.timerId);
+			this.timerId = void 0;
+		}
+		var task = this.queue.shift();
+		if (!task) {
+			if (this.status === SeqQueueManager.STATUS_BUSY) {
+				this.status = SeqQueueManager.STATUS_IDLE;
+				this.curId++;
+			} else {
+				this.status = SeqQueueManager.STATUS_DRAINED;
+				this.emit(EVENT_DRAINED);
+			}
+			return;
+		}
+		var self$1 = this;
+		task.id = ++this.curId;
+		var timeout = task.timeout > 0 ? task.timeout : this.timeout;
+		timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;
+		this.timerId = setTimeout(function() {
+			process.nextTick(function() {
+				self$1._next(task.id);
+			});
+			self$1.emit("timeout", task);
+			if (task.ontimeout) task.ontimeout();
+		}, timeout);
+		try {
+			task.fn({ done: function() {
+				var res = task.id === self$1.curId;
+				process.nextTick(function() {
+					self$1._next(task.id);
+				});
+				return res;
+			} });
+		} catch (err) {
+			self$1.emit("error", err, task);
+			process.nextTick(function() {
+				self$1._next(task.id);
+			});
+		}
+	};
+	/**
+	* Queue manager.
+	* 
+	* @module
+	*/
+	var SeqQueueManager = module.exports;
+	/**
+	* Queue status: idle, welcome new tasks
+	*
+	* @const
+	* @type {Number}
+	* @memberOf SeqQueueManager
+	*/
+	SeqQueueManager.STATUS_IDLE = 0;
+	/**
+	* Queue status: busy, queue is working for some tasks now
+	*
+	* @const
+	* @type {Number}
+	* @memberOf SeqQueueManager
+	*/
+	SeqQueueManager.STATUS_BUSY = 1;
+	/**
+	* Queue status: closed, queue has closed and would not receive task any more 
+	* 					and is processing the remaining tasks now.
+	*
+	* @const
+	* @type {Number}
+	* @memberOf SeqQueueManager
+	*/
+	SeqQueueManager.STATUS_CLOSED = 2;
+	/**
+	* Queue status: drained, queue is ready to be destroy
+	*
+	* @const
+	* @type {Number}
+	* @memberOf SeqQueueManager
+	*/
+	SeqQueueManager.STATUS_DRAINED = 3;
+	/**
+	* Create Sequence queue
+	* 
+	* @param  {Number} timeout a global timeout for the new queue instance
+	* @return {Object}         new queue instance
+	* @memberOf SeqQueueManager
+	*/
+	SeqQueueManager.createQueue = function(timeout) {
+		return new SeqQueue(timeout);
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/seq-queue@0.0.5/node_modules/seq-queue/index.js
+var require_seq_queue = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/seq-queue@0.0.5/node_modules/seq-queue/index.js": ((exports, module) => {
+	module.exports = require_seq_queue$1();
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/compressed_protocol.js
+var require_compressed_protocol = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/compressed_protocol.js": ((exports, module) => {
+	const zlib = __require("zlib");
+	const PacketParser$1 = require_packet_parser();
+	function handleCompressedPacket(packet) {
+		const connection = this;
+		const deflatedLength = packet.readInt24();
+		const body = packet.readBuffer();
+		if (deflatedLength !== 0) connection.inflateQueue.push((task) => {
+			zlib.inflate(body, (err, data) => {
+				if (err) {
+					connection._handleNetworkError(err);
+					return;
+				}
+				connection._bumpCompressedSequenceId(packet.numPackets);
+				connection._inflatedPacketsParser.execute(data);
+				task.done();
+			});
+		});
+		else connection.inflateQueue.push((task) => {
+			connection._bumpCompressedSequenceId(packet.numPackets);
+			connection._inflatedPacketsParser.execute(body);
+			task.done();
+		});
+	}
+	function writeCompressed(buffer$1) {
+		const MAX_COMPRESSED_LENGTH = 16777210;
+		let start;
+		if (buffer$1.length > MAX_COMPRESSED_LENGTH) {
+			for (start = 0; start < buffer$1.length; start += MAX_COMPRESSED_LENGTH) writeCompressed.call(this, buffer$1.slice(start, start + MAX_COMPRESSED_LENGTH));
+			return;
+		}
+		const connection = this;
+		let packetLen = buffer$1.length;
+		const compressHeader = Buffer.allocUnsafe(7);
+		(function(seqId) {
+			connection.deflateQueue.push((task) => {
+				zlib.deflate(buffer$1, (err, compressed) => {
+					if (err) {
+						connection._handleFatalError(err);
+						return;
+					}
+					let compressedLength = compressed.length;
+					if (compressedLength < packetLen) {
+						compressHeader.writeUInt8(compressedLength & 255, 0);
+						compressHeader.writeUInt16LE(compressedLength >> 8, 1);
+						compressHeader.writeUInt8(seqId, 3);
+						compressHeader.writeUInt8(packetLen & 255, 4);
+						compressHeader.writeUInt16LE(packetLen >> 8, 5);
+						connection.writeUncompressed(compressHeader);
+						connection.writeUncompressed(compressed);
+					} else {
+						compressedLength = packetLen;
+						packetLen = 0;
+						compressHeader.writeUInt8(compressedLength & 255, 0);
+						compressHeader.writeUInt16LE(compressedLength >> 8, 1);
+						compressHeader.writeUInt8(seqId, 3);
+						compressHeader.writeUInt8(packetLen & 255, 4);
+						compressHeader.writeUInt16LE(packetLen >> 8, 5);
+						connection.writeUncompressed(compressHeader);
+						connection.writeUncompressed(buffer$1);
+					}
+					task.done();
+				});
+			});
+		})(connection.compressedSequenceId);
+		connection._bumpCompressedSequenceId(1);
+	}
+	function enableCompression(connection) {
+		connection._lastWrittenPacketId = 0;
+		connection._lastReceivedPacketId = 0;
+		connection._handleCompressedPacket = handleCompressedPacket;
+		connection._inflatedPacketsParser = new PacketParser$1((p) => {
+			connection.handlePacket(p);
+		}, 4);
+		connection._inflatedPacketsParser._lastPacket = 0;
+		connection.packetParser = new PacketParser$1((packet) => {
+			connection._handleCompressedPacket(packet);
+		}, 7);
+		connection.writeUncompressed = connection.write;
+		connection.write = writeCompressed;
+		const seqqueue = require_seq_queue();
+		connection.inflateQueue = seqqueue.createQueue();
+		connection.deflateQueue = seqqueue.createQueue();
+	}
+	module.exports = { enableCompression };
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/client_handshake.js
+var require_client_handshake = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/client_handshake.js": ((exports, module) => {
+	const Command$10 = require_command();
+	const Packets$9 = require_packets();
+	const ClientConstants$2 = require_client();
+	const CharsetToEncoding$2 = require_charset_encodings();
+	const auth41 = require_auth_41();
+	function flagNames(flags) {
+		const res = [];
+		for (const c in ClientConstants$2) if (flags & ClientConstants$2[c]) res.push(c.replace(/_/g, " ").toLowerCase());
+		return res;
+	}
+	var ClientHandshake$2 = class ClientHandshake$2 extends Command$10 {
+		constructor(clientFlags) {
+			super();
+			this.handshake = null;
+			this.clientFlags = clientFlags;
+			this.authenticationFactor = 0;
+		}
+		start() {
+			return ClientHandshake$2.prototype.handshakeInit;
+		}
+		sendSSLRequest(connection) {
+			const sslRequest = new Packets$9.SSLRequest(this.clientFlags, connection.config.charsetNumber);
+			connection.writePacket(sslRequest.toPacket());
+		}
+		sendCredentials(connection) {
+			if (connection.config.debug) console.log("Sending handshake packet: flags:%d=(%s)", this.clientFlags, flagNames(this.clientFlags).join(", "));
+			this.user = connection.config.user;
+			this.password = connection.config.password;
+			this.password1 = connection.config.password;
+			this.password2 = connection.config.password2;
+			this.password3 = connection.config.password3;
+			this.passwordSha1 = connection.config.passwordSha1;
+			this.database = connection.config.database;
+			this.authPluginName = this.handshake.authPluginName;
+			const handshakeResponse = new Packets$9.HandshakeResponse({
+				flags: this.clientFlags,
+				user: this.user,
+				database: this.database,
+				password: this.password,
+				passwordSha1: this.passwordSha1,
+				charsetNumber: connection.config.charsetNumber,
+				authPluginData1: this.handshake.authPluginData1,
+				authPluginData2: this.handshake.authPluginData2,
+				compress: connection.config.compress,
+				connectAttributes: connection.config.connectAttributes
+			});
+			connection.writePacket(handshakeResponse.toPacket());
+		}
+		calculateNativePasswordAuthToken(authPluginData) {
+			const authPluginData1 = authPluginData.slice(0, 8);
+			const authPluginData2 = authPluginData.slice(8, 20);
+			let authToken;
+			if (this.passwordSha1) authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, authPluginData1, authPluginData2);
+			else authToken = auth41.calculateToken(this.password, authPluginData1, authPluginData2);
+			return authToken;
+		}
+		handshakeInit(helloPacket, connection) {
+			this.on("error", (e) => {
+				connection._fatalError = e;
+				connection._protocolError = e;
+			});
+			this.handshake = Packets$9.Handshake.fromPacket(helloPacket);
+			if (connection.config.debug) console.log("Server hello packet: capability flags:%d=(%s)", this.handshake.capabilityFlags, flagNames(this.handshake.capabilityFlags).join(", "));
+			connection.serverCapabilityFlags = this.handshake.capabilityFlags;
+			connection.serverEncoding = CharsetToEncoding$2[this.handshake.characterSet];
+			connection.connectionId = this.handshake.connectionId;
+			const serverSSLSupport = this.handshake.capabilityFlags & ClientConstants$2.SSL;
+			const multiFactorAuthentication = this.handshake.capabilityFlags & ClientConstants$2.MULTI_FACTOR_AUTHENTICATION;
+			this.clientFlags = this.clientFlags | multiFactorAuthentication;
+			connection.config.compress = connection.config.compress && this.handshake.capabilityFlags & ClientConstants$2.COMPRESS;
+			this.clientFlags = this.clientFlags | connection.config.compress;
+			if (connection.config.ssl) {
+				if (!serverSSLSupport) {
+					const err = /* @__PURE__ */ new Error("Server does not support secure connection");
+					err.code = "HANDSHAKE_NO_SSL_SUPPORT";
+					err.fatal = true;
+					this.emit("error", err);
+					return false;
+				}
+				this.clientFlags |= ClientConstants$2.SSL;
+				this.sendSSLRequest(connection);
+				connection.startTLS((err) => {
+					if (err) {
+						err.code = "HANDSHAKE_SSL_ERROR";
+						err.fatal = true;
+						this.emit("error", err);
+						return;
+					}
+					this.sendCredentials(connection);
+				});
+			} else this.sendCredentials(connection);
+			if (multiFactorAuthentication) this.authenticationFactor = 1;
+			return ClientHandshake$2.prototype.handshakeResult;
+		}
+		handshakeResult(packet, connection) {
+			const marker = packet.peekByte();
+			if (marker === 254 || marker === 1 || marker === 2) {
+				const authSwitch = require_auth_switch();
+				try {
+					if (marker === 1) authSwitch.authSwitchRequestMoreData(packet, connection, this);
+					else {
+						if (this.authenticationFactor !== 0) {
+							connection.config.password = this[`password${this.authenticationFactor}`];
+							this.authenticationFactor += 1;
+						}
+						authSwitch.authSwitchRequest(packet, connection, this);
+					}
+					return ClientHandshake$2.prototype.handshakeResult;
+				} catch (err) {
+					err.code = "AUTH_SWITCH_PLUGIN_ERROR";
+					err.fatal = true;
+					if (this.onResult) this.onResult(err);
+					else this.emit("error", err);
+					return null;
+				}
+			}
+			if (marker !== 0) {
+				const err = /* @__PURE__ */ new Error("Unexpected packet during handshake phase");
+				err.code = "HANDSHAKE_UNKNOWN_ERROR";
+				err.fatal = true;
+				if (this.onResult) this.onResult(err);
+				else this.emit("error", err);
+				return null;
+			}
+			if (!connection.authorized) {
+				connection.authorized = true;
+				if (connection.config.compress) {
+					const enableCompression$1 = require_compressed_protocol().enableCompression;
+					enableCompression$1(connection);
+				}
+			}
+			if (this.onResult) this.onResult(null);
+			return null;
+		}
+	};
+	module.exports = ClientHandshake$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/server_handshake.js
+var require_server_handshake = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/server_handshake.js": ((exports, module) => {
+	const CommandCode$2 = require_commands$1();
+	const Errors = require_errors();
+	const Command$9 = require_command();
+	const Packets$8 = require_packets();
+	var ServerHandshake$1 = class ServerHandshake$1 extends Command$9 {
+		constructor(args) {
+			super();
+			this.args = args;
+		}
+		start(packet, connection) {
+			const serverHelloPacket = new Packets$8.Handshake(this.args);
+			this.serverHello = serverHelloPacket;
+			serverHelloPacket.setScrambleData((err) => {
+				if (err) {
+					connection.emit("error", /* @__PURE__ */ new Error("Error generating random bytes"));
+					return;
+				}
+				connection.writePacket(serverHelloPacket.toPacket(0));
+			});
+			return ServerHandshake$1.prototype.readClientReply;
+		}
+		readClientReply(packet, connection) {
+			const clientHelloReply = Packets$8.HandshakeResponse.fromPacket(packet);
+			connection.clientHelloReply = clientHelloReply;
+			if (this.args.authCallback) this.args.authCallback({
+				user: clientHelloReply.user,
+				database: clientHelloReply.database,
+				address: connection.stream.remoteAddress,
+				authPluginData1: this.serverHello.authPluginData1,
+				authPluginData2: this.serverHello.authPluginData2,
+				authToken: clientHelloReply.authToken
+			}, (err, mysqlError) => {
+				if (!mysqlError) connection.writeOk();
+				else {
+					connection.writeError({
+						message: mysqlError.message || "",
+						code: mysqlError.code || 1045
+					});
+					connection.close();
+				}
+			});
+			else connection.writeOk();
+			return ServerHandshake$1.prototype.dispatchCommands;
+		}
+		_isStatement(query, name) {
+			return query.split(" ")[0].toUpperCase() === name;
+		}
+		dispatchCommands(packet, connection) {
+			let knownCommand = true;
+			const encoding = connection.clientHelloReply.encoding;
+			const commandCode = packet.readInt8();
+			switch (commandCode) {
+				case CommandCode$2.STMT_PREPARE:
+					if (connection.listeners("stmt_prepare").length) {
+						const query = packet.readString(void 0, encoding);
+						connection.emit("stmt_prepare", query);
+					} else connection.writeError({
+						code: Errors.HA_ERR_INTERNAL_ERROR,
+						message: "No query handler for prepared statements."
+					});
+					break;
+				case CommandCode$2.STMT_EXECUTE:
+					if (connection.listeners("stmt_execute").length) {
+						const { stmtId, flags, iterationCount, values } = Packets$8.Execute.fromPacket(packet, encoding);
+						connection.emit("stmt_execute", stmtId, flags, iterationCount, values);
+					} else connection.writeError({
+						code: Errors.HA_ERR_INTERNAL_ERROR,
+						message: "No query handler for execute statements."
+					});
+					break;
+				case CommandCode$2.QUIT:
+					if (connection.listeners("quit").length) connection.emit("quit");
+					else connection.stream.end();
+					break;
+				case CommandCode$2.INIT_DB:
+					if (connection.listeners("init_db").length) {
+						const schemaName = packet.readString(void 0, encoding);
+						connection.emit("init_db", schemaName);
+					} else connection.writeOk();
+					break;
+				case CommandCode$2.QUERY:
+					if (connection.listeners("query").length) {
+						const query = packet.readString(void 0, encoding);
+						if (this._isStatement(query, "PREPARE") || this._isStatement(query, "SET")) connection.emit("stmt_prepare", query);
+						else if (this._isStatement(query, "EXECUTE")) connection.emit("stmt_execute", null, null, null, null, query);
+						else connection.emit("query", query);
+					} else connection.writeError({
+						code: Errors.HA_ERR_INTERNAL_ERROR,
+						message: "No query handler"
+					});
+					break;
+				case CommandCode$2.FIELD_LIST:
+					if (connection.listeners("field_list").length) {
+						const table = packet.readNullTerminatedString(encoding);
+						const fields$1 = packet.readString(void 0, encoding);
+						connection.emit("field_list", table, fields$1);
+					} else connection.writeError({
+						code: Errors.ER_WARN_DEPRECATED_SYNTAX,
+						message: "As of MySQL 5.7.11, COM_FIELD_LIST is deprecated and will be removed in a future version of MySQL."
+					});
+					break;
+				case CommandCode$2.PING:
+					if (connection.listeners("ping").length) connection.emit("ping");
+					else connection.writeOk();
+					break;
+				default: knownCommand = false;
+			}
+			if (connection.listeners("packet").length) connection.emit("packet", packet.clone(), knownCommand, commandCode);
+			else if (!knownCommand) console.log("Unknown command:", commandCode);
+			return ServerHandshake$1.prototype.dispatchCommands;
+		}
+	};
+	module.exports = ServerHandshake$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/charsets.js
+var require_charsets = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/charsets.js": ((exports) => {
+	exports.BIG5_CHINESE_CI = 1;
+	exports.LATIN2_CZECH_CS = 2;
+	exports.DEC8_SWEDISH_CI = 3;
+	exports.CP850_GENERAL_CI = 4;
+	exports.LATIN1_GERMAN1_CI = 5;
+	exports.HP8_ENGLISH_CI = 6;
+	exports.KOI8R_GENERAL_CI = 7;
+	exports.LATIN1_SWEDISH_CI = 8;
+	exports.LATIN2_GENERAL_CI = 9;
+	exports.SWE7_SWEDISH_CI = 10;
+	exports.ASCII_GENERAL_CI = 11;
+	exports.UJIS_JAPANESE_CI = 12;
+	exports.SJIS_JAPANESE_CI = 13;
+	exports.CP1251_BULGARIAN_CI = 14;
+	exports.LATIN1_DANISH_CI = 15;
+	exports.HEBREW_GENERAL_CI = 16;
+	exports.TIS620_THAI_CI = 18;
+	exports.EUCKR_KOREAN_CI = 19;
+	exports.LATIN7_ESTONIAN_CS = 20;
+	exports.LATIN2_HUNGARIAN_CI = 21;
+	exports.KOI8U_GENERAL_CI = 22;
+	exports.CP1251_UKRAINIAN_CI = 23;
+	exports.GB2312_CHINESE_CI = 24;
+	exports.GREEK_GENERAL_CI = 25;
+	exports.CP1250_GENERAL_CI = 26;
+	exports.LATIN2_CROATIAN_CI = 27;
+	exports.GBK_CHINESE_CI = 28;
+	exports.CP1257_LITHUANIAN_CI = 29;
+	exports.LATIN5_TURKISH_CI = 30;
+	exports.LATIN1_GERMAN2_CI = 31;
+	exports.ARMSCII8_GENERAL_CI = 32;
+	exports.UTF8_GENERAL_CI = 33;
+	exports.CP1250_CZECH_CS = 34;
+	exports.UCS2_GENERAL_CI = 35;
+	exports.CP866_GENERAL_CI = 36;
+	exports.KEYBCS2_GENERAL_CI = 37;
+	exports.MACCE_GENERAL_CI = 38;
+	exports.MACROMAN_GENERAL_CI = 39;
+	exports.CP852_GENERAL_CI = 40;
+	exports.LATIN7_GENERAL_CI = 41;
+	exports.LATIN7_GENERAL_CS = 42;
+	exports.MACCE_BIN = 43;
+	exports.CP1250_CROATIAN_CI = 44;
+	exports.UTF8MB4_GENERAL_CI = 45;
+	exports.UTF8MB4_BIN = 46;
+	exports.LATIN1_BIN = 47;
+	exports.LATIN1_GENERAL_CI = 48;
+	exports.LATIN1_GENERAL_CS = 49;
+	exports.CP1251_BIN = 50;
+	exports.CP1251_GENERAL_CI = 51;
+	exports.CP1251_GENERAL_CS = 52;
+	exports.MACROMAN_BIN = 53;
+	exports.UTF16_GENERAL_CI = 54;
+	exports.UTF16_BIN = 55;
+	exports.UTF16LE_GENERAL_CI = 56;
+	exports.CP1256_GENERAL_CI = 57;
+	exports.CP1257_BIN = 58;
+	exports.CP1257_GENERAL_CI = 59;
+	exports.UTF32_GENERAL_CI = 60;
+	exports.UTF32_BIN = 61;
+	exports.UTF16LE_BIN = 62;
+	exports.BINARY = 63;
+	exports.ARMSCII8_BIN = 64;
+	exports.ASCII_BIN = 65;
+	exports.CP1250_BIN = 66;
+	exports.CP1256_BIN = 67;
+	exports.CP866_BIN = 68;
+	exports.DEC8_BIN = 69;
+	exports.GREEK_BIN = 70;
+	exports.HEBREW_BIN = 71;
+	exports.HP8_BIN = 72;
+	exports.KEYBCS2_BIN = 73;
+	exports.KOI8R_BIN = 74;
+	exports.KOI8U_BIN = 75;
+	exports.UTF8_TOLOWER_CI = 76;
+	exports.LATIN2_BIN = 77;
+	exports.LATIN5_BIN = 78;
+	exports.LATIN7_BIN = 79;
+	exports.CP850_BIN = 80;
+	exports.CP852_BIN = 81;
+	exports.SWE7_BIN = 82;
+	exports.UTF8_BIN = 83;
+	exports.BIG5_BIN = 84;
+	exports.EUCKR_BIN = 85;
+	exports.GB2312_BIN = 86;
+	exports.GBK_BIN = 87;
+	exports.SJIS_BIN = 88;
+	exports.TIS620_BIN = 89;
+	exports.UCS2_BIN = 90;
+	exports.UJIS_BIN = 91;
+	exports.GEOSTD8_GENERAL_CI = 92;
+	exports.GEOSTD8_BIN = 93;
+	exports.LATIN1_SPANISH_CI = 94;
+	exports.CP932_JAPANESE_CI = 95;
+	exports.CP932_BIN = 96;
+	exports.EUCJPMS_JAPANESE_CI = 97;
+	exports.EUCJPMS_BIN = 98;
+	exports.CP1250_POLISH_CI = 99;
+	exports.UTF16_UNICODE_CI = 101;
+	exports.UTF16_ICELANDIC_CI = 102;
+	exports.UTF16_LATVIAN_CI = 103;
+	exports.UTF16_ROMANIAN_CI = 104;
+	exports.UTF16_SLOVENIAN_CI = 105;
+	exports.UTF16_POLISH_CI = 106;
+	exports.UTF16_ESTONIAN_CI = 107;
+	exports.UTF16_SPANISH_CI = 108;
+	exports.UTF16_SWEDISH_CI = 109;
+	exports.UTF16_TURKISH_CI = 110;
+	exports.UTF16_CZECH_CI = 111;
+	exports.UTF16_DANISH_CI = 112;
+	exports.UTF16_LITHUANIAN_CI = 113;
+	exports.UTF16_SLOVAK_CI = 114;
+	exports.UTF16_SPANISH2_CI = 115;
+	exports.UTF16_ROMAN_CI = 116;
+	exports.UTF16_PERSIAN_CI = 117;
+	exports.UTF16_ESPERANTO_CI = 118;
+	exports.UTF16_HUNGARIAN_CI = 119;
+	exports.UTF16_SINHALA_CI = 120;
+	exports.UTF16_GERMAN2_CI = 121;
+	exports.UTF16_CROATIAN_CI = 122;
+	exports.UTF16_UNICODE_520_CI = 123;
+	exports.UTF16_VIETNAMESE_CI = 124;
+	exports.UCS2_UNICODE_CI = 128;
+	exports.UCS2_ICELANDIC_CI = 129;
+	exports.UCS2_LATVIAN_CI = 130;
+	exports.UCS2_ROMANIAN_CI = 131;
+	exports.UCS2_SLOVENIAN_CI = 132;
+	exports.UCS2_POLISH_CI = 133;
+	exports.UCS2_ESTONIAN_CI = 134;
+	exports.UCS2_SPANISH_CI = 135;
+	exports.UCS2_SWEDISH_CI = 136;
+	exports.UCS2_TURKISH_CI = 137;
+	exports.UCS2_CZECH_CI = 138;
+	exports.UCS2_DANISH_CI = 139;
+	exports.UCS2_LITHUANIAN_CI = 140;
+	exports.UCS2_SLOVAK_CI = 141;
+	exports.UCS2_SPANISH2_CI = 142;
+	exports.UCS2_ROMAN_CI = 143;
+	exports.UCS2_PERSIAN_CI = 144;
+	exports.UCS2_ESPERANTO_CI = 145;
+	exports.UCS2_HUNGARIAN_CI = 146;
+	exports.UCS2_SINHALA_CI = 147;
+	exports.UCS2_GERMAN2_CI = 148;
+	exports.UCS2_CROATIAN_CI = 149;
+	exports.UCS2_UNICODE_520_CI = 150;
+	exports.UCS2_VIETNAMESE_CI = 151;
+	exports.UCS2_GENERAL_MYSQL500_CI = 159;
+	exports.UTF32_UNICODE_CI = 160;
+	exports.UTF32_ICELANDIC_CI = 161;
+	exports.UTF32_LATVIAN_CI = 162;
+	exports.UTF32_ROMANIAN_CI = 163;
+	exports.UTF32_SLOVENIAN_CI = 164;
+	exports.UTF32_POLISH_CI = 165;
+	exports.UTF32_ESTONIAN_CI = 166;
+	exports.UTF32_SPANISH_CI = 167;
+	exports.UTF32_SWEDISH_CI = 168;
+	exports.UTF32_TURKISH_CI = 169;
+	exports.UTF32_CZECH_CI = 170;
+	exports.UTF32_DANISH_CI = 171;
+	exports.UTF32_LITHUANIAN_CI = 172;
+	exports.UTF32_SLOVAK_CI = 173;
+	exports.UTF32_SPANISH2_CI = 174;
+	exports.UTF32_ROMAN_CI = 175;
+	exports.UTF32_PERSIAN_CI = 176;
+	exports.UTF32_ESPERANTO_CI = 177;
+	exports.UTF32_HUNGARIAN_CI = 178;
+	exports.UTF32_SINHALA_CI = 179;
+	exports.UTF32_GERMAN2_CI = 180;
+	exports.UTF32_CROATIAN_CI = 181;
+	exports.UTF32_UNICODE_520_CI = 182;
+	exports.UTF32_VIETNAMESE_CI = 183;
+	exports.UTF8_UNICODE_CI = 192;
+	exports.UTF8_ICELANDIC_CI = 193;
+	exports.UTF8_LATVIAN_CI = 194;
+	exports.UTF8_ROMANIAN_CI = 195;
+	exports.UTF8_SLOVENIAN_CI = 196;
+	exports.UTF8_POLISH_CI = 197;
+	exports.UTF8_ESTONIAN_CI = 198;
+	exports.UTF8_SPANISH_CI = 199;
+	exports.UTF8_SWEDISH_CI = 200;
+	exports.UTF8_TURKISH_CI = 201;
+	exports.UTF8_CZECH_CI = 202;
+	exports.UTF8_DANISH_CI = 203;
+	exports.UTF8_LITHUANIAN_CI = 204;
+	exports.UTF8_SLOVAK_CI = 205;
+	exports.UTF8_SPANISH2_CI = 206;
+	exports.UTF8_ROMAN_CI = 207;
+	exports.UTF8_PERSIAN_CI = 208;
+	exports.UTF8_ESPERANTO_CI = 209;
+	exports.UTF8_HUNGARIAN_CI = 210;
+	exports.UTF8_SINHALA_CI = 211;
+	exports.UTF8_GERMAN2_CI = 212;
+	exports.UTF8_CROATIAN_CI = 213;
+	exports.UTF8_UNICODE_520_CI = 214;
+	exports.UTF8_VIETNAMESE_CI = 215;
+	exports.UTF8_GENERAL_MYSQL500_CI = 223;
+	exports.UTF8MB4_UNICODE_CI = 224;
+	exports.UTF8MB4_ICELANDIC_CI = 225;
+	exports.UTF8MB4_LATVIAN_CI = 226;
+	exports.UTF8MB4_ROMANIAN_CI = 227;
+	exports.UTF8MB4_SLOVENIAN_CI = 228;
+	exports.UTF8MB4_POLISH_CI = 229;
+	exports.UTF8MB4_ESTONIAN_CI = 230;
+	exports.UTF8MB4_SPANISH_CI = 231;
+	exports.UTF8MB4_SWEDISH_CI = 232;
+	exports.UTF8MB4_TURKISH_CI = 233;
+	exports.UTF8MB4_CZECH_CI = 234;
+	exports.UTF8MB4_DANISH_CI = 235;
+	exports.UTF8MB4_LITHUANIAN_CI = 236;
+	exports.UTF8MB4_SLOVAK_CI = 237;
+	exports.UTF8MB4_SPANISH2_CI = 238;
+	exports.UTF8MB4_ROMAN_CI = 239;
+	exports.UTF8MB4_PERSIAN_CI = 240;
+	exports.UTF8MB4_ESPERANTO_CI = 241;
+	exports.UTF8MB4_HUNGARIAN_CI = 242;
+	exports.UTF8MB4_SINHALA_CI = 243;
+	exports.UTF8MB4_GERMAN2_CI = 244;
+	exports.UTF8MB4_CROATIAN_CI = 245;
+	exports.UTF8MB4_UNICODE_520_CI = 246;
+	exports.UTF8MB4_VIETNAMESE_CI = 247;
+	exports.GB18030_CHINESE_CI = 248;
+	exports.GB18030_BIN = 249;
+	exports.GB18030_UNICODE_520_CI = 250;
+	exports.UTF8_GENERAL50_CI = 253;
+	exports.UTF8MB4_0900_AI_CI = 255;
+	exports.UTF8MB4_DE_PB_0900_AI_CI = 256;
+	exports.UTF8MB4_IS_0900_AI_CI = 257;
+	exports.UTF8MB4_LV_0900_AI_CI = 258;
+	exports.UTF8MB4_RO_0900_AI_CI = 259;
+	exports.UTF8MB4_SL_0900_AI_CI = 260;
+	exports.UTF8MB4_PL_0900_AI_CI = 261;
+	exports.UTF8MB4_ET_0900_AI_CI = 262;
+	exports.UTF8MB4_ES_0900_AI_CI = 263;
+	exports.UTF8MB4_SV_0900_AI_CI = 264;
+	exports.UTF8MB4_TR_0900_AI_CI = 265;
+	exports.UTF8MB4_CS_0900_AI_CI = 266;
+	exports.UTF8MB4_DA_0900_AI_CI = 267;
+	exports.UTF8MB4_LT_0900_AI_CI = 268;
+	exports.UTF8MB4_SK_0900_AI_CI = 269;
+	exports.UTF8MB4_ES_TRAD_0900_AI_CI = 270;
+	exports.UTF8MB4_LA_0900_AI_CI = 271;
+	exports.UTF8MB4_EO_0900_AI_CI = 273;
+	exports.UTF8MB4_HU_0900_AI_CI = 274;
+	exports.UTF8MB4_HR_0900_AI_CI = 275;
+	exports.UTF8MB4_VI_0900_AI_CI = 277;
+	exports.UTF8MB4_0900_AS_CS = 278;
+	exports.UTF8MB4_DE_PB_0900_AS_CS = 279;
+	exports.UTF8MB4_IS_0900_AS_CS = 280;
+	exports.UTF8MB4_LV_0900_AS_CS = 281;
+	exports.UTF8MB4_RO_0900_AS_CS = 282;
+	exports.UTF8MB4_SL_0900_AS_CS = 283;
+	exports.UTF8MB4_PL_0900_AS_CS = 284;
+	exports.UTF8MB4_ET_0900_AS_CS = 285;
+	exports.UTF8MB4_ES_0900_AS_CS = 286;
+	exports.UTF8MB4_SV_0900_AS_CS = 287;
+	exports.UTF8MB4_TR_0900_AS_CS = 288;
+	exports.UTF8MB4_CS_0900_AS_CS = 289;
+	exports.UTF8MB4_DA_0900_AS_CS = 290;
+	exports.UTF8MB4_LT_0900_AS_CS = 291;
+	exports.UTF8MB4_SK_0900_AS_CS = 292;
+	exports.UTF8MB4_ES_TRAD_0900_AS_CS = 293;
+	exports.UTF8MB4_LA_0900_AS_CS = 294;
+	exports.UTF8MB4_EO_0900_AS_CS = 296;
+	exports.UTF8MB4_HU_0900_AS_CS = 297;
+	exports.UTF8MB4_HR_0900_AS_CS = 298;
+	exports.UTF8MB4_VI_0900_AS_CS = 300;
+	exports.UTF8MB4_JA_0900_AS_CS = 303;
+	exports.UTF8MB4_JA_0900_AS_CS_KS = 304;
+	exports.UTF8MB4_0900_AS_CI = 305;
+	exports.UTF8MB4_RU_0900_AI_CI = 306;
+	exports.UTF8MB4_RU_0900_AS_CS = 307;
+	exports.UTF8MB4_ZH_0900_AS_CS = 308;
+	exports.UTF8MB4_0900_BIN = 309;
+	exports.BIG5 = exports.BIG5_CHINESE_CI;
+	exports.DEC8 = exports.DEC8_SWEDISH_CI;
+	exports.CP850 = exports.CP850_GENERAL_CI;
+	exports.HP8 = exports.HP8_ENGLISH_CI;
+	exports.KOI8R = exports.KOI8R_GENERAL_CI;
+	exports.LATIN1 = exports.LATIN1_SWEDISH_CI;
+	exports.LATIN2 = exports.LATIN2_GENERAL_CI;
+	exports.SWE7 = exports.SWE7_SWEDISH_CI;
+	exports.ASCII = exports.ASCII_GENERAL_CI;
+	exports.UJIS = exports.UJIS_JAPANESE_CI;
+	exports.SJIS = exports.SJIS_JAPANESE_CI;
+	exports.HEBREW = exports.HEBREW_GENERAL_CI;
+	exports.TIS620 = exports.TIS620_THAI_CI;
+	exports.EUCKR = exports.EUCKR_KOREAN_CI;
+	exports.KOI8U = exports.KOI8U_GENERAL_CI;
+	exports.GB2312 = exports.GB2312_CHINESE_CI;
+	exports.GREEK = exports.GREEK_GENERAL_CI;
+	exports.CP1250 = exports.CP1250_GENERAL_CI;
+	exports.GBK = exports.GBK_CHINESE_CI;
+	exports.LATIN5 = exports.LATIN5_TURKISH_CI;
+	exports.ARMSCII8 = exports.ARMSCII8_GENERAL_CI;
+	exports.UTF8 = exports.UTF8_GENERAL_CI;
+	exports.UCS2 = exports.UCS2_GENERAL_CI;
+	exports.CP866 = exports.CP866_GENERAL_CI;
+	exports.KEYBCS2 = exports.KEYBCS2_GENERAL_CI;
+	exports.MACCE = exports.MACCE_GENERAL_CI;
+	exports.MACROMAN = exports.MACROMAN_GENERAL_CI;
+	exports.CP852 = exports.CP852_GENERAL_CI;
+	exports.LATIN7 = exports.LATIN7_GENERAL_CI;
+	exports.UTF8MB4 = exports.UTF8MB4_GENERAL_CI;
+	exports.CP1251 = exports.CP1251_GENERAL_CI;
+	exports.UTF16 = exports.UTF16_GENERAL_CI;
+	exports.UTF16LE = exports.UTF16LE_GENERAL_CI;
+	exports.CP1256 = exports.CP1256_GENERAL_CI;
+	exports.CP1257 = exports.CP1257_GENERAL_CI;
+	exports.UTF32 = exports.UTF32_GENERAL_CI;
+	exports.CP932 = exports.CP932_JAPANESE_CI;
+	exports.EUCJPMS = exports.EUCJPMS_JAPANESE_CI;
+	exports.GB18030 = exports.GB18030_CHINESE_CI;
+	exports.GEOSTD8 = exports.GEOSTD8_GENERAL_CI;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/helpers.js
+var require_helpers = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/helpers.js": ((exports) => {
+	function srcEscape(str) {
+		return JSON.stringify({ [str]: 1 }).slice(1, -3);
+	}
+	exports.srcEscape = srcEscape;
+	let highlightFn;
+	let cardinalRecommended = false;
+	try {
+		highlightFn = __require("cardinal").highlight;
+	} catch (err) {
+		highlightFn = (text) => {
+			if (!cardinalRecommended) {
+				console.log("For nicer debug output consider install cardinal@^2.0.0");
+				cardinalRecommended = true;
+			}
+			return text;
+		};
+	}
+	/**
+	* Prints debug message with code frame, will try to use `cardinal` if available.
+	*/
+	function printDebugWithCode(msg, code) {
+		console.log(`\n\n${msg}:\n`);
+		console.log(`${highlightFn(code)}\n`);
+	}
+	exports.printDebugWithCode = printDebugWithCode;
+	/**
+	* checks whether the `type` is in the `list`
+	*/
+	function typeMatch(type, list, Types$7) {
+		if (Array.isArray(list)) return list.some((t) => type === Types$7[t]);
+		return !!list;
+	}
+	exports.typeMatch = typeMatch;
+	const privateObjectProps = new Set([
+		"__defineGetter__",
+		"__defineSetter__",
+		"__lookupGetter__",
+		"__lookupSetter__",
+		"__proto__"
+	]);
+	exports.privateObjectProps = privateObjectProps;
+	const fieldEscape = (field, isEval = true) => {
+		if (privateObjectProps.has(field)) throw new Error(`The field name (${field}) can't be the same as an object's private property.`);
+		return isEval ? srcEscape(field) : field;
+	};
+	exports.fieldEscape = fieldEscape;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/is-property@1.0.2/node_modules/is-property/is-property.js
+var require_is_property = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/is-property@1.0.2/node_modules/is-property/is-property.js": ((exports, module) => {
+	function isProperty$1(str) {
+		return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str);
+	}
+	module.exports = isProperty$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/generate-function@2.3.1/node_modules/generate-function/index.js
+var require_generate_function = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/generate-function@2.3.1/node_modules/generate-function/index.js": ((exports, module) => {
+	var util = __require("util");
+	var isProperty = require_is_property();
+	var INDENT_START = /[\{\[]/;
+	var INDENT_END = /[\}\]]/;
+	var RESERVED = [
+		"do",
+		"if",
+		"in",
+		"for",
+		"let",
+		"new",
+		"try",
+		"var",
+		"case",
+		"else",
+		"enum",
+		"eval",
+		"null",
+		"this",
+		"true",
+		"void",
+		"with",
+		"await",
+		"break",
+		"catch",
+		"class",
+		"const",
+		"false",
+		"super",
+		"throw",
+		"while",
+		"yield",
+		"delete",
+		"export",
+		"import",
+		"public",
+		"return",
+		"static",
+		"switch",
+		"typeof",
+		"default",
+		"extends",
+		"finally",
+		"package",
+		"private",
+		"continue",
+		"debugger",
+		"function",
+		"arguments",
+		"interface",
+		"protected",
+		"implements",
+		"instanceof",
+		"NaN",
+		"undefined"
+	];
+	var RESERVED_MAP = {};
+	for (var i = 0; i < RESERVED.length; i++) RESERVED_MAP[RESERVED[i]] = true;
+	var isVariable = function(name) {
+		return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name);
+	};
+	var formats = {
+		s: function(s) {
+			return "" + s;
+		},
+		d: function(d) {
+			return "" + Number(d);
+		},
+		o: function(o) {
+			return JSON.stringify(o);
+		}
+	};
+	var genfun = function() {
+		var lines = [];
+		var indent = 0;
+		var vars = {};
+		var push = function(str) {
+			var spaces = "";
+			while (spaces.length < indent * 2) spaces += "  ";
+			lines.push(spaces + str);
+		};
+		var pushLine = function(line$1) {
+			if (INDENT_END.test(line$1.trim()[0]) && INDENT_START.test(line$1[line$1.length - 1])) {
+				indent--;
+				push(line$1);
+				indent++;
+				return;
+			}
+			if (INDENT_START.test(line$1[line$1.length - 1])) {
+				push(line$1);
+				indent++;
+				return;
+			}
+			if (INDENT_END.test(line$1.trim()[0])) {
+				indent--;
+				push(line$1);
+				return;
+			}
+			push(line$1);
+		};
+		var line = function(fmt) {
+			if (!fmt) return line;
+			if (arguments.length === 1 && fmt.indexOf("\n") > -1) {
+				var lines$1 = fmt.trim().split("\n");
+				for (var i$4 = 0; i$4 < lines$1.length; i$4++) pushLine(lines$1[i$4].trim());
+			} else pushLine(util.format.apply(util, arguments));
+			return line;
+		};
+		line.scope = {};
+		line.formats = formats;
+		line.sym = function(name) {
+			if (!name || !isVariable(name)) name = "tmp";
+			if (!vars[name]) vars[name] = 0;
+			return name + (vars[name]++ || "");
+		};
+		line.property = function(obj, name) {
+			if (arguments.length === 1) {
+				name = obj;
+				obj = "";
+			}
+			name = name + "";
+			if (isProperty(name)) return obj ? obj + "." + name : name;
+			return obj ? obj + "[" + JSON.stringify(name) + "]" : JSON.stringify(name);
+		};
+		line.toString = function() {
+			return lines.join("\n");
+		};
+		line.toFunction = function(scope) {
+			if (!scope) scope = {};
+			var src = "return (" + line.toString() + ")";
+			Object.keys(line.scope).forEach(function(key$1) {
+				if (!scope[key$1]) scope[key$1] = line.scope[key$1];
+			});
+			var keys$1 = Object.keys(scope).map(function(key$1) {
+				return key$1;
+			});
+			var vals = keys$1.map(function(key$1) {
+				return scope[key$1];
+			});
+			return Function.apply(null, keys$1.concat(src)).apply(null, vals);
+		};
+		if (arguments.length) line.apply(null, arguments);
+		return line;
+	};
+	genfun.formats = formats;
+	module.exports = genfun;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/text_parser.js
+var require_text_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/text_parser.js": ((exports, module) => {
+	const Types$3 = require_types();
+	const Charsets$4 = require_charsets();
+	const helpers$3 = require_helpers();
+	const genFunc$1 = require_generate_function();
+	const parserCache$2 = require_parser_cache();
+	const typeNames$3 = [];
+	for (const t in Types$3) typeNames$3[Types$3[t]] = t;
+	function readCodeFor$1(type, charset, encodingExpr, config, options) {
+		const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);
+		const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);
+		const timezone = options.timezone || config.timezone;
+		const dateStrings = options.dateStrings || config.dateStrings;
+		switch (type) {
+			case Types$3.TINY:
+			case Types$3.SHORT:
+			case Types$3.LONG:
+			case Types$3.INT24:
+			case Types$3.YEAR: return "packet.parseLengthCodedIntNoBigCheck()";
+			case Types$3.LONGLONG:
+				if (supportBigNumbers && bigNumberStrings) return "packet.parseLengthCodedIntString()";
+				return `packet.parseLengthCodedInt(${supportBigNumbers})`;
+			case Types$3.FLOAT:
+			case Types$3.DOUBLE: return "packet.parseLengthCodedFloat()";
+			case Types$3.NULL: return "packet.readLengthCodedNumber()";
+			case Types$3.DECIMAL:
+			case Types$3.NEWDECIMAL:
+				if (config.decimalNumbers) return "packet.parseLengthCodedFloat()";
+				return "packet.readLengthCodedString(\"ascii\")";
+			case Types$3.DATE:
+				if (helpers$3.typeMatch(type, dateStrings, Types$3)) return "packet.readLengthCodedString(\"ascii\")";
+				return `packet.parseDate(${helpers$3.srcEscape(timezone)})`;
+			case Types$3.DATETIME:
+			case Types$3.TIMESTAMP:
+				if (helpers$3.typeMatch(type, dateStrings, Types$3)) return "packet.readLengthCodedString(\"ascii\")";
+				return `packet.parseDateTime(${helpers$3.srcEscape(timezone)})`;
+			case Types$3.TIME: return "packet.readLengthCodedString(\"ascii\")";
+			case Types$3.GEOMETRY: return "packet.parseGeometryValue()";
+			case Types$3.VECTOR: return "packet.parseVector()";
+			case Types$3.JSON: return config.jsonStrings ? "packet.readLengthCodedString(\"utf8\")" : "JSON.parse(packet.readLengthCodedString(\"utf8\"))";
+			default:
+				if (charset === Charsets$4.BINARY) return "packet.readLengthCodedBuffer()";
+				return `packet.readLengthCodedString(${encodingExpr})`;
+		}
+	}
+	function compile$1(fields$1, options, config) {
+		if (typeof config.typeCast === "function" && typeof options.typeCast !== "function") options.typeCast = config.typeCast;
+		function wrap(field, _this) {
+			return {
+				type: typeNames$3[field.columnType],
+				length: field.columnLength,
+				db: field.schema,
+				table: field.table,
+				name: field.name,
+				string: function(encoding = field.encoding) {
+					if (field.columnType === Types$3.JSON && encoding === field.encoding) console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
+					return _this.packet.readLengthCodedString(encoding);
+				},
+				buffer: function() {
+					return _this.packet.readLengthCodedBuffer();
+				},
+				geometry: function() {
+					return _this.packet.parseGeometryValue();
+				}
+			};
+		}
+		const parserFn = genFunc$1();
+		parserFn("(function () {")("return class TextRow {");
+		parserFn("constructor(fields) {");
+		if (typeof options.typeCast === "function") {
+			parserFn("const _this = this;");
+			parserFn("for(let i=0; i<fields.length; ++i) {");
+			parserFn("this[`wrap${i}`] = wrap(fields[i], _this);");
+			parserFn("}");
+		}
+		parserFn("}");
+		parserFn("next(packet, fields, options) {");
+		parserFn("this.packet = packet;");
+		if (options.rowsAsArray) parserFn(`const result = new Array(${fields$1.length});`);
+		else parserFn("const result = {};");
+		const resultTables = {};
+		let resultTablesArray = [];
+		if (options.nestTables === true) {
+			for (let i$4 = 0; i$4 < fields$1.length; i$4++) resultTables[fields$1[i$4].table] = 1;
+			resultTablesArray = Object.keys(resultTables);
+			for (let i$4 = 0; i$4 < resultTablesArray.length; i$4++) parserFn(`result[${helpers$3.fieldEscape(resultTablesArray[i$4])}] = {};`);
+		}
+		let lvalue = "";
+		let fieldName = "";
+		let tableName = "";
+		for (let i$4 = 0; i$4 < fields$1.length; i$4++) {
+			fieldName = helpers$3.fieldEscape(fields$1[i$4].name);
+			if (typeof options.nestTables === "string") lvalue = `result[${helpers$3.fieldEscape(fields$1[i$4].table + options.nestTables + fields$1[i$4].name)}]`;
+			else if (options.nestTables === true) {
+				tableName = helpers$3.fieldEscape(fields$1[i$4].table);
+				parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
+				lvalue = `result[${tableName}][${fieldName}]`;
+			} else if (options.rowsAsArray) lvalue = `result[${i$4.toString(10)}]`;
+			else lvalue = `result[${fieldName}]`;
+			if (options.typeCast === false) parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
+			else {
+				const encodingExpr = `fields[${i$4}].encoding`;
+				const readCode = readCodeFor$1(fields$1[i$4].columnType, fields$1[i$4].characterSet, encodingExpr, config, options);
+				if (typeof options.typeCast === "function") parserFn(`${lvalue} = options.typeCast(this.wrap${i$4}, function() { return ${readCode} });`);
+				else parserFn(`${lvalue} = ${readCode};`);
+			}
+		}
+		parserFn("return result;");
+		parserFn("}");
+		parserFn("};")("})()");
+		if (config.debug) helpers$3.printDebugWithCode("Compiled text protocol row parser", parserFn.toString());
+		if (typeof options.typeCast === "function") return parserFn.toFunction({ wrap });
+		return parserFn.toFunction();
+	}
+	function getTextParser$2(fields$1, options, config) {
+		return parserCache$2.getParser("text", fields$1, options, config, compile$1);
+	}
+	module.exports = getTextParser$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/static_text_parser.js
+var require_static_text_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/static_text_parser.js": ((exports, module) => {
+	const Types$2 = require_types();
+	const Charsets$3 = require_charsets();
+	const helpers$2 = require_helpers();
+	const typeNames$2 = [];
+	for (const t in Types$2) typeNames$2[Types$2[t]] = t;
+	function readField({ packet, type, charset, encoding, config, options }) {
+		const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);
+		const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);
+		const timezone = options.timezone || config.timezone;
+		const dateStrings = options.dateStrings || config.dateStrings;
+		switch (type) {
+			case Types$2.TINY:
+			case Types$2.SHORT:
+			case Types$2.LONG:
+			case Types$2.INT24:
+			case Types$2.YEAR: return packet.parseLengthCodedIntNoBigCheck();
+			case Types$2.LONGLONG:
+				if (supportBigNumbers && bigNumberStrings) return packet.parseLengthCodedIntString();
+				return packet.parseLengthCodedInt(supportBigNumbers);
+			case Types$2.FLOAT:
+			case Types$2.DOUBLE: return packet.parseLengthCodedFloat();
+			case Types$2.NULL:
+			case Types$2.DECIMAL:
+			case Types$2.NEWDECIMAL:
+				if (config.decimalNumbers) return packet.parseLengthCodedFloat();
+				return packet.readLengthCodedString("ascii");
+			case Types$2.DATE:
+				if (helpers$2.typeMatch(type, dateStrings, Types$2)) return packet.readLengthCodedString("ascii");
+				return packet.parseDate(timezone);
+			case Types$2.DATETIME:
+			case Types$2.TIMESTAMP:
+				if (helpers$2.typeMatch(type, dateStrings, Types$2)) return packet.readLengthCodedString("ascii");
+				return packet.parseDateTime(timezone);
+			case Types$2.TIME: return packet.readLengthCodedString("ascii");
+			case Types$2.GEOMETRY: return packet.parseGeometryValue();
+			case Types$2.VECTOR: return packet.parseVector();
+			case Types$2.JSON: return config.jsonStrings ? packet.readLengthCodedString("utf8") : JSON.parse(packet.readLengthCodedString("utf8"));
+			default:
+				if (charset === Charsets$3.BINARY) return packet.readLengthCodedBuffer();
+				return packet.readLengthCodedString(encoding);
+		}
+	}
+	function createTypecastField(field, packet) {
+		return {
+			type: typeNames$2[field.columnType],
+			length: field.columnLength,
+			db: field.schema,
+			table: field.table,
+			name: field.name,
+			string: function(encoding = field.encoding) {
+				if (field.columnType === Types$2.JSON && encoding === field.encoding) console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
+				return packet.readLengthCodedString(encoding);
+			},
+			buffer: function() {
+				return packet.readLengthCodedBuffer();
+			},
+			geometry: function() {
+				return packet.parseGeometryValue();
+			}
+		};
+	}
+	function getTextParser$1(_fields, _options, config) {
+		return { next(packet, fields$1, options) {
+			const result = options.rowsAsArray ? [] : {};
+			for (let i$4 = 0; i$4 < fields$1.length; i$4++) {
+				const field = fields$1[i$4];
+				const typeCast = options.typeCast ? options.typeCast : config.typeCast;
+				const next = () => readField({
+					packet,
+					type: field.columnType,
+					encoding: field.encoding,
+					charset: field.characterSet,
+					config,
+					options
+				});
+				let value;
+				if (options.typeCast === false) value = packet.readLengthCodedBuffer();
+				else if (typeof typeCast === "function") value = typeCast(createTypecastField(field, packet), next);
+				else value = next();
+				if (options.rowsAsArray) result.push(value);
+				else if (typeof options.nestTables === "string") result[`${helpers$2.fieldEscape(field.table, false)}${options.nestTables}${helpers$2.fieldEscape(field.name, false)}`] = value;
+				else if (options.nestTables) {
+					const tableName = helpers$2.fieldEscape(field.table, false);
+					if (!result[tableName]) result[tableName] = {};
+					result[tableName][helpers$2.fieldEscape(field.name, false)] = value;
+				} else result[helpers$2.fieldEscape(field.name, false)] = value;
+			}
+			return result;
+		} };
+	}
+	module.exports = getTextParser$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/query.js
+var require_query = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/query.js": ((exports, module) => {
+	const process$3 = __require("process");
+	const Timers$1 = __require("timers");
+	const Readable$1 = __require("stream").Readable;
+	const Command$8 = require_command();
+	const Packets$7 = require_packets();
+	const getTextParser = require_text_parser();
+	const staticParser = require_static_text_parser();
+	const ServerStatus = require_server_status();
+	const EmptyPacket = new Packets$7.Packet(0, Buffer.allocUnsafe(4), 0, 4);
+	var Query$2 = class Query$2 extends Command$8 {
+		constructor(options, callback) {
+			super();
+			this.sql = options.sql;
+			this.values = options.values;
+			this._queryOptions = options;
+			this.namedPlaceholders = options.namedPlaceholders || false;
+			this.onResult = callback;
+			this.timeout = options.timeout;
+			this.queryTimeout = null;
+			this._fieldCount = 0;
+			this._rowParser = null;
+			this._fields = [];
+			this._rows = [];
+			this._receivedFieldsCount = 0;
+			this._resultIndex = 0;
+			this._localStream = null;
+			this._unpipeStream = function() {};
+			this._streamFactory = options.infileStreamFactory;
+			this._connection = null;
+		}
+		then() {
+			const err = "You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://sidorares.github.io/node-mysql2/docs#using-promise-wrapper, or the mysql2 documentation at https://sidorares.github.io/node-mysql2/docs/documentation/promise-wrapper";
+			console.log(err);
+			throw new Error(err);
+		}
+		start(_packet, connection) {
+			if (connection.config.debug) console.log("        Sending query command: %s", this.sql);
+			this._connection = connection;
+			this.options = Object.assign({}, connection.config, this._queryOptions);
+			this._setTimeout();
+			const cmdPacket = new Packets$7.Query(this.sql, connection.config.charsetNumber);
+			connection.writePacket(cmdPacket.toPacket(1));
+			return Query$2.prototype.resultsetHeader;
+		}
+		done() {
+			this._unpipeStream();
+			if (this.timeout && !this.queryTimeout) return null;
+			if (this.queryTimeout) {
+				Timers$1.clearTimeout(this.queryTimeout);
+				this.queryTimeout = null;
+			}
+			if (this.onResult) {
+				let rows, fields$1;
+				if (this._resultIndex === 0) {
+					rows = this._rows[0];
+					fields$1 = this._fields[0];
+				} else {
+					rows = this._rows;
+					fields$1 = this._fields;
+				}
+				if (fields$1) process$3.nextTick(() => {
+					this.onResult(null, rows, fields$1);
+				});
+				else process$3.nextTick(() => {
+					this.onResult(null, rows);
+				});
+			}
+			return null;
+		}
+		doneInsert(rs) {
+			if (this._localStreamError) {
+				if (this.onResult) this.onResult(this._localStreamError, rs);
+				else this.emit("error", this._localStreamError);
+				return null;
+			}
+			this._rows.push(rs);
+			this._fields.push(void 0);
+			this.emit("fields", void 0);
+			this.emit("result", rs);
+			if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
+				this._resultIndex++;
+				return this.resultsetHeader;
+			}
+			return this.done();
+		}
+		resultsetHeader(packet, connection) {
+			const rs = new Packets$7.ResultSetHeader(packet, connection);
+			this._fieldCount = rs.fieldCount;
+			if (connection.config.debug) console.log(`        Resultset header received, expecting ${rs.fieldCount} column definition packets`);
+			if (this._fieldCount === 0) return this.doneInsert(rs);
+			if (this._fieldCount === null) return this._streamLocalInfile(connection, rs.infileName);
+			this._receivedFieldsCount = 0;
+			this._rows.push([]);
+			this._fields.push([]);
+			return this.readField;
+		}
+		_streamLocalInfile(connection, path) {
+			if (this._streamFactory) this._localStream = this._streamFactory(path);
+			else {
+				this._localStreamError = /* @__PURE__ */ new Error(`As a result of LOCAL INFILE command server wants to read ${path} file, but as of v2.0 you must provide streamFactory option returning ReadStream.`);
+				connection.writePacket(EmptyPacket);
+				return this.infileOk;
+			}
+			const onConnectionError = () => {
+				this._unpipeStream();
+			};
+			const onDrain = () => {
+				this._localStream.resume();
+			};
+			const onPause = () => {
+				this._localStream.pause();
+			};
+			const onData = function(data) {
+				const dataWithHeader = Buffer.allocUnsafe(data.length + 4);
+				data.copy(dataWithHeader, 4);
+				connection.writePacket(new Packets$7.Packet(0, dataWithHeader, 0, dataWithHeader.length));
+			};
+			const onEnd = () => {
+				connection.removeListener("error", onConnectionError);
+				connection.writePacket(EmptyPacket);
+			};
+			const onError = (err) => {
+				this._localStreamError = err;
+				connection.removeListener("error", onConnectionError);
+				connection.writePacket(EmptyPacket);
+			};
+			this._unpipeStream = () => {
+				connection.stream.removeListener("pause", onPause);
+				connection.stream.removeListener("drain", onDrain);
+				this._localStream.removeListener("data", onData);
+				this._localStream.removeListener("end", onEnd);
+				this._localStream.removeListener("error", onError);
+			};
+			connection.stream.on("pause", onPause);
+			connection.stream.on("drain", onDrain);
+			this._localStream.on("data", onData);
+			this._localStream.on("end", onEnd);
+			this._localStream.on("error", onError);
+			connection.once("error", onConnectionError);
+			return this.infileOk;
+		}
+		readField(packet, connection) {
+			this._receivedFieldsCount++;
+			if (this._fields[this._resultIndex].length !== this._fieldCount) {
+				const field = new Packets$7.ColumnDefinition(packet, connection.clientEncoding);
+				this._fields[this._resultIndex].push(field);
+				if (connection.config.debug) {
+					console.log("        Column definition:");
+					console.log(`          name: ${field.name}`);
+					console.log(`          type: ${field.columnType}`);
+					console.log(`         flags: ${field.flags}`);
+				}
+			}
+			if (this._receivedFieldsCount === this._fieldCount) {
+				const fields$1 = this._fields[this._resultIndex];
+				this.emit("fields", fields$1);
+				if (this.options.disableEval) this._rowParser = staticParser(fields$1, this.options, connection.config);
+				else this._rowParser = new (getTextParser(fields$1, this.options, connection.config))(fields$1);
+				return Query$2.prototype.fieldsEOF;
+			}
+			return Query$2.prototype.readField;
+		}
+		fieldsEOF(packet, connection) {
+			if (!packet.isEOF()) return connection.protocolError("Expected EOF packet");
+			return this.row;
+		}
+		row(packet, _connection) {
+			if (packet.isEOF()) {
+				if (packet.eofStatusFlags() & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {
+					this._resultIndex++;
+					return Query$2.prototype.resultsetHeader;
+				}
+				return this.done();
+			}
+			let row;
+			try {
+				row = this._rowParser.next(packet, this._fields[this._resultIndex], this.options);
+			} catch (err) {
+				this._localStreamError = err;
+				return this.doneInsert(null);
+			}
+			if (this.onResult) this._rows[this._resultIndex].push(row);
+			else this.emit("result", row, this._resultIndex);
+			return Query$2.prototype.row;
+		}
+		infileOk(packet, connection) {
+			const rs = new Packets$7.ResultSetHeader(packet, connection);
+			return this.doneInsert(rs);
+		}
+		stream(options) {
+			options = options || Object.create(null);
+			options.objectMode = true;
+			const stream = new Readable$1({
+				...options,
+				emitClose: true,
+				autoDestroy: true,
+				read: () => {
+					this._connection && this._connection.resume();
+				}
+			});
+			stream.once("close", () => {
+				if (!stream.readableEnded) stream.emit("end");
+			});
+			const onResult = (row, index) => {
+				if (stream.destroyed) return;
+				if (!stream.push(row)) this._connection && this._connection.pause();
+				stream.emit("result", row, index);
+			};
+			const onFields = (fields$1) => {
+				if (stream.destroyed) return;
+				stream.emit("fields", fields$1);
+			};
+			const onEnd = () => {
+				if (stream.destroyed) return;
+				stream.push(null);
+			};
+			const onError = (err) => {
+				stream.destroy(err);
+			};
+			stream._destroy = (err, cb) => {
+				this._connection && this._connection.resume();
+				this.removeListener("result", onResult);
+				this.removeListener("fields", onFields);
+				this.removeListener("end", onEnd);
+				this.removeListener("error", onError);
+				cb(err);
+			};
+			this.on("result", onResult);
+			this.on("fields", onFields);
+			this.on("end", onEnd);
+			this.on("error", onError);
+			return stream;
+		}
+		_setTimeout() {
+			if (this.timeout) {
+				const timeoutHandler = this._handleTimeoutError.bind(this);
+				this.queryTimeout = Timers$1.setTimeout(timeoutHandler, this.timeout);
+			}
+		}
+		_handleTimeoutError() {
+			if (this.queryTimeout) {
+				Timers$1.clearTimeout(this.queryTimeout);
+				this.queryTimeout = null;
+			}
+			const err = /* @__PURE__ */ new Error("Query inactivity timeout");
+			err.errorno = "PROTOCOL_SEQUENCE_TIMEOUT";
+			err.code = "PROTOCOL_SEQUENCE_TIMEOUT";
+			err.syscall = "query";
+			if (this.onResult) this.onResult(err);
+			else this.emit("error", err);
+		}
+	};
+	Query$2.prototype.catch = Query$2.prototype.then;
+	module.exports = Query$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/close_statement.js
+var require_close_statement = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/close_statement.js": ((exports, module) => {
+	const Command$7 = require_command();
+	const Packets$6 = require_packets();
+	var CloseStatement$2 = class extends Command$7 {
+		constructor(id) {
+			super();
+			this.id = id;
+		}
+		start(packet, connection) {
+			connection.writePacket(new Packets$6.CloseStatement(this.id).toPacket(1));
+			return null;
+		}
+	};
+	module.exports = CloseStatement$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/binary_parser.js
+var require_binary_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/binary_parser.js": ((exports, module) => {
+	const FieldFlags$1 = require_field_flags();
+	const Charsets$2 = require_charsets();
+	const Types$1 = require_types();
+	const helpers$1 = require_helpers();
+	const genFunc = require_generate_function();
+	const parserCache$1 = require_parser_cache();
+	const typeNames$1 = [];
+	for (const t in Types$1) typeNames$1[Types$1[t]] = t;
+	function readCodeFor(field, config, options, fieldNum) {
+		const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);
+		const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);
+		const timezone = options.timezone || config.timezone;
+		const dateStrings = options.dateStrings || config.dateStrings;
+		const unsigned = field.flags & FieldFlags$1.UNSIGNED;
+		switch (field.columnType) {
+			case Types$1.TINY: return unsigned ? "packet.readInt8();" : "packet.readSInt8();";
+			case Types$1.SHORT: return unsigned ? "packet.readInt16();" : "packet.readSInt16();";
+			case Types$1.LONG:
+			case Types$1.INT24: return unsigned ? "packet.readInt32();" : "packet.readSInt32();";
+			case Types$1.YEAR: return "packet.readInt16()";
+			case Types$1.FLOAT: return "packet.readFloat();";
+			case Types$1.DOUBLE: return "packet.readDouble();";
+			case Types$1.NULL: return "null;";
+			case Types$1.DATE:
+			case Types$1.DATETIME:
+			case Types$1.TIMESTAMP:
+			case Types$1.NEWDATE:
+				if (helpers$1.typeMatch(field.columnType, dateStrings, Types$1)) return `packet.readDateTimeString(${parseInt(field.decimals, 10)}, null, ${field.columnType});`;
+				return `packet.readDateTime(${helpers$1.srcEscape(timezone)});`;
+			case Types$1.TIME: return "packet.readTimeString()";
+			case Types$1.DECIMAL:
+			case Types$1.NEWDECIMAL:
+				if (config.decimalNumbers) return "packet.parseLengthCodedFloat();";
+				return "packet.readLengthCodedString(\"ascii\");";
+			case Types$1.GEOMETRY: return "packet.parseGeometryValue();";
+			case Types$1.VECTOR: return "packet.parseVector()";
+			case Types$1.JSON: return config.jsonStrings ? "packet.readLengthCodedString(\"utf8\")" : "JSON.parse(packet.readLengthCodedString(\"utf8\"));";
+			case Types$1.LONGLONG:
+				if (!supportBigNumbers) return unsigned ? "packet.readInt64JSNumber();" : "packet.readSInt64JSNumber();";
+				if (bigNumberStrings) return unsigned ? "packet.readInt64String();" : "packet.readSInt64String();";
+				return unsigned ? "packet.readInt64();" : "packet.readSInt64();";
+			default:
+				if (field.characterSet === Charsets$2.BINARY) return "packet.readLengthCodedBuffer();";
+				return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;
+		}
+	}
+	function compile(fields$1, options, config) {
+		const parserFn = genFunc();
+		const nullBitmapLength = Math.floor((fields$1.length + 7 + 2) / 8);
+		function wrap(field, packet) {
+			return {
+				type: typeNames$1[field.columnType],
+				length: field.columnLength,
+				db: field.schema,
+				table: field.table,
+				name: field.name,
+				string: function(encoding = field.encoding) {
+					if (field.columnType === Types$1.JSON && encoding === field.encoding) console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
+					if ([
+						Types$1.DATETIME,
+						Types$1.NEWDATE,
+						Types$1.TIMESTAMP,
+						Types$1.DATE
+					].includes(field.columnType)) return packet.readDateTimeString(parseInt(field.decimals, 10), " ", field.columnType);
+					if (field.columnType === Types$1.TINY) {
+						const unsigned = field.flags & FieldFlags$1.UNSIGNED;
+						return String(unsigned ? packet.readInt8() : packet.readSInt8());
+					}
+					if (field.columnType === Types$1.TIME) return packet.readTimeString();
+					return packet.readLengthCodedString(encoding);
+				},
+				buffer: function() {
+					return packet.readLengthCodedBuffer();
+				},
+				geometry: function() {
+					return packet.parseGeometryValue();
+				}
+			};
+		}
+		parserFn("(function(){");
+		parserFn("return class BinaryRow {");
+		parserFn("constructor() {");
+		parserFn("}");
+		parserFn("next(packet, fields, options) {");
+		if (options.rowsAsArray) parserFn(`const result = new Array(${fields$1.length});`);
+		else parserFn("const result = {};");
+		if (typeof config.typeCast === "function" && typeof options.typeCast !== "function") options.typeCast = config.typeCast;
+		parserFn("packet.readInt8();");
+		for (let i$4 = 0; i$4 < nullBitmapLength; ++i$4) parserFn(`const nullBitmaskByte${i$4} = packet.readInt8();`);
+		let lvalue = "";
+		let currentFieldNullBit = 4;
+		let nullByteIndex = 0;
+		let fieldName = "";
+		let tableName = "";
+		for (let i$4 = 0; i$4 < fields$1.length; i$4++) {
+			fieldName = helpers$1.fieldEscape(fields$1[i$4].name);
+			if (typeof options.nestTables === "string") lvalue = `result[${helpers$1.fieldEscape(fields$1[i$4].table + options.nestTables + fields$1[i$4].name)}]`;
+			else if (options.nestTables === true) {
+				tableName = helpers$1.fieldEscape(fields$1[i$4].table);
+				parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);
+				lvalue = `result[${tableName}][${fieldName}]`;
+			} else if (options.rowsAsArray) lvalue = `result[${i$4.toString(10)}]`;
+			else lvalue = `result[${fieldName}]`;
+			parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);
+			parserFn(`${lvalue} = null;`);
+			parserFn("else {");
+			if (options.typeCast === false) parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);
+			else {
+				const fieldWrapperVar = `fieldWrapper${i$4}`;
+				parserFn(`const ${fieldWrapperVar} = wrap(fields[${i$4}], packet);`);
+				const readCode = readCodeFor(fields$1[i$4], config, options, i$4);
+				if (typeof options.typeCast === "function") parserFn(`${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`);
+				else parserFn(`${lvalue} = ${readCode};`);
+			}
+			parserFn("}");
+			currentFieldNullBit *= 2;
+			if (currentFieldNullBit === 256) {
+				currentFieldNullBit = 1;
+				nullByteIndex++;
+			}
+		}
+		parserFn("return result;");
+		parserFn("}");
+		parserFn("};")("})()");
+		if (config.debug) helpers$1.printDebugWithCode("Compiled binary protocol row parser", parserFn.toString());
+		return parserFn.toFunction({ wrap });
+	}
+	function getBinaryParser$2(fields$1, options, config) {
+		return parserCache$1.getParser("binary", fields$1, options, config, compile);
+	}
+	module.exports = getBinaryParser$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/static_binary_parser.js
+var require_static_binary_parser = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/parsers/static_binary_parser.js": ((exports, module) => {
+	const FieldFlags = require_field_flags();
+	const Charsets$1 = require_charsets();
+	const Types = require_types();
+	const helpers = require_helpers();
+	const typeNames = [];
+	for (const t in Types) typeNames[Types[t]] = t;
+	function getBinaryParser$1(fields$1, _options, config) {
+		function readCode(field, config$1, options, fieldNum, packet) {
+			const supportBigNumbers = Boolean(options.supportBigNumbers || config$1.supportBigNumbers);
+			const bigNumberStrings = Boolean(options.bigNumberStrings || config$1.bigNumberStrings);
+			const timezone = options.timezone || config$1.timezone;
+			const dateStrings = options.dateStrings || config$1.dateStrings;
+			const unsigned = field.flags & FieldFlags.UNSIGNED;
+			switch (field.columnType) {
+				case Types.TINY: return unsigned ? packet.readInt8() : packet.readSInt8();
+				case Types.SHORT: return unsigned ? packet.readInt16() : packet.readSInt16();
+				case Types.LONG:
+				case Types.INT24: return unsigned ? packet.readInt32() : packet.readSInt32();
+				case Types.YEAR: return packet.readInt16();
+				case Types.FLOAT: return packet.readFloat();
+				case Types.DOUBLE: return packet.readDouble();
+				case Types.NULL: return null;
+				case Types.DATE:
+				case Types.DATETIME:
+				case Types.TIMESTAMP:
+				case Types.NEWDATE: return helpers.typeMatch(field.columnType, dateStrings, Types) ? packet.readDateTimeString(parseInt(field.decimals, 10), null, field.columnType) : packet.readDateTime(timezone);
+				case Types.TIME: return packet.readTimeString();
+				case Types.DECIMAL:
+				case Types.NEWDECIMAL: return config$1.decimalNumbers ? packet.parseLengthCodedFloat() : packet.readLengthCodedString("ascii");
+				case Types.GEOMETRY: return packet.parseGeometryValue();
+				case Types.VECTOR: return packet.parseVector();
+				case Types.JSON: return config$1.jsonStrings ? packet.readLengthCodedString("utf8") : JSON.parse(packet.readLengthCodedString("utf8"));
+				case Types.LONGLONG:
+					if (!supportBigNumbers) return unsigned ? packet.readInt64JSNumber() : packet.readSInt64JSNumber();
+					return bigNumberStrings ? unsigned ? packet.readInt64String() : packet.readSInt64String() : unsigned ? packet.readInt64() : packet.readSInt64();
+				default: return field.characterSet === Charsets$1.BINARY ? packet.readLengthCodedBuffer() : packet.readLengthCodedString(fields$1[fieldNum].encoding);
+			}
+		}
+		return class BinaryRow$1 {
+			constructor() {}
+			next(packet, fields$2, options) {
+				packet.readInt8();
+				const nullBitmapLength = Math.floor((fields$2.length + 7 + 2) / 8);
+				const nullBitmaskBytes = new Array(nullBitmapLength);
+				for (let i$4 = 0; i$4 < nullBitmapLength; i$4++) nullBitmaskBytes[i$4] = packet.readInt8();
+				const result = options.rowsAsArray ? new Array(fields$2.length) : {};
+				let currentFieldNullBit = 4;
+				let nullByteIndex = 0;
+				for (let i$4 = 0; i$4 < fields$2.length; i$4++) {
+					const field = fields$2[i$4];
+					const typeCast = options.typeCast !== void 0 ? options.typeCast : config.typeCast;
+					let value;
+					if (nullBitmaskBytes[nullByteIndex] & currentFieldNullBit) value = null;
+					else if (options.typeCast === false) value = packet.readLengthCodedBuffer();
+					else {
+						const next = () => readCode(field, config, options, i$4, packet);
+						value = typeof typeCast === "function" ? typeCast({
+							type: typeNames[field.columnType],
+							length: field.columnLength,
+							db: field.schema,
+							table: field.table,
+							name: field.name,
+							string: function(encoding = field.encoding) {
+								if (field.columnType === Types.JSON && encoding === field.encoding) console.warn(`typeCast: JSON column "${field.name}" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \`field.string("utf8")\``);
+								if ([
+									Types.DATETIME,
+									Types.NEWDATE,
+									Types.TIMESTAMP,
+									Types.DATE
+								].includes(field.columnType)) return packet.readDateTimeString(parseInt(field.decimals, 10), " ", field.columnType);
+								if (field.columnType === Types.TINY) {
+									const unsigned = field.flags & FieldFlags.UNSIGNED;
+									return String(unsigned ? packet.readInt8() : packet.readSInt8());
+								}
+								if (field.columnType === Types.TIME) return packet.readTimeString();
+								return packet.readLengthCodedString(encoding);
+							},
+							buffer: function() {
+								return packet.readLengthCodedBuffer();
+							},
+							geometry: function() {
+								return packet.parseGeometryValue();
+							}
+						}, next) : next();
+					}
+					if (options.rowsAsArray) result[i$4] = value;
+					else if (typeof options.nestTables === "string") {
+						const key$1 = helpers.fieldEscape(field.table + options.nestTables + field.name, false);
+						result[key$1] = value;
+					} else if (options.nestTables === true) {
+						const tableName = helpers.fieldEscape(field.table, false);
+						if (!result[tableName]) result[tableName] = {};
+						const fieldName = helpers.fieldEscape(field.name, false);
+						result[tableName][fieldName] = value;
+					} else {
+						const key$1 = helpers.fieldEscape(field.name, false);
+						result[key$1] = value;
+					}
+					currentFieldNullBit *= 2;
+					if (currentFieldNullBit === 256) {
+						currentFieldNullBit = 1;
+						nullByteIndex++;
+					}
+				}
+				return result;
+			}
+		};
+	}
+	module.exports = getBinaryParser$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/execute.js
+var require_execute = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/execute.js": ((exports, module) => {
+	const Command$6 = require_command();
+	const Query$1 = require_query();
+	const Packets$5 = require_packets();
+	const getBinaryParser = require_binary_parser();
+	const getStaticBinaryParser = require_static_binary_parser();
+	var Execute$2 = class Execute$2 extends Command$6 {
+		constructor(options, callback) {
+			super();
+			this.statement = options.statement;
+			this.sql = options.sql;
+			this.values = options.values;
+			this.onResult = callback;
+			this.parameters = options.values;
+			this.insertId = 0;
+			this.timeout = options.timeout;
+			this.queryTimeout = null;
+			this._rows = [];
+			this._fields = [];
+			this._result = [];
+			this._fieldCount = 0;
+			this._rowParser = null;
+			this._executeOptions = options;
+			this._resultIndex = 0;
+			this._localStream = null;
+			this._unpipeStream = function() {};
+			this._streamFactory = options.infileStreamFactory;
+			this._connection = null;
+		}
+		buildParserFromFields(fields$1, connection) {
+			if (this.options.disableEval) return getStaticBinaryParser(fields$1, this.options, connection.config);
+			return getBinaryParser(fields$1, this.options, connection.config);
+		}
+		start(packet, connection) {
+			this._connection = connection;
+			this.options = Object.assign({}, connection.config, this._executeOptions);
+			this._setTimeout();
+			const executePacket = new Packets$5.Execute(this.statement.id, this.parameters, connection.config.charsetNumber, connection.config.timezone);
+			try {
+				connection.writePacket(executePacket.toPacket(1));
+			} catch (error) {
+				this.onResult(error);
+			}
+			return Execute$2.prototype.resultsetHeader;
+		}
+		readField(packet, connection) {
+			let fields$1;
+			const field = new Packets$5.ColumnDefinition(packet, connection.clientEncoding);
+			this._receivedFieldsCount++;
+			this._fields[this._resultIndex].push(field);
+			if (this._receivedFieldsCount === this._fieldCount) {
+				fields$1 = this._fields[this._resultIndex];
+				this.emit("fields", fields$1, this._resultIndex);
+				return Execute$2.prototype.fieldsEOF;
+			}
+			return Execute$2.prototype.readField;
+		}
+		fieldsEOF(packet, connection) {
+			if (!packet.isEOF()) return connection.protocolError("Expected EOF packet");
+			this._rowParser = new (this.buildParserFromFields(this._fields[this._resultIndex], connection))();
+			return Execute$2.prototype.row;
+		}
+	};
+	Execute$2.prototype.done = Query$1.prototype.done;
+	Execute$2.prototype.doneInsert = Query$1.prototype.doneInsert;
+	Execute$2.prototype.resultsetHeader = Query$1.prototype.resultsetHeader;
+	Execute$2.prototype._findOrCreateReadStream = Query$1.prototype._findOrCreateReadStream;
+	Execute$2.prototype._streamLocalInfile = Query$1.prototype._streamLocalInfile;
+	Execute$2.prototype._setTimeout = Query$1.prototype._setTimeout;
+	Execute$2.prototype._handleTimeoutError = Query$1.prototype._handleTimeoutError;
+	Execute$2.prototype.row = Query$1.prototype.row;
+	Execute$2.prototype.stream = Query$1.prototype.stream;
+	module.exports = Execute$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/prepare.js
+var require_prepare = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/prepare.js": ((exports, module) => {
+	const Packets$4 = require_packets();
+	const Command$5 = require_command();
+	const CloseStatement$1 = require_close_statement();
+	const Execute$1 = require_execute();
+	var PreparedStatementInfo = class {
+		constructor(query, id, columns, parameters, connection) {
+			this.query = query;
+			this.id = id;
+			this.columns = columns;
+			this.parameters = parameters;
+			this.rowParser = null;
+			this._connection = connection;
+		}
+		close() {
+			return this._connection.addCommand(new CloseStatement$1(this.id));
+		}
+		execute(parameters, callback) {
+			if (typeof parameters === "function") {
+				callback = parameters;
+				parameters = [];
+			}
+			return this._connection.addCommand(new Execute$1({
+				statement: this,
+				values: parameters
+			}, callback));
+		}
+	};
+	var Prepare$1 = class Prepare$1 extends Command$5 {
+		constructor(options, callback) {
+			super();
+			this.query = options.sql;
+			this.onResult = callback;
+			this.id = 0;
+			this.fieldCount = 0;
+			this.parameterCount = 0;
+			this.fields = [];
+			this.parameterDefinitions = [];
+			this.options = options;
+		}
+		start(packet, connection) {
+			this.key = connection.constructor.statementKey(this.options);
+			const statement = connection._statements.get(this.key);
+			if (statement) {
+				if (this.onResult) this.onResult(null, statement);
+				return null;
+			}
+			const cmdPacket = new Packets$4.PrepareStatement(this.query, connection.config.charsetNumber, this.options.values);
+			connection.writePacket(cmdPacket.toPacket(1));
+			return Prepare$1.prototype.prepareHeader;
+		}
+		prepareHeader(packet, connection) {
+			const header = new Packets$4.PreparedStatementHeader(packet);
+			this.id = header.id;
+			this.fieldCount = header.fieldCount;
+			this.parameterCount = header.parameterCount;
+			if (this.parameterCount > 0) return Prepare$1.prototype.readParameter;
+			if (this.fieldCount > 0) return Prepare$1.prototype.readField;
+			return this.prepareDone(connection);
+		}
+		readParameter(packet, connection) {
+			if (packet.isEOF()) {
+				if (this.fieldCount > 0) return Prepare$1.prototype.readField;
+				return this.prepareDone(connection);
+			}
+			const def = new Packets$4.ColumnDefinition(packet, connection.clientEncoding);
+			this.parameterDefinitions.push(def);
+			if (this.parameterDefinitions.length === this.parameterCount) return Prepare$1.prototype.parametersEOF;
+			return this.readParameter;
+		}
+		readField(packet, connection) {
+			if (packet.isEOF()) return this.prepareDone(connection);
+			const def = new Packets$4.ColumnDefinition(packet, connection.clientEncoding);
+			this.fields.push(def);
+			if (this.fields.length === this.fieldCount) return Prepare$1.prototype.fieldsEOF;
+			return Prepare$1.prototype.readField;
+		}
+		parametersEOF(packet, connection) {
+			if (!packet.isEOF()) return connection.protocolError("Expected EOF packet after parameters");
+			if (this.fieldCount > 0) return Prepare$1.prototype.readField;
+			return this.prepareDone(connection);
+		}
+		fieldsEOF(packet, connection) {
+			if (!packet.isEOF()) return connection.protocolError("Expected EOF packet after fields");
+			return this.prepareDone(connection);
+		}
+		prepareDone(connection) {
+			const statement = new PreparedStatementInfo(this.query, this.id, this.fields, this.parameterDefinitions, connection);
+			connection._statements.set(this.key, statement);
+			if (this.onResult) this.onResult(null, statement);
+			return null;
+		}
+	};
+	module.exports = Prepare$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/ping.js
+var require_ping = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/ping.js": ((exports, module) => {
+	const Command$4 = require_command();
+	const CommandCode$1 = require_commands$1();
+	const Packet$1 = require_packet();
+	var Ping$1 = class Ping$1 extends Command$4 {
+		constructor(callback) {
+			super();
+			this.onResult = callback;
+		}
+		start(packet, connection) {
+			const ping = new Packet$1(0, Buffer.from([
+				1,
+				0,
+				0,
+				0,
+				CommandCode$1.PING
+			]), 0, 5);
+			connection.writePacket(ping);
+			return Ping$1.prototype.pingResponse;
+		}
+		pingResponse() {
+			if (this.onResult) process.nextTick(this.onResult.bind(this));
+			return null;
+		}
+	};
+	module.exports = Ping$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/register_slave.js
+var require_register_slave = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/register_slave.js": ((exports, module) => {
+	const Command$3 = require_command();
+	const Packets$3 = require_packets();
+	var RegisterSlave$1 = class RegisterSlave$1 extends Command$3 {
+		constructor(opts, callback) {
+			super();
+			this.onResult = callback;
+			this.opts = opts;
+		}
+		start(packet, connection) {
+			const newPacket = new Packets$3.RegisterSlave(this.opts);
+			connection.writePacket(newPacket.toPacket(1));
+			return RegisterSlave$1.prototype.registerResponse;
+		}
+		registerResponse() {
+			if (this.onResult) process.nextTick(this.onResult.bind(this));
+			return null;
+		}
+	};
+	module.exports = RegisterSlave$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/binlog_query_statusvars.js
+var require_binlog_query_statusvars = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/packets/binlog_query_statusvars.js": ((exports, module) => {
+	const keys = {
+		FLAGS2: 0,
+		SQL_MODE: 1,
+		CATALOG: 2,
+		AUTO_INCREMENT: 3,
+		CHARSET: 4,
+		TIME_ZONE: 5,
+		CATALOG_NZ: 6,
+		LC_TIME_NAMES: 7,
+		CHARSET_DATABASE: 8,
+		TABLE_MAP_FOR_UPDATE: 9,
+		MASTER_DATA_WRITTEN: 10,
+		INVOKERS: 11,
+		UPDATED_DB_NAMES: 12,
+		MICROSECONDS: 3
+	};
+	module.exports = function parseStatusVars(buffer$1) {
+		const result = {};
+		let offset = 0;
+		let key$1, length, prevOffset;
+		while (offset < buffer$1.length) {
+			key$1 = buffer$1[offset++];
+			switch (key$1) {
+				case keys.FLAGS2:
+					result.flags = buffer$1.readUInt32LE(offset);
+					offset += 4;
+					break;
+				case keys.SQL_MODE:
+					result.sqlMode = buffer$1.readUInt32LE(offset);
+					offset += 8;
+					break;
+				case keys.CATALOG:
+					length = buffer$1[offset++];
+					result.catalog = buffer$1.toString("utf8", offset, offset + length);
+					offset += length + 1;
+					break;
+				case keys.CHARSET:
+					result.clientCharset = buffer$1.readUInt16LE(offset);
+					result.connectionCollation = buffer$1.readUInt16LE(offset + 2);
+					result.serverCharset = buffer$1.readUInt16LE(offset + 4);
+					offset += 6;
+					break;
+				case keys.TIME_ZONE:
+					length = buffer$1[offset++];
+					result.timeZone = buffer$1.toString("utf8", offset, offset + length);
+					offset += length;
+					break;
+				case keys.CATALOG_NZ:
+					length = buffer$1[offset++];
+					result.catalogNz = buffer$1.toString("utf8", offset, offset + length);
+					offset += length;
+					break;
+				case keys.LC_TIME_NAMES:
+					result.lcTimeNames = buffer$1.readUInt16LE(offset);
+					offset += 2;
+					break;
+				case keys.CHARSET_DATABASE:
+					result.schemaCharset = buffer$1.readUInt16LE(offset);
+					offset += 2;
+					break;
+				case keys.TABLE_MAP_FOR_UPDATE:
+					result.mapForUpdate1 = buffer$1.readUInt32LE(offset);
+					result.mapForUpdate2 = buffer$1.readUInt32LE(offset + 4);
+					offset += 8;
+					break;
+				case keys.MASTER_DATA_WRITTEN:
+					result.masterDataWritten = buffer$1.readUInt32LE(offset);
+					offset += 4;
+					break;
+				case keys.INVOKERS:
+					length = buffer$1[offset++];
+					result.invokerUsername = buffer$1.toString("utf8", offset, offset + length);
+					offset += length;
+					length = buffer$1[offset++];
+					result.invokerHostname = buffer$1.toString("utf8", offset, offset + length);
+					offset += length;
+					break;
+				case keys.UPDATED_DB_NAMES:
+					length = buffer$1[offset++];
+					result.updatedDBs = [];
+					for (; length; --length) {
+						prevOffset = offset;
+						while (buffer$1[offset++] && offset < buffer$1.length);
+						result.updatedDBs.push(buffer$1.toString("utf8", prevOffset, offset - 1));
+					}
+					break;
+				case keys.MICROSECONDS:
+					result.microseconds = buffer$1.readInt16LE(offset) + (buffer$1[offset + 2] << 16);
+					offset += 3;
+			}
+		}
+		return result;
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/binlog_dump.js
+var require_binlog_dump = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/binlog_dump.js": ((exports, module) => {
+	const Command$2 = require_command();
+	const Packets$2 = require_packets();
+	const eventParsers = [];
+	var BinlogEventHeader = class {
+		constructor(packet) {
+			this.timestamp = packet.readInt32();
+			this.eventType = packet.readInt8();
+			this.serverId = packet.readInt32();
+			this.eventSize = packet.readInt32();
+			this.logPos = packet.readInt32();
+			this.flags = packet.readInt16();
+		}
+	};
+	var BinlogDump$1 = class BinlogDump$1 extends Command$2 {
+		constructor(opts) {
+			super();
+			this.opts = opts;
+		}
+		start(packet, connection) {
+			const newPacket = new Packets$2.BinlogDump(this.opts);
+			connection.writePacket(newPacket.toPacket(1));
+			return BinlogDump$1.prototype.binlogData;
+		}
+		binlogData(packet) {
+			if (packet.isEOF()) {
+				this.emit("eof");
+				return null;
+			}
+			packet.readInt8();
+			const header = new BinlogEventHeader(packet);
+			const EventParser = eventParsers[header.eventType];
+			let event;
+			if (EventParser) event = new EventParser(packet);
+			else event = { name: "UNKNOWN" };
+			event.header = header;
+			this.emit("event", event);
+			return BinlogDump$1.prototype.binlogData;
+		}
+	};
+	var RotateEvent = class {
+		constructor(packet) {
+			this.pposition = packet.readInt32();
+			packet.readInt32();
+			this.nextBinlog = packet.readString();
+			this.name = "RotateEvent";
+		}
+	};
+	var FormatDescriptionEvent = class {
+		constructor(packet) {
+			this.binlogVersion = packet.readInt16();
+			this.serverVersion = packet.readString(50).replace(/\u0000.*/, "");
+			this.createTimestamp = packet.readInt32();
+			this.eventHeaderLength = packet.readInt8();
+			this.eventsLength = packet.readBuffer();
+			this.name = "FormatDescriptionEvent";
+		}
+	};
+	var QueryEvent = class {
+		constructor(packet) {
+			const parseStatusVars = require_binlog_query_statusvars();
+			this.slaveProxyId = packet.readInt32();
+			this.executionTime = packet.readInt32();
+			const schemaLength = packet.readInt8();
+			this.errorCode = packet.readInt16();
+			const statusVarsLength = packet.readInt16();
+			const statusVars = packet.readBuffer(statusVarsLength);
+			this.schema = packet.readString(schemaLength);
+			packet.readInt8();
+			this.statusVars = parseStatusVars(statusVars);
+			this.query = packet.readString();
+			this.name = "QueryEvent";
+		}
+	};
+	var XidEvent = class {
+		constructor(packet) {
+			this.binlogVersion = packet.readInt16();
+			this.xid = packet.readInt64();
+			this.name = "XidEvent";
+		}
+	};
+	eventParsers[2] = QueryEvent;
+	eventParsers[4] = RotateEvent;
+	eventParsers[15] = FormatDescriptionEvent;
+	eventParsers[16] = XidEvent;
+	module.exports = BinlogDump$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/change_user.js
+var require_change_user = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/change_user.js": ((exports, module) => {
+	const Command$1 = require_command();
+	const Packets$1 = require_packets();
+	const ClientConstants$1 = require_client();
+	const ClientHandshake$1 = require_client_handshake();
+	const CharsetToEncoding$1 = require_charset_encodings();
+	var ChangeUser$1 = class ChangeUser$1 extends Command$1 {
+		constructor(options, callback) {
+			super();
+			this.onResult = callback;
+			this.user = options.user;
+			this.password = options.password;
+			this.password1 = options.password;
+			this.password2 = options.password2;
+			this.password3 = options.password3;
+			this.database = options.database;
+			this.passwordSha1 = options.passwordSha1;
+			this.charsetNumber = options.charsetNumber;
+			this.currentConfig = options.currentConfig;
+			this.authenticationFactor = 0;
+		}
+		start(packet, connection) {
+			const newPacket = new Packets$1.ChangeUser({
+				flags: connection.config.clientFlags,
+				user: this.user,
+				database: this.database,
+				charsetNumber: this.charsetNumber,
+				password: this.password,
+				passwordSha1: this.passwordSha1,
+				authPluginData1: connection._handshakePacket.authPluginData1,
+				authPluginData2: connection._handshakePacket.authPluginData2
+			});
+			this.currentConfig.user = this.user;
+			this.currentConfig.password = this.password;
+			this.currentConfig.database = this.database;
+			this.currentConfig.charsetNumber = this.charsetNumber;
+			connection.clientEncoding = CharsetToEncoding$1[this.charsetNumber];
+			connection._statements.clear();
+			connection.writePacket(newPacket.toPacket());
+			if (connection.serverCapabilityFlags & ClientConstants$1.MULTI_FACTOR_AUTHENTICATION) this.authenticationFactor = 1;
+			return ChangeUser$1.prototype.handshakeResult;
+		}
+	};
+	ChangeUser$1.prototype.handshakeResult = ClientHandshake$1.prototype.handshakeResult;
+	ChangeUser$1.prototype.calculateNativePasswordAuthToken = ClientHandshake$1.prototype.calculateNativePasswordAuthToken;
+	module.exports = ChangeUser$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/quit.js
+var require_quit = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/quit.js": ((exports, module) => {
+	const Command = require_command();
+	const CommandCode = require_commands$1();
+	const Packet = require_packet();
+	var Quit$1 = class extends Command {
+		constructor(callback) {
+			super();
+			this.onResult = callback;
+		}
+		start(packet, connection) {
+			connection._closing = true;
+			const quit = new Packet(0, Buffer.from([
+				1,
+				0,
+				0,
+				0,
+				CommandCode.QUIT
+			]), 0, 5);
+			if (this.onResult) this.onResult();
+			connection.writePacket(quit);
+			return null;
+		}
+	};
+	module.exports = Quit$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/index.js
+var require_commands = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/commands/index.js": ((exports, module) => {
+	const ClientHandshake = require_client_handshake();
+	const ServerHandshake = require_server_handshake();
+	const Query = require_query();
+	const Prepare = require_prepare();
+	const CloseStatement = require_close_statement();
+	const Execute = require_execute();
+	const Ping = require_ping();
+	const RegisterSlave = require_register_slave();
+	const BinlogDump = require_binlog_dump();
+	const ChangeUser = require_change_user();
+	const Quit = require_quit();
+	module.exports = {
+		ClientHandshake,
+		ServerHandshake,
+		Query,
+		Prepare,
+		CloseStatement,
+		Execute,
+		Ping,
+		RegisterSlave,
+		BinlogDump,
+		ChangeUser,
+		Quit
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/package.json
+var require_package = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/package.json": ((exports, module) => {
+	module.exports = {
+		"name": "mysql2",
+		"version": "3.14.4",
+		"description": "fast mysql driver. Implements core protocol, prepared statements, ssl and compression in native JS",
+		"main": "index.js",
+		"typings": "typings/mysql/index",
+		"type": "commonjs",
+		"scripts": {
+			"lint": "eslint . && prettier --check .",
+			"lint:fix": "eslint . --fix && prettier --write .",
+			"test": "poku -d -r=verbose --sequential test/esm test/unit test/integration",
+			"test:bun": "bun poku -d --sequential test/esm test/unit test/integration",
+			"test:deno": "deno run --allow-read --allow-env --allow-run npm:poku -d --sequential --denoAllow=\"read,env,net,sys\" test/esm test/unit test/integration",
+			"test:tsc-build": "cd \"test/tsc-build\" && npx tsc -p \"tsconfig.json\"",
+			"coverage-test": "c8 npm run test",
+			"benchmark": "node ./benchmarks/benchmark.js",
+			"wait-port": "wait-on"
+		},
+		"repository": {
+			"type": "git",
+			"url": "git+https://github.com/sidorares/node-mysql2.git"
+		},
+		"homepage": "https://sidorares.github.io/node-mysql2/docs",
+		"keywords": [
+			"mysql",
+			"client",
+			"server"
+		],
+		"files": [
+			"lib",
+			"typings/mysql",
+			"index.js",
+			"index.d.ts",
+			"promise.js",
+			"promise.d.ts"
+		],
+		"exports": {
+			".": "./index.js",
+			"./package.json": "./package.json",
+			"./promise": "./promise.js",
+			"./promise.js": "./promise.js"
+		},
+		"engines": { "node": ">= 8.0" },
+		"author": "Andrey Sidorov <andrey.sidorov@gmail.com>",
+		"license": "MIT",
+		"dependencies": {
+			"aws-ssl-profiles": "^1.1.1",
+			"denque": "^2.1.0",
+			"generate-function": "^2.3.1",
+			"iconv-lite": "^0.7.0",
+			"long": "^5.2.1",
+			"lru.min": "^1.0.0",
+			"named-placeholders": "^1.1.3",
+			"seq-queue": "^0.0.5",
+			"sqlstring": "^2.3.2"
+		},
+		"devDependencies": {
+			"@eslint/eslintrc": "^3.3.0",
+			"@eslint/js": "^9.21.0",
+			"@eslint/markdown": "^7.0.0",
+			"@types/node": "^24.0.0",
+			"@typescript-eslint/eslint-plugin": "^8.26.0",
+			"@typescript-eslint/parser": "^8.26.0",
+			"assert-diff": "^3.0.2",
+			"benchmark": "^2.1.4",
+			"c8": "^10.1.1",
+			"error-stack-parser": "^2.0.3",
+			"eslint-config-prettier": "^10.0.2",
+			"eslint-plugin-async-await": "^0.0.0",
+			"eslint-plugin-markdown": "^5.1.0",
+			"eslint-plugin-prettier": "^5.2.3",
+			"globals": "^16.0.0",
+			"poku": "^3.0.0",
+			"portfinder": "^1.0.28",
+			"prettier": "^3.0.0",
+			"typescript": "^5.0.2"
+		}
+	};
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/aws-ssl-profiles@1.1.2/node_modules/aws-ssl-profiles/lib/profiles/ca/defaults.js
+var require_defaults = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/aws-ssl-profiles@1.1.2/node_modules/aws-ssl-profiles/lib/profiles/ca/defaults.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.defaults = void 0;
+	/**
+	* CA Certificates for **Amazon RDS** (2024)
+	*
+	* - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html
+	* - https://docs.amazonaws.cn/en_us/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html
+	* - https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.tls
+	*/
+	exports.defaults = [
+		"-----BEGIN CERTIFICATE-----\nMIIEEjCCAvqgAwIBAgIJAM2ZN/+nPi27MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0Ew\nHhcNMTkxMDI4MTgwNTU4WhcNMjQxMDI2MTgwNTU4WjCBlTELMAkGA1UEBhMCVVMx\nEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nJjAkBgNVBAMMHUFtYXpvbiBSRFMgYWYtc291dGgtMSBSb290IENBMIIBIjANBgkq\nhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwR2351uPMZaJk2gMGT+1sk8HE9MQh2rc\n/sCnbxGn2p1c7Oi9aBbd/GiFijeJb2BXvHU+TOq3d3Jjqepq8tapXVt4ojbTJNyC\nJ5E7r7KjTktKdLxtBE1MK25aY+IRJjtdU6vG3KiPKUT1naO3xs3yt0F76WVuFivd\n9OHv2a+KHvPkRUWIxpmAHuMY9SIIMmEZtVE7YZGx5ah0iO4JzItHcbVR0y0PBH55\narpFBddpIVHCacp1FUPxSEWkOpI7q0AaU4xfX0fe1BV5HZYRKpBOIp1TtZWvJD+X\njGUtL1BEsT5vN5g9MkqdtYrC+3SNpAk4VtpvJrdjraI/hhvfeXNnAwIDAQABo2Mw\nYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUEEi/\nWWMcBJsoGXg+EZwkQ0MscZQwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0Ms\ncZQwDQYJKoZIhvcNAQELBQADggEBAGDZ5js5Pc/gC58LJrwMPXFhJDBS8QuDm23C\nFFUdlqucskwOS3907ErK1ZkmVJCIqFLArHqskFXMAkRZ2PNR7RjWLqBs+0znG5yH\nhRKb4DXzhUFQ18UBRcvT6V6zN97HTRsEEaNhM/7k8YLe7P8vfNZ28VIoJIGGgv9D\nwQBBvkxQ71oOmAG0AwaGD0ORGUfbYry9Dz4a4IcUsZyRWRMADixgrFv6VuETp26s\n/+z+iqNaGWlELBKh3iQCT6Y/1UnkPLO42bxrCSyOvshdkYN58Q2gMTE1SVTqyo8G\nLw8lLAz9bnvUSgHzB3jRrSx6ggF/WRMRYlR++y6LXP4SAsSAaC0=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEEjCCAvqgAwIBAgIJAJYM4LxvTZA6MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0Ew\nHhcNMTkxMDMwMjAyMDM2WhcNMjQxMDI4MjAyMDM2WjCBlTELMAkGA1UEBhMCVVMx\nEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nJjAkBgNVBAMMHUFtYXpvbiBSRFMgZXUtc291dGgtMSBSb290IENBMIIBIjANBgkq\nhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqM921jXCXeqpRNCS9CBPOe5N7gMaEt+D\ns5uR3riZbqzRlHGiF1jZihkXfHAIQewDwy+Yz+Oec1aEZCQMhUHxZJPusuX0cJfj\nb+UluFqHIijL2TfXJ3D0PVLLoNTQJZ8+GAPECyojAaNuoHbdVqxhOcznMsXIXVFq\nyVLKDGvyKkJjai/iSPDrQMXufg3kWt0ISjNLvsG5IFXgP4gttsM8i0yvRd4QcHoo\nDjvH7V3cS+CQqW5SnDrGnHToB0RLskE1ET+oNOfeN9PWOxQprMOX/zmJhnJQlTqD\nQP7jcf7SddxrKFjuziFiouskJJyNDsMjt1Lf60+oHZhed2ogTeifGwIDAQABo2Mw\nYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUFBAF\ncgJe/BBuZiGeZ8STfpkgRYQwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkg\nRYQwDQYJKoZIhvcNAQELBQADggEBAKAYUtlvDuX2UpZW9i1QgsjFuy/ErbW0dLHU\ne/IcFtju2z6RLZ+uF+5A8Kme7IKG1hgt8s+w9TRVQS/7ukQzoK3TaN6XKXRosjtc\no9Rm4gYWM8bmglzY1TPNaiI4HC7546hSwJhubjN0bXCuj/0sHD6w2DkiGuwKNAef\nyTu5vZhPkeNyXLykxkzz7bNp2/PtMBnzIp+WpS7uUDmWyScGPohKMq5PqvL59z+L\nZI3CYeMZrJ5VpXUg3fNNIz/83N3G0sk7wr0ohs/kHTP7xPOYB0zD7Ku4HA0Q9Swf\nWX0qr6UQgTPMjfYDLffI7aEId0gxKw1eGYc6Cq5JAZ3ipi/cBFc=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEEjCCAvqgAwIBAgIJANew34ehz5l8MA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEmMCQGA1UEAwwdQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0Ew\nHhcNMTkwNTEwMjE0ODI3WhcNMjQwNTA4MjE0ODI3WjCBlTELMAkGA1UEBhMCVVMx\nEDAOBgNVBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoM\nGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMx\nJjAkBgNVBAMMHUFtYXpvbiBSRFMgbWUtc291dGgtMSBSb290IENBMIIBIjANBgkq\nhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp7BYV88MukcY+rq0r79+C8UzkT30fEfT\naPXbx1d6M7uheGN4FMaoYmL+JE1NZPaMRIPTHhFtLSdPccInvenRDIatcXX+jgOk\nUA6lnHQ98pwN0pfDUyz/Vph4jBR9LcVkBbe0zdoKKp+HGbMPRU0N2yNrog9gM5O8\ngkU/3O2csJ/OFQNnj4c2NQloGMUpEmedwJMOyQQfcUyt9CvZDfIPNnheUS29jGSw\nERpJe/AENu8Pxyc72jaXQuD+FEi2Ck6lBkSlWYQFhTottAeGvVFNCzKszCntrtqd\nrdYUwurYsLTXDHv9nW2hfDUQa0mhXf9gNDOBIVAZugR9NqNRNyYLHQIDAQABo2Mw\nYTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU54cf\nDjgwBx4ycBH8+/r8WXdaiqYwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXda\niqYwDQYJKoZIhvcNAQELBQADggEBAIIMTSPx/dR7jlcxggr+O6OyY49Rlap2laKA\neC/XI4ySP3vQkIFlP822U9Kh8a9s46eR0uiwV4AGLabcu0iKYfXjPkIprVCqeXV7\nny9oDtrbflyj7NcGdZLvuzSwgl9SYTJp7PVCZtZutsPYlbJrBPHwFABvAkMvRtDB\nhitIg4AESDGPoCl94sYHpfDfjpUDMSrAMDUyO6DyBdZH5ryRMAs3lGtsmkkNUrso\naTW6R05681Z0mvkRdb+cdXtKOSuDZPoe2wJJIaz3IlNQNSrB5TImMYgmt6iAsFhv\n3vfTSTKrZDNTJn4ybG6pq1zWExoXsktZPylJly6R3RBwV6nwqBM=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBjCCAu6gAwIBAgIJAMc0ZzaSUK51MA0GCSqGSIb3DQEBCwUAMIGPMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkw\nODIyMTcwODUwWhcNMjQwODIyMTcwODUwWjCBjzELMAkGA1UEBhMCVVMxEDAOBgNV\nBAcMB1NlYXR0bGUxEzARBgNVBAgMCldhc2hpbmd0b24xIjAgBgNVBAoMGUFtYXpv\nbiBXZWIgU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxIDAeBgNV\nBAMMF0FtYXpvbiBSRFMgUm9vdCAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEArXnF/E6/Qh+ku3hQTSKPMhQQlCpoWvnIthzX6MK3p5a0eXKZ\noWIjYcNNG6UwJjp4fUXl6glp53Jobn+tWNX88dNH2n8DVbppSwScVE2LpuL+94vY\n0EYE/XxN7svKea8YvlrqkUBKyxLxTjh+U/KrGOaHxz9v0l6ZNlDbuaZw3qIWdD/I\n6aNbGeRUVtpM6P+bWIoxVl/caQylQS6CEYUk+CpVyJSkopwJlzXT07tMoDL5WgX9\nO08KVgDNz9qP/IGtAcRduRcNioH3E9v981QO1zt/Gpb2f8NqAjUUCUZzOnij6mx9\nMcZ+9cWX88CRzR0vQODWuZscgI08NvM69Fn2SQIDAQABo2MwYTAOBgNVHQ8BAf8E\nBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUc19g2LzLA5j0Kxc0LjZa\npmD/vB8wHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJKoZIhvcN\nAQELBQADggEBAHAG7WTmyjzPRIM85rVj+fWHsLIvqpw6DObIjMWokpliCeMINZFV\nynfgBKsf1ExwbvJNzYFXW6dihnguDG9VMPpi2up/ctQTN8tm9nDKOy08uNZoofMc\nNUZxKCEkVKZv+IL4oHoeayt8egtv3ujJM6V14AstMQ6SwvwvA93EP/Ug2e4WAXHu\ncbI1NAbUgVDqp+DRdfvZkgYKryjTWd/0+1fS8X1bBZVWzl7eirNVnHbSH2ZDpNuY\n0SBd8dj5F6ld3t58ydZbrTHze7JJOd8ijySAp4/kiu9UfZWuTPABzDa/DSdz9Dk/\nzPW4CXXvhLmE02TA9/HeCw3KEHIwicNuEfw=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEEDCCAvigAwIBAgIJAKFMXyltvuRdMA0GCSqGSIb3DQEBCwUAMIGUMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzElMCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTAe\nFw0xOTA4MTkxNzM4MjZaFw0yNDA4MTkxNzM4MjZaMIGUMQswCQYDVQQGEwJVUzEQ\nMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UECgwZ\nQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEl\nMCMGA1UEAwwcQW1hem9uIFJEUyBCZXRhIFJvb3QgMjAxOSBDQTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMkZdnIH9ndatGAcFo+DppGJ1HUt4x+zeO+0\nZZ29m0sfGetVulmTlv2d5b66e+QXZFWpcPQMouSxxYTW08TbrQiZngKr40JNXftA\natvzBqIImD4II0ZX5UEVj2h98qe/ypW5xaDN7fEa5e8FkYB1TEemPaWIbNXqchcL\ntV7IJPr3Cd7Z5gZJlmujIVDPpMuSiNaal9/6nT9oqN+JSM1fx5SzrU5ssg1Vp1vv\n5Xab64uOg7wCJRB9R2GC9XD04odX6VcxUAGrZo6LR64ZSifupo3l+R5sVOc5i8NH\nskdboTzU9H7+oSdqoAyhIU717PcqeDum23DYlPE2nGBWckE+eT8CAwEAAaNjMGEw\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFK2hDBWl\nsbHzt/EHd0QYOooqcFPhMB8GA1UdIwQYMBaAFK2hDBWlsbHzt/EHd0QYOooqcFPh\nMA0GCSqGSIb3DQEBCwUAA4IBAQAO/718k8EnOqJDx6wweUscGTGL/QdKXUzTVRAx\nJUsjNUv49mH2HQVEW7oxszfH6cPCaupNAddMhQc4C/af6GHX8HnqfPDk27/yBQI+\nyBBvIanGgxv9c9wBbmcIaCEWJcsLp3HzXSYHmjiqkViXwCpYfkoV3Ns2m8bp+KCO\ny9XmcCKRaXkt237qmoxoh2sGmBHk2UlQtOsMC0aUQ4d7teAJG0q6pbyZEiPyKZY1\nXR/UVxMJL0Q4iVpcRS1kaNCMfqS2smbLJeNdsan8pkw1dvPhcaVTb7CvjhJtjztF\nYfDzAI5794qMlWxwilKMmUvDlPPOTen8NNHkLwWvyFCH7Doh\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEFjCCAv6gAwIBAgIJAMzYZJ+R9NBVMA0GCSqGSIb3DQEBCwUAMIGXMQswCQYD\nVQQGEwJVUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEi\nMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1h\nem9uIFJEUzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBD\nQTAeFw0xOTA4MjEyMjI5NDlaFw0yNDA4MjEyMjI5NDlaMIGXMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEoMCYGA1UEAwwfQW1hem9uIFJEUyBQcmV2aWV3IFJvb3QgMjAxOSBDQTCCASIw\nDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM7kkS6vjgKKQTPynC2NjdN5aPPV\nO71G0JJS/2ARVBVJd93JLiGovVJilfWYfwZCs4gTRSSjrUD4D4HyqCd6A+eEEtJq\nM0DEC7i0dC+9WNTsPszuB206Jy2IUmxZMIKJAA1NHSbIMjB+b6/JhbSUi7nKdbR/\nbrj83bF+RoSA+ogrgX7mQbxhmFcoZN9OGaJgYKsKWUt5Wqv627KkGodUK8mDepgD\nS3ZfoRQRx3iceETpcmHJvaIge6+vyDX3d9Z22jmvQ4AKv3py2CmU2UwuhOltFDwB\n0ddtb39vgwrJxaGfiMRHpEP1DfNLWHAnA69/pgZPwIggidS+iBPUhgucMp8CAwEA\nAaNjMGEwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\nFGnTGpQuQ2H/DZlXMQijZEhjs7TdMB8GA1UdIwQYMBaAFGnTGpQuQ2H/DZlXMQij\nZEhjs7TdMA0GCSqGSIb3DQEBCwUAA4IBAQC3xz1vQvcXAfpcZlngiRWeqU8zQAMQ\nLZPCFNv7PVk4pmqX+ZiIRo4f9Zy7TrOVcboCnqmP/b/mNq0gVF4O+88jwXJZD+f8\n/RnABMZcnGU+vK0YmxsAtYU6TIb1uhRFmbF8K80HHbj9vSjBGIQdPCbvmR2zY6VJ\nBYM+w9U9hp6H4DVMLKXPc1bFlKA5OBTgUtgkDibWJKFOEPW3UOYwp9uq6pFoN0AO\nxMTldqWFsOF3bJIlvOY0c/1EFZXu3Ns6/oCP//Ap9vumldYMUZWmbK+gK33FPOXV\n8BQ6jNC29icv7lLDpRPwjibJBXX+peDR5UK4FdYcswWEB1Tix5X8dYu6\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSYwJAYDVQQDDB1BbWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\nMjgxODA2NTNaFw0yNDEwMjgxODA2NTNaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\nCAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\nIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\nAwwYQW1hem9uIFJEUyBhZi1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAvtV1OqmFa8zCVQSKOvPUJERLVFtd4rZmDpImc5rIoeBk7w/P\n9lcKUJjO8R/w1a2lJXx3oQ81tiY0Piw6TpT62YWVRMWrOw8+Vxq1dNaDSFp9I8d0\nUHillSSbOk6FOrPDp+R6AwbGFqUDebbN5LFFoDKbhNmH1BVS0a6YNKpGigLRqhka\ncClPslWtPqtjbaP3Jbxl26zWzLo7OtZl98dR225pq8aApNBwmtgA7Gh60HK/cX0t\n32W94n8D+GKSg6R4MKredVFqRTi9hCCNUu0sxYPoELuM+mHiqB5NPjtm92EzCWs+\n+vgWhMc6GxG+82QSWx1Vj8sgLqtE/vLrWddf5QIDAQABo2YwZDAOBgNVHQ8BAf8E\nBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUuLB4gYVJrSKJj/Gz\npqc6yeA+RcAwHwYDVR0jBBgwFoAUEEi/WWMcBJsoGXg+EZwkQ0MscZQwDQYJKoZI\nhvcNAQELBQADggEBABauYOZxUhe9/RhzGJ8MsWCz8eKcyDVd4FCnY6Qh+9wcmYNT\nLtnD88LACtJKb/b81qYzcB0Em6+zVJ3Z9jznfr6buItE6es9wAoja22Xgv44BTHL\nrimbgMwpTt3uEMXDffaS0Ww6YWb3pSE0XYI2ISMWz+xRERRf+QqktSaL39zuiaW5\ntfZMre+YhohRa/F0ZQl3RCd6yFcLx4UoSPqQsUl97WhYzwAxZZfwvLJXOc4ATt3u\nVlCUylNDkaZztDJc/yN5XQoK9W5nOt2cLu513MGYKbuarQr8f+gYU8S+qOyuSRSP\nNRITzwCRVnsJE+2JmcRInn/NcanB7uOGqTvJ9+c=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSYwJAYDVQQDDB1BbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQTAeFw0xOTEw\nMzAyMDIxMzBaFw0yNDEwMzAyMDIxMzBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\nCAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\nIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\nAwwYQW1hem9uIFJEUyBldS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAtEyjYcajx6xImJn8Vz1zjdmL4ANPgQXwF7+tF7xccmNAZETb\nbzb3I9i5fZlmrRaVznX+9biXVaGxYzIUIR3huQ3Q283KsDYnVuGa3mk690vhvJbB\nQIPgKa5mVwJppnuJm78KqaSpi0vxyCPe3h8h6LLFawVyWrYNZ4okli1/U582eef8\nRzJp/Ear3KgHOLIiCdPDF0rjOdCG1MOlDLixVnPn9IYOciqO+VivXBg+jtfc5J+L\nAaPm0/Yx4uELt1tkbWkm4BvTU/gBOODnYziITZM0l6Fgwvbwgq5duAtKW+h031lC\n37rEvrclqcp4wrsUYcLAWX79ZyKIlRxcAdvEhQIDAQABo2YwZDAOBgNVHQ8BAf8E\nBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQU7zPyc0azQxnBCe7D\nb9KAadH1QSEwHwYDVR0jBBgwFoAUFBAFcgJe/BBuZiGeZ8STfpkgRYQwDQYJKoZI\nhvcNAQELBQADggEBAFGaNiYxg7yC/xauXPlaqLCtwbm2dKyK9nIFbF/7be8mk7Q3\nMOA0of1vGHPLVQLr6bJJpD9MAbUcm4cPAwWaxwcNpxOjYOFDaq10PCK4eRAxZWwF\nNJRIRmGsl8NEsMNTMCy8X+Kyw5EzH4vWFl5Uf2bGKOeFg0zt43jWQVOX6C+aL3Cd\npRS5MhmYpxMG8irrNOxf4NVFE2zpJOCm3bn0STLhkDcV/ww4zMzObTJhiIb5wSWn\nEXKKWhUXuRt7A2y1KJtXpTbSRHQxE++69Go1tWhXtRiULCJtf7wF2Ksm0RR/AdXT\n1uR1vKyH5KBJPX3ppYkQDukoHTFR0CpB+G84NLo=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZUxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSYwJAYDVQQDDB1BbWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQTAeFw0xOTA1\nMTAyMTU4NDNaFw0yNTA2MDExMjAwMDBaMIGQMQswCQYDVQQGEwJVUzETMBEGA1UE\nCAwKV2FzaGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9u\nIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEhMB8GA1UE\nAwwYQW1hem9uIFJEUyBtZS1zb3V0aC0xIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC\nAQ8AMIIBCgKCAQEAudOYPZH+ihJAo6hNYMB5izPVBe3TYhnZm8+X3IoaaYiKtsp1\nJJhkTT0CEejYIQ58Fh4QrMUyWvU8qsdK3diNyQRoYLbctsBPgxBR1u07eUJDv38/\nC1JlqgHmMnMi4y68Iy7ymv50QgAMuaBqgEBRI1R6Lfbyrb2YvH5txjJyTVMwuCfd\nYPAtZVouRz0JxmnfsHyxjE+So56uOKTDuw++Ho4HhZ7Qveej7XB8b+PIPuroknd3\nFQB5RVbXRvt5ZcVD4F2fbEdBniF7FAF4dEiofVCQGQ2nynT7dZdEIPfPdH3n7ZmE\nlAOmwHQ6G83OsiHRBLnbp+QZRgOsjkHJxT20bQIDAQABo2YwZDAOBgNVHQ8BAf8E\nBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUOEVDM7VomRH4HVdA\nQvIMNq2tXOcwHwYDVR0jBBgwFoAU54cfDjgwBx4ycBH8+/r8WXdaiqYwDQYJKoZI\nhvcNAQELBQADggEBAHhvMssj+Th8IpNePU6RH0BiL6o9c437R3Q4IEJeFdYL+nZz\nPW/rELDPvLRUNMfKM+KzduLZ+l29HahxefejYPXtvXBlq/E/9czFDD4fWXg+zVou\nuDXhyrV4kNmP4S0eqsAP/jQHPOZAMFA4yVwO9hlqmePhyDnszCh9c1PfJSBh49+b\n4w7i/L3VBOMt8j3EKYvqz0gVfpeqhJwL4Hey8UbVfJRFJMJzfNHpePqtDRAY7yjV\nPYquRaV2ab/E+/7VFkWMM4tazYz/qsYA2jSH+4xDHvYk8LnsbcrF9iuidQmEc5sb\nFgcWaSKG4DJjcI5k7AJLWcXyTDt21Ci43LE+I9Q=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgICVIYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDQxNzEz\nMDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\nem9uIFJEUyBhcC1zb3V0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDUYOz1hGL42yUCrcsMSOoU8AeD/3KgZ4q7gP+vAz1WnY9K/kim\neWN/2Qqzlo3+mxSFQFyD4MyV3+CnCPnBl9Sh1G/F6kThNiJ7dEWSWBQGAB6HMDbC\nBaAsmUc1UIz8sLTL3fO+S9wYhA63Wun0Fbm/Rn2yk/4WnJAaMZcEtYf6e0KNa0LM\np/kN/70/8cD3iz3dDR8zOZFpHoCtf0ek80QqTich0A9n3JLxR6g6tpwoYviVg89e\nqCjQ4axxOkWWeusLeTJCcY6CkVyFvDAKvcUl1ytM5AiaUkXblE7zDFXRM4qMMRdt\nlPm8d3pFxh0fRYk8bIKnpmtOpz3RIctDrZZxAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBT99wKJftD3jb4sHoHG\ni3uGlH6W6TAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAZ17hhr3dII3hUfuHQ1hPWGrpJOX/G9dLzkprEIcCidkmRYl+\nhu1Pe3caRMh/17+qsoEErmnVq5jNY9X1GZL04IZH8YbHc7iRHw3HcWAdhN8633+K\njYEB2LbJ3vluCGnCejq9djDb6alOugdLMJzxOkHDhMZ6/gYbECOot+ph1tQuZXzD\ntZ7prRsrcuPBChHlPjmGy8M9z8u+kF196iNSUGC4lM8vLkHM7ycc1/ZOwRq9aaTe\niOghbQQyAEe03MWCyDGtSmDfr0qEk+CHN+6hPiaL8qKt4s+V9P7DeK4iW08ny8Ox\nAVS7u0OK/5+jKMAMrKwpYrBydOjTUTHScocyNw==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICQ2QwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MDUxODQ2\nMjlaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBzYS1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAMMvR+ReRnOzqJzoaPipNTt1Z2VA968jlN1+SYKUrYM3No+Vpz0H\nM6Tn0oYB66ByVsXiGc28ulsqX1HbHsxqDPwvQTKvO7SrmDokoAkjJgLocOLUAeld\n5AwvUjxGRP6yY90NV7X786MpnYb2Il9DIIaV9HjCmPt+rjy2CZjS0UjPjCKNfB8J\nbFjgW6GGscjeyGb/zFwcom5p4j0rLydbNaOr9wOyQrtt3ZQWLYGY9Zees/b8pmcc\nJt+7jstZ2UMV32OO/kIsJ4rMUn2r/uxccPwAc1IDeRSSxOrnFKhW3Cu69iB3bHp7\nJbawY12g7zshE4I14sHjv3QoXASoXjx4xgMCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFI1Fc/Ql2jx+oJPgBVYq\nccgP0pQ8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQB4VVVabVp70myuYuZ3vltQIWqSUMhkaTzehMgGcHjMf9iLoZ/I\n93KiFUSGnek5cRePyS9wcpp0fcBT3FvkjpUdCjVtdttJgZFhBxgTd8y26ImdDDMR\n4+BUuhI5msvjL08f+Vkkpu1GQcGmyFVPFOy/UY8iefu+QyUuiBUnUuEDd49Hw0Fn\n/kIPII6Vj82a2mWV/Q8e+rgN8dIRksRjKI03DEoP8lhPlsOkhdwU6Uz9Vu6NOB2Q\nLs1kbcxAc7cFSyRVJEhh12Sz9d0q/CQSTFsVJKOjSNQBQfVnLz1GwO/IieUEAr4C\njkTntH0r1LX5b/GwN4R887LvjAEdTbg1his7\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIDAIkHMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTA2MTc0\nMDIxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\nc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\nU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\nYXpvbiBSRFMgdXMtd2VzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDD2yzbbAl77OofTghDMEf624OvU0eS9O+lsdO0QlbfUfWa1Kd6\n0WkgjkLZGfSRxEHMCnrv4UPBSK/Qwn6FTjkDLgemhqBtAnplN4VsoDL+BkRX4Wwq\n/dSQJE2b+0hm9w9UMVGFDEq1TMotGGTD2B71eh9HEKzKhGzqiNeGsiX4VV+LJzdH\nuM23eGisNqmd4iJV0zcAZ+Gbh2zK6fqTOCvXtm7Idccv8vZZnyk1FiWl3NR4WAgK\nAkvWTIoFU3Mt7dIXKKClVmvssG8WHCkd3Xcb4FHy/G756UZcq67gMMTX/9fOFM/v\nl5C0+CHl33Yig1vIDZd+fXV1KZD84dEJfEvHAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBR+ap20kO/6A7pPxo3+\nT3CfqZpQWjAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAHCJky2tPjPttlDM/RIqExupBkNrnSYnOK4kr9xJ3sl8UF2DA\nPAnYsjXp3rfcjN/k/FVOhxwzi3cXJF/2Tjj39Bm/OEfYTOJDNYtBwB0VVH4ffa/6\ntZl87jaIkrxJcreeeHqYMnIxeN0b/kliyA+a5L2Yb0VPjt9INq34QDc1v74FNZ17\n4z8nr1nzg4xsOWu0Dbjo966lm4nOYIGBRGOKEkHZRZ4mEiMgr3YLkv8gSmeitx57\nZ6dVemNtUic/LVo5Iqw4n3TBS0iF2C1Q1xT/s3h+0SXZlfOWttzSluDvoMv5PvCd\npFjNn+aXLAALoihL1MJSsxydtsLjOBro5eK0Vw==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICOFAwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAxNzQ2\nMjFaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAzU72e6XbaJbi4HjJoRNjKxzUEuChKQIt7k3CWzNnmjc5\n8I1MjCpa2W1iw1BYVysXSNSsLOtUsfvBZxi/1uyMn5ZCaf9aeoA9UsSkFSZBjOCN\nDpKPCmfV1zcEOvJz26+1m8WDg+8Oa60QV0ou2AU1tYcw98fOQjcAES0JXXB80P2s\n3UfkNcnDz+l4k7j4SllhFPhH6BQ4lD2NiFAP4HwoG6FeJUn45EPjzrydxjq6v5Fc\ncQ8rGuHADVXotDbEhaYhNjIrsPL+puhjWfhJjheEw8c4whRZNp6gJ/b6WEes/ZhZ\nh32DwsDsZw0BfRDUMgUn8TdecNexHUw8vQWeC181hwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwW9bWgkWkr0U\nlrOsq2kvIdrECDgwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAEugF0Gj7HVhX0ehPZoGRYRt3PBuI2YjfrrJRTZ9X5wc\n9T8oHmw07mHmNy1qqWvooNJg09bDGfB0k5goC2emDiIiGfc/kvMLI7u+eQOoMKj6\nmkfCncyRN3ty08Po45vTLBFZGUvtQmjM6yKewc4sXiASSBmQUpsMbiHRCL72M5qV\nobcJOjGcIdDTmV1BHdWT+XcjynsGjUqOvQWWhhLPrn4jWe6Xuxll75qlrpn3IrIx\nCRBv/5r7qbcQJPOgwQsyK4kv9Ly8g7YT1/vYBlR3cRsYQjccw5ceWUj2DrMVWhJ4\nprf+E3Aa4vYmLLOUUvKnDQ1k3RGNu56V0tonsQbfsaM=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECjCCAvKgAwIBAgICEzUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTAyMDUy\nMjVaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\nem9uIFJEUyBjYS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAOxHqdcPSA2uBjsCP4DLSlqSoPuQ/X1kkJLusVRKiQE2zayB\nviuCBt4VB9Qsh2rW3iYGM+usDjltGnI1iUWA5KHcvHszSMkWAOYWLiMNKTlg6LCp\nXnE89tvj5dIH6U8WlDvXLdjB/h30gW9JEX7S8supsBSci2GxEzb5mRdKaDuuF/0O\nqvz4YE04pua3iZ9QwmMFuTAOYzD1M72aOpj+7Ac+YLMM61qOtU+AU6MndnQkKoQi\nqmUN2A9IFaqHFzRlSdXwKCKUA4otzmz+/N3vFwjb5F4DSsbsrMfjeHMo6o/nb6Nh\nYDb0VJxxPee6TxSuN7CQJ2FxMlFUezcoXqwqXD0CAwEAAaNmMGQwDgYDVR0PAQH/\nBAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFDGGpon9WfIpsggE\nCxHq8hZ7E2ESMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\nSIb3DQEBCwUAA4IBAQAvpeQYEGZvoTVLgV9rd2+StPYykMsmFjWQcyn3dBTZRXC2\nlKq7QhQczMAOhEaaN29ZprjQzsA2X/UauKzLR2Uyqc2qOeO9/YOl0H3qauo8C/W9\nr8xqPbOCDLEXlOQ19fidXyyEPHEq5WFp8j+fTh+s8WOx2M7IuC0ANEetIZURYhSp\nxl9XOPRCJxOhj7JdelhpweX0BJDNHeUFi0ClnFOws8oKQ7sQEv66d5ddxqqZ3NVv\nRbCvCtEutQMOUMIuaygDlMn1anSM8N7Wndx8G6+Uy67AnhjGx7jw/0YPPxopEj6x\nJXP8j0sJbcT9K/9/fPVLNT25RvQ/93T2+IQL4Ca2\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICYpgwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExNzMx\nNDhaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAMk3YdSZ64iAYp6MyyKtYJtNzv7zFSnnNf6vv0FB4VnfITTMmOyZ\nLXqKAT2ahZ00hXi34ewqJElgU6eUZT/QlzdIu359TEZyLVPwURflL6SWgdG01Q5X\nO++7fSGcBRyIeuQWs9FJNIIqK8daF6qw0Rl5TXfu7P9dBc3zkgDXZm2DHmxGDD69\n7liQUiXzoE1q2Z9cA8+jirDioJxN9av8hQt12pskLQumhlArsMIhjhHRgF03HOh5\ntvi+RCfihVOxELyIRTRpTNiIwAqfZxxTWFTgfn+gijTmd0/1DseAe82aYic8JbuS\nEMbrDduAWsqrnJ4GPzxHKLXX0JasCUcWyMECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPLtsq1NrwJXO13C9eHt\nsLY11AGwMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQAnWBKj5xV1A1mYd0kIgDdkjCwQkiKF5bjIbGkT3YEFFbXoJlSP\n0lZZ/hDaOHI8wbLT44SzOvPEEmWF9EE7SJzkvSdQrUAWR9FwDLaU427ALI3ngNHy\nlGJ2hse1fvSRNbmg8Sc9GBv8oqNIBPVuw+AJzHTacZ1OkyLZrz1c1QvwvwN2a+Jd\nvH0V0YIhv66llKcYDMUQJAQi4+8nbRxXWv6Gq3pvrFoorzsnkr42V3JpbhnYiK+9\nnRKd4uWl62KRZjGkfMbmsqZpj2fdSWMY1UGyN1k+kDmCSWYdrTRDP0xjtIocwg+A\nJ116n4hV/5mbA0BaPiS2krtv17YAeHABZcvz\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECjCCAvKgAwIBAgICV2YwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTExOTM2\nMjBaFw0yNDA4MjIxNzA4NTBaMIGXMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEoMCYGA1UEAwwfQW1h\nem9uIFJEUyBldS1jZW50cmFsLTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQAD\nggEPADCCAQoCggEBAMEx54X2pHVv86APA0RWqxxRNmdkhAyp2R1cFWumKQRofoFv\nn+SPXdkpIINpMuEIGJANozdiEz7SPsrAf8WHyD93j/ZxrdQftRcIGH41xasetKGl\nI67uans8d+pgJgBKGb/Z+B5m+UsIuEVekpvgpwKtmmaLFC/NCGuSsJoFsRqoa6Gh\nm34W6yJoY87UatddCqLY4IIXaBFsgK9Q/wYzYLbnWM6ZZvhJ52VMtdhcdzeTHNW0\n5LGuXJOF7Ahb4JkEhoo6TS2c0NxB4l4MBfBPgti+O7WjR3FfZHpt18A6Zkq6A2u6\nD/oTSL6c9/3sAaFTFgMyL3wHb2YlW0BPiljZIqECAwEAAaNmMGQwDgYDVR0PAQH/\nBAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFOcAToAc6skWffJa\nTnreaswAfrbcMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqG\nSIb3DQEBCwUAA4IBAQA1d0Whc1QtspK496mFWfFEQNegLh0a9GWYlJm+Htcj5Nxt\nDAIGXb+8xrtOZFHmYP7VLCT5Zd2C+XytqseK/+s07iAr0/EPF+O2qcyQWMN5KhgE\ncXw2SwuP9FPV3i+YAm11PBVeenrmzuk9NrdHQ7TxU4v7VGhcsd2C++0EisrmquWH\nmgIfmVDGxphwoES52cY6t3fbnXmTkvENvR+h3rj+fUiSz0aSo+XZUGHPgvuEKM/W\nCBD9Smc9CBoBgvy7BgHRgRUmwtABZHFUIEjHI5rIr7ZvYn+6A0O6sogRfvVYtWFc\nqpyrW1YX8mD0VlJ8fGKM3G+aCOsiiPKDV/Uafrm+\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgICGAcwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIxODE5\nNDRaFw0yNDA4MjIxNzA4NTBaMIGVMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEmMCQGA1UEAwwdQW1h\nem9uIFJEUyBldS1ub3J0aC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQCiIYnhe4UNBbdBb/nQxl5giM0XoVHWNrYV5nB0YukA98+TPn9v\nAoj1RGYmtryjhrf01Kuv8SWO+Eom95L3zquoTFcE2gmxCfk7bp6qJJ3eHOJB+QUO\nXsNRh76fwDzEF1yTeZWH49oeL2xO13EAx4PbZuZpZBttBM5zAxgZkqu4uWQczFEs\nJXfla7z2fvWmGcTagX10O5C18XaFroV0ubvSyIi75ue9ykg/nlFAeB7O0Wxae88e\nuhiBEFAuLYdqWnsg3459NfV8Yi1GnaitTym6VI3tHKIFiUvkSiy0DAlAGV2iiyJE\nq+DsVEO4/hSINJEtII4TMtysOsYPpINqeEzRAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRR0UpnbQyjnHChgmOc\nhnlc0PogzTAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAKJD4xVzSf4zSGTBJrmamo86jl1NHQxXUApAZuBZEc8tqC6TI\nT5CeoSr9CMuVC8grYyBjXblC4OsM5NMvmsrXl/u5C9dEwtBFjo8mm53rOOIm1fxl\nI1oYB/9mtO9ANWjkykuLzWeBlqDT/i7ckaKwalhLODsRDO73vRhYNjsIUGloNsKe\npxw3dzHwAZx4upSdEVG4RGCZ1D0LJ4Gw40OfD69hfkDfRVVxKGrbEzqxXRvovmDc\ntKLdYZO/6REoca36v4BlgIs1CbUXJGLSXUwtg7YXGLSVBJ/U0+22iGJmBSNcoyUN\ncjPFD9JQEhDDIYYKSGzIYpvslvGc4T5ISXFiuQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICZIEwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTIyMTMy\nMzJaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBALGiwqjiF7xIjT0Sx7zB3764K2T2a1DHnAxEOr+/EIftWKxWzT3u\nPFwS2eEZcnKqSdRQ+vRzonLBeNLO4z8aLjQnNbkizZMBuXGm4BqRm1Kgq3nlLDQn\n7YqdijOq54SpShvR/8zsO4sgMDMmHIYAJJOJqBdaus2smRt0NobIKc0liy7759KB\n6kmQ47Gg+kfIwxrQA5zlvPLeQImxSoPi9LdbRoKvu7Iot7SOa+jGhVBh3VdqndJX\n7tm/saj4NE375csmMETFLAOXjat7zViMRwVorX4V6AzEg1vkzxXpA9N7qywWIT5Y\nfYaq5M8i6vvLg0CzrH9fHORtnkdjdu1y+0MCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFFOhOx1yt3Z7mvGB9jBv\n2ymdZwiOMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQBehqY36UGDvPVU9+vtaYGr38dBbp+LzkjZzHwKT1XJSSUc2wqM\nhnCIQKilonrTIvP1vmkQi8qHPvDRtBZKqvz/AErW/ZwQdZzqYNFd+BmOXaeZWV0Q\noHtDzXmcwtP8aUQpxN0e1xkWb1E80qoy+0uuRqb/50b/R4Q5qqSfJhkn6z8nwB10\n7RjLtJPrK8igxdpr3tGUzfAOyiPrIDncY7UJaL84GFp7WWAkH0WG3H8Y8DRcRXOU\nmqDxDLUP3rNuow3jnGxiUY+gGX5OqaZg4f4P6QzOSmeQYs6nLpH0PiN00+oS1BbD\nbpWdZEttILPI+vAYkU4QuBKKDjJL6HbSd+cn\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIDAIVCMA0GCSqGSIb3DQEBCwUAMIGPMQswCQYDVQQGEwJV\nUzEQMA4GA1UEBwwHU2VhdHRsZTETMBEGA1UECAwKV2FzaGluZ3RvbjEiMCAGA1UE\nCgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJE\nUzEgMB4GA1UEAwwXQW1hem9uIFJEUyBSb290IDIwMTkgQ0EwHhcNMTkwOTEzMTcw\nNjQxWhcNMjQwODIyMTcwODUwWjCBlDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCldh\nc2hpbmd0b24xEDAOBgNVBAcMB1NlYXR0bGUxIjAgBgNVBAoMGUFtYXpvbiBXZWIg\nU2VydmljZXMsIEluYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxJTAjBgNVBAMMHEFt\nYXpvbiBSRFMgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDE+T2xYjUbxOp+pv+gRA3FO24+1zCWgXTDF1DHrh1lsPg5k7ht\n2KPYzNc+Vg4E+jgPiW0BQnA6jStX5EqVh8BU60zELlxMNvpg4KumniMCZ3krtMUC\nau1NF9rM7HBh+O+DYMBLK5eSIVt6lZosOb7bCi3V6wMLA8YqWSWqabkxwN4w0vXI\n8lu5uXXFRemHnlNf+yA/4YtN4uaAyd0ami9+klwdkZfkrDOaiy59haOeBGL8EB/c\ndbJJlguHH5CpCscs3RKtOOjEonXnKXldxarFdkMzi+aIIjQ8GyUOSAXHtQHb3gZ4\nnS6Ey0CMlwkB8vUObZU9fnjKJcL5QCQqOfwvAgMBAAGjZjBkMA4GA1UdDwEB/wQE\nAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQUPuRHohPxx4VjykmH\n6usGrLL1ETAfBgNVHSMEGDAWgBRzX2DYvMsDmPQrFzQuNlqmYP+8HzANBgkqhkiG\n9w0BAQsFAAOCAQEAUdR9Vb3y33Yj6X6KGtuthZ08SwjImVQPtknzpajNE5jOJAh8\nquvQnU9nlnMO85fVDU1Dz3lLHGJ/YG1pt1Cqq2QQ200JcWCvBRgdvH6MjHoDQpqZ\nHvQ3vLgOGqCLNQKFuet9BdpsHzsctKvCVaeBqbGpeCtt3Hh/26tgx0rorPLw90A2\nV8QSkZJjlcKkLa58N5CMM8Xz8KLWg3MZeT4DmlUXVCukqK2RGuP2L+aME8dOxqNv\nOnOz1zrL5mR2iJoDpk8+VE/eBDmJX40IJk6jBjWoxAO/RXq+vBozuF5YHN1ujE92\ntO8HItgTp37XT8bJBAiAnt5mxw+NLSqtxk2QdQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICY4kwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTMyMDEx\nNDJaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAr5u9OuLL/OF/fBNUX2kINJLzFl4DnmrhnLuSeSnBPgbb\nqddjf5EFFJBfv7IYiIWEFPDbDG5hoBwgMup5bZDbas+ZTJTotnnxVJTQ6wlhTmns\neHECcg2pqGIKGrxZfbQhlj08/4nNAPvyYCTS0bEcmQ1emuDPyvJBYDDLDU6AbCB5\n6Z7YKFQPTiCBblvvNzchjLWF9IpkqiTsPHiEt21sAdABxj9ityStV3ja/W9BfgxH\nwzABSTAQT6FbDwmQMo7dcFOPRX+hewQSic2Rn1XYjmNYzgEHisdUsH7eeXREAcTw\n61TRvaLH8AiOWBnTEJXPAe6wYfrcSd1pD0MXpoB62wIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUytwMiomQOgX5\nIchd+2lDWRUhkikwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBACf6lRDpfCD7BFRqiWM45hqIzffIaysmVfr+Jr+fBTjP\nuYe/ba1omSrNGG23bOcT9LJ8hkQJ9d+FxUwYyICQNWOy6ejicm4z0C3VhphbTPqj\nyjpt9nG56IAcV8BcRJh4o/2IfLNzC/dVuYJV8wj7XzwlvjysenwdrJCoLadkTr1h\neIdG6Le07sB9IxrGJL9e04afk37h7c8ESGSE4E+oS4JQEi3ATq8ne1B9DQ9SasXi\nIRmhNAaISDzOPdyLXi9N9V9Lwe/DHcja7hgLGYx3UqfjhLhOKwp8HtoZORixAmOI\nHfILgNmwyugAbuZoCazSKKBhQ0wgO0WZ66ZKTMG8Oho=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICUYkwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxODIx\nMTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyB1cy13ZXN0LTIgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBANCEZBZyu6yJQFZBJmSUZfSZd3Ui2gitczMKC4FLr0QzkbxY+cLa\nuVONIOrPt4Rwi+3h/UdnUg917xao3S53XDf1TDMFEYp4U8EFPXqCn/GXBIWlU86P\nPvBN+gzw3nS+aco7WXb+woTouvFVkk8FGU7J532llW8o/9ydQyDIMtdIkKTuMfho\nOiNHSaNc+QXQ32TgvM9A/6q7ksUoNXGCP8hDOkSZ/YOLiI5TcdLh/aWj00ziL5bj\npvytiMZkilnc9dLY9QhRNr0vGqL0xjmWdoEXz9/OwjmCihHqJq+20MJPsvFm7D6a\n2NKybR9U+ddrjb8/iyLOjURUZnj5O+2+OPcCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFEBxMBdv81xuzqcK5TVu\npHj+Aor8MB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQBZkfiVqGoJjBI37aTlLOSjLcjI75L5wBrwO39q+B4cwcmpj58P\n3sivv+jhYfAGEbQnGRzjuFoyPzWnZ1DesRExX+wrmHsLLQbF2kVjLZhEJMHF9eB7\nGZlTPdTzHErcnuXkwA/OqyXMpj9aghcQFuhCNguEfnROY9sAoK2PTfnTz9NJHL+Q\nUpDLEJEUfc0GZMVWYhahc0x38ZnSY2SKacIPECQrTI0KpqZv/P+ijCEcMD9xmYEb\njL4en+XKS1uJpw5fIU5Sj0MxhdGstH6S84iAE5J3GM3XHklGSFwwqPYvuTXvANH6\nuboynxRgSae59jIlAK6Jrr6GWMwQRbgcaAlW\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICEkYwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTYxOTUz\nNDdaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMiAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAufodI2Flker8q7PXZG0P0vmFSlhQDw907A6eJuF/WeMo\nGHnll3b4S6nC3oRS3nGeRMHbyU2KKXDwXNb3Mheu+ox+n5eb/BJ17eoj9HbQR1cd\ngEkIciiAltf8gpMMQH4anP7TD+HNFlZnP7ii3geEJB2GGXSxgSWvUzH4etL67Zmn\nTpGDWQMB0T8lK2ziLCMF4XAC/8xDELN/buHCNuhDpxpPebhct0T+f6Arzsiswt2j\n7OeNeLLZwIZvVwAKF7zUFjC6m7/VmTQC8nidVY559D6l0UhhU0Co/txgq3HVsMOH\nPbxmQUwJEKAzQXoIi+4uZzHFZrvov/nDTNJUhC6DqwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUwaZpaCme+EiV\nM5gcjeHZSTgOn4owHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAAR6a2meCZuXO2TF9bGqKGtZmaah4pH2ETcEVUjkvXVz\nsl+ZKbYjrun+VkcMGGKLUjS812e7eDF726ptoku9/PZZIxlJB0isC/0OyixI8N4M\nNsEyvp52XN9QundTjkl362bomPnHAApeU0mRbMDRR2JdT70u6yAzGLGsUwMkoNnw\n1VR4XKhXHYGWo7KMvFrZ1KcjWhubxLHxZWXRulPVtGmyWg/MvE6KF+2XMLhojhUL\n+9jB3Fpn53s6KMx5tVq1x8PukHmowcZuAF8k+W4gk8Y68wIwynrdZrKRyRv6CVtR\nFZ8DeJgoNZT3y/GT254VqMxxfuy2Ccb/RInd16tEvVk=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICOYIwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTcyMDA1\nMjlaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMyAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEA4dMak8W+XW8y/2F6nRiytFiA4XLwePadqWebGtlIgyCS\nkbug8Jv5w7nlMkuxOxoUeD4WhI6A9EkAn3r0REM/2f0aYnd2KPxeqS2MrtdxxHw1\nxoOxk2x0piNSlOz6yog1idsKR5Wurf94fvM9FdTrMYPPrDabbGqiBMsZZmoHLvA3\nZ+57HEV2tU0Ei3vWeGIqnNjIekS+E06KhASxrkNU5vi611UsnYZlSi0VtJsH4UGV\nLhnHl53aZL0YFO5mn/fzuNG/51qgk/6EFMMhaWInXX49Dia9FnnuWXwVwi6uX1Wn\n7kjoHi5VtmC8ZlGEHroxX2DxEr6bhJTEpcLMnoQMqwIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQUsUI5Cb3SWB8+\ngv1YLN/ABPMdxSAwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAJAF3E9PM1uzVL8YNdzb6fwJrxxqI2shvaMVmC1mXS+w\nG0zh4v2hBZOf91l1EO0rwFD7+fxoI6hzQfMxIczh875T6vUXePKVOCOKI5wCrDad\nzQbVqbFbdhsBjF4aUilOdtw2qjjs9JwPuB0VXN4/jY7m21oKEOcnpe36+7OiSPjN\nxngYewCXKrSRqoj3mw+0w/+exYj3Wsush7uFssX18av78G+ehKPIVDXptOCP/N7W\n8iKVNeQ2QGTnu2fzWsGUSvMGyM7yqT+h1ILaT//yQS8er511aHMLc142bD4D9VSy\nDgactwPDTShK/PXqhvNey9v/sKXm4XatZvwcc8KYlW4=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEDDCCAvSgAwIBAgICcEUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNjU2\nMjBaFw0yNDA4MjIxNzA4NTBaMIGZMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzEqMCgGA1UEAwwhQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMSAyMDE5IENBMIIBIjANBgkqhkiG9w0BAQEF\nAAOCAQ8AMIIBCgKCAQEAndtkldmHtk4TVQAyqhAvtEHSMb6pLhyKrIFved1WO3S7\n+I+bWwv9b2W/ljJxLq9kdT43bhvzonNtI4a1LAohS6bqyirmk8sFfsWT3akb+4Sx\n1sjc8Ovc9eqIWJCrUiSvv7+cS7ZTA9AgM1PxvHcsqrcUXiK3Jd/Dax9jdZE1e15s\nBEhb2OEPE+tClFZ+soj8h8Pl2Clo5OAppEzYI4LmFKtp1X/BOf62k4jviXuCSst3\nUnRJzE/CXtjmN6oZySVWSe0rQYuyqRl6//9nK40cfGKyxVnimB8XrrcxUN743Vud\nQQVU0Esm8OVTX013mXWQXJHP2c0aKkog8LOga0vobQIDAQABo2YwZDAOBgNVHQ8B\nAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADAdBgNVHQ4EFgQULmoOS1mFSjj+\nsnUPx4DgS3SkLFYwHwYDVR0jBBgwFoAUc19g2LzLA5j0Kxc0LjZapmD/vB8wDQYJ\nKoZIhvcNAQELBQADggEBAAkVL2P1M2/G9GM3DANVAqYOwmX0Xk58YBHQu6iiQg4j\nb4Ky/qsZIsgT7YBsZA4AOcPKQFgGTWhe9pvhmXqoN3RYltN8Vn7TbUm/ZVDoMsrM\ngwv0+TKxW1/u7s8cXYfHPiTzVSJuOogHx99kBW6b2f99GbP7O1Sv3sLq4j6lVvBX\nFiacf5LAWC925nvlTzLlBgIc3O9xDtFeAGtZcEtxZJ4fnGXiqEnN4539+nqzIyYq\nnvlgCzyvcfRAxwltrJHuuRu6Maw5AGcd2Y0saMhqOVq9KYKFKuD/927BTrbd2JVf\n2sGWyuPZPCk3gq+5pCjbD0c6DkhcMGI6WwxvM5V/zSM=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICJDQwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTgxNzAz\nMTVaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyBldS13ZXN0LTMgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAL9bL7KE0n02DLVtlZ2PL+g/BuHpMYFq2JnE2RgompGurDIZdjmh\n1pxfL3nT+QIVMubuAOy8InRfkRxfpxyjKYdfLJTPJG+jDVL+wDcPpACFVqoV7Prg\npVYEV0lc5aoYw4bSeYFhdzgim6F8iyjoPnObjll9mo4XsHzSoqJLCd0QC+VG9Fw2\nq+GDRZrLRmVM2oNGDRbGpGIFg77aRxRapFZa8SnUgs2AqzuzKiprVH5i0S0M6dWr\ni+kk5epmTtkiDHceX+dP/0R1NcnkCPoQ9TglyXyPdUdTPPRfKCq12dftqll+u4mV\nARdN6WFjovxax8EAP2OAUTi1afY+1JFMj+sCAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFLfhrbrO5exkCVgxW0x3\nY2mAi8lNMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQAigQ5VBNGyw+OZFXwxeJEAUYaXVoP/qrhTOJ6mCE2DXUVEoJeV\nSxScy/TlFA9tJXqmit8JH8VQ/xDL4ubBfeMFAIAo4WzNWDVoeVMqphVEcDWBHsI1\nAETWzfsapRS9yQekOMmxg63d/nV8xewIl8aNVTHdHYXMqhhik47VrmaVEok1UQb3\nO971RadLXIEbVd9tjY5bMEHm89JsZDnDEw1hQXBb67Elu64OOxoKaHBgUH8AZn/2\nzFsL1ynNUjOhCSAA15pgd1vjwc0YsBbAEBPcHBWYBEyME6NLNarjOzBl4FMtATSF\nwWCKRGkvqN8oxYhwR2jf2rR5Mu4DWkK5Q8Ep\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBzCCAu+gAwIBAgICJVUwDQYJKoZIhvcNAQELBQAwgY8xCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSAwHgYDVQQDDBdBbWF6b24gUkRTIFJvb3QgMjAxOSBDQTAeFw0xOTA5MTkxODE2\nNTNaFw0yNDA4MjIxNzA4NTBaMIGUMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2Fz\naGluZ3RvbjEQMA4GA1UEBwwHU2VhdHRsZTEiMCAGA1UECgwZQW1hem9uIFdlYiBT\nZXJ2aWNlcywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzElMCMGA1UEAwwcQW1h\nem9uIFJEUyB1cy1lYXN0LTEgMjAxOSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP\nADCCAQoCggEBAM3i/k2u6cqbMdcISGRvh+m+L0yaSIoOXjtpNEoIftAipTUYoMhL\nInXGlQBVA4shkekxp1N7HXe1Y/iMaPEyb3n+16pf3vdjKl7kaSkIhjdUz3oVUEYt\ni8Z/XeJJ9H2aEGuiZh3kHixQcZczn8cg3dA9aeeyLSEnTkl/npzLf//669Ammyhs\nXcAo58yvT0D4E0D/EEHf2N7HRX7j/TlyWvw/39SW0usiCrHPKDLxByLojxLdHzso\nQIp/S04m+eWn6rmD+uUiRteN1hI5ncQiA3wo4G37mHnUEKo6TtTUh+sd/ku6a8HK\nglMBcgqudDI90s1OpuIAWmuWpY//8xEG2YECAwEAAaNmMGQwDgYDVR0PAQH/BAQD\nAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFPqhoWZcrVY9mU7tuemR\nRBnQIj1jMB8GA1UdIwQYMBaAFHNfYNi8ywOY9CsXNC42WqZg/7wfMA0GCSqGSIb3\nDQEBCwUAA4IBAQB6zOLZ+YINEs72heHIWlPZ8c6WY8MDU+Be5w1M+BK2kpcVhCUK\nPJO4nMXpgamEX8DIiaO7emsunwJzMSvavSPRnxXXTKIc0i/g1EbiDjnYX9d85DkC\nE1LaAUCmCZBVi9fIe0H2r9whIh4uLWZA41oMnJx/MOmo3XyMfQoWcqaSFlMqfZM4\n0rNoB/tdHLNuV4eIdaw2mlHxdWDtF4oH+HFm+2cVBUVC1jXKrFv/euRVtsTT+A6i\nh2XBHKxQ1Y4HgAn0jACP2QSPEmuoQEIa57bEKEcZsBR8SDY6ZdTd2HLRIApcCOSF\nMRM8CKLeF658I0XgF8D5EsYoKPsA+74Z+jDH\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEETCCAvmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwgZQxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSUwIwYDVQQDDBxBbWF6b24gUkRTIEJldGEgUm9vdCAyMDE5IENBMB4XDTE5MDgy\nMDE3MTAwN1oXDTI0MDgxOTE3MzgyNlowgZkxCzAJBgNVBAYTAlVTMRMwEQYDVQQI\nDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6b24g\nV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMSowKAYDVQQD\nDCFBbWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIDIwMTkgQ0EwggEiMA0GCSqGSIb3\nDQEBAQUAA4IBDwAwggEKAoIBAQDTNCOlotQcLP8TP82U2+nk0bExVuuMVOgFeVMx\nvbUHZQeIj9ikjk+jm6eTDnnkhoZcmJiJgRy+5Jt69QcRbb3y3SAU7VoHgtraVbxF\nQDh7JEHI9tqEEVOA5OvRrDRcyeEYBoTDgh76ROco2lR+/9uCvGtHVrMCtG7BP7ZB\nsSVNAr1IIRZZqKLv2skKT/7mzZR2ivcw9UeBBTUf8xsfiYVBvMGoEsXEycjYdf6w\nWV+7XS7teNOc9UgsFNN+9AhIBc1jvee5E//72/4F8pAttAg/+mmPUyIKtekNJ4gj\nOAR2VAzGx1ybzWPwIgOudZFHXFduxvq4f1hIRPH0KbQ/gkRrAgMBAAGjZjBkMA4G\nA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBTkvpCD\n6C43rar9TtJoXr7q8dkrrjAfBgNVHSMEGDAWgBStoQwVpbGx87fxB3dEGDqKKnBT\n4TANBgkqhkiG9w0BAQsFAAOCAQEAJd9fOSkwB3uVdsS+puj6gCER8jqmhd3g/J5V\nZjk9cKS8H0e8pq/tMxeJ8kpurPAzUk5RkCspGt2l0BSwmf3ahr8aJRviMX6AuW3/\ng8aKplTvq/WMNGKLXONa3Sq8591J+ce8gtOX/1rDKmFI4wQ/gUzOSYiT991m7QKS\nFr6HMgFuz7RNJbb3Fy5cnurh8eYWA7mMv7laiLwTNsaro5qsqErD5uXuot6o9beT\na+GiKinEur35tNxAr47ax4IRubuIzyfCrezjfKc5raVV2NURJDyKP0m0CCaffAxE\nqn2dNfYc3v1D8ypg3XjHlOzRo32RB04o8ALHMD9LSwsYDLpMag==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEFzCCAv+gAwIBAgICFSUwDQYJKoZIhvcNAQELBQAwgZcxCzAJBgNVBAYTAlVT\nMRAwDgYDVQQHDAdTZWF0dGxlMRMwEQYDVQQIDApXYXNoaW5ndG9uMSIwIAYDVQQK\nDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRT\nMSgwJgYDVQQDDB9BbWF6b24gUkRTIFByZXZpZXcgUm9vdCAyMDE5IENBMB4XDTE5\nMDgyMTIyMzk0N1oXDTI0MDgyMTIyMjk0OVowgZwxCzAJBgNVBAYTAlVTMRMwEQYD\nVQQIDApXYXNoaW5ndG9uMRAwDgYDVQQHDAdTZWF0dGxlMSIwIAYDVQQKDBlBbWF6\nb24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMS0wKwYD\nVQQDDCRBbWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIDIwMTkgQ0EwggEiMA0G\nCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQD0dB/U7qRnSf05wOi7m10Pa2uPMTJv\nr6U/3Y17a5prq5Zr4++CnSUYarG51YuIf355dKs+7Lpzs782PIwCmLpzAHKWzix6\npOaTQ+WZ0+vUMTxyqgqWbsBgSCyP7pVBiyqnmLC/L4az9XnscrbAX4pNaoJxsuQe\nmzBo6yofjQaAzCX69DuqxFkVTRQnVy7LCFkVaZtjNAftnAHJjVgQw7lIhdGZp9q9\nIafRt2gteihYfpn+EAQ/t/E4MnhrYs4CPLfS7BaYXBycEKC5Muj1l4GijNNQ0Efo\nxG8LSZz7SNgUvfVwiNTaqfLP3AtEAWiqxyMyh3VO+1HpCjT7uNBFtmF3AgMBAAGj\nZjBkMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\nBBQtinkdrj+0B2+qdXngV2tgHnPIujAfBgNVHSMEGDAWgBRp0xqULkNh/w2ZVzEI\no2RIY7O03TANBgkqhkiG9w0BAQsFAAOCAQEAtJdqbCxDeMc8VN1/RzCabw9BIL/z\n73Auh8eFTww/sup26yn8NWUkfbckeDYr1BrXa+rPyLfHpg06kwR8rBKyrs5mHwJx\nbvOzXD/5WTdgreB+2Fb7mXNvWhenYuji1MF+q1R2DXV3I05zWHteKX6Dajmx+Uuq\nYq78oaCBSV48hMxWlp8fm40ANCL1+gzQ122xweMFN09FmNYFhwuW+Ao+Vv90ZfQG\nPYwTvN4n/gegw2TYcifGZC2PNX74q3DH03DXe5fvNgRW5plgz/7f+9mS+YHd5qa9\ntYTPUvoRbi169ou6jicsMKUKPORHWhiTpSCWR1FMMIbsAcsyrvtIsuaGCQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQdOCSuA9psBpQd8EI368/0DANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTE5MTgwNjI2WhgPMjA2MTA1MTkxOTA2MjZaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgc2EtZWFzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN6ftL6w8v3dB2yW\nLjCxSP1D7ZsOTeLZOSCz1Zv0Gkd0XLhil5MdHOHBvwH/DrXqFU2oGzCRuAy+aZis\nDardJU6ChyIQIciXCO37f0K23edhtpXuruTLLwUwzeEPdcnLPCX+sWEn9Y5FPnVm\npCd6J8edH2IfSGoa9LdErkpuESXdidLym/w0tWG/O2By4TabkNSmpdrCL00cqI+c\nprA8Bx1jX8/9sY0gpAovtuFaRN+Ivg3PAnWuhqiSYyQ5nC2qDparOWuDiOhpY56E\nEgmTvjwqMMjNtExfYx6Rv2Ndu50TriiNKEZBzEtkekwXInTupmYTvc7U83P/959V\nUiQ+WSMCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU4uYHdH0+\nbUeh81Eq2l5/RJbW+vswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQBhxcExJ+w74bvDknrPZDRgTeMLYgbVJjx2ExH7/Ac5FZZWcpUpFwWMIJJxtewI\nAnhryzM3tQYYd4CG9O+Iu0+h/VVfW7e4O3joWVkxNMb820kQSEwvZfA78aItGwOY\nWSaFNVRyloVicZRNJSyb1UL9EiJ9ldhxm4LTT0ax+4ontI7zTx6n6h8Sr6r/UOvX\nd9T5aUUENWeo6M9jGupHNn3BobtL7BZm2oS8wX8IVYj4tl0q5T89zDi2x0MxbsIV\n5ZjwqBQ5JWKv7ASGPb+z286RjPA9R2knF4lJVZrYuNV90rHvI/ECyt/JrDqeljGL\nBLl1W/UsvZo6ldLIpoMbbrb5\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIQUfVbqapkLYpUqcLajpTJWzANBgkqhkiG9w0BAQsFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNTA2MjMyMDA5WhgPMjA2MjA1MDcwMDIwMDlaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJIeovu3\newI9FVitXMQzvkh34aQ6WyI4NO3YepfJaePiv3cnyFGYHN2S1cR3UQcLWgypP5va\nj6bfroqwGbCbZZcb+6cyOB4ceKO9Ws1UkcaGHnNDcy5gXR7aCW2OGTUfinUuhd2d\n5bOGgV7JsPbpw0bwJ156+MwfOK40OLCWVbzy8B1kITs4RUPNa/ZJnvIbiMu9rdj4\n8y7GSFJLnKCjlOFUkNI5LcaYvI1+ybuNgphT3nuu5ZirvTswGakGUT/Q0J3dxP0J\npDfg5Sj/2G4gXiaM0LppVOoU5yEwVewhQ250l0eQAqSrwPqAkdTg9ng360zqCFPE\nJPPcgI1tdGUgneECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\n/2AJVxWdZxc8eJgdpbwpW7b0f7IwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\nCwUAA4IBAQBYm63jTu2qYKJ94gKnqc+oUgqmb1mTXmgmp/lXDbxonjszJDOXFbri\n3CCO7xB2sg9bd5YWY8sGKHaWmENj3FZpCmoefbUx++8D7Mny95Cz8R32rNcwsPTl\nebpd9A/Oaw5ug6M0x/cNr0qzF8Wk9Dx+nFEimp8RYQdKvLDfNFZHjPa1itnTiD8M\nTorAqj+VwnUGHOYBsT/0NY12tnwXdD+ATWfpEHdOXV+kTMqFFwDyhfgRVNpTc+os\nygr8SwhnSCpJPB/EYl2S7r+tgAbJOkuwUvGT4pTqrzDQEhwE7swgepnHC87zhf6l\nqN6mVpSnQKQLm6Ob5TeCEFgcyElsF5bH\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAOxu0I1QuMAhIeszB3fJIlkwCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyB1cy13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTI0MjIwNjU5WhgPMjEyMTA1MjQyMzA2NTlaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgdXMtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEz4bylRcGqqDWdP7gQIIoTHdBK6FNtKH1\n4SkEIXRXkYDmRvL9Bci1MuGrwuvrka5TDj4b7e+csY0llEzHpKfq6nJPFljoYYP9\nuqHFkv77nOpJJ633KOr8IxmeHW5RXgrZo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBQQikVz8wmjd9eDFRXzBIU8OseiGzAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIwf06Mcrpw1O0EBLBBrp84m37NYtOkE/0Z0O+C7D41wnXi\nEQdn6PXUVgdD23Gj82SrAjEAklhKs+liO1PtN15yeZR1Io98nFve+lLptaLakZcH\n+hfFuUtCqMbaI8CdvJlKnPqT\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRALyWMTyCebLZOGcZZQmkmfcwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyODAzWhgPMjEyMTA1MjQyMTI4MDNa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nwGFiyDyCrGqgdn4fXG12cxKAAfVvhMea1mw5h9CVRoavkPqhzQpAitSOuMB9DeiP\nwQyqcsiGl/cTEau4L+AUBG8b9v26RlY48exUYBXj8CieYntOT9iNw5WtdYJa3kF/\nJxgI+HDMzE9cmHDs5DOO3S0uwZVyra/xE1ymfSlpOeUIOTpHRJv97CBUEpaZMUW5\nSr6GruuOwFVpO5FX3A/jQlcS+UN4GjSRgDUJuqg6RRQldEZGCVCCmodbByvI2fGm\nreGpsPJD54KkmAX08nOR8e5hkGoHxq0m2DLD4SrOFmt65vG47qnuwplWJjtk9B3Z\n9wDoopwZLBOtlkPIkUllWm1P8EuHC1IKOA+wSP6XdT7cy8S77wgyHzR0ynxv7q/l\nvlZtH30wnNqFI0y9FeogD0TGMCHcnGqfBSicJXPy9T4fU6f0r1HwqKwPp2GArwe7\ndnqLTj2D7M9MyVtFjEs6gfGWXmu1y5uDrf+CszurE8Cycoma+OfjjuVQgWOCy7Nd\njJswPxAroTzVfpgoxXza4ShUY10woZu0/J+HmNmqK7lh4NS75q1tz75in8uTZDkV\nbe7GK+SEusTrRgcf3tlgPjSTWG3veNzFDF2Vn1GLJXmuZfhdlVQDBNXW4MNREExS\ndG57kJjICpT+r8X+si+5j51gRzkSnMYs7VHulpxfcwECAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQU4JWOpDBmUBuWKvGPZelw87ezhL8wDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBRNLMql7itvXSEFQRAnyOjivHz\nl5IlWVQjAbOUr6ogZcwvK6YpxNAFW5zQr8F+fdkiypLz1kk5irx9TIpff0BWC9hQ\n/odMPO8Gxn8+COlSvc+dLsF2Dax3Hvz0zLeKMo+cYisJOzpdR/eKd0/AmFdkvQoM\nAOK9n0yYvVJU2IrSgeJBiiCarpKSeAktEVQ4rvyacQGr+QAPkkjRwm+5LHZKK43W\nnNnggRli9N/27qYtc5bgr3AaQEhEXMI4RxPRXCLsod0ehMGWyRRK728a+6PMMJAJ\nWHOU0x7LCEMPP/bvpLj3BdvSGqNor4ZtyXEbwREry1uzsgODeRRns5acPwTM6ff+\nCmxO2NZ0OktIUSYRmf6H/ZFlZrIhV8uWaIwEJDz71qvj7buhQ+RFDZ9CNL64C0X6\nmf0zJGEpddjANHaaVky+F4gYMtEy2K2Lcm4JGTdyIzUoIe+atzCnRp0QeIcuWtF+\ns8AjDYCVFNypcMmqbRmNpITSnOoCHSRuVkY3gutVoYyMLbp8Jm9SJnCIlEWTA6Rm\nwADOMGZJVn5/XRTRuetVOB3KlQDjs9OO01XN5NzGSZO2KT9ngAUfh9Eqhf1iRWSP\nnZlRbQ2NRCuY/oJ5N59mLGxnNJSE7giEKEBRhTQ/XEPIUYAUPD5fca0arKRJwbol\nl9Se1Hsq0ZU5f+OZKQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAK7vlRrGVEePJpW1VHMXdlIwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MTkxOTI4NDNaGA8yMTIxMDUxOTIwMjg0M1owgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhZi1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMZiHOQC6x4o\neC7vVOMCGiN5EuLqPYHdceFPm4h5k/ZejXTf7kryk6aoKZKsDIYihkaZwXVS7Y/y\n7Ig1F1ABi2jD+CYprj7WxXbhpysmN+CKG7YC3uE4jSvfvUnpzionkQbjJsRJcrPO\ncZJM4FVaVp3mlHHtvnM+K3T+ni4a38nAd8xrv1na4+B8ZzZwWZXarfg8lJoGskSn\nou+3rbGQ0r+XlUP03zWujHoNlVK85qUIQvDfTB7n3O4s1XNGvkfv3GNBhYRWJYlB\n4p8T+PFN8wG+UOByp1gV7BD64RnpuZ8V3dRAlO6YVAmINyG5UGrPzkIbLtErUNHO\n4iSp4UqYvztDqJWWHR/rA84ef+I9RVwwZ8FQbjKq96OTnPrsr63A5mXTC9dXKtbw\nXNJPQY//FEdyM3K8sqM0IdCzxCA1MXZ8+QapWVjwyTjUwFvL69HYky9H8eAER59K\n5I7u/CWWeCy2R1SYUBINc3xxLr0CGGukcWPEZW2aPo5ibW5kepU1P/pzdMTaTfao\nF42jSFXbc7gplLcSqUgWwzBnn35HLTbiZOFBPKf6vRRu8aRX9atgHw/EjCebi2xP\nxIYr5Ub8u0QVHIqcnF1/hVzO/Xz0chj3E6VF/yTXnsakm+W1aM2QkZbFGpga+LMy\nmFCtdPrELjea2CfxgibaJX1Q4rdEpc8DAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFDSaycEyuspo/NOuzlzblui8KotFMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAbosemjeTRsL9o4v0KadBUNS3V7gdAH+X4vH2\nEe1Jc91VOGLdd/s1L9UX6bhe37b9WjUD69ur657wDW0RzxMYgQdZ27SUl0tEgGGp\ncCmVs1ky3zEN+Hwnhkz+OTmIg1ufq0W2hJgJiluAx2r1ib1GB+YI3Mo3rXSaBYUk\nbgQuujYPctf0PA153RkeICE5GI3OaJ7u6j0caYEixBS3PDHt2MJWexITvXGwHWwc\nCcrC05RIrTUNOJaetQw8smVKYOfRImEzLLPZ5kf/H3Cbj8BNAFNsa10wgvlPuGOW\nXLXqzNXzrG4V3sjQU5YtisDMagwYaN3a6bBf1wFwFIHQoAPIgt8q5zaQ9WI+SBns\nIl6rd4zfvjq/BPmt0uI7rVg/cgbaEg/JDL2neuM9CJAzmKxYxLQuHSX2i3Fy4Y1B\ncnxnRQETCRZNPGd00ADyxPKVoYBC45/t+yVusArFt+2SVLEGiFBr23eG2CEZu+HS\nnDEgIfQ4V3YOTUNa86wvbAss1gbbnT/v1XCnNGClEWCWNCSRjwV2ZmQ/IVTmNHPo\n7axTTBBJbKJbKzFndCnuxnDXyytdYRgFU7Ly3sa27WS2KFyFEDebLFRHQEfoYqCu\nIupSqBSbXsR3U10OTjc9z6EPo1nuV6bdz+gEDthmxKa1NI+Qb1kvyliXQHL2lfhr\n5zT5+Bs=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAOLV6zZcL4IV2xmEneN1GwswDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE5MDg1OFoYDzIxMjEwNTE5MjAwODU4WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC7koAKGXXlLixN\nfVjhuqvz0WxDeTQfhthPK60ekRpftkfE5QtnYGzeovaUAiS58MYVzqnnTACDwcJs\nIGTFE6Wd7sB6r8eI/3CwI1pyJfxepubiQNVAQG0zJETOVkoYKe/5KnteKtnEER3X\ntCBRdV/rfbxEDG9ZAsYfMl6zzhEWKF88G6xhs2+VZpDqwJNNALvQuzmTx8BNbl5W\nRUWGq9CQ9GK9GPF570YPCuURW7kl35skofudE9bhURNz51pNoNtk2Z3aEeRx3ouT\nifFJlzh+xGJRHqBG7nt5NhX8xbg+vw4xHCeq1aAe6aVFJ3Uf9E2HzLB4SfIT9bRp\nP7c9c0ySGt+3n+KLSHFf/iQ3E4nft75JdPjeSt0dnyChi1sEKDi0tnWGiXaIg+J+\nr1ZtcHiyYpCB7l29QYMAdD0TjfDwwPayLmq//c20cPmnSzw271VwqjUT0jYdrNAm\ngV+JfW9t4ixtE3xF2jaUh/NzL3bAmN5v8+9k/aqPXlU1BgE3uPwMCjrfn7V0I7I1\nWLpHyd9jF3U/Ysci6H6i8YKgaPiOfySimQiDu1idmPld659qerutUSemQWmPD3bE\ndcjZolmzS9U0Ujq/jDF1YayN3G3xvry1qWkTci0qMRMu2dZu30Herugh9vsdTYkf\n00EqngPbqtIVLDrDjEQLqPcb8QvWFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBQBqg8Za/L0YMHURGExHfvPyfLbOTAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBACAGPMa1QL7P/FIO7jEtMelJ0hQlQepKnGtbKz4r\nXq1bUX1jnLvnAieR9KZmeQVuKi3g3CDU6b0mDgygS+FL1KDDcGRCSPh238Ou8KcG\nHIxtt3CMwMHMa9gmdcMlR5fJF9vhR0C56KM2zvyelUY51B/HJqHwGvWuexryXUKa\nwq1/iK2/d9mNeOcjDvEIj0RCMI8dFQCJv3PRCTC36XS36Tzr6F47TcTw1c3mgKcs\nxpcwt7ezrXMUunzHS4qWAA5OGdzhYlcv+P5GW7iAA7TDNrBF+3W4a/6s9v2nQAnX\nUvXd9ul0ob71377UhZbJ6SOMY56+I9cJOOfF5QvaL83Sz29Ij1EKYw/s8TYdVqAq\n+dCyQZBkMSnDFLVe3J1KH2SUSfm3O98jdPORQrUlORQVYCHPls19l2F6lCmU7ICK\nhRt8EVSpXm4sAIA7zcnR2nU00UH8YmMQLnx5ok9YGhuh3Ehk6QlTQLJux6LYLskd\n9YHOLGW/t6knVtV78DgPqDeEx/Wu/5A8R0q7HunpWxr8LCPBK6hksZnOoUhhb8IP\nvl46Ve5Tv/FlkyYr1RTVjETmg7lb16a8J0At14iLtpZWmwmuv4agss/1iBVMXfFk\n+ZGtx5vytWU5XJmsfKA51KLsMQnhrLxb3X3zC+JRCyJoyc8++F3YEcRi2pkRYE3q\nHing\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRANxgyBbnxgTEOpDul2ZnC0UwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNjEwMTgxOTA3WhgPMjA2MTA2MTAxOTE5MDda\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nxnwSDAChrMkfk5TA4Dk8hKzStDlSlONzmd3fTG0Wqr5+x3EmFT6Ksiu/WIwEl9J2\nK98UI7vYyuZfCxUKb1iMPeBdVGqk0zb92GpURd+Iz/+K1ps9ZLeGBkzR8mBmAi1S\nOfpwKiTBzIv6E8twhEn4IUpHsdcuX/2Y78uESpJyM8O5CpkG0JaV9FNEbDkJeBUQ\nAo2qqNcH4R0Qcr5pyeqA9Zto1RswgL06BQMI9dTpfwSP5VvkvcNUaLl7Zv5WzLQE\nJzORWePvdPzzvWEkY/3FPjxBypuYwssKaERW0fkPDmPtykktP9W/oJolKUFI6pXp\ny+Y6p6/AVdnQD2zZjW5FhQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBT+jEKs96LC+/X4BZkUYUkzPfXdqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAIGQqgqcQ6XSGkmNebzR6DhadTbfDmbYeN5N0Vuzv+Tdmufb\ntMGjdjnYMg4B+IVnTKQb+Ox3pL9gbX6KglGK8HupobmIRtwKVth+gYYz3m0SL/Nk\nhaWPYzOm0x3tJm8jSdufJcEob4/ATce9JwseLl76pSWdl5A4lLjnhPPKudUDfH+1\nBLNUi3lxpp6GkC8aWUPtupnhZuXddolTLOuA3GwTZySI44NfaFRm+o83N1jp+EwD\n6e94M4cTRzjUv6J3MZmSbdtQP/Tk1uz2K4bQZGP0PZC3bVpqiesdE/xr+wbu8uHr\ncM1JXH0AmXf1yIkTgyWzmvt0k1/vgcw5ixAqvvE=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEATCCAumgAwIBAgIRAMhw98EQU18mIji+unM2YH8wDQYJKoZIhvcNAQELBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQyMjJaGA8yMDYyMDYwNjIyNDIyMlowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIeeRoLfTm+7\nvqm7ZlFSx+1/CGYHyYrOOryM4/Z3dqYVHFMgWTR7V3ziO8RZ6yUanrRcWVX3PZbF\nAfX0KFE8OgLsXEZIX8odSrq86+/Th5eZOchB2fDBsUB7GuN2rvFBbM8lTI9ivVOU\nlbuTnYyb55nOXN7TpmH2bK+z5c1y9RVC5iQsNAl6IJNvSN8VCqXh31eK5MlKB4DT\n+Y3OivCrSGsjM+UR59uZmwuFB1h+icE+U0p9Ct3Mjq3MzSX5tQb6ElTNGlfmyGpW\nKh7GQ5XU1KaKNZXoJ37H53woNSlq56bpVrKI4uv7ATpdpFubOnSLtpsKlpLdR3sy\nWs245200pC8CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUp0ki\n6+eWvsnBjQhMxwMW5pwn7DgwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUA\nA4IBAQB2V8lv0aqbYQpj/bmVv/83QfE4vOxKCJAHv7DQ35cJsTyBdF+8pBczzi3t\n3VNL5IUgW6WkyuUOWnE0eqAFOUVj0yTS1jSAtfl3vOOzGJZmWBbqm9BKEdu1D8O6\nsB8bnomwiab2tNDHPmUslpdDqdabbkWwNWzLJ97oGFZ7KNODMEPXWKWNxg33iHfS\n/nlmnrTVI3XgaNK9qLZiUrxu9Yz5gxi/1K+sG9/Dajd32ZxjRwDipOLiZbiXQrsd\nqzIMY4GcWf3g1gHL5mCTfk7dG22h/rhPyGV0svaDnsb+hOt6sv1McMN6Y3Ou0mtM\n/UaAXojREmJmTSCNvs2aBny3/2sy\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAMnRxsKLYscJV8Qv5pWbL7swCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTgxNjAxWhgPMjEyMTA1MTkxOTE2MDFaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgc2EtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEjFOCZgTNVKxLKhUxffiDEvTLFhrmIqdO\ndKqVdgDoELEzIHWDdC+19aDPitbCYtBVHl65ITu/9pn6mMUl5hhUNtfZuc6A+Iw1\nsBe0v0qI3y9Q9HdQYrGgeHDh8M5P7E2ho0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBS5L7/8M0TzoBZk39Ps7BkfTB4yJTAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIwI43O0NtWKTgnVv9z0LO5UMZYgSve7GvGTwqktZYCMObE\nrUI4QerXM9D6JwLy09mqAjEAypfkdLyVWtaElVDUyHFkihAS1I1oUxaaDrynLNQK\nOu/Ay+ns+J+GyvyDUjBpVVW1\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQR71Z8lTO5Sj+as2jB7IWXzANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI0MjIwMzIwWhgPMjEyMTA1MjQyMzAzMjBaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAM977bHIs1WJijrS\nXQMfUOhmlJjr2v0K0UjPl52sE1TJ76H8umo1yR4T7Whkd9IwBHNGKXCJtJmMr9zp\nfB38eLTu+5ydUAXdFuZpRMKBWwPVe37AdJRKqn5beS8HQjd3JXAgGKUNNuE92iqF\nqi2fIqFMpnJXWo0FIW6s2Dl2zkORd7tH0DygcRi7lgVxCsw1BJQhFJon3y+IV8/F\nbnbUXSNSDUnDW2EhvWSD8L+t4eiXYsozhDAzhBvojpxhPH9OB7vqFYw5qxFx+G0t\nlSLX5iWi1jzzc3XyGnB6WInZDVbvnvJ4BGZ+dTRpOCvsoMIn9bz4EQTvu243c7aU\nHbS/kvnCASNt+zk7C6lbmaq0AGNztwNj85Opn2enFciWZVnnJ/4OeefUWQxD0EPp\nSjEd9Cn2IHzkBZrHCg+lWZJQBKbUVS0lLIMSsLQQ6WvR38jY7D2nxM1A93xWxwpt\nZtQnYRCVXH6zt2OwDAFePInWwxUjR5t/wu3XxPgpSfrmTi3WYtr1wFypAJ811e/P\nyBtswWUQ6BNJQvy+KnOEeGfOwmtdDFYR+GOCfvCihzrKJrxOtHIieehR5Iw3cbXG\nsm4pDzfMUVvDDz6C2M6PRlJhhClbatHCjik9hxFYEsAlqtVVK9pxaz9i8hOqSFQq\nkJSQsgWw+oM/B2CyjcSqkSQEu8RLAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFPmrdxpRRgu3IcaB5BTqlprcKdTsMA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEAVdlxWjPvVKky3kn8ZizeM4D+EsLw9dWLau2UD/ls\nzwDCFoT6euagVeCknrn+YEl7g20CRYT9iaonGoMUPuMR/cdtPL1W/Rf40PSrGf9q\nQuxavWiHLEXOQTCtCaVZMokkvjuuLNDXyZnstgECuiZECTwhexUF4oiuhyGk9o01\nQMaiz4HX4lgk0ozALUvEzaNd9gWEwD2qe+rq9cQMTVq3IArUkvTIftZUaVUMzr0O\ned1+zAsNa9nJhURJ/6anJPJjbQgb5qA1asFcp9UaMT1ku36U3gnR1T/BdgG2jX3X\nUm0UcaGNVPrH1ukInWW743pxWQb7/2sumEEMVh+jWbB18SAyLI4WIh4lkurdifzS\nIuTFp8TEx+MouISFhz/vJDWZ84tqoLVjkEcP6oDypq9lFoEzHDJv3V1CYcIgOusT\nk1jm9P7BXdTG7TYzUaTb9USb6bkqkD9EwJAOSs7DI94aE6rsSws2yAHavjAMfuMZ\nsDAZvkqS2Qg2Z2+CI6wUZn7mzkJXbZoqRjDvChDXEB1mIhzVXhiNW/CR5WKVDvlj\n9v1sdGByh2pbxcLQtVaq/5coM4ANgphoNz3pOYUPWHS+JUrIivBZ+JobjXcxr3SN\n9iDzcu5/FVVNbq7+KN/nvPMngT+gduEN5m+EBjm8GukJymFG0m6BENRA0QSDqZ7k\nzDY=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAK5EYG3iHserxMqgg+0EFjgwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI0MjAyMzE2WhgPMjA2MTA1MjQyMTIzMTZa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\ns1L6TtB84LGraLHVC+rGPhLBW2P0oN/91Rq3AnYwqDOuTom7agANwEjvLq7dSRG/\nsIfZsSV/ABTgArZ5sCmLjHFZAo8Kd45yA9byx20RcYtAG8IZl+q1Cri+s0XefzyO\nU6mlfXZkVe6lzjlfXBkrlE/+5ifVbJK4dqOS1t9cWIpgKqv5fbE6Qbq4LVT+5/WM\nVd2BOljuBMGMzdZubqFKFq4mzTuIYfnBm7SmHlZfTdfBYPP1ScNuhpjuzw4n3NCR\nEdU6dQv04Q6th4r7eiOCwbWI9LkmVbvBe3ylhH63lApC7MiiPYLlB13xBubVHVhV\nq1NHoNTi+zA3MN9HWicRxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBSuxoqm0/wjNiZLvqv+JlQwsDvTPDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAFfTK/j5kv90uIbM8VaFdVbr/6weKTwehafT0pAk1bfLVX+7\nuf8oHgYiyKTTl0DFQicXejghXTeyzwoEkWSR8c6XkhD5vYG3oESqmt/RGvvoxz11\nrHHy7yHYu7RIUc3VQG60c4qxXv/1mWySGwVwJrnuyNT9KZXPevu3jVaWOVHEILaK\nHvzQ2YEcWBPmde/zEseO2QeeGF8FL45Q1d66wqIP4nNUd2pCjeTS5SpB0MMx7yi9\nki1OH1pv8tOuIdimtZ7wkdB8+JSZoaJ81b8sRrydRwJyvB88rftuI3YB4WwGuONT\nZezUPsmaoK69B0RChB0ofDpAaviF9V3xOWvVZfo=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGDzCCA/egAwIBAgIRAI0sMNG2XhaBMRN3zD7ZyoEwDQYJKoZIhvcNAQEMBQAw\ngZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\nQW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzEx\nEDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA1NzUwWhgPMjEyMTA1MTgyMTU3\nNTBaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\nBAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2\nIEcxMRAwDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC\nCgKCAgEAh/otSiCu4Uw3hu7OJm0PKgLsLRqBmUS6jihcrkxfN2SHmp2zuRflkweU\nBhMkebzL+xnNvC8okzbgPWtUxSmDnIRhE8J7bvSKFlqs/tmEdiI/LMqe/YIKcdsI\n20UYmvyLIjtDaJIh598SHHlF9P8DB5jD8snJfhxWY+9AZRN+YVTltgQAAgayxkWp\nM1BbvxpOnz4CC00rE0eqkguXIUSuobb1vKqdKIenlYBNxm2AmtgvQfpsBIQ0SB+8\n8Zip8Ef5rtjSw5J3s2Rq0aYvZPfCVIsKYepIboVwXtD7E9J31UkB5onLBQlaHaA6\nXlH4srsMmrew5d2XejQGy/lGZ1nVWNsKO0x/Az2QzY5Kjd6AlXZ8kq6H68hscA5i\nOMbNlXzeEQsZH0YkId3+UsEns35AAjZv4qfFoLOu8vDotWhgVNT5DfdbIWZW3ZL8\nqbmra3JnCHuaTwXMnc25QeKgVq7/rG00YB69tCIDwcf1P+tFJWxvaGtV0g2NthtB\na+Xo09eC0L53gfZZ3hZw1pa3SIF5dIZ6RFRUQ+lFOux3Q/I3u+rYstYw7Zxc4Zeo\nY8JiedpQXEAnbw2ECHix/L6mVWgiWCiDzBnNLLdbmXjJRnafNSndSfFtHCnY1SiP\naCrNpzwZIJejoV1zDlWAMO+gyS28EqzuIq3WJK/TFE7acHkdKIcCAwEAAaNCMEAw\nDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUrmV1YASnuudfmqAZP4sKGTvScaEw\nDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBGpEKeQoPvE85tN/25\nqHFkys9oHDl93DZ62EnOqAUKLd6v0JpCyEiop4nlrJe+4KrBYVBPyKOJDcIqE2Sp\n3cvgJXLhY4i46VM3Qxe8yuYF1ElqBpg3jJVj/sCQnYz9dwoAMWIJFaDWOvmU2E7M\nMRaKx+sPXFkIjiDA6Bv0m+VHef7aedSYIY7IDltEQHuXoqNacGrYo3I50R+fZs88\n/mB3e/V7967e99D6565yf9Lcjw4oQf2Hy7kl/6P9AuMz0LODnGITwh2TKk/Zo3RU\nVgq25RDrT4xJK6nFHyjUF6+4cOBxVpimmFw/VP1zaXT8DN5r4HyJ9p4YuSK8ha5N\n2pJc/exvU8Nv2+vS/efcDZWyuEdZ7eh1IJWQZlOZKIAONfRDRTpeQHJ3zzv3QVYy\nt78pYp/eWBHyVIfEE8p2lFKD4279WYe+Uvdb8c4Jm4TJwqkSJV8ifID7Ub80Lsir\nlPAU3OCVTBeVRFPXT2zpC4PB4W6KBSuj6OOcEu2y/HgWcoi7Cnjvp0vFTUhDFdus\nWz3ucmJjfVsrkEO6avDKu4SwdbVHsk30TVAwPd6srIdi9U6MOeOQSOSE4EsrrS7l\nSVmu2QIDUVFpm8QAHYplkyWIyGkupyl3ashH9mokQhixIU/Pzir0byePxHLHrwLu\n1axqeKpI0F5SBUPsaVNYY2uNFg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECDCCAvCgAwIBAgIQCREfzzVyDTMcNME+gWnTCTANBgkqhkiG9w0BAQsFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQyMzNaGA8yMDYxMDUyNDIxNDIzM1ow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDL\n1MT6br3L/4Pq87DPXtcjlXN3cnbNk2YqRAZHJayStTz8VtsFcGPJOpk14geRVeVk\ne9uKFHRbcyr/RM4owrJTj5X4qcEuATYZbo6ou/rW2kYzuWFZpFp7lqm0vasV4Z9F\nfChlhwkNks0UbM3G+psCSMNSoF19ERunj7w2c4E62LwujkeYLvKGNepjnaH10TJL\n2krpERd+ZQ4jIpObtRcMH++bTrvklc+ei8W9lqrVOJL+89v2piN3Ecdd389uphst\nqQdb1BBVXbhUrtuGHgVf7zKqN1SkCoktoWxVuOprVWhSvr7akaWeq0UmlvbEsujU\nvADqxGMcJFyCzxx3CkJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O\nBBYEFFk8UJmlhoxFT3PP12PvhvazHjT4MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG\n9w0BAQsFAAOCAQEAfFtr2lGoWVXmWAsIo2NYre7kzL8Xb9Tx7desKxCCz5HOOvIr\n8JMB1YK6A7IOvQsLJQ/f1UnKRh3X3mJZjKIywfrMSh0FiDf+rjcEzXxw2dGtUem4\nA+WMvIA3jwxnJ90OQj5rQ8bg3iPtE6eojzo9vWQGw/Vu48Dtw1DJo9210Lq/6hze\nhPhNkFh8fMXNT7Q1Wz/TJqJElyAQGNOXhyGpHKeb0jHMMhsy5UNoW5hLeMS5ffao\nTBFWEJ1gVfxIU9QRxSh+62m46JIg+dwDlWv8Aww14KgepspRbMqDuaM2cinoejv6\nt3dyOyHHrsOyv3ffZUKtQhQbQr+sUcL89lARsg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAIJLTMpzGNxqHZ4t+c1MlCIwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBhcC1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIxMzAzM1oYDzIwNjEwNTI1MjIzMDMzWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDtdHut0ZhJ9Nn2\nMpVafFcwHdoEzx06okmmhjJsNy4l9QYVeh0UUoek0SufRNMRF4d5ibzpgZol0Y92\n/qKWNe0jNxhEj6sXyHsHPeYtNBPuDMzThfbvsLK8z7pBP7vVyGPGuppqW/6m4ZBB\nlcc9fsf7xpZ689iSgoyjiT6J5wlVgmCx8hFYc/uvcRtfd8jAHvheug7QJ3zZmIye\nV4htOW+fRVWnBjf40Q+7uTv790UAqs0Zboj4Yil+hER0ibG62y1g71XcCyvcVpto\n2/XW7Y9NCgMNqQ7fGN3wR1gjtSYPd7DO32LTzYhutyvfbpAZjsAHnoObmoljcgXI\nQjfBcCFpAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFJI3aWLg\nCS5xqU5WYVaeT5s8lpO0MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAUwATpJOcGVOs3hZAgJwznWOoTzOVJKfrqBum7lvkVH1vBwxBl9CahaKj3ZOt\nYYp2qJzhDUWludL164DL4ZjS6eRedLRviyy5cRy0581l1MxPWTThs27z+lCC14RL\nPJZNVYYdl7Jy9Q5NsQ0RBINUKYlRY6OqGDySWyuMPgno2GPbE8aynMdKP+f6G/uE\nYHOf08gFDqTsbyfa70ztgVEJaRooVf5JJq4UQtpDvVswW2reT96qi6tXPKHN5qp3\n3wI0I1Mp4ePmiBKku2dwYzPfrJK/pQlvu0Gu5lKOQ65QdotwLAAoaFqrf9za1yYs\nINUkHLWIxDds+4OHNYcerGp5Dw==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAIO6ldra1KZvNWJ0TA1ihXEwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjE0NTA1WhgPMjEyMTA1MjEyMjQ1MDVa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nsDN52Si9pFSyZ1ruh3xAN0nVqEs960o2IK5CPu/ZfshFmzAwnx/MM8EHt/jMeZtj\nSM58LADAsNDL01ELpFZATjgZQ6xNAyXRXE7RiTRUvNkK7O3o2qAGbLnJq/UqF7Sw\nLRnB8V6hYOv+2EjVnohtGCn9SUFGZtYDjWXsLd4ML4Zpxv0a5LK7oEC7AHzbUR7R\njsjkrXqSv7GE7bvhSOhMkmgxgj1F3J0b0jdQdtyyj109aO0ATUmIvf+Bzadg5AI2\nA9UA+TUcGeebhpHu8AP1Hf56XIlzPpaQv3ZJ4vzoLaVNUC7XKzAl1dlvCl7Klg/C\n84qmbD/tjZ6GHtzpLKgg7kQEV7mRoXq8X4wDX2AFPPQl2fv+Kbe+JODqm5ZjGegm\nuskABBi8IFv1hYx9jEulZPxC6uD/09W2+niFm3pirnlWS83BwVDTUBzF+CooUIMT\njhWkIIZGDDgMJTzouBHfoSJtS1KpUZi99m2WyVs21MNKHeWAbs+zmI6TO5iiMC+T\nuB8spaOiHFO1573Fmeer4sy3YA6qVoqVl6jjTQqOdy3frAMbCkwH22/crV8YA+08\nhLeHXrMK+6XUvU+EtHAM3VzcrLbuYJUI2XJbzTj5g0Eb8I8JWsHvWHR5K7Z7gceR\n78AzxQmoGEfV6KABNWKsgoCQnfb1BidDJIe3BsI0A6UCAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUABp0MlB14MSHgAcuNSOhs3MOlUcwDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCv4CIOBSQi/QR9NxdRgVAG/pAh\ntFJhV7OWb/wqwsNKFDtg6tTxwaahdCfWpGWId15OUe7G9LoPiKiwM9C92n0ZeHRz\n4ewbrQVo7Eu1JI1wf0rnZJISL72hVYKmlvaWaacHhWxvsbKLrB7vt6Cknxa+S993\nKf8i2Psw8j5886gaxhiUtzMTBwoDWak8ZaK7m3Y6C6hXQk08+3pnIornVSFJ9dlS\nPAqt5UPwWmrEfF+0uIDORlT+cvrAwgSp7nUF1q8iasledycZ/BxFgQqzNwnkBDwQ\nZ/aM52ArGsTzfMhkZRz9HIEhz1/0mJw8gZtDVQroD8778h8zsx2SrIz7eWQ6uWsD\nQEeSWXpcheiUtEfzkDImjr2DLbwbA23c9LoexUD10nwohhoiQQg77LmvBVxeu7WU\nE63JqaYUlOLOzEmNJp85zekIgR8UTkO7Gc+5BD7P4noYscI7pPOL5rP7YLg15ZFi\nega+G53NTckRXz4metsd8XFWloDjZJJq4FfD60VuxgXzoMNT9wpFTNSH42PR2s9L\nI1vcl3w8yNccs9se2utM2nLsItZ3J0m/+QSRiw9hbrTYTcM9sXki0DtH2kyIOwYf\nlOrGJDiYOIrXSQK36H0gQ+8omlrUTvUj4msvkXuQjlfgx6sgp2duOAfnGxE7uHnc\nUhnJzzoe6M+LfGHkVQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICuDCCAj2gAwIBAgIQSAG6j2WHtWUUuLGJTPb1nTAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE2MzgyNloYDzIxMjEwNTIwMTczODI2WjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE2eqwU4FOzW8RV1W381Bd\nolhDOrqoMqzWli21oDUt7y8OnXM/lmAuOS6sr8Nt61BLVbONdbr+jgCYw75KabrK\nZGg3siqvMOgabIKkKuXO14wtrGyGDt7dnKXg5ERGYOZlo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBS1Acp2WYxOcblv5ikZ3ZIbRCCW+zAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAJL84J08PBprxmsAKPTotBuVI3MyW1r8\nxQ0i8lgCQUf8GcmYjQ0jI4oZyv+TuYJAcwIxAP9Xpzq0Docxb+4N1qVhpiOfWt1O\nFnemFiy9m1l+wv6p3riQMPV7mBVpklmijkIv3Q==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRALZLcqCVIJ25maDPE3sbPCIwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjEzOTM5WhgPMjA2MTA1MjEyMjM5Mzla\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nypKc+6FfGx6Gl6fQ78WYS29QoKgQiur58oxR3zltWeg5fqh9Z85K5S3UbRSTqWWu\nXcfnkz0/FS07qHX+nWAGU27JiQb4YYqhjZNOAq8q0+ptFHJ6V7lyOqXBq5xOzO8f\n+0DlbJSsy7GEtJp7d7QCM3M5KVY9dENVZUKeJwa8PC5StvwPx4jcLeZRJC2rAVDG\nSW7NAInbATvr9ssSh03JqjXb+HDyywiqoQ7EVLtmtXWimX+0b3/2vhqcH5jgcKC9\nIGFydrjPbv4kwMrKnm6XlPZ9L0/3FMzanXPGd64LQVy51SI4d5Xymn0Mw2kMX8s6\nNf05OsWcDzJ1n6/Q1qHSxQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBRmaIc8eNwGP7i6P7AJrNQuK6OpFzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAIBeHfGwz3S2zwIUIpqEEI5/sMySDeS+3nJR+woWAHeO0C8i\nBJdDh+kzzkP0JkWpr/4NWz84/IdYo1lqASd1Kopz9aT1+iROXaWr43CtbzjXb7/X\nZv7eZZFC8/lS5SROq42pPWl4ekbR0w8XGQElmHYcWS41LBfKeHCUwv83ATF0XQ6I\n4t+9YSqZHzj4vvedrvcRInzmwWJaal9s7Z6GuwTGmnMsN3LkhZ+/GD6oW3pU/Pyh\nEtWqffjsLhfcdCs3gG8x9BbkcJPH5aPAVkPn4wc8wuXg6xxb9YGsQuY930GWTYRf\nschbgjsuqznW4HHakq4WNhs1UdTSTKkRdZz7FUQ=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEDzCCAvegAwIBAgIRAM2zAbhyckaqRim63b+Tib8wDQYJKoZIhvcNAQELBQAw\ngZ8xCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE4MDYGA1UEAwwv\nQW1hem9uIFJEUyBQcmV2aWV3IHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzEx\nEDAOBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjA0OTQ1WhgPMjA2MTA1MTgyMTQ5\nNDVaMIGfMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNl\ncywgSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExODA2BgNV\nBAMML0FtYXpvbiBSRFMgUHJldmlldyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4\nIEcxMRAwDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\nCgKCAQEA1ybjQMH1MkbvfKsWJaCTXeCSN1SG5UYid+Twe+TjuSqaXWonyp4WRR5z\ntlkqq+L2MWUeQQAX3S17ivo/t84mpZ3Rla0cx39SJtP3BiA2BwfUKRjhPwOjmk7j\n3zrcJjV5k1vSeLNOfFFSlwyDiVyLAE61lO6onBx+cRjelu0egMGq6WyFVidTdCmT\nQ9Zw3W6LTrnPvPmEyjHy2yCHzH3E50KSd/5k4MliV4QTujnxYexI2eR8F8YQC4m3\nDYjXt/MicbqA366SOoJA50JbgpuVv62+LSBu56FpzY12wubmDZsdn4lsfYKiWxUy\nuc83a2fRXsJZ1d3whxrl20VFtLFHFQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBRC0ytKmDYbfz0Bz0Psd4lRQV3aNTAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQELBQADggEBAGv8qZu4uaeoF6zsbumauz6ea6tdcWt+hGFuwGrb\ntRbI85ucAmVSX06x59DJClsb4MPhL1XmqO3RxVMIVVfRwRHWOsZQPnXm8OYQ2sny\nrYuFln1COOz1U/KflZjgJmxbn8x4lYiTPZRLarG0V/OsCmnLkQLPtEl/spMu8Un7\nr3K8SkbWN80gg17Q8EV5mnFwycUx9xsTAaFItuG0en9bGsMgMmy+ZsDmTRbL+lcX\nFq8r4LT4QjrFz0shrzCwuuM4GmcYtBSxlacl+HxYEtAs5k10tmzRf6OYlY33tGf6\n1tkYvKryxDPF/EDgGp/LiBwx6ixYMBfISoYASt4V/ylAlHA=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICtTCCAjqgAwIBAgIRAK9BSZU6nIe6jqfODmuVctYwCgYIKoZIzj0EAwMwgZkx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\nem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTIxMjIxMzA5WhgPMjEyMTA1MjEyMzEzMDlaMIGZMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\nbiBSRFMgY2EtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEUkEERcgxneT5H+P+fERcbGmf\nbVx+M7rNWtgWUr6w+OBENebQA9ozTkeSg4c4M+qdYSObFqjxITdYxT1z/nHz1gyx\nOKAhLjWu+nkbRefqy3RwXaWT680uUaAP6ccnkZOMo0IwQDAPBgNVHRMBAf8EBTAD\nAQH/MB0GA1UdDgQWBBSN6fxlg0s5Wny08uRBYZcQ3TUoyzAOBgNVHQ8BAf8EBAMC\nAYYwCgYIKoZIzj0EAwMDaQAwZgIxAORaz+MBVoFBTmZ93j2G2vYTwA6T5hWzBWrx\nCrI54pKn5g6At56DBrkjrwZF5T1enAIxAJe/LZ9xpDkAdxDgGJFN8gZYLRWc0NRy\nRb4hihy5vj9L+w9uKc9VfEBIFuhT7Z3ljg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQB/57HSuaqUkLaasdjxUdPjANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE3NDAzNFoYDzIwNjEwNTE5MTg0MDM0WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtbkaoVsUS76o\nTgLFmcnaB8cswBk1M3Bf4IVRcwWT3a1HeJSnaJUqWHCJ+u3ip/zGVOYl0gN1MgBb\nMuQRIJiB95zGVcIa6HZtx00VezDTr3jgGWRHmRjNVCCHGmxOZWvJjsIE1xavT/1j\nQYV/ph4EZEIZ/qPq7e3rHohJaHDe23Z7QM9kbyqp2hANG2JtU/iUhCxqgqUHNozV\nZd0l5K6KnltZQoBhhekKgyiHqdTrH8fWajYl5seD71bs0Axowb+Oh0rwmrws3Db2\nDh+oc2PwREnjHeca9/1C6J2vhY+V0LGaJmnnIuOANrslx2+bgMlyhf9j0Bv8AwSi\ndSWsobOhNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQb7vJT\nVciLN72yJGhaRKLn6Krn2TAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAAxEj8N9GslReAQnNOBpGl8SLgCMTejQ6AW/bapQvzxrZrfVOZOYwp/5oV0f\n9S1jcGysDM+DrmfUJNzWxq2Y586R94WtpH4UpJDGqZp+FuOVJL313te4609kopzO\nlDdmd+8z61+0Au93wB1rMiEfnIMkOEyt7D2eTFJfJRKNmnPrd8RjimRDlFgcLWJA\n3E8wca67Lz/G0eAeLhRHIXv429y8RRXDtKNNz0wA2RwURWIxyPjn1fHjA9SPDkeW\nE1Bq7gZj+tBnrqz+ra3yjZ2blss6Ds3/uRY6NYqseFTZWmQWT7FolZEnT9vMUitW\nI0VynUbShVpGf6946e0vgaaKw20=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQGyUVTaVjYJvWhroVEiHPpDANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTE5MTkwNDA2WhgPMjA2MTA1MTkyMDA0MDZaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtd2VzdC0xIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANhyXpJ0t4nigRDZ\nEwNtFOem1rM1k8k5XmziHKDvDk831p7QsX9ZOxl/BT59Pu/P+6W6SvasIyKls1sW\nFJIjFF+6xRQcpoE5L5evMgN/JXahpKGeQJPOX9UEXVW5B8yi+/dyUitFT7YK5LZA\nMqWBN/LtHVPa8UmE88RCDLiKkqiv229tmwZtWT7nlMTTCqiAHMFcryZHx0pf9VPh\nx/iPV8p2gBJnuPwcz7z1kRKNmJ8/cWaY+9w4q7AYlAMaq/rzEqDaN2XXevdpsYAK\nTMMj2kji4x1oZO50+VPNfBl5ZgJc92qz1ocF95SAwMfOUsP8AIRZkf0CILJYlgzk\n/6u6qZECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm5jfcS9o\n+LwL517HpB6hG+PmpBswDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQAcQ6lsqxi63MtpGk9XK8mCxGRLCad51+MF6gcNz6i6PAqhPOoKCoFqdj4cEQTF\nF8dCfa3pvfJhxV6RIh+t5FCk/y6bWT8Ls/fYKVo6FhHj57bcemWsw/Z0XnROdVfK\nYqbc7zvjCPmwPHEqYBhjU34NcY4UF9yPmlLOL8uO1JKXa3CAR0htIoW4Pbmo6sA4\n6P0co/clW+3zzsQ92yUCjYmRNeSbdXbPfz3K/RtFfZ8jMtriRGuO7KNxp8MqrUho\nHK8O0mlSUxGXBZMNicfo7qY8FD21GIPH9w5fp5oiAl7lqFzt3E3sCLD3IiVJmxbf\nfUwpGd1XZBBSdIxysRLM6j48\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrTCCAjOgAwIBAgIQU+PAILXGkpoTcpF200VD/jAKBggqhkjOPQQDAzCBljEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\nb24gUkRTIGFwLWVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTAgFw0yMTA1MjUyMTQ1MTFaGA8yMTIxMDUyNTIyNDUxMVowgZYxCzAJBgNV\nBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\nVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\nUyBhcC1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\ndjAQBgcqhkjOPQIBBgUrgQQAIgNiAAT3tFKE8Kw1sGQAvNLlLhd8OcGhlc7MiW/s\nNXm3pOiCT4vZpawKvHBzD76Kcv+ZZzHRxQEmG1/muDzZGlKR32h8AAj+NNO2Wy3d\nCKTtYMiVF6Z2zjtuSkZQdjuQbe4eQ7qjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\nVR0OBBYEFAiSQOp16Vv0Ohpvqcbd2j5RmhYNMA4GA1UdDwEB/wQEAwIBhjAKBggq\nhkjOPQQDAwNoADBlAjBVsi+5Ape0kOhMt/WFkANkslD4qXA5uqhrfAtH29Xzz2NV\ntR7akiA771OaIGB/6xsCMQCZt2egCtbX7J0WkuZ2KivTh66jecJr5DHvAP4X2xtS\nF/5pS+AUhcKTEGjI9jDH3ew=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICuDCCAj2gAwIBAgIQT5mGlavQzFHsB7hV6Mmy6TAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNDIwNTAxNVoYDzIxMjEwNTI0MjE1MDE1WjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEcm4BBBjYK7clwm0HJRWS\nflt3iYwoJbIXiXn9c1y3E+Vb7bmuyKhS4eO8mwO4GefUcXObRfoHY2TZLhMJLVBQ\n7MN2xDc0RtZNj07BbGD3VAIFRTDX0mH9UNYd0JQM3t/Oo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBRrd5ITedfAwrGo4FA9UaDaGFK3rjAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAPBNqmVv1IIA3EZyQ6XuVf4gj79/DMO8\nbkicNS1EcBpUqbSuU4Zwt2BYc8c/t7KVOQIxAOHoWkoKZPiKyCxfMtJpCZySUG+n\nsXgB/LOyWE5BJcXUfm+T1ckeNoWeUUMOLmnJjg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAJcDeinvdNrDQBeJ8+t38WQwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY0OTE2WhgPMjA2MjA1MjUxNzQ5MTZa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nk8DBNkr9tMoIM0NHoFiO7cQfSX0cOMhEuk/CHt0fFx95IBytx7GHCnNzpM27O5z6\nx6iRhfNnx+B6CrGyCzOjxvPizneY+h+9zfvNz9jj7L1I2uYMuiNyOKR6FkHR46CT\n1CiArfVLLPaTqgD/rQjS0GL2sLHS/0dmYipzynnZcs613XT0rAWdYDYgxDq7r/Yi\nXge5AkWQFkMUq3nOYDLCyGGfQqWKkwv6lZUHLCDKf+Y0Uvsrj8YGCI1O8mF0qPCQ\nlmlfaDvbuBu1AV+aabmkvyFj3b8KRIlNLEtQ4N8KGYR2Jdb82S4YUGIOAt4wuuFt\n1B7AUDLk3V/u+HTWiwfoLQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBSNpcjz6ArWBtAA+Gz6kyyZxrrgdDAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAGJEd7UgOzHYIcQRSF7nSYyjLROyalaIV9AX4WXW/Cqlul1c\nMblP5etDZm7A/thliZIWAuyqv2bNicmS3xKvNy6/QYi1YgxZyy/qwJ3NdFl067W0\nt8nGo29B+EVK94IPjzFHWShuoktIgp+dmpijB7wkTIk8SmIoe9yuY4+hzgqk+bo4\nms2SOXSN1DoQ75Xv+YmztbnZM8MuWhL1T7hA4AMorzTQLJ9Pof8SpSdMHeDsHp0R\n01jogNFkwy25nw7cL62nufSuH2fPYGWXyNDg+y42wKsKWYXLRgUQuDVEJ2OmTFMB\nT0Vf7VuNijfIA9hkN2d3K53m/9z5WjGPSdOjGhg=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQRiwspKyrO0xoxDgSkqLZczANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI0MjE1OTAwWhgPMjA2MTA1MjQyMjU5MDBaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL53Jk3GsKiu+4bx\njDfsevWbwPCNJ3H08Zp7GWhvI3Tgi39opfHYv2ku2BKFjK8N2L6RvNPSR8yplv5j\nY0tK0U+XVNl8o0ibhqRDhbTuh6KL8CFINWYzAajuxFS+CF0U6c1Q3tXLBdALxA7l\nFlXJ71QrP06W31kRe7kvgrvO7qWU3/OzUf9qYw4LSiR1/VkvvRCTqcVNw09clw/M\nJbw6FSgweN65M9j7zPbjGAXSHkXyxH1Erin2fa+B9PE4ZDgX9cp2C1DHewYJQL/g\nSepwwcudVNRN1ibKH7kpMrgPnaNIVNx5sXVsTjk6q2ZqYw3SVHegltJpLy/cZReP\nmlivF2kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUmTcQd6o1\nCuS65MjBrMwQ9JJjmBwwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQAKSDSIzl956wVddPThf2VAzI8syw9ngSwsEHZvxVGHBvu5gg618rDyguVCYX9L\n4Kw/xJrk6S3qxOS2ZDyBcOpsrBskgahDFIunzoRP3a18ARQVq55LVgfwSDQiunch\nBd05cnFGLoiLkR5rrkgYaP2ftn3gRBRaf0y0S3JXZ2XB3sMZxGxavYq9mfiEcwB0\nLMTMQ1NYzahIeG6Jm3LqRqR8HkzP/Ztq4dT2AtSLvFebbNMiWqeqT7OcYp94HTYT\nzqrtaVdUg9bwyAUCDgy0GV9RHDIdNAOInU/4LEETovrtuBU7Z1q4tcHXvN6Hd1H8\ngMb0mCG5I393qW5hFsA/diFb\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAPQAvihfjBg/JDbj6U64K98wDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYyODQxWhgPMjA2MTA1MjAxNzI4NDFa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\nvJ9lgyksCxkBlY40qOzI1TCj/Q0FVGuPL/Z1Mw2YN0l+41BDv0FHApjTUkIKOeIP\nnwDwpXTa3NjYbk3cOZ/fpH2rYJ++Fte6PNDGPgKppVCUh6x3jiVZ1L7wOgnTdK1Q\nTrw8440IDS5eLykRHvz8OmwvYDl0iIrt832V0QyOlHTGt6ZJ/aTQKl12Fy3QBLv7\nstClPzvHTrgWqVU6uidSYoDtzHbU7Vda7YH0wD9IUoMBf7Tu0rqcE4uH47s2XYkc\nSdLEoOg/Ngs7Y9B1y1GCyj3Ux7hnyvCoRTw014QyNB7dTatFMDvYlrRDGG14KeiU\nUL7Vo/+EejWI31eXNLw84wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBQkgTWFsNg6wA3HbbihDQ4vpt1E2zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAGz1Asiw7hn5WYUj8RpOCzpE0h/oBZcnxP8wulzZ5Xd0YxWO\n0jYUcUk3tTQy1QvoY+Q5aCjg6vFv+oFBAxkib/SmZzp4xLisZIGlzpJQuAgRkwWA\n6BVMgRS+AaOMQ6wKPgz1x4v6T0cIELZEPq3piGxvvqkcLZKdCaeC3wCS6sxuafzZ\n4qA3zMwWuLOzRftgX2hQto7d/2YkRXga7jSvQl3id/EI+xrYoH6zIWgjdU1AUaNq\nNGT7DIo47vVMfnd9HFZNhREsd4GJE83I+JhTqIxiKPNxrKgESzyADmNPt0gXDnHo\ntbV1pMZz5HpJtjnP/qVZhEK5oB0tqlKPv9yx074=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICuTCCAj6gAwIBAgIRAKp1Rn3aL/g/6oiHVIXtCq8wCgYIKoZIzj0EAwMwgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDMyMTdaGA8yMTIxMDUyNDIxMzIxN1owgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1ub3J0aGVhc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABGTYWPILeBJXfcL3Dz4z\nEWMUq78xB1HpjBwHoTURYfcMd5r96BTVG6yaUBWnAVCMeeD6yTG9a1eVGNhG14Hk\nZAEjgLiNB7RRbEG5JZ/XV7W/vODh09WCst2y9SLKsdgeAaNCMEAwDwYDVR0TAQH/\nBAUwAwEB/zAdBgNVHQ4EFgQUoE0qZHmDCDB+Bnm8GUa/evpfPwgwDgYDVR0PAQH/\nBAQDAgGGMAoGCCqGSM49BAMDA2kAMGYCMQCnil5MMwhY3qoXv0xvcKZGxGPaBV15\n0CCssCKn0oVtdJQfJQ3Jrf3RSaEyijXIJsoCMQC35iJi4cWoNX3N/qfgnHohW52O\nB5dg0DYMqy5cNZ40+UcAanRMyqNQ6P7fy3umGco=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICtzCCAj2gAwIBAgIQPXnDTPegvJrI98qz8WxrMjAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxODIxNDAxMloYDzIxMjEwNTE4MjI0MDEyWjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEI0sR7gwutK5AB46hM761\ngcLTGBIYlURSEoM1jcBwy56CL+3CJKZwLLyJ7qoOKfWbu5GsVLUTWS8MV6Nw33cx\n2KQD2svb694wi+Px2f4n9+XHkEFQw8BbiodDD7RZA70fo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBTQSioOvnVLEMXwNSDg+zgln/vAkjAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAMwu1hqm5Bc98uE/E0B5iMYbBQ4kpMxO\ntP8FTfz5UR37HUn26nXE0puj6S/Ffj4oJgIwXI7s2c26tFQeqzq6u3lrNJHp5jC9\nUxlo/hEJOLoDj5jnpxo8dMAtCNoQPaHdfL0P\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjWgAwIBAgIQGKVv+5VuzEZEBzJ+bVfx2zAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFwLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTc1MDU5WhgPMjEyMTA1MTkxODUwNTlaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgYXAtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABMqdLJ0tZF/DGFZTKZDrGRJZID8ivC2I\nJRCYTWweZKCKSCAzoiuGGHzJhr5RlLHQf/QgmFcgXsdmO2n3CggzhA4tOD9Ip7Lk\nP05eHd2UPInyPCHRgmGjGb0Z+RdQ6zkitKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUC1yhRgVqU5bR8cGzOUCIxRpl4EYwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2cAMGQCMG0c/zLGECRPzGKJvYCkpFTCUvdP4J74YP0v/dPvKojL\nt/BrR1Tg4xlfhaib7hPc7wIwFvgqHes20CubQnZmswbTKLUrgSUW4/lcKFpouFd2\nt2/ewfi/0VhkeUW+IiHhOMdU\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAOXxJuyXVkbfhZCkS/dOpfEwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1OTEwWhgPMjEyMTA1MjUyMjU5MTBa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nxiP4RDYm4tIS12hGgn1csfO8onQDmK5SZDswUpl0HIKXOUVVWkHNlINkVxbdqpqH\nFhbyZmNN6F/EWopotMDKe1B+NLrjNQf4zefv2vyKvPHJXhxoKmfyuTd5Wk8k1F7I\nlNwLQzznB+ElhrLIDJl9Ro8t31YBBNFRGAGEnxyACFGcdkjlsa52UwfYrwreEg2l\ngW5AzqHgjFfj9QRLydeU/n4bHm0F1adMsV7P3rVwilcUlqsENDwXnWyPEyv3sw6F\nwNemLEs1129mB77fwvySb+lLNGsnzr8w4wdioZ74co+T9z2ca+eUiP+EQccVw1Is\nD4Fh57IjPa6Wuc4mwiUYKkKY63+38aCfEWb0Qoi+zW+mE9nek6MOQ914cN12u5LX\ndBoYopphRO5YmubSN4xcBy405nIdSdbrAVWwxXnVVyjqjknmNeqQsPZaxAhdoKhV\nAqxNr8AUAdOAO6Sz3MslmcLlDXFihrEEOeUbpg/m1mSUUHGbu966ajTG1FuEHHwS\n7WB52yxoJo/tHvt9nAWnh3uH5BHmS8zn6s6CGweWKbX5yICnZ1QFR1e4pogxX39v\nXD6YcNOO+Vn+HY4nXmjgSYVC7l+eeP8eduMg1xJujzjrbmrXU+d+cBObgdTOAlpa\nJFHaGwYw1osAwPCo9cZ2f04yitBfj9aPFia8ASKldakCAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUqKS+ltlior0SyZKYAkJ/efv55towDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQAdElvp8bW4B+Cv+1WSN87dg6TN\nwGyIjJ14/QYURgyrZiYpUmZpj+/pJmprSWXu4KNyqHftmaidu7cdjL5nCAvAfnY5\n/6eDDbX4j8Gt9fb/6H9y0O0dn3mUPSEKG0crR+JRFAtPhn/2FNvst2P82yguWLv0\npHjHVUVcq+HqDMtUIJsTPYjSh9Iy77Q6TOZKln9dyDOWJpCSkiUWQtMAKbCSlvzd\nzTs/ahqpT+zLfGR1SR+T3snZHgQnbnemmz/XtlKl52NxccARwfcEEKaCRQyGq/pR\n0PVZasyJS9JY4JfQs4YOdeOt4UMZ8BmW1+BQWGSkkb0QIRl8CszoKofucAlqdPcO\nIT/ZaMVhI580LFGWiQIizWFskX6lqbCyHqJB3LDl8gJISB5vNTHOHpvpMOMs5PYt\ncRl5Mrksx5MKMqG7y5R734nMlZxQIHjL5FOoOxTBp9KeWIL/Ib89T2QDaLw1SQ+w\nihqWBJ4ZdrIMWYpP3WqM+MXWk7WAem+xsFJdR+MDgOOuobVQTy5dGBlPks/6gpjm\nrO9TjfQ36ppJ3b7LdKUPeRfnYmlR5RU4oyYJ//uLbClI443RZAgxaCXX/nyc12lr\neVLUMNF2abLX4/VF63m2/Z9ACgMRfqGshPssn1NN33OonrotQoj4S3N9ZrjvzKt8\niHcaqd60QKpfiH2A3A==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICuDCCAj2gAwIBAgIQPaVGRuu86nh/ylZVCLB0MzAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIyMDMxNloYDzIxMjEwNTI1MjMwMzE2WjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLW5vcnRoZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEexNURoB9KE93MEtEAlJG\nobz4LS/pD2hc8Gczix1WhVvpJ8bN5zCDXaKdnDMCebetyRQsmQ2LYlfmCwpZwSDu\n0zowB11Pt3I5Avu2EEcuKTlKIDMBeZ1WWuOd3Tf7MEAMo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBSaYbZPBvFLikSAjpa8mRJvyArMxzAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaQAwZgIxAOEJkuh3Zjb7Ih/zuNRd1RBqmIYcnyw0\nnwUZczKXry+9XebYj3VQxSRNadrarPWVqgIxAMg1dyGoDAYjY/L/9YElyMnvHltO\nPwpJShmqHvCLc/mXMgjjYb/akK7yGthvW6j/uQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCDCCA/CgAwIBAgIQChu3v5W1Doil3v6pgRIcVzANBgkqhkiG9w0BAQwFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIEJldGEgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA1MTgyMTM0MTVaGA8yMTIxMDUxODIyMzQxNVow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC1\nFUGQ5tf3OwpDR6hGBxhUcrkwKZhaXP+1St1lSOQvjG8wXT3RkKzRGMvb7Ee0kzqI\nmzKKe4ASIhtV3UUWdlNmP0EA3XKnif6N79MismTeGkDj75Yzp5A6tSvqByCgxIjK\nJqpJrch3Dszoyn8+XhwDxMZtkUa5nQVdJgPzJ6ltsQ8E4SWLyLtTu0S63jJDkqYY\nS7cQblk7y7fel+Vn+LS5dGTdRRhMvSzEnb6mkVBaVzRyVX90FNUED06e8q+gU8Ob\nhtvQlf9/kRzHwRAdls2YBhH40ZeyhpUC7vdtPwlmIyvW5CZ/QiG0yglixnL6xahL\npbmTuTSA/Oqz4UGQZv2WzHe1lD2gRHhtFX2poQZeNQX8wO9IcUhrH5XurW/G9Xwl\nSat9CMPERQn4KC3HSkat4ir2xaEUrjfg6c4XsGyh2Pk/LZ0gLKum0dyWYpWP4JmM\nRQNjrInXPbMhzQObozCyFT7jYegS/3cppdyy+K1K7434wzQGLU1gYXDKFnXwkX8R\nbRKgx2pHNbH5lUddjnNt75+e8m83ygSq/ZNBUz2Ur6W2s0pl6aBjwaDES4VfWYlI\njokcmrGvJNDfQWygb1k00eF2bzNeNCHwgWsuo3HSxVgc/WGsbcGrTlDKfz+g3ich\nbXUeUidPhRiv5UQIVCLIHpHuin3bj9lQO/0t6p+tAQIDAQABo0IwQDAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBSFmMBgm5IsRv3hLrvDPIhcPweXYTAOBgNVHQ8B\nAf8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAAa2EuozymOsQDJlEi7TqnyA2OhT\nGXPfYqCyMJVkfrqNgcnsNpCAiNEiZbb+8sIPXnT8Ay8hrwJYEObJ5b7MHXpLuyft\nz0Pu1oFLKnQxKjNxrIsCvaB4CRRdYjm1q7EqGhMGv76se9stOxkOqO9it31w/LoU\nENDk7GLsSqsV1OzYLhaH8t+MaNP6rZTSNuPrHwbV3CtBFl2TAZ7iKgKOhdFz1Hh9\nPez0lG+oKi4mHZ7ajov6PD0W7njn5KqzCAkJR6OYmlNVPjir+c/vUtEs0j+owsMl\ng7KE5g4ZpTRShyh5BjCFRK2tv0tkqafzNtxrKC5XNpEkqqVTCnLcKG+OplIEadtr\nC7UWf4HyhCiR+xIyxFyR05p3uY/QQU/5uza7GlK0J+U1sBUytx7BZ+Fo8KQfPPqV\nCqDCaYUksoJcnJE/KeoksyqNQys7sDGJhkd0NeUGDrFLKHSLhIwAMbEWnqGxvhli\nE7sP2E5rI/I9Y9zTbLIiI8pfeZlFF8DBdoP/Hzg8pqsiE/yiXSFTKByDwKzGwNqz\nF0VoFdIZcIbLdDbzlQitgGpJtvEL7HseB0WH7B2PMMD8KPJlYvPveO3/6OLzCsav\n+CAkvk47NQViKMsUTKOA0JDCW+u981YRozxa3K081snhSiSe83zIPBz1ikldXxO9\n6YYLNPRrj3mi9T/f\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAMkvdFnVDb0mWWFiXqnKH68wCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyB1cy13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTkxMzI0WhgPMjEyMTA1MTkyMDEzMjRaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgdXMtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEy86DB+9th/0A5VcWqMSWDxIUblWTt/R0\nao6Z2l3vf2YDF2wt1A2NIOGpfQ5+WAOJO/IQmnV9LhYo+kacB8sOnXdQa6biZZkR\nIyouUfikVQAKWEJnh1Cuo5YMM4E2sUt5o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBQ8u3OnecANmG8OoT7KLWDuFzZwBTAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIwQ817qkb7mWJFnieRAN+m9W3E0FLVKaV3zC5aYJUk2fcZ\nTaUx3oLp3jPLGvY5+wgeAjEA6wAicAki4ZiDfxvAIuYiIe1OS/7H5RA++R8BH6qG\niRzUBM/FItFpnkus7u/eTkvo\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQS/+Ryfgb/IOVEa1pWoe8oTAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFwLXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjIwNjA2MjE1NDQyWhgPMjEyMjA2MDYyMjU0NDJaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgYXAtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDsX6fhdUWBQpYTdseBD/P3s96Dtw2Iw\nOrXKNToCnmX5nMkUGdRn9qKNiz1pw3EPzaPxShbYwQ7LYP09ENK/JN4QQjxMihxC\njLFxS85nhBQQQGRCWikDAe38mD8fSvREQKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUIh1xZiseQYFjPYKJmGbruAgRH+AwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMFudS4zLy+UUGrtgNLtRMcu/DZ9BUzV4NdHxo0bkG44O\nthnjl4+wTKI6VbyAbj2rkgIxAOHps8NMITU5DpyiMnKTxV8ubb/WGHrLl0BjB8Lw\nETVJk5DNuZvsIIcm7ykk6iL4Tw==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGBDCCA+ygAwIBAgIQDcEmNIAVrDpUw5cH5ynutDANBgkqhkiG9w0BAQwFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIG1lLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNTA3MDA0MDIzWhgPMjEyMjA1MDcwMTQwMjNaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKvADk8t\nFl9bFlU5sajLPPDSOUpPAkKs6iPlz+27o1GJC88THcOvf3x0nVAcu9WYe9Qaas+4\nj4a0vv51agqyODRD/SNi2HnqW7DbtLPAm6KBHe4twl28ItB/JD5g7u1oPAHFoXMS\ncH1CZEAs5RtlZGzJhcBXLFsHNv/7+SCLyZ7+2XFh9OrtgU4wMzkHoRNndhfwV5bu\n17bPTwuH+VxH37zXf1mQ/KjhuJos0C9dL0FpjYBAuyZTAWhZKs8dpSe4DI544z4w\ngkwUB4bC2nA1TBzsywEAHyNuZ/xRjNpWvx0ToWAA2iFJqC3VO3iKcnBplMvaUuMt\njwzVSNBnKcoabXCZL2XDLt4YTZR8FSwz05IvsmwcPB7uNTBXq3T9sjejW8QQK3vT\ntzyfLq4jKmQE7PoS6cqYm+hEPm2hDaC/WP9bp3FdEJxZlPH26fq1b7BWYWhQ9pBA\nNv9zTnzdR1xohTyOJBUFQ81ybEzabqXqVXUIANqIOaNcTB09/sLJ7+zuMhp3mwBu\nLtjfJv8PLuT1r63bU3seROhKA98b5KfzjvbvPSg3vws78JQyoYGbqNyDfyjVjg3U\nv//AdVuPie6PNtdrW3upZY4Qti5IjP9e3kimaJ+KAtTgMRG56W0WxD3SP7+YGGbG\nKhntDOkKsN39hLpn9UOafTIqFu7kIaueEy/NAgMBAAGjQjBAMA8GA1UdEwEB/wQF\nMAMBAf8wHQYDVR0OBBYEFHAems86dTwdZbLe8AaPy3kfIUVoMA4GA1UdDwEB/wQE\nAwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOBHpp0ICx81kmeoBcZTrMdJs2gnhcd85\nFoSCjXx9H5XE5rmN/lQcxxOgj8hr3uPuLdLHu+i6THAyzjrl2NA1FWiqpfeECGmy\n0jm7iZsYORgGQYp/VKnDrwnKNSqlZvOuRr0kfUexwFlr34Y4VmupvEOK/RdGsd3S\n+3hiemcHse9ST/sJLHx962AWMkN86UHPscJEe4+eT3f2Wyzg6La8ARwdWZSNS+WH\nZfybrncMmuiXuUdHv9XspPsqhKgtHhcYeXOGUtrwQPLe3+VJZ0LVxhlTWr9951GZ\nGfmWwTV/9VsyKVaCFIXeQ6L+gjcKyEzYF8wpMtQlSc7FFqwgC4bKxvMBSaRy88Nr\nlV2+tJD/fr8zGUeBK44Emon0HKDBWGX+/Hq1ZIv0Da0S+j6LbA4fusWxtGfuGha+\nluhHgVInCpALIOamiBEdGhILkoTtx7JrYppt3/Raqg9gUNCOOYlCvGhqX7DXeEfL\nDGabooiY2FNWot6h04JE9nqGj5QqT8D6t/TL1nzxhRPzbcSDIHUd/b5R+a0bAA+7\nYTU6JqzEVCWKEIEynYmqikgLMGB/OzWsgyEL6822QW6hJAQ78XpbNeCzrICF4+GC\n7KShLnwuWoWpAb26268lvOEvCTFM47VC6jNQl97md+2SA9Ma81C9wflid2M83Wle\ncuLMVcQZceE=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQAhAteLRCvizAElaWORFU2zANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE3MDkxNloYDzIwNjEwNTIwMTgwOTE2WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+qg7JAcOVKjh\nN83SACnBFZPyB63EusfDr/0V9ZdL8lKcmZX9sv/CqoBo3N0EvBqHQqUUX6JvFb7F\nXrMUZ740kr28gSRALfXTFgNODjXeDsCtEkKRTkac/UM8xXHn+hR7UFRPHS3e0GzI\niLiwQWDkr0Op74W8aM0CfaVKvh2bp4BI1jJbdDnQ9OKXpOxNHGUf0ZGb7TkNPkgI\nb2CBAc8J5o3H9lfw4uiyvl6Fz5JoP+A+zPELAioYBXDrbE7wJeqQDJrETWqR9VEK\nBXURCkVnHeaJy123MpAX2ozf4pqk0V0LOEOZRS29I+USF5DcWr7QIXR/w2I8ws1Q\n7ys+qbE+kQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQFJ16n\n1EcCMOIhoZs/F9sR+Jy++zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAOc5nXbT3XTDEZsxX2iD15YrQvmL5m13B3ImZWpx/pqmObsgx3/dg75rF2nQ\nqS+Vl+f/HLh516pj2BPP/yWCq12TRYigGav8UH0qdT3CAClYy2o+zAzUJHm84oiB\nud+6pFVGkbqpsY+QMpJUbZWu52KViBpJMYsUEy+9cnPSFRVuRAHjYynSiLk2ZEjb\nWkdc4x0nOZR5tP0FgrX0Ve2KcjFwVQJVZLgOUqmFYQ/G0TIIGTNh9tcmR7yp+xJR\nA2tbPV2Z6m9Yxx4E8lLEPNuoeouJ/GR4CkMEmF8cLwM310t174o3lKKUXJ4Vs2HO\nWj2uN6R9oI+jGLMSswTzCNV1vgc=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICuDCCAj6gAwIBAgIRAOocLeZWjYkG/EbHmscuy8gwCgYIKoZIzj0EAwMwgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjEyMTUwMDFaGA8yMTIxMDUyMTIyNTAwMVowgZsx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE0MDIGA1UEAwwrQW1h\nem9uIFJEUyBhcC1zb3V0aGVhc3QtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABCEr3jq1KtRncnZfK5cq\nbtY0nW6ZG3FMbh7XwBIR6Ca0f8llGZ4vJEC1pXgiM/4Dh045B9ZIzNrR54rYOIfa\n2NcYZ7mk06DjIQML64hbAxbQzOAuNzLPx268MrlL2uW2XaNCMEAwDwYDVR0TAQH/\nBAUwAwEB/zAdBgNVHQ4EFgQUln75pChychwN4RfHl+tOinMrfVowDgYDVR0PAQH/\nBAQDAgGGMAoGCCqGSM49BAMDA2gAMGUCMGiyPINRU1mwZ4Crw01vpuPvxZxb2IOr\nyX3RNlOIu4We1H+5dQk5tIvH8KGYFbWEpAIxAO9NZ6/j9osMhLgZ0yj0WVjb+uZx\nYlZR9fyFisY/jNfX7QhSk+nrc3SFLRUNtpXrng==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBTCCAu2gAwIBAgIRAKiaRZatN8eiz9p0s0lu0rQwDQYJKoZIhvcNAQELBQAw\ngZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\nQW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDIzNVoYDzIwNjEwNTIxMjMwMjM1WjCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCygVMf\nqB865IR9qYRBRFHn4eAqGJOCFx+UbraQZmjr/mnRqSkY+nhbM7Pn/DWOrRnxoh+w\nq5F9ZxdZ5D5T1v6kljVwxyfFgHItyyyIL0YS7e2h7cRRscCM+75kMedAP7icb4YN\nLfWBqfKHbHIOqvvQK8T6+Emu/QlG2B5LvuErrop9K0KinhITekpVIO4HCN61cuOe\nCADBKF/5uUJHwS9pWw3uUbpGUwsLBuhJzCY/OpJlDqC8Y9aToi2Ivl5u3/Q/sKjr\n6AZb9lx4q3J2z7tJDrm5MHYwV74elGSXoeoG8nODUqjgklIWAPrt6lQ3WJpO2kug\n8RhCdSbWkcXHfX95AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\nFOIxhqTPkKVqKBZvMWtKewKWDvDBMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\nAQsFAAOCAQEAqoItII89lOl4TKvg0I1EinxafZLXIheLcdGCxpjRxlZ9QMQUN3yb\ny/8uFKBL0otbQgJEoGhxm4h0tp54g28M6TN1U0332dwkjYxUNwvzrMaV5Na55I2Z\n1hq4GB3NMXW+PvdtsgVOZbEN+zOyOZ5MvJHEQVkT3YRnf6avsdntltcRzHJ16pJc\nY8rR7yWwPXh1lPaPkxddrCtwayyGxNbNmRybjR48uHRhwu7v2WuAMdChL8H8bp89\nTQLMrMHgSbZfee9hKhO4Zebelf1/cslRSrhkG0ESq6G5MUINj6lMg2g6F0F7Xz2v\nncD/vuRN5P+vT8th/oZ0Q2Gc68Pun0cn/g==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAJYlnmkGRj4ju/2jBQsnXJYwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMTIzMDQ0NFoYDzIwNjEwNTIyMDAwNDQ0WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC74V3eigv+pCj5\nnqDBqplY0Jp16pTeNB06IKbzb4MOTvNde6QjsZxrE1xUmprT8LxQqN9tI3aDYEYk\nb9v4F99WtQVgCv3Y34tYKX9NwWQgwS1vQwnIR8zOFBYqsAsHEkeJuSqAB12AYUSd\nZv2RVFjiFmYJho2X30IrSLQfS/IE3KV7fCyMMm154+/K1Z2IJlcissydEAwgsUHw\nedrE6CxJVkkJ3EvIgG4ugK/suxd8eEMztaQYJwSdN8TdfT59LFuSPl7zmF3fIBdJ\n//WexcQmGabaJ7Xnx+6o2HTfkP8Zzzzaq8fvjAcvA7gyFH5EP26G2ZqMG+0y4pTx\nSPVTrQEXAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFIWWuNEF\nsUMOC82XlfJeqazzrkPDMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAgClmxcJaQTGpEZmjElL8G2Zc8lGc+ylGjiNlSIw8X25/bcLRptbDA90nuP+q\nzXAMhEf0ccbdpwxG/P5a8JipmHgqQLHfpkvaXx+0CuP++3k+chAJ3Gk5XtY587jX\n+MJfrPgjFt7vmMaKmynndf+NaIJAYczjhJj6xjPWmGrjM3MlTa9XesmelMwP3jep\nbApIWAvCYVjGndbK9byyMq1nyj0TUzB8oJZQooaR3MMjHTmADuVBylWzkRMxbKPl\n4Nlsk4Ef1JvIWBCzsMt+X17nuKfEatRfp3c9tbpGlAE/DSP0W2/Lnayxr4RpE9ds\nICF35uSis/7ZlsftODUe8wtpkQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAPvvd+MCcp8E36lHziv0xhMwDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy1lYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMTIzMTEwNloYDzIxMjEwNTIyMDAxMTA2WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLWVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDbvwekKIKGcV/s\nlDU96a71ZdN2pTYkev1X2e2/ICb765fw/i1jP9MwCzs8/xHBEQBJSxdfO4hPeNx3\nENi0zbM+TrMKliS1kFVe1trTTEaHYjF8BMK9yTY0VgSpWiGxGwg4tshezIA5lpu8\nsF6XMRxosCEVCxD/44CFqGZTzZaREIvvFPDTXKJ6yOYnuEkhH3OcoOajHN2GEMMQ\nShuyRFDQvYkqOC/Q5icqFbKg7eGwfl4PmimdV7gOVsxSlw2s/0EeeIILXtHx22z3\n8QBhX25Lrq2rMuaGcD3IOMBeBo2d//YuEtd9J+LGXL9AeOXHAwpvInywJKAtXTMq\nWsy3LjhuANFrzMlzjR2YdjkGVzeQVx3dKUzJ2//Qf7IXPSPaEGmcgbxuatxjnvfT\nH85oeKr3udKnXm0Kh7CLXeqJB5ITsvxI+Qq2iXtYCc+goHNR01QJwtGDSzuIMj3K\nf+YMrqBXZgYBwU2J/kCNTH31nfw96WTbOfNGwLwmVRDgguzFa+QzmQsJW4FTDMwc\n7cIjwdElQQVA+Gqa67uWmyDKAnoTkudmgAP+OTBkhnmc6NJuZDcy6f/iWUdl0X0u\n/tsfgXXR6ZovnHonM13ANiN7VmEVqFlEMa0VVmc09m+2FYjjlk8F9sC7Rc4wt214\n7u5YvCiCsFZwx44baP5viyRZgkJVpQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBQgCZCsc34nVTRbWsniXBPjnUTQ2DAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBAAQas3x1G6OpsIvQeMS9BbiHG3+kU9P/ba6Rrg+E\nlUz8TmL04Bcd+I+R0IyMBww4NznT+K60cFdk+1iSmT8Q55bpqRekyhcdWda1Qu0r\nJiTi7zz+3w2v66akofOnGevDpo/ilXGvCUJiLOBnHIF0izUqzvfczaMZGJT6xzKq\nPcEVRyAN1IHHf5KnGzUlVFv9SGy47xJ9I1vTk24JU0LWkSLzMMoxiUudVmHSqJtN\nu0h+n/x3Q6XguZi1/C1KOntH56ewRh8n5AF7c+9LJJSRM9wunb0Dzl7BEy21Xe9q\n03xRYjf5wn8eDELB8FZPa1PrNKXIOLYM9egdctbKEcpSsse060+tkyBrl507+SJT\n04lvJ4tcKjZFqxn+bUkDQvXYj0D3WK+iJ7a8kZJPRvz8BDHfIqancY8Tgw+69SUn\nWqIb+HNZqFuRs16WFSzlMksqzXv6wcDSyI7aZOmCGGEcYW9NHk8EuOnOQ+1UMT9C\nQb1GJcipjRzry3M4KN/t5vN3hIetB+/PhmgTO4gKhBETTEyPC3HC1QbdVfRndB6e\nU/NF2U/t8U2GvD26TTFLK4pScW7gyw4FQyXWs8g8FS8f+R2yWajhtS9++VDJQKom\nfAUISoCH+PlPRJpu/nHd1Zrddeiiis53rBaLbXu2J1Q3VqjWOmtj0HjxJJxWnYmz\nPqj2\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAI/U4z6+GF8/znpHM8Dq8G0wDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMjA2MDYyMTQ4MThaGA8yMTIyMDYwNjIyNDgxOFowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhcC1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK5WqMvyq888\n3uuOtEj1FcP6iZhqO5kJurdJF59Otp2WCg+zv6I+QwaAspEWHQsKD405XfFsTGKV\nSKTCwoMxwBniuChSmyhlagQGKSnRY9+znOWq0v7hgmJRwp6FqclTbubmr+K6lzPy\nhs86mEp68O5TcOTYWUlPZDqfKwfNTbtCl5YDRr8Gxb5buHmkp6gUSgDkRsXiZ5VV\nb3GBmXRqbnwo5ZRNAzQeM6ylXCn4jKs310lQGUrFbrJqlyxUdfxzqdlaIRn2X+HY\nxRSYbHox3LVNPpJxYSBRvpQVFSy9xbX8d1v6OM8+xluB31cbLBtm08KqPFuqx+cO\nI2H5F0CYqYzhyOSKJsiOEJT6/uH4ewryskZzncx9ae62SC+bB5n3aJLmOSTkKLFY\nYS5IsmDT2m3iMgzsJNUKVoCx2zihAzgBanFFBsG+Xmoq0aKseZUI6vd2qpd5tUST\n/wS1sNk0Ph7teWB2ACgbFE6etnJ6stwjHFZOj/iTYhlnR2zDRU8akunFdGb6CB4/\nhMxGJxaqXSJeGtHm7FpadlUTf+2ESbYcVW+ui/F8sdBJseQdKZf3VdZZMgM0bcaX\nNE47cauDTy72WdU9YJX/YXKYMLDE0iFHTnGpfVGsuWGPYhlwZ3dFIO07mWnCRM6X\nu5JXRB1oy5n5HRluMsmpSN/R92MeBxKFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFNtH0F0xfijSLHEyIkRGD9gW6NazMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEACo+5jFeY3ygxoDDzL3xpfe5M0U1WxdKk+az4\n/OfjZvkoma7WfChi3IIMtwtKLYC2/seKWA4KjlB3rlTsCVNPnK6D+gAnybcfTKk/\nIRSPk92zagwQkSUWtAk80HpVfWJzpkSU16ejiajhedzOBRtg6BwsbSqLCDXb8hXr\neXWC1S9ZceGc+LcKRHewGWPu31JDhHE9bNcl9BFSAS0lYVZqxIRWxivZ+45j5uQv\nwPrC8ggqsdU3K8quV6dblUQzzA8gKbXJpCzXZihkPrYpQHTH0szvXvgebh+CNUAG\nrUxm8+yTS0NFI3U+RLbcLFVzSvjMOnEwCX0SPj5XZRYYXs5ajtQCoZhTUkkwpDV8\nRxXk8qGKiXwUxDO8GRvmvM82IOiXz5w2jy/h7b7soyIgdYiUydMq4Ja4ogB/xPZa\ngf4y0o+bremO15HFf1MkaU2UxPK5FFVUds05pKvpSIaQWbF5lw4LHHj4ZtVup7zF\nCLjPWs4Hs/oUkxLMqQDw0FBwlqa4uot8ItT8uq5BFpz196ZZ+4WXw5PVzfSxZibI\nC/nwcj0AS6qharXOs8yPnPFLPSZ7BbmWzFDgo3tpglRqo3LbSPsiZR+sLeivqydr\n0w4RK1btRda5Ws88uZMmW7+2aufposMKcbAdrApDEAVzHijbB/nolS5nsnFPHZoA\nKDPtFEk=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICtzCCAj2gAwIBAgIQVZ5Y/KqjR4XLou8MCD5pOjAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIyMDUyNTE2NTgzM1oYDzIxMjIwNTI1MTc1ODMzWjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC00IFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEbo473OmpD5vkckdJajXg\nbrhmNFyoSa0WCY1njuZC2zMFp3zP6rX4I1r3imrYnJd9pFH/aSiV/r6L5ACE5RPx\n4qdg5SQ7JJUaZc3DWsTOiOed7BCZSzM+KTYK/2QzDMApo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBTmogc06+1knsej1ltKUOdWFvwgsjAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAIs7TlLMbGTWNXpGiKf9DxaM07d/iDHe\nF/Vv/wyWSTGdobxBL6iArQNVXz0Gr4dvPAIwd0rsoa6R0x5mtvhdRPtM37FYrbHJ\npbV+OMusQqcSLseunLBoCHenvJW0QOCQ8EDY\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICvTCCAkOgAwIBAgIQCIY7E/bFvFN2lK9Kckb0dTAKBggqhkjOPQQDAzCBnjEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5BbWF6\nb24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUxODIxMDUxMFoYDzIxMjEwNTE4MjIwNTEwWjCB\nnjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTcwNQYDVQQDDC5B\nbWF6b24gUkRTIFByZXZpZXcgdXMtZWFzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEMI0hzf1JCEOI\nEue4+DmcNnSs2i2UaJxHMrNGGfU7b42a7vwP53F7045ffHPBGP4jb9q02/bStZzd\nVHqfcgqkSRI7beBKjD2mfz82hF/wJSITTgCLs+NRpS6zKMFOFHUNo0IwQDAPBgNV\nHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS8uF/6hk5mPLH4qaWv9NVZaMmyTjAOBgNV\nHQ8BAf8EBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIxAO7Pu9wzLyM0X7Q08uLIL+vL\nqaxe3UFuzFTWjM16MLJHbzLf1i9IDFKz+Q4hXCSiJwIwClMBsqT49BPUxVsJnjGr\nEbyEk6aOOVfY1p2yQL649zh3M4h8okLnwf+bYIb1YpeU\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQY+JhwFEQTe36qyRlUlF8ozANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE5MjQxNloYDzIwNjEwNTE5MjAyNDE2WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnIye77j6ev40\n8wRPyN2OdKFSUfI9jB20Or2RLO+RDoL43+USXdrze0Wv4HMRLqaen9BcmCfaKMp0\nE4SFo47bXK/O17r6G8eyq1sqnHE+v288mWtYH9lAlSamNFRF6YwA7zncmE/iKL8J\n0vePHMHP/B6svw8LULZCk+nZk3tgxQn2+r0B4FOz+RmpkoVddfqqUPMbKUxhM2wf\nfO7F6bJaUXDNMBPhCn/3ayKCjYr49ErmnpYV2ZVs1i34S+LFq39J7kyv6zAgbHv9\n+/MtRMoRB1CjpqW0jIOZkHBdYcd1o9p1zFn591Do1wPkmMsWdjIYj+6e7UXcHvOB\n2+ScIRAcnwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQGtq2W\nYSyMMxpdQ3IZvcGE+nyZqTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAEgoP3ixJsKSD5FN8dQ01RNHERl/IFbA7TRXfwC+L1yFocKnQh4Mp/msPRSV\n+OeHIvemPW/wtZDJzLTOFJ6eTolGekHK1GRTQ6ZqsWiU2fmiOP8ks4oSpI+tQ9Lw\nVrfZqTiEcS5wEIqyfUAZZfKDo7W1xp+dQWzfczSBuZJZwI5iaha7+ILM0r8Ckden\nTVTapc5pLSoO15v0ziRuQ2bT3V3nwu/U0MRK44z+VWOJdSiKxdnOYDs8hFNnKhfe\nklbTZF7kW7WbiNYB43OaAQBJ6BALZsIskEaqfeZT8FD71uN928TcEQyBDXdZpRN+\niGQZDGhht0r0URGMDSs9waJtTfA=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQXY/dmS+72lZPranO2JM9jjANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIGFwLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI1MjEzNDUxWhgPMjEyMTA1MjUyMjM0NTFaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgYXAtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMyW9kBJjD/hx8e8\nb5E1sF42bp8TXsz1htSYE3Tl3T1Aq379DfEhB+xa/ASDZxt7/vwa81BkNo4M6HYq\nokYIXeE7cu5SnSgjWXqcERhgPevtAwgmhdE3yREe8oz2DyOi2qKKZqah+1gpPaIQ\nfK0uAqoeQlyHosye3KZZKkDHBatjBsQ5kf8lhuf7wVulEZVRHY2bP2X7N98PfbpL\nQdH7mWXzDtJJ0LiwFwds47BrkgK1pkHx2p1mTo+HMkfX0P6Fq1atkVC2RHHtbB/X\niYyH7paaHBzviFrhr679zNqwXIOKlbf74w3mS11P76rFn9rS1BAH2Qm6eY5S/Fxe\nHEKXm4kjPN63Zy0p3yE5EjPt54yPkvumOnT+RqDGJ2HCI9k8Ehcbve0ogfdRKNqQ\nVHWYTy8V33ndQRHZlx/CuU1yN61TH4WSoMly1+q1ihTX9sApmlQ14B2pJi/9DnKW\ncwECrPy1jAowC2UJ45RtC8UC05CbP9yrIy/7Noj8gQDiDOepm+6w1g6aNlWoiuQS\nkyI6nzz1983GcnOHya73ga7otXo0Qfg9jPghlYiMomrgshlSLDHZG0Ib/3hb8cnR\n1OcN9FpzNmVK2Ll1SmTMLrIhuCkyNYX9O/bOknbcf706XeESxGduSkHEjIw/k1+2\nAtteoq5dT6cwjnJ9hyhiueVlVkiDAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFLUI+DD7RJs+0nRnjcwIVWzzYSsFMA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEAb1mcCHv4qMQetLGTBH9IxsB2YUUhr5dda0D2BcHr\nUtDbfd0VQs4tux6h/6iKwHPx0Ew8fuuYj99WknG0ffgJfNc5/fMspxR/pc1jpdyU\n5zMQ+B9wi0lOZPO9uH7/pr+d2odcNEy8zAwqdv/ihsTwLmGP54is9fVbsgzNW1cm\nHKAVL2t/Ope+3QnRiRilKCN1lzhav4HHdLlN401TcWRWKbEuxF/FgxSO2Hmx86pj\ne726lweCTMmnq/cTsPOVY0WMjs0or3eHDVlyLgVeV5ldyN+ptg3Oit60T05SRa58\nAJPTaVKIcGQ/gKkKZConpu7GDofT67P/ox0YNY57LRbhsx9r5UY4ROgz7WMQ1yoS\nY+19xizm+mBm2PyjMUbfwZUyCxsdKMwVdOq5/UmTmdms+TR8+m1uBHPOTQ2vKR0s\nPd/THSzPuu+d3dbzRyDSLQbHFFneG760CUlD/ZmzFlQjJ89/HmAmz8IyENq+Sjhx\nJgzy+FjVZb8aRUoYLlnffpUpej1n87Ynlr1GrvC4GsRpNpOHlwuf6WD4W0qUTsC/\nC9JO+fBzUj/aWlJzNcLEW6pte1SB+EdkR2sZvWH+F88TxemeDrV0jKJw5R89CDf8\nZQNfkxJYjhns+YeV0moYjqQdc7tq4i04uggEQEtVzEhRLU5PE83nlh/K2NZZm8Kj\ndIA=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAPVSMfFitmM5PhmbaOFoGfUwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIyMzQ1N1oYDzIwNjEwNTI1MjMzNDU3WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDu9H7TBeGoDzMr\ndxN6H8COntJX4IR6dbyhnj5qMD4xl/IWvp50lt0VpmMd+z2PNZzx8RazeGC5IniV\n5nrLg0AKWRQ2A/lGGXbUrGXCSe09brMQCxWBSIYe1WZZ1iU1IJ/6Bp4D2YEHpXrW\nbPkOq5x3YPcsoitgm1Xh8ygz6vb7PsvJvPbvRMnkDg5IqEThapPjmKb8ZJWyEFEE\nQRrkCIRueB1EqQtJw0fvP4PKDlCJAKBEs/y049FoOqYpT3pRy0WKqPhWve+hScMd\n6obq8kxTFy1IHACjHc51nrGII5Bt76/MpTWhnJIJrCnq1/Uc3Qs8IVeb+sLaFC8K\nDI69Sw6bAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFE7PCopt\nlyOgtXX0Y1lObBUxuKaCMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAFj+bX8gLmMNefr5jRJfHjrL3iuZCjf7YEZgn89pS4z8408mjj9z6Q5D1H7yS\njNETVV8QaJip1qyhh5gRzRaArgGAYvi2/r0zPsy+Tgf7v1KGL5Lh8NT8iCEGGXwF\ng3Ir+Nl3e+9XUp0eyyzBIjHtjLBm6yy8rGk9p6OtFDQnKF5OxwbAgip42CD75r/q\np421maEDDvvRFR4D+99JZxgAYDBGqRRceUoe16qDzbMvlz0A9paCZFclxeftAxv6\nQlR5rItMz/XdzpBJUpYhdzM0gCzAzdQuVO5tjJxmXhkSMcDP+8Q+Uv6FA9k2VpUV\nE/O5jgpqUJJ2Hc/5rs9VkAPXeA==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQW0yuFCle3uj4vWiGU0SaGzAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGFmLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTE5MTkzNTE2WhgPMjEyMTA1MTkyMDM1MTZaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgYWYtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABDPiKNZSaXs3Un/J/v+LTsFDANHpi7en\noL2qh0u0DoqNzEBTbBjvO23bLN3k599zh6CY3HKW0r2k1yaIdbWqt4upMCRCcUFi\nI4iedAmubgzh56wJdoMZztjXZRwDthTkJKNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUWbYkcrvVSnAWPR5PJhIzppcAnZIwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMCESGqpat93CjrSEjE7z+Hbvz0psZTHwqaxuiH64GKUm\nmYynIiwpKHyBrzjKBmeDoQIxANGrjIo6/b8Jl6sdIZQI18V0pAyLfLiZjlHVOnhM\nMOTVgr82ZuPoEHTX78MxeMnYlw==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAIbsx8XOl0sgTNiCN4O+18QwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTI1MjE1NDU4WhgPMjA2MTA1MjUyMjU0NTha\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\ntROxwXWCgn5R9gI/2Ivjzaxc0g95ysBjoJsnhPdJEHQb7w3y2kWrVWU3Y9fOitgb\nCEsnEC3PrhRnzNVW0fPsK6kbvOeCmjvY30rdbxbc8h+bjXfGmIOgAkmoULEr6Hc7\nG1Q/+tvv4lEwIs7bEaf+abSZxRJbZ0MBxhbHn7UHHDiMZYvzK+SV1MGCxx7JVhrm\nxWu3GC1zZCsGDhB9YqY9eR6PmjbqA5wy8vqbC57dZZa1QVtWIQn3JaRXn+faIzHx\nnLMN5CEWihsdmHBXhnRboXprE/OS4MFv1UrQF/XM/h5RBeCywpHePpC+Oe1T3LNC\niP8KzRFrjC1MX/WXJnmOVQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBS33XbXAUMs1znyZo4B0+B3D68WFTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBADuadd2EmlpueY2VlrIIPC30QkoA1EOSoCmZgN6124apkoY1\nHiV4r+QNPljN4WP8gmcARnNkS7ZeR4fvWi8xPh5AxQCpiaBMw4gcbTMCuKDV68Pw\nP2dZCTMspvR3CDfM35oXCufdtFnxyU6PAyINUqF/wyTHguO3owRFPz64+sk3r2pT\nWHmJjG9E7V+KOh0s6REgD17Gqn6C5ijLchSrPUHB0wOIkeLJZndHxN/76h7+zhMt\nfFeNxPWHY2MfpcaLjz4UREzZPSB2U9k+y3pW1omCIcl6MQU9itGx/LpQE+H3ZeX2\nM2bdYd5L+ow+bdbGtsVKOuN+R9Dm17YpswF+vyQ=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAKlQ+3JX9yHXyjP/Ja6kZhkwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MTkxNzQ1MjBaGA8yMTIxMDUxOTE4NDUyMFowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBhcC1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKtahBrpUjQ6\nH2mni05BAKU6Z5USPZeSKmBBJN3YgD17rJ93ikJxSgzJ+CupGy5rvYQ0xznJyiV0\n91QeQN4P+G2MjGQR0RGeUuZcfcZitJro7iAg3UBvw8WIGkcDUg+MGVpRv/B7ry88\n7E4OxKb8CPNoa+a9j6ABjOaaxaI22Bb7j3OJ+JyMICs6CU2bgkJaj3VUV9FCNUOc\nh9PxD4jzT9yyGYm/sK9BAT1WOTPG8XQUkpcFqy/IerZDfiQkf1koiSd4s5VhBkUn\naQHOdri/stldT7a+HJFVyz2AXDGPDj+UBMOuLq0K6GAT6ThpkXCb2RIf4mdTy7ox\nN5BaJ+ih+Ro3ZwPkok60egnt/RN98jgbm+WstgjJWuLqSNInnMUgkuqjyBWwePqX\nKib+wdpyx/LOzhKPEFpeMIvHQ3A0sjlulIjnh+j+itezD+dp0UNxMERlW4Bn/IlS\nsYQVNfYutWkRPRLErXOZXtlxxkI98JWQtLjvGzQr+jywxTiw644FSLWdhKa6DtfU\n2JWBHqQPJicMElfZpmfaHZjtXuCZNdZQXWg7onZYohe281ZrdFPOqC4rUq7gYamL\nT+ZB+2P+YCPOLJ60bj/XSvcB7mesAdg8P0DNddPhHUFWx2dFqOs1HxIVB4FZVA9U\nPpbv4a484yxjTgG7zFZNqXHKTqze6rBBAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFCEAqjighncv/UnWzBjqu1Ka2Yb4MA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAYyvumblckIXlohzi3QiShkZhqFzZultbFIu9\nGhA5CDar1IFMhJ9vJpO9nUK/camKs1VQRs8ZsBbXa0GFUM2p8y2cgUfLwFULAiC/\nsWETyW5lcX/xc4Pyf6dONhqFJt/ovVBxNZtcmMEWv/1D6Tf0nLeEb0P2i/pnSRR4\nOq99LVFjossXtyvtaq06OSiUUZ1zLPvV6AQINg8dWeBOWRcQYhYcEcC2wQ06KShZ\n0ahuu7ar5Gym3vuLK6nH+eQrkUievVomN/LpASrYhK32joQ5ypIJej3sICIgJUEP\nUoeswJ+Z16f3ECoL1OSnq4A0riiLj1ZGmVHNhM6m/gotKaHNMxsK9zsbqmuU6IT/\nP6cR0S+vdigQG8ZNFf5vEyVNXhl8KcaJn6lMD/gMB2rY0qpaeTg4gPfU5wcg8S4Y\nC9V//tw3hv0f2n+8kGNmqZrylOQDQWSSo8j8M2SRSXiwOHDoTASd1fyBEIqBAwzn\nLvXVg8wQd1WlmM3b0Vrsbzltyh6y4SuKSkmgufYYvC07NknQO5vqvZcNoYbLNea3\n76NkFaMHUekSbwVejZgG5HGwbaYBgNdJEdpbWlA3X4yGRVxknQSUyt4dZRnw/HrX\nk8x6/wvtw7wht0/DOqz1li7baSsMazqxx+jDdSr1h9xML416Q4loFCLgqQhil8Jq\nEm4Hy3A=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGBTCCA+2gAwIBAgIRAJfKe4Zh4aWNt3bv6ZjQwogwDQYJKoZIhvcNAQEMBQAw\ngZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\nQW1hem9uIFJEUyBjYS1jZW50cmFsLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMDg1M1oYDzIxMjEwNTIxMjMwODUzWjCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGNhLWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCpgUH6\nCrzd8cOw9prAh2rkQqAOx2vtuI7xX4tmBG4I/um28eBjyVmgwQ1fpq0Zg2nCKS54\nNn0pCmT7f3h6Bvopxn0J45AzXEtajFqXf92NQ3iPth95GVfAJSD7gk2LWMhpmID9\nJGQyoGuDPg+hYyr292X6d0madzEktVVGO4mKTF989qEg+tY8+oN0U2fRTrqa2tZp\niYsmg350ynNopvntsJAfpCO/srwpsqHHLNFZ9jvhTU8uW90wgaKO9i31j/mHggCE\n+CAOaJCM3g+L8DPl/2QKsb6UkBgaaIwKyRgKSj1IlgrK+OdCBCOgM9jjId4Tqo2j\nZIrrPBGl6fbn1+etZX+2/tf6tegz+yV0HHQRAcKCpaH8AXF44bny9andslBoNjGx\nH6R/3ib4FhPrnBMElzZ5i4+eM/cuPC2huZMBXb/jKgRC/QN1Wm3/nah5FWq+yn+N\ntiAF10Ga0BYzVhHDEwZzN7gn38bcY5yi/CjDUNpY0OzEe2+dpaBKPlXTaFfn9Nba\nCBmXPRF0lLGGtPeTAgjcju+NEcVa82Ht1pqxyu2sDtbu3J5bxp4RKtj+ShwN8nut\nTkf5Ea9rSmHEY13fzgibZlQhXaiFSKA2ASUwgJP19Putm0XKlBCNSGCoECemewxL\n+7Y8FszS4Uu4eaIwvXVqUEE2yf+4ex0hqQ1acQIDAQABo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBSeUnXIRxNbYsZLtKomIz4Y1nOZEzAOBgNVHQ8BAf8E\nBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBAIpRvxVS0dzoosBh/qw65ghPUGSbP2D4\ndm6oYCv5g/zJr4fR7NzEbHOXX5aOQnHbQL4M/7veuOCLNPOW1uXwywMg6gY+dbKe\nYtPVA1as8G9sUyadeXyGh2uXGsziMFXyaESwiAXZyiYyKChS3+g26/7jwECFo5vC\nXGhWpIO7Hp35Yglp8AnwnEAo/PnuXgyt2nvyTSrxlEYa0jus6GZEZd77pa82U1JH\nqFhIgmKPWWdvELA3+ra1nKnvpWM/xX0pnMznMej5B3RT3Y+k61+kWghJE81Ix78T\n+tG4jSotgbaL53BhtQWBD1yzbbilqsGE1/DXPXzHVf9yD73fwh2tGWSaVInKYinr\na4tcrB3KDN/PFq0/w5/21lpZjVFyu/eiPj6DmWDuHW73XnRwZpHo/2OFkei5R7cT\nrn/YdDD6c1dYtSw5YNnS6hdCQ3sOiB/xbPRN9VWJa6se79uZ9NLz6RMOr73DNnb2\nbhIR9Gf7XAA5lYKqQk+A+stoKbIT0F65RnkxrXi/6vSiXfCh/bV6B41cf7MY/6YW\nehserSdjhQamv35rTFdM+foJwUKz1QN9n9KZhPxeRmwqPitAV79PloksOnX25ElN\nSlyxdndIoA1wia1HRd26EFm2pqfZ2vtD2EjU3wD42CXX4H8fKVDna30nNFSYF0yn\njGKc3k6UNxpg\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQaRHaEqqacXN20e8zZJtmDDANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIHVzLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI1MjIzODM1WhgPMjEyMTA1MjUyMzM4MzVaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgdXMtZWFzdC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAInfBCaHuvj6Rb5c\nL5Wmn1jv2PHtEGMHm+7Z8dYosdwouG8VG2A+BCYCZfij9lIGszrTXkY4O7vnXgru\nJUNdxh0Q3M83p4X+bg+gODUs3jf+Z3Oeq7nTOk/2UYvQLcxP4FEXILxDInbQFcIx\nyen1ESHggGrjEodgn6nbKQNRfIhjhW+TKYaewfsVWH7EF2pfj+cjbJ6njjgZ0/M9\nVZifJFBgat6XUTOf3jwHwkCBh7T6rDpgy19A61laImJCQhdTnHKvzTpxcxiLRh69\nZObypR7W04OAUmFS88V7IotlPmCL8xf7kwxG+gQfvx31+A9IDMsiTqJ1Cc4fYEKg\nbL+Vo+2Ii4W2esCTGVYmHm73drznfeKwL+kmIC/Bq+DrZ+veTqKFYwSkpHRyJCEe\nU4Zym6POqQ/4LBSKwDUhWLJIlq99bjKX+hNTJykB+Lbcx0ScOP4IAZQoxmDxGWxN\nS+lQj+Cx2pwU3S/7+OxlRndZAX/FKgk7xSMkg88HykUZaZ/ozIiqJqSnGpgXCtED\noQ4OJw5ozAr+/wudOawaMwUWQl5asD8fuy/hl5S1nv9XxIc842QJOtJFxhyeMIXt\nLVECVw/dPekhMjS3Zo3wwRgYbnKG7YXXT5WMxJEnHu8+cYpMiRClzq2BEP6/MtI2\nAZQQUFu2yFjRGL2OZA6IYjxnXYiRAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFADCcQCPX2HmkqQcmuHfiQ2jjqnrMA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEASXkGQ2eUmudIKPeOIF7RBryCoPmMOsqP0+1qxF8l\npGkwmrgNDGpmd9s0ArfIVBTc1jmpgB3oiRW9c6n2OmwBKL4UPuQ8O3KwSP0iD2sZ\nKMXoMEyphCEzW1I2GRvYDugL3Z9MWrnHkoaoH2l8YyTYvszTvdgxBPpM2x4pSkp+\n76d4/eRpJ5mVuQ93nC+YG0wXCxSq63hX4kyZgPxgCdAA+qgFfKIGyNqUIqWgeyTP\nn5OgKaboYk2141Rf2hGMD3/hsGm0rrJh7g3C0ZirPws3eeJfulvAOIy2IZzqHUSY\njkFzraz6LEH3IlArT3jUPvWKqvh2lJWnnp56aqxBR7qHH5voD49UpJWY1K0BjGnS\nOHcurpp0Yt/BIs4VZeWdCZwI7JaSeDcPMaMDBvND3Ia5Fga0thgYQTG6dE+N5fgF\nz+hRaujXO2nb0LmddVyvE8prYlWRMuYFv+Co8hcMdJ0lEZlfVNu0jbm9/GmwAZ+l\n9umeYO9yz/uC7edC8XJBglMAKUmVK9wNtOckUWAcCfnPWYLbYa/PqtXBYcxrso5j\niaS/A7iEW51uteHBGrViCy1afGG+hiUWwFlesli+Rq4dNstX3h6h2baWABaAxEVJ\ny1RnTQSz6mROT1VmZSgSVO37rgIyY0Hf0872ogcTS+FfvXgBxCxsNWEbiQ/XXva4\n0Ws=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICtDCCAjqgAwIBAgIRAMyaTlVLN0ndGp4ffwKAfoMwCgYIKoZIzj0EAwMwgZkx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\nem9uIFJEUyBtZS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjIwNTA3MDA0NDM3WhgPMjEyMjA1MDcwMTQ0MzdaMIGZMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\nbiBSRFMgbWUtY2VudHJhbC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE19nCV1nsI6CohSor13+B25cr\nzg+IHdi9Y3L7ziQnHWI6yjBazvnKD+oC71aRRlR8b5YXsYGUQxWzPLHN7EGPcSGv\nbzA9SLG1KQYCJaQ0m9Eg/iGrwKWOgylbhVw0bCxoo0IwQDAPBgNVHRMBAf8EBTAD\nAQH/MB0GA1UdDgQWBBS4KsknsJXM9+QPEkBdZxUPaLr11zAOBgNVHQ8BAf8EBAMC\nAYYwCgYIKoZIzj0EAwMDaAAwZQIxAJaRgrYIEfXQMZQQDxMTYS0azpyWSseQooXo\nL3nYq4OHGBgYyQ9gVjvRYWU85PXbfgIwdi82DtANQFkCu+j+BU0JBY/uRKPEeYzo\nJG92igKIcXPqCoxIJ7lJbbzmuf73gQu5\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAJwCobx0Os8F7ihbJngxrR8wDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjAxNzE1MzNaGA8yMTIxMDUyMDE4MTUzM1owgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBtZS1zb3V0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANukKwlm+ZaI\nY5MkWGbEVLApEyLmlrHLEg8PfiiEa9ts7jssQcin3bzEPdTqGr5jo91ONoZ3ccWq\nxJgg1W3bLu5CAO2CqIOXTXHRyCO/u0Ch1FGgWB8xETPSi3UHt/Vn1ltdO6DYdbDU\nmYgwzYrvLBdRCwxsb9o+BuYQHVFzUYonqk/y9ujz3gotzFq7r55UwDTA1ita3vb4\neDKjIb4b1M4Wr81M23WHonpje+9qkkrAkdQcHrkgvSCV046xsq/6NctzwCUUNsgF\n7Q1a8ut5qJEYpz5ta8vI1rqFqAMBqCbFjRYlmAoTTpFPOmzAVxV+YoqTrW5A16su\n/2SXlMYfJ/n/ad/QfBNPPAAQMpyOr2RCL/YiL/PFZPs7NxYjnZHNWxMLSPgFyI+/\nt2klnn5jR76KJK2qimmaXedB90EtFsMRUU1e4NxH9gDuyrihKPJ3aVnZ35mSipvR\n/1KB8t8gtFXp/VQaz2sg8+uxPMKB81O37fL4zz6Mg5K8+aq3ejBiyHucpFGnsnVB\n3kQWeD36ONkybngmgWoyPceuSWm1hQ0Z7VRAQX+KlxxSaHmSaIk1XxZu9h9riQHx\nfMuev6KXjRn/CjCoUTn+7eFrt0dT5GryQEIZP+nA0oq0LKxogigHNZlwAT4flrqb\nJUfZJrqgoce5HjZSXl10APbtPjJi0fW9AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFEfV+LztI29OVDRm0tqClP3NrmEWMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAvSNe+0wuk53KhWlRlRf2x/97H2Q76X3anzF0\n5fOSVm022ldALzXMzqOfdnoKIhAu2oVKiHHKs7mMas+T6TL+Mkphx0CYEVxFE3PG\n061q3CqJU+wMm9W9xsB79oB2XG47r1fIEywZZ3GaRsatAbjcNOT8uBaATPQAfJFN\nzjFe4XyN+rA4cFrYNvfHTeu5ftrYmvks7JlRaJgEGWsz+qXux7uvaEEVPqEumd2H\nuYeaRNOZ2V23R009X5lbgBFx9tq5VDTnKhQiTQ2SeT0rc1W3Dz5ik6SbQQNP3nSR\n0Ywy7r/sZ3fcDyfFiqnrVY4Ympfvb4YW2PZ6OsQJbzH6xjdnTG2HtzEU30ngxdp1\nWUEF4zt6rjJCp7QBUqXgdlHvJqYu6949qtWjEPiFN9uSsRV2i1YDjJqN52dLjAPn\nAipJKo8x1PHTwUzuITqnB9BdP+5TlTl8biJfkEf/+08eWDTLlDHr2VrZLOLompTh\nbS5OrhDmqA2Q+O+EWrTIhMflwwlCpR9QYM/Xwvlbad9H0FUHbJsCVNaru3wGOgWo\ntt3dNSK9Lqnv/Ej9K9v6CRr36in4ylJKivhJ5B9E7ABHg7EpBJ1xi7O5eNDkNoJG\n+pFyphJq3AkBR2U4ni2tUaTAtSW2tks7IaiDV+UMtqZyGabT5ISQfWLLtLHSWn2F\nTspdjbg=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIECTCCAvGgAwIBAgIRAJZFh4s9aZGzKaTMLrSb4acwDQYJKoZIhvcNAQELBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBCZXRhIHVzLWVhc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTE4MjEyODQxWhgPMjA2MTA1MTgyMjI4NDFa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgQmV0YSB1cy1lYXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA\n17i2yoU6diep+WrqxIn2CrDEO2NdJVwWTSckx4WMZlLpkQDoymSmkNHjq9ADIApD\nA31Cx+843apL7wub8QkFZD0Tk7/ThdHWJOzcAM3ov98QBPQfOC1W5zYIIRP2F+vQ\nTRETHQnLcW3rLv0NMk5oQvIKpJoC9ett6aeVrzu+4cU4DZVWYlJUoC/ljWzCluau\n8blfW0Vwin6OB7s0HCG5/wijQWJBU5SrP/KAIPeQi1GqG5efbqAXDr/ple0Ipwyo\nXjjl73LenGUgqpANlC9EAT4i7FkJcllLPeK3NcOHjuUG0AccLv1lGsHAxZLgjk/x\nz9ZcnVV9UFWZiyJTKxeKPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBRWyMuZUo4gxCR3Luf9/bd2AqZ7CjAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZI\nhvcNAQELBQADggEBAIqN2DlIKlvDFPO0QUZQVFbsi/tLdYM98/vvzBpttlTGVMyD\ngJuQeHVz+MnhGIwoCGOlGU3OOUoIlLAut0+WG74qYczn43oA2gbMd7HoD7oL/IGg\nnjorBwJVcuuLv2G//SqM3nxGcLRtkRnQ+lvqPxMz9+0fKFUn6QcIDuF0QSfthLs2\nWSiGEPKO9c9RSXdRQ4pXA7c3hXng8P4A2ZmdciPne5Nu4I4qLDGZYRrRLRkNTrOi\nTyS6r2HNGUfgF7eOSeKt3NWL+mNChcYj71/Vycf5edeczpUgfnWy9WbPrK1svKyl\naAs2xg+X6O8qB+Mnj2dNBzm+lZIS3sIlm+nO9sg=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAPAlEk8VJPmEzVRRaWvTh2AwCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyB1cy1lYXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTI1MjI0MTU1WhgPMjEyMTA1MjUyMzQxNTVaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgdXMtZWFzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEx5xjrup8II4HOJw15NTnS3H5yMrQGlbj\nEDA5MMGnE9DmHp5dACIxmPXPMe/99nO7wNdl7G71OYPCgEvWm0FhdvVUeTb3LVnV\nBnaXt32Ek7/oxGk1T+Df03C+W0vmuJ+wo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBTGXmqBWN/1tkSea4pNw0oHrjk2UDAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIxAIqqZWCSrIkZ7zsv/FygtAusW6yvlL935YAWYPVXU30m\njkMFLM+/RJ9GMvnO8jHfCgIwB+whlkcItzE9CRQ6CsMo/d5cEHDUu/QW6jSIh9BR\nOGh9pTYPVkUbBiKPA7lVVhre\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAJGY9kZITwfSRaAS/bSBOw8wDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBzYS1lYXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE4MTEyMFoYDzIxMjEwNTE5MTkxMTIwWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIHNhLWVhc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDe2vlDp6Eo4WQi\nWi32YJOgdXHhxTFrLjB9SRy22DYoMaWfginJIwJcSR8yse8ZDQuoNhERB9LRggAE\neng23mhrfvtL1yQkMlZfBu4vG1nOb22XiPFzk7X2wqz/WigdYNBCqa1kK3jrLqPx\nYUy7jk2oZle4GLVRTNGuMfcid6S2hs3UCdXfkJuM2z2wc3WUlvHoVNk37v2/jzR/\nhSCHZv5YHAtzL/kLb/e64QkqxKll5QmKhyI6d7vt6Lr1C0zb+DmwxUoJhseAS0hI\ndRk5DklMb4Aqpj6KN0ss0HAYqYERGRIQM7KKA4+hxDMUkJmt8KqWKZkAlCZgflzl\nm8NZ31o2cvBzf6g+VFHx+6iVrSkohVQydkCxx7NJ743iPKsh8BytSM4qU7xx4OnD\nH2yNXcypu+D5bZnVZr4Pywq0w0WqbTM2bpYthG9IC4JeVUvZ2mDc01lqOlbMeyfT\nog5BRPLDXdZK8lapo7se2teh64cIfXtCmM2lDSwm1wnH2iSK+AWZVIM3iE45WSGc\nvZ+drHfVgjJJ5u1YrMCWNL5C2utFbyF9Obw9ZAwm61MSbPQL9JwznhNlCh7F2ANW\nZHWQPNcOAJqzE4uVcJB1ZeVl28ORYY1668lx+s9yYeMXk3QQdj4xmdnvoBFggqRB\nZR6Z0D7ZohADXe024RzEo1TukrQgKQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBT7Vs4Y5uG/9aXnYGNMEs6ycPUT3jAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBACN4Htp2PvGcQA0/sAS+qUVWWJoAXSsu8Pgc6Gar\n7tKVlNJ/4W/a6pUV2Xo/Tz3msg4yiE8sMESp2k+USosD5n9Alai5s5qpWDQjrqrh\n76AGyF2nzve4kIN19GArYhm4Mz/EKEG1QHYvBDGgXi3kNvL/a2Zbybp+3LevG+q7\nxtx4Sz9yIyMzuT/6Y7ijtiMZ9XbuxGf5wab8UtwT3Xq1UradJy0KCkzRJAz/Wy/X\nHbTkEvKSaYKExH6sLo0jqdIjV/d2Io31gt4e0Ly1ER2wPyFa+pc/swu7HCzrN+iz\nA2ZM4+KX9nBvFyfkHLix4rALg+WTYJa/dIsObXkdZ3z8qPf5A9PXlULiaa1mcP4+\nrokw74IyLEYooQ8iSOjxumXhnkTS69MAdGzXYE5gnHokABtGD+BB5qLhtLt4fqAp\n8AyHpQWMyV42M9SJLzQ+iOz7kAgJOBOaVtJI3FV/iAg/eqWVm3yLuUTWDxSHrKuL\nN19+pSjF6TNvUSFXwEa2LJkfDqIOCE32iOuy85QY//3NsgrSQF6UkSPa95eJrSGI\n3hTRYYh3Up2GhBGl1KUy7/o0k3KRZTk4s38fylY8bZ3TakUOH5iIGoHyFVVcp361\nPyy25SzFSmNalWoQd9wZVc/Cps2ldxhcttM+WLkFNzprd0VJa8qTz8vYtHP0ouDN\nnWS0\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAOY7gfcBZgR2tqfBzMbFQCUwDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtNCBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjIwNTI1MTY1NDU5WhgPMjEyMjA1MjUxNzU0NTla\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtc291dGhlYXN0LTQgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\nlfxER43FuLRdL08bddF0YhbCP+XXKj1A/TFMXmd2My8XDei8rPXFYyyjMig9+xZw\nuAsIxLwz8uiA26CKA8bCZKg5VG2kTeOJAfvBJaLv1CZefs3Z4Uf1Sjvm6MF2yqEj\nGoORfyfL9HiZFTDuF/hcjWoKYCfMuG6M/wO8IbdICrX3n+BiYQJu/pFO660Mg3h/\n8YBBWYDbHoCiH/vkqqJugQ5BM3OI5nsElW51P1icEEqti4AZ7JmtSv9t7fIFBVyR\noaEyOgpp0sm193F/cDJQdssvjoOnaubsSYm1ep3awZAUyGN/X8MBrPY95d0hLhfH\nEhc5Icyg+hsosBljlAyksmt4hFQ9iBnWIz/ZTfGMck+6p3HVL9RDgvluez+rWv59\n8q7omUGsiPApy5PDdwI/Wt/KtC34/2sjslIJfvgifdAtkRPkhff1WEwER00ADrN9\neGGInaCpJfb1Rq8cV2n00jxg7DcEd65VR3dmIRb0bL+jWK62ni/WdEyomAOMfmGj\naWf78S/4rasHllWJ+QwnaUYY3u6N8Cgio0/ep4i34FxMXqMV3V0/qXdfhyabi/LM\nwCxNo1Dwt+s6OtPJbwO92JL+829QAxydfmaMTeHBsgMPkG7RwAekeuatKGHNsc2Z\nx2Q4C2wVvOGAhcHwxfM8JfZs3nDSZJndtVVnFlUY0UECAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUpnG7mWazy6k97/tb5iduRB3RXgQwDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQCDLqq1Wwa9Tkuv7vxBnIeVvvFF\necTn+P+wJxl9Qa2ortzqTHZsBDyJO62d04AgBwiDXkJ9a+bthgG0H1J7Xee8xqv1\nxyX2yKj24ygHjspLotKP4eDMdDi5TYq+gdkbPmm9Q69B1+W6e049JVGXvWG8/7kU\nigxeuCYwtCCdUPRLf6D8y+1XMGgVv3/DSOHWvTg3MJ1wJ3n3+eve3rjGdRYWZeJu\nk21HLSZYzVrCtUsh2YAeLnUbSxVuT2Xr4JehYe9zW5HEQ8Je/OUfnCy9vzoN/ITw\nosAH+EBJQey7RxEDqMwCaRefH0yeHFcnOll0OXg/urnQmwbEYzQ1uutJaBPsjU0J\nQf06sMxI7GiB5nPE+CnI2sM6A9AW9kvwexGXpNJiLxF8dvPQthpOKGcYu6BFvRmt\n6ctfXd9b7JJoVqMWuf5cCY6ihpk1e9JTlAqu4Eb/7JNyGiGCR40iSLvV28un9wiE\nplrdYxwcNYq851BEu3r3AyYWw/UW1AKJ5tM+/Gtok+AphMC9ywT66o/Kfu44mOWm\nL3nSLSWEcgfUVgrikpnyGbUnGtgCmHiMlUtNVexcE7OtCIZoVAlCGKNu7tyuJf10\nQlk8oIIzfSIlcbHpOYoN79FkLoDNc2er4Gd+7w1oPQmdAB0jBJnA6t0OUBPKdDdE\nUfff2jrbfbzECn1ELg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCDCCA/CgAwIBAgIQIuO1A8LOnmc7zZ/vMm3TrDANBgkqhkiG9w0BAQwFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA1MjQyMDQ2MThaGA8yMTIxMDUyNDIxNDYxOFow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDq\nqRHKbG8ZK6/GkGm2cenznEF06yHwI1gD5sdsHjTgekDZ2Dl9RwtDmUH2zFuIQwGj\nSeC7E2iKwrJRA5wYzL9/Vk8NOILEKQOP8OIKUHbc7q8rEtjs401KcU6pFBBEdO9G\nCTiRhogq+8mhC13AM/UriZJbKhwgM2UaDOzAneGMhQAGjH8z83NsNcPxpYVE7tqM\nsch5yLtIJLkJRusrmQQTeHUev16YNqyUa+LuFclFL0FzFCimkcxUhXlbfEKXbssS\nyPzjiv8wokGyo7+gA0SueceMO2UjfGfute3HlXZDcNvBbkSY+ver41jPydyRD6Qq\noEkh0tyIbPoa3oU74kwipJtz6KBEA3u3iq61OUR0ENhR2NeP7CSKrC24SnQJZ/92\nqxusrbyV/0w+U4m62ug/o4hWNK1lUcc2AqiBOvCSJ7qpdteTFxcEIzDwYfERDx6a\nd9+3IPvzMb0ZCxBIIUFMxLTF7yAxI9s6KZBBXSZ6tDcCCYIgEysEPRWMRAcG+ye/\nfZVn9Vnzsj4/2wchC2eQrYpb1QvG4eMXA4M5tFHKi+/8cOPiUzJRgwS222J8YuDj\nyEBval874OzXk8H8Mj0JXJ/jH66WuxcBbh5K7Rp5oJn7yju9yqX6qubY8gVeMZ1i\nu4oXCopefDqa35JplQNUXbWwSebi0qJ4EK0V8F9Q+QIDAQABo0IwQDAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBT4ysqCxaPe7y+g1KUIAenqu8PAgzAOBgNVHQ8B\nAf8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBALU8WN35KAjPZEX65tobtCDQFkIO\nuJjv0alD7qLB0i9eY80C+kD87HKqdMDJv50a5fZdqOta8BrHutgFtDm+xo5F/1M3\nu5/Vva5lV4xy5DqPajcF4Mw52czYBmeiLRTnyPJsU93EQIC2Bp4Egvb6LI4cMOgm\n4pY2hL8DojOC5PXt4B1/7c1DNcJX3CMzHDm4SMwiv2MAxSuC/cbHXcWMk+qXdrVx\n+ayLUSh8acaAOy3KLs1MVExJ6j9iFIGsDVsO4vr4ZNsYQiyHjp+L8ops6YVBO5AT\nk/pI+axHIVsO5qiD4cFWvkGqmZ0gsVtgGUchZaacboyFsVmo6QPrl28l6LwxkIEv\nGGJYvIBW8sfqtGRspjfX5TlNy5IgW/VOwGBdHHsvg/xpRo31PR3HOFw7uPBi7cAr\nFiZRLJut7af98EB2UvovZnOh7uIEGPeecQWeOTQfJeWet2FqTzFYd0NUMgqPuJx1\nvLKferP+ajAZLJvVnW1J7Vccx/pm0rMiUJEf0LRb/6XFxx7T2RGjJTi0EzXODTYI\ngnLfBBjnolQqw+emf4pJ4pAtly0Gq1KoxTG2QN+wTd4lsCMjnelklFDjejwnl7Uy\nvtxzRBAu/hi/AqDkDFf94m6j+edIrjbi9/JDFtQ9EDlyeqPgw0qwi2fwtJyMD45V\nfejbXelUSJSzDIdY\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCTCCA/GgAwIBAgIRAN7Y9G9i4I+ZaslPobE7VL4wDQYJKoZIhvcNAQEMBQAw\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1ub3J0aGVhc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwIBcNMjEwNTIwMTYzMzIzWhgPMjEyMTA1MjAxNzMzMjNa\nMIGcMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywg\nSW5jLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExNTAzBgNVBAMM\nLEFtYXpvbiBSRFMgYXAtbm9ydGhlYXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAw\nDgYDVQQHDAdTZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n4BEPCiIfiK66Q/qa8k+eqf1Q3qsa6Xuu/fPkpuStXVBShhtXd3eqrM0iT4Xxs420\nVa0vSB3oZ7l86P9zYfa60n6PzRxdYFckYX330aI7L/oFIdaodB/C9szvROI0oLG+\n6RwmIF2zcprH0cTby8MiM7G3v9ykpq27g4WhDC1if2j8giOQL3oHpUaByekZNIHF\ndIllsI3RkXmR3xmmxoOxJM1B9MZi7e1CvuVtTGOnSGpNCQiqofehTGwxCN2wFSK8\nxysaWlw48G0VzZs7cbxoXMH9QbMpb4tpk0d+T8JfAPu6uWO9UwCLWWydf0CkmA/+\nD50/xd1t33X9P4FEaPSg5lYbHXzSLWn7oLbrN2UqMLaQrkoEBg/VGvzmfN0mbflw\n+T87bJ/VEOVNlG+gepyCTf89qIQVWOjuYMox4sK0PjzZGsYEuYiq1+OUT3vk/e5K\nag1fCcq2Isy4/iwB2xcXrsQ6ljwdk1fc+EmOnjGKrhuOHJY3S+RFv4ToQBsVyYhC\nXGaC3EkqIX0xaCpDimxYhFjWhpDXAjG/zJ+hRLDAMCMhl/LPGRk/D1kzSbPmdjpl\nlEMK5695PeBvEBTQdBQdOiYgOU3vWU6tzwwHfiM2/wgvess/q0FDAHfJhppbgbb9\n3vgsIUcsvoC5o29JvMsUxsDRvsAfEmMSDGkJoA/X6GECAwEAAaNCMEAwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUgEWm1mZCbGD6ytbwk2UU1aLaOUUwDgYDVR0P\nAQH/BAQDAgGGMA0GCSqGSIb3DQEBDAUAA4ICAQBb4+ABTGBGwxK1U/q4g8JDqTQM\n1Wh8Oz8yAk4XtPJMAmCctxbd81cRnSnePWw/hxViLVtkZ/GsemvXfqAQyOn1coN7\nQeYSw+ZOlu0j2jEJVynmgsR7nIRqE7QkCyZAU+d2FTJUfmee+IiBiGyFGgxz9n7A\nJhBZ/eahBbiuoOik/APW2JWLh0xp0W0GznfJ8lAlaQTyDa8iDXmVtbJg9P9qzkvl\nFgPXQttzEOyooF8Pb2LCZO4kUz+1sbU7tHdr2YE+SXxt6D3SBv+Yf0FlvyWLiqVk\nGDEOlPPTDSjAWgKnqST8UJ0RDcZK/v1ixs7ayqQJU0GUQm1I7LGTErWXHMnCuHKe\nUKYuiSZwmTcJ06NgdhcCnGZgPq13ryMDqxPeltQc3n5eO7f1cL9ERYLDLOzm6A9P\noQ3MfcVOsbHgGHZWaPSeNrQRN9xefqBXH0ZPasgcH9WJdsLlEjVUXoultaHOKx3b\nUCCb+d3EfqF6pRT488ippOL6bk7zNubwhRa/+y4wjZtwe3kAX78ACJVcjPobH9jZ\nErySads5zdQeaoee5wRKdp3TOfvuCe4bwLRdhOLCHWzEcXzY3g/6+ppLvNom8o+h\nBh5X26G6KSfr9tqhQ3O9IcbARjnuPbvtJnoPY0gz3EHHGPhy0RNW8i2gl3nUp0ah\nPtjwbKW0hYAhIttT0Q==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICtzCCAj2gAwIBAgIQQRBQTs6Y3H1DDbpHGta3lzAKBggqhkjOPQQDAzCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDYxMTAwMTI0M1oYDzIxMjEwNjExMDExMjQzWjCBmzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTQwMgYDVQQDDCtBbWF6\nb24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEs0942Xj4m/gKA+WA6F5h\nAHYuek9eGpzTRoLJddM4rEV1T3eSueytMVKOSlS3Ub9IhyQrH2D8EHsLYk9ktnGR\npATk0kCYTqFbB7onNo070lmMJmGT/Q7NgwC8cySChFxbo0IwQDAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBQ20iKBKiNkcbIZRu0y1uoF1yJTEzAOBgNVHQ8BAf8E\nBAMCAYYwCgYIKoZIzj0EAwMDaAAwZQIwYv0wTSrpQTaPaarfLN8Xcqrqu3hzl07n\nFrESIoRw6Cx77ZscFi2/MV6AFyjCV/TlAjEAhpwJ3tpzPXpThRML8DMJYZ3YgMh3\nCMuLqhPpla3cL0PhybrD27hJWl29C4el6aMO\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrDCCAjOgAwIBAgIQGcztRyV40pyMKbNeSN+vXTAKBggqhkjOPQQDAzCBljEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\nb24gUkRTIHVzLWVhc3QtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTAgFw0yMTA1MjEyMzE1NTZaGA8yMTIxMDUyMjAwMTU1NlowgZYxCzAJBgNV\nBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\nVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\nUyB1cy1lYXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\ndjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfDcv+GGRESD9wT+I5YIPRsD3L+/jsiIis\nTr7t9RSbFl+gYpO7ZbDXvNbV5UGOC5lMJo/SnqFRTC6vL06NF7qOHfig3XO8QnQz\n6T5uhhrhnX2RSY3/10d2kTyHq3ZZg3+jQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\nVR0OBBYEFLDyD3PRyNXpvKHPYYxjHXWOgfPnMA4GA1UdDwEB/wQEAwIBhjAKBggq\nhkjOPQQDAwNnADBkAjB20HQp6YL7CqYD82KaLGzgw305aUKw2aMrdkBR29J183jY\n6Ocj9+Wcif9xnRMS+7oCMAvrt03rbh4SU9BohpRUcQ2Pjkh7RoY0jDR4Xq4qzjNr\n5UFr3BXpFvACxXF51BksGQ==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjWgAwIBAgIQeKbS5zvtqDvRtwr5H48cAjAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIG1lLXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTIwMTcxOTU1WhgPMjEyMTA1MjAxODE5NTVaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgbWUtc291dGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABEKjgUaAPmUlRMEQdBC7BScAGosJ1zRV\nLDd38qTBjzgmwBfQJ5ZfGIvyEK5unB09MB4e/3qqK5I/L6Qn5Px/n5g4dq0c7MQZ\nu7G9GBYm90U3WRJBf7lQrPStXaRnS4A/O6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUNKcAbGEIn03/vkwd8g6jNyiRdD4wDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2cAMGQCMHIeTrjenCSYuGC6txuBt/0ZwnM/ciO9kHGWVCoK8QLs\njGghb5/YSFGZbmQ6qpGlSAIwVOQgdFfTpEfe5i+Vs9frLJ4QKAfc27cTNYzRIM0I\nE+AJgK4C4+DiyyMzOpiCfmvq\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGCDCCA/CgAwIBAgIQSFkEUzu9FYgC5dW+5lnTgjANBgkqhkiG9w0BAQwFADCB\nnDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTUwMwYDVQQDDCxB\nbWF6b24gUkRTIGFwLXNvdXRoZWFzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4G\nA1UEBwwHU2VhdHRsZTAgFw0yMTA2MTEwMDA4MzZaGA8yMTIxMDYxMTAxMDgzNlow\ngZwxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTE1MDMGA1UEAwws\nQW1hem9uIFJEUyBhcC1zb3V0aGVhc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAO\nBgNVBAcMB1NlYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDx\nmy5Qmd8zdwaI/KOKV9Xar9oNbhJP5ED0JCiigkuvCkg5qM36klszE8JhsUj40xpp\nvQw9wkYW4y+C8twBpzKGBvakqMnoaVUV7lOCKx0RofrnNwkZCboTBB4X/GCZ3fIl\nYTybS7Ehi1UuiaZspIT5A2jidoA8HiBPk+mTg1UUkoWS9h+MEAPa8L4DY6fGf4pO\nJ1Gk2cdePuNzzIrpm2yPto+I8MRROwZ3ha7ooyymOXKtz2c7jEHHJ314boCXAv9G\ncdo27WiebewZkHHH7Zx9iTIVuuk2abyVSzvLVeGv7Nuy4lmSqa5clWYqWsGXxvZ2\n0fZC5Gd+BDUMW1eSpW7QDTk3top6x/coNoWuLSfXiC5ZrJkIKimSp9iguULgpK7G\nabMMN4PR+O+vhcB8E879hcwmS2yd3IwcPTl3QXxufqeSV58/h2ibkqb/W4Bvggf6\n5JMHQPlPHOqMCVFIHP1IffIo+Of7clb30g9FD2j3F4qgV3OLwEDNg/zuO1DiAvH1\nL+OnmGHkfbtYz+AVApkAZrxMWwoYrwpauyBusvSzwRE24vLTd2i80ZDH422QBLXG\nrN7Zas8rwIiBKacJLYtBYETw8mfsNt8gb72aIQX6cZOsphqp6hUtKaiMTVgGazl7\ntBXqbB+sIv3S9X6bM4cZJKkMJOXbnyCCLZFYv8TurwIDAQABo0IwQDAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBTOVtaS1b/lz6yJDvNk65vEastbQTAOBgNVHQ8B\nAf8EBAMCAYYwDQYJKoZIhvcNAQEMBQADggIBABEONg+TmMZM/PrYGNAfB4S41zp1\n3CVjslZswh/pC4kgXSf8cPJiUOzMwUevuFQj7tCqxQtJEygJM2IFg4ViInIah2kh\nxlRakEGGw2dEVlxZAmmLWxlL1s1lN1565t5kgVwM0GVfwYM2xEvUaby6KDVJIkD3\naM6sFDBshvVA70qOggM6kU6mwTbivOROzfoIQDnVaT+LQjHqY/T+ok6IN0YXXCWl\nFavai8RDjzLDFwXSRvgIK+1c49vlFFY4W9Efp7Z9tPSZU1TvWUcKdAtV8P2fPHAS\nvAZ+g9JuNfeawhEibjXkwg6Z/yFUueQCQOs9TRXYogzp5CMMkfdNJF8byKYqHscs\nUosIcETnHwqwban99u35sWcoDZPr6aBIrz7LGKTJrL8Nis8qHqnqQBXu/fsQEN8u\nzJ2LBi8sievnzd0qI0kaWmg8GzZmYH1JCt1GXSqOFkI8FMy2bahP7TUQR1LBUKQ3\nhrOSqldkhN+cSAOnvbQcFzLr+iEYEk34+NhcMIFVE+51KJ1n6+zISOinr6mI3ckX\n6p2tmiCD4Shk2Xx/VTY/KGvQWKFcQApWezBSvDNlGe0yV71LtLf3dr1pr4ofo7cE\nrYucCJ40bfxEU/fmzYdBF32xP7AOD9U0FbOR3Mcthc6Z6w20WFC+zru8FGY08gPf\nWT1QcNdw7ntUJP/w\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQARky6+5PNFRkFVOp3Ob1CTAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjIwNTIzMTg0MTI4WhgPMjEyMjA1MjMxOTQxMjdaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgZXUtc291dGgtMiBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABNVGL5oF7cfIBxKyWd2PVK/S5yQfaJY3\nQFHWvEdt6951n9JhiiPrHzfVHsxZp1CBjILRMzjgRbYWmc8qRoLkgGE7htGdwudJ\nFa/WuKzO574Prv4iZXUnVGTboC7JdvKbh6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUgDeIIEKynwUbNXApdIPnmRWieZwwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMEOOJfucrST+FxuqJkMZyCM3gWGZaB+/w6+XUAJC6hFM\nuSTY0F44/bERkA4XhH+YGAIxAIpJQBakCA1/mXjsTnQ+0El9ty+LODp8ibkn031c\n8DKDS7pR9UK7ZYdR6zFg3ZCjQw==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjOgAwIBAgIQJvkWUcYLbnxtuwnyjMmntDAKBggqhkjOPQQDAzCBljEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMS8wLQYDVQQDDCZBbWF6\nb24gUkRTIGV1LXdlc3QtMyBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTAgFw0yMTA1MjUyMjI2MTJaGA8yMTIxMDUyNTIzMjYxMlowgZYxCzAJBgNV\nBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMwEQYD\nVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1hem9uIFJE\nUyBldS13ZXN0LTMgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0bGUw\ndjAQBgcqhkjOPQIBBgUrgQQAIgNiAARENn8uHCyjn1dFax4OeXxvbV861qsXFD9G\nDshumTmFzWWHN/69WN/AOsxy9XN5S7Cgad4gQgeYYYgZ5taw+tFo/jQvCLY//uR5\nuihcLuLJ78opvRPvD9kbWZ6oXfBtFkWjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYD\nVR0OBBYEFKiK3LpoF+gDnqPldGSwChBPCYciMA4GA1UdDwEB/wQEAwIBhjAKBggq\nhkjOPQQDAwNpADBmAjEA+7qfvRlnvF1Aosyp9HzxxCbN7VKu+QXXPhLEBWa5oeWW\nUOcifunf/IVLC4/FGCsLAjEAte1AYp+iJyOHDB8UYkhBE/1sxnFaTiEPbvQBU0wZ\nSuwWVLhu2wWDuSW+K7tTuL8p\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAKeDpqX5WFCGNo94M4v69sUwDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTMgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNTIyMTgzM1oYDzIwNjEwNTI1MjMxODMzWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCcKOTEMTfzvs4H\nWtJR8gI7GXN6xesulWtZPv21oT+fLGwJ+9Bv8ADCGDDrDxfeH/HxJmzG9hgVAzVn\n4g97Bn7q07tGZM5pVi96/aNp11velZT7spOJKfJDZTlGns6DPdHmx48whpdO+dOb\n6+eR0VwCIv+Vl1fWXgoACXYCoKjhxJs+R+fwY//0JJ1YG8yjZ+ghLCJmvlkOJmE1\nTCPUyIENaEONd6T+FHGLVYRRxC2cPO65Jc4yQjsXvvQypoGgx7FwD5voNJnFMdyY\n754JGPOOe/SZdepN7Tz7UEq8kn7NQSbhmCsgA/Hkjkchz96qN/YJ+H/okiQUTNB0\neG9ogiVFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFjayw9Y\nMjbxfF14XAhMM2VPl0PfMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAAtmx6d9+9CWlMoU0JCirtp4dSS41bBfb9Oor6GQ8WIr2LdfZLL6uES/ubJPE\n1Sh5Vu/Zon5/MbqLMVrfniv3UpQIof37jKXsjZJFE1JVD/qQfRzG8AlBkYgHNEiS\nVtD4lFxERmaCkY1tjKB4Dbd5hfhdrDy29618ZjbSP7NwAfnwb96jobCmMKgxVGiH\nUqsLSiEBZ33b2hI7PJ6iTJnYBWGuiDnsWzKRmheA4nxwbmcQSfjbrNwa93w3caL2\nv/4u54Kcasvcu3yFsUwJygt8z43jsGAemNZsS7GWESxVVlW93MJRn6M+MMakkl9L\ntWaXdHZ+KUV7LhfYLb0ajvb40w==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBDCCAuygAwIBAgIQJ5oxPEjefCsaESSwrxk68DANBgkqhkiG9w0BAQsFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNjA2MjExNzA1WhgPMjA2MjA2MDYyMjE3MDVaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALTQt5eX\ng+VP3BjO9VBkWJhE0GfLrU/QIk32I6WvrnejayTrlup9H1z4QWlXF7GNJrqScRMY\nKhJHlcP05aPsx1lYco6pdFOf42ybXyWHHJdShj4A5glU81GTT+VrXGzHSarLmtua\neozkQgPpDsSlPt0RefyTyel7r3Cq+5K/4vyjCTcIqbfgaGwTU36ffjM1LaPCuE4O\nnINMeD6YuImt2hU/mFl20FZ+IZQUIFZZU7pxGLqTRz/PWcH8tDDxnkYg7tNuXOeN\nJbTpXrw7St50/E9ZQ0llGS+MxJD8jGRAa/oL4G/cwnV8P2OEPVVkgN9xDDQeieo0\n3xkzolkDkmeKOnUCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU\nbwu8635iQGQMRanekesORM8Hkm4wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEB\nCwUAA4IBAQAgN6LE9mUgjsj6xGCX1afYE69fnmCjjb0rC6eEe1mb/QZNcyw4XBIW\n6+zTXo4mjZ4ffoxb//R0/+vdTE7IvaLgfAZgFsLKJCtYDDstXZj8ujQnGR9Pig3R\nW+LpNacvOOSJSawNQq0Xrlcu55AU4buyD5VjcICnfF1dqBMnGTnh27m/scd/ZMx/\nkapHZ/fMoK2mAgSX/NvUKF3UkhT85vSSM2BTtET33DzCPDQTZQYxFBa4rFRmFi4c\nBLlmIReiCGyh3eJhuUUuYAbK6wLaRyPsyEcIOLMQmZe1+gAFm1+1/q5Ke9ugBmjf\nPbTWjsi/lfZ5CdVAhc5lmZj/l5aKqwaS\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAKKPTYKln9L4NTx9dpZGUjowCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTIxMjI1NTIxWhgPMjEyMTA1MjEyMzU1MjFaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgZXUtd2VzdC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE/owTReDvaRqdmbtTzXbyRmEpKCETNj6O\nhZMKH0F8oU9Tmn8RU7kQQj6xUKEyjLPrFBN7c+26TvrVO1KmJAvbc8bVliiJZMbc\nC0yV5PtJTalvlMZA1NnciZuhxaxrzlK1o0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBT4i5HaoHtrs7Mi8auLhMbKM1XevDAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIxAK9A+8/lFdX4XJKgfP+ZLy5ySXC2E0Spoy12Gv2GdUEZ\np1G7c1KbWVlyb1d6subzkQIwKyH0Naf/3usWfftkmq8SzagicKz5cGcEUaULq4tO\nGzA/AMpr63IDBAqkZbMDTCmH\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrzCCAjWgAwIBAgIQTgIvwTDuNWQo0Oe1sOPQEzAKBggqhkjOPQQDAzCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTI0MjEwNjM4WhgPMjEyMTA1MjQyMjA2MzhaMIGXMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpvbiBS\nRFMgZXUtbm9ydGgtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwHU2VhdHRs\nZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABJuzXLU8q6WwSKXBvx8BbdIi3mPhb7Xo\nrNJBfuMW1XRj5BcKH1ZoGaDGw+BIIwyBJg8qNmCK8kqIb4cH8/Hbo3Y+xBJyoXq/\ncuk8aPrxiNoRsKWwiDHCsVxaK9L7GhHHAqNCMEAwDwYDVR0TAQH/BAUwAwEB/zAd\nBgNVHQ4EFgQUYgcsdU4fm5xtuqLNppkfTHM2QMYwDgYDVR0PAQH/BAQDAgGGMAoG\nCCqGSM49BAMDA2gAMGUCMQDz/Rm89+QJOWJecYAmYcBWCcETASyoK1kbr4vw7Hsg\n7Ew3LpLeq4IRmTyuiTMl0gMCMAa0QSjfAnxBKGhAnYxcNJSntUyyMpaXzur43ec0\n3D8npJghwC4DuICtKEkQiI5cSg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAORIGqQXLTcbbYT2upIsSnQwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMjA1MjMxODM0MjJaGA8yMTIyMDUyMzE5MzQyMlowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBldS1zb3V0aC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAPKukwsW2s/h\n1k+Hf65pOP0knVBnOnMQyT1mopp2XHGdXznj9xS49S30jYoUnWccyXgD983A1bzu\nw4fuJRHg4MFdz/NWTgXvy+zy0Roe83OPIJjUmXnnzwUHQcBa9vl6XUO65iQ3pbSi\nfQfNDFXD8cvuXbkezeADoy+iFAlzhXTzV9MD44GTuo9Z3qAXNGHQCrgRSCL7uRYt\nt1nfwboCbsVRnElopn2cTigyVXE62HzBUmAw1GTbAZeFAqCn5giBWYAfHwTUldRL\n6eEa6atfsS2oPNus4ZENa1iQxXq7ft+pMdNt0qKXTCZiiCZjmLkY0V9kWwHTRRF8\nr+75oSL//3di43QnuSCgjwMRIeWNtMud5jf3eQzSBci+9njb6DrrSUbx7blP0srg\n94/C/fYOp/0/EHH34w99Th14VVuGWgDgKahT9/COychLOubXUT6vD1As47S9KxTv\nyYleVKwJnF9cVjepODN72fNlEf74BwzgSIhUmhksmZSeJBabrjSUj3pdyo/iRZN/\nCiYz9YPQ29eXHPQjBZVIUqWbOVfdwsx0/Xu5T1e7yyXByQ3/oDulahtcoKPAFQ3J\nee6NJK655MdS7pM9hJnU2Rzu3qZ/GkM6YK7xTlMXVouPUZov/VbiaCKbqYDs8Dg+\nUKdeNXAT6+BMleGQzly1X7vjhgeA8ugVAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFJdaPwpCf78UolFTEn6GO85/QwUIMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAWkxHIT3mers5YnZRSVjmpxCLivGj1jMB9VYC\niKqTAeIvD0940L0YaZgivQll5pue8UUcQ6M2uCdVVAsNJdmQ5XHIYiGOknYPtxzO\naO+bnZp7VIZw/vJ49hvH6RreA2bbxYMZO/ossYdcWsWbOKHFrRmAw0AhtK/my51g\nobV7eQg+WmlE5Iqc75ycUsoZdc3NimkjBi7LQoNP1HMvlLHlF71UZhQDdq+/WdV7\n0zmg+epkki1LjgMmuPyb+xWuYkFKT1/faX+Xs62hIm5BY+aI4if4RuQ+J//0pOSs\nUajrjTo+jLGB8A96jAe8HaFQenbwMjlaHRDAF0wvbkYrMr5a6EbneAB37V05QD0Y\nRh4L4RrSs9DX2hbSmS6iLDuPEjanHKzglF5ePEvnItbRvGGkynqDVlwF+Bqfnw8l\n0i8Hr1f1/LP1c075UjkvsHlUnGgPbLqA0rDdcxF8Fdlv1BunUjX0pVlz10Ha5M6P\nAdyWUOneOfaA5G7jjv7i9qg3r99JNs1/Lmyg/tV++gnWTAsSPFSSEte81kmPhlK3\n2UtAO47nOdTtk+q4VIRAwY1MaOR7wTFZPfer1mWs4RhKNu/odp8urEY87iIzbMWT\nQYO/4I6BGj9rEWNGncvR5XTowwIthMCj2KWKM3Z/JxvjVFylSf+s+FFfO1bNIm6h\nu3UBpZI=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICtDCCAjmgAwIBAgIQenQbcP/Zbj9JxvZ+jXbRnTAKBggqhkjOPQQDAzCBmTEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTIwMAYDVQQDDClBbWF6\nb24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIEVDQzM4NCBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTAgFw0yMTA1MjEyMjMzMjRaGA8yMTIxMDUyMTIzMzMyNFowgZkxCzAJ\nBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMuMRMw\nEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1hem9u\nIFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATlBHiEM9LoEb1Hdnd5j2VpCDOU\n5nGuFoBD8ROUCkFLFh5mHrHfPXwBc63heW9WrP3qnDEm+UZEUvW7ROvtWCTPZdLz\nZ4XaqgAlSqeE2VfUyZOZzBSgUUJk7OlznXfkCMOjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFDT/ThjQZl42Nv/4Z/7JYaPNMly2MA4GA1UdDwEB/wQEAwIB\nhjAKBggqhkjOPQQDAwNpADBmAjEAnZWmSgpEbmq+oiCa13l5aGmxSlfp9h12Orvw\nDq/W5cENJz891QD0ufOsic5oGq1JAjEAp5kSJj0MxJBTHQze1Aa9gG4sjHBxXn98\n4MP1VGsQuhfndNHQb4V0Au7OWnOeiobq\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/zCCAuegAwIBAgIRAMgnyikWz46xY6yRgiYwZ3swDQYJKoZIhvcNAQELBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE2NDkxMloYDzIwNjEwNTIwMTc0OTEyWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCi8JYOc9cYSgZH\ngYPxLk6Xcc7HqzamvsnjYU98Dcb98y6iDqS46Ra2Ne02MITtU5MDL+qjxb8WGDZV\nRUA9ZS69tkTO3gldW8QdiSh3J6hVNJQW81F0M7ZWgV0gB3n76WCmfT4IWos0AXHM\n5v7M/M4tqVmCPViQnZb2kdVlM3/Xc9GInfSMCgNfwHPTXl+PXX+xCdNBePaP/A5C\n5S0oK3HiXaKGQAy3K7VnaQaYdiv32XUatlM4K2WS4AMKt+2cw3hTCjlmqKRHvYFQ\nveWCXAuc+U5PQDJ9SuxB1buFJZhT4VP3JagOuZbh5NWpIbOTxlAJOb5pGEDuJTKi\n1gQQQVEFAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNXm+N87\nOFxK9Af/bjSxDCiulGUzMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOC\nAQEAkqIbkgZ45spvrgRQ6n9VKzDLvNg+WciLtmVrqyohwwJbj4pYvWwnKQCkVc7c\nhUOSBmlSBa5REAPbH5o8bdt00FPRrD6BdXLXhaECKgjsHe1WW08nsequRKD8xVmc\n8bEX6sw/utBeBV3mB+3Zv7ejYAbDFM4vnRsWtO+XqgReOgrl+cwdA6SNQT9oW3e5\nrSQ+VaXgJtl9NhkiIysq9BeYigxqS/A13pHQp0COMwS8nz+kBPHhJTsajHCDc8F4\nHfLi6cgs9G0gaRhT8FCH66OdGSqn196sE7Y3bPFFFs/3U+vxvmQgoZC6jegQXAg5\nPrxd+VNXtNI/azitTysQPumH7A==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEBTCCAu2gAwIBAgIRAO8bekN7rUReuNPG8pSTKtEwDQYJKoZIhvcNAQELBQAw\ngZoxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEzMDEGA1UEAwwq\nQW1hem9uIFJEUyBldS1jZW50cmFsLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYD\nVQQHDAdTZWF0dGxlMCAXDTIxMDUyMTIyMjM0N1oYDzIwNjEwNTIxMjMyMzQ3WjCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTIwNDggRzExEDAOBgNV\nBAcMB1NlYXR0bGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCTTYds\nTray+Q9VA5j5jTh5TunHKFQzn68ZbOzdqaoi/Rq4ohfC0xdLrxCpfqn2TGDHN6Zi\n2qGK1tWJZEd1H0trhzd9d1CtGK+3cjabUmz/TjSW/qBar7e9MA67/iJ74Gc+Ww43\nA0xPNIWcL4aLrHaLm7sHgAO2UCKsrBUpxErOAACERScVYwPAfu79xeFcX7DmcX+e\nlIqY16pQAvK2RIzrekSYfLFxwFq2hnlgKHaVgZ3keKP+nmXcXmRSHQYUUr72oYNZ\nHcNYl2+gxCc9ccPEHM7xncVEKmb5cWEWvVoaysgQ+osi5f5aQdzgC2X2g2daKbyA\nXL/z5FM9GHpS5BJjAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE\nFBDAiJ7Py9/A9etNa/ebOnx5l5MGMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0B\nAQsFAAOCAQEALMh/+81fFPdJV/RrJUeoUvFCGMp8iaANu97NpeJyKitNOv7RoeVP\nWjivS0KcCqZaDBs+p6IZ0sLI5ZH098LDzzytcfZg0PsGqUAb8a0MiU/LfgDCI9Ee\njsOiwaFB8k0tfUJK32NPcIoQYApTMT2e26lPzYORSkfuntme2PTHUnuC7ikiQrZk\nP+SZjWgRuMcp09JfRXyAYWIuix4Gy0eZ4rpRuaTK6mjAb1/LYoNK/iZ/gTeIqrNt\nl70OWRsWW8jEmSyNTIubGK/gGGyfuZGSyqoRX6OKHESkP6SSulbIZHyJ5VZkgtXo\n2XvyRyJ7w5pFyoofrL3Wv0UF8yt/GDszmg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAMDk/F+rrhdn42SfE+ghPC8wDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTIgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMTIyNTEyMloYDzIxMjEwNTIxMjM1MTIyWjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2twMALVg9vRVu\nVNqsr6N8thmp3Dy8jEGTsm3GCQ+C5P2YcGlD/T/5icfWW84uF7Sx3ezcGlvsqFMf\nUkj9sQyqtz7qfFFugyy7pa/eH9f48kWFHLbQYm9GEgbYBIrWMp1cy3vyxuMCwQN4\nDCncqU+yNpy0CprQJEha3PzY+3yJOjDQtc3zr99lyECCFJTDUucxHzyQvX89eL74\nuh8la0lKH3v9wPpnEoftbrwmm5jHNFdzj7uXUHUJ41N7af7z7QUfghIRhlBDiKtx\n5lYZemPCXajTc3ryDKUZC/b+B6ViXZmAeMdmQoPE0jwyEp/uaUcdp+FlUQwCfsBk\nayPFEApTWgPiku2isjdeTVmEgL8bJTDUZ6FYFR7ZHcYAsDzcwHgIu3GGEMVRS3Uf\nILmioiyly9vcK4Sa01ondARmsi/I0s7pWpKflaekyv5boJKD/xqwz9lGejmJHelf\n8Od2TyqJScMpB7Q8c2ROxBwqwB72jMCEvYigB+Wnbb8RipliqNflIGx938FRCzKL\nUQUBmNAznR/yRRL0wHf9UAE/8v9a09uZABeiznzOFAl/frHpgdAbC00LkFlnwwgX\ng8YfEFlkp4fLx5B7LtoO6uVNFVimLxtwirpyKoj3G4M/kvSTux8bTw0heBCmWmKR\n57MS6k7ODzbv+Kpeht2hqVZCNFMxoQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBRuMnDhJjoj7DcKALj+HbxEqj3r6jAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBALSnXfx72C3ldhBP5kY4Mo2DDaGQ8FGpTOOiD95d\n0rf7I9LrsBGVqu/Nir+kqqP80PB70+Jy9fHFFigXwcPBX3MpKGxK8Cel7kVf8t1B\n4YD6A6bqlzP+OUL0uGWfZpdpDxwMDI2Flt4NEldHgXWPjvN1VblEKs0+kPnKowyg\njhRMgBbD/y+8yg0fIcjXUDTAw/+INcp21gWaMukKQr/8HswqC1yoqW9in2ijQkpK\n2RB9vcQ0/gXR0oJUbZQx0jn0OH8Agt7yfMAnJAdnHO4M3gjvlJLzIC5/4aGrRXZl\nJoZKfJ2fZRnrFMi0nhAYDeInoS+Rwx+QzaBk6fX5VPyCj8foZ0nmqvuYoydzD8W5\nmMlycgxFqS+DUmO+liWllQC4/MnVBlHGB1Cu3wTj5kgOvNs/k+FW3GXGzD3+rpv0\nQTLuwSbMr+MbEThxrSZRSXTCQzKfehyC+WZejgLb+8ylLJUA10e62o7H9PvCrwj+\nZDVmN7qj6amzvndCP98sZfX7CFZPLfcBd4wVIjHsFjSNEwWHOiFyLPPG7cdolGKA\nlOFvonvo4A1uRc13/zFeP0Xi5n5OZ2go8aOOeGYdI2vB2sgH9R2IASH/jHmr0gvY\n0dfBCcfXNgrS0toq0LX/y+5KkKOxh52vEYsJLdhqrveuZhQnsFEm/mFwjRXkyO7c\n2jpC\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGADCCA+igAwIBAgIQYe0HgSuFFP9ivYM2vONTrTANBgkqhkiG9w0BAQwFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE4MzMyMVoYDzIxMjEwNTE5MTkzMzIxWjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuO7QPKfPMTo2\nPOQWvzDLwi5f++X98hGjORI1zkN9kotCYH5pAzSBwBPoMNaIfedgmsIxGHj2fq5G\n4oXagNhNuGP79Zl6uKW5H7S74W7aWM8C0s8zuxMOI4GZy5h2IfQk3m/3AzZEX5w8\nUtNPkzo2feDVOkerHT+j+vjXgAxZ4wHnuMDcRT+K4r9EXlAH6X9b/RO0JlfEwmNz\nxlqqGxocq9qRC66N6W0HF2fNEAKP84n8H80xcZBOBthQORRi8HSmKcPdmrvwCuPz\nM+L+j18q6RAVaA0ABbD0jMWcTf0UvjUfBStn5mvu/wGlLjmmRkZsppUTRukfwqXK\nyltUsTq0tOIgCIpne5zA4v+MebbR5JBnsvd4gdh5BI01QH470yB7BkUefZ9bobOm\nOseAAVXcYFJKe4DAA6uLDrqOfFSxV+CzVvEp3IhLRaik4G5MwI/h2c/jEYDqkg2J\nHMflxc2gcSMdk7E5ByLz5f6QrFfSDFk02ZJTs4ssbbUEYohht9znPMQEaWVqATWE\n3n0VspqZyoBNkH/agE5GiGZ/k/QyeqzMNj+c9kr43Upu8DpLrz8v2uAp5xNj3YVg\nihaeD6GW8+PQoEjZ3mrCmH7uGLmHxh7Am59LfEyNrDn+8Rq95WvkmbyHSVxZnBmo\nh/6O3Jk+0/QhIXZ2hryMflPcYWeRGH0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB\n/zAdBgNVHQ4EFgQU2eFK7+R3x/me8roIBNxBrplkM6EwDgYDVR0PAQH/BAQDAgGG\nMA0GCSqGSIb3DQEBDAUAA4ICAQB5gWFe5s7ObQFj1fTO9L6gYgtFhnwdmxU0q8Ke\nHWCrdFmyXdC39qdAFOwM5/7fa9zKmiMrZvy9HNvCXEp4Z7z9mHhBmuqPZQx0qPgU\nuLdP8wGRuWryzp3g2oqkX9t31Z0JnkbIdp7kfRT6ME4I4VQsaY5Y3mh+hIHOUvcy\np+98i3UuEIcwJnVAV9wTTzrWusZl9iaQ1nSYbmkX9bBssJ2GmtW+T+VS/1hJ/Q4f\nAlE3dOQkLFoPPb3YRWBHr2n1LPIqMVwDNAuWavRA2dSfaLl+kzbn/dua7HTQU5D4\nb2Fu2vLhGirwRJe+V7zdef+tI7sngXqjgObyOeG5O2BY3s+um6D4fS0Th3QchMO7\n0+GwcIgSgcjIjlrt6/xJwJLE8cRkUUieYKq1C4McpZWTF30WnzOPUzRzLHkcNzNA\n0A7sKMK6QoYWo5Rmo8zewUxUqzc9oQSrYADP7PEwGncLtFe+dlRFx+PA1a+lcIgo\n1ZGfXigYtQ3VKkcknyYlJ+hN4eCMBHtD81xDy9iP2MLE41JhLnoB2rVEtewO5diF\n7o95Mwl84VMkLhhHPeGKSKzEbBtYYBifHNct+Bst8dru8UumTltgfX6urH3DN+/8\nJF+5h3U8oR2LL5y76cyeb+GWDXXy9zoQe2QvTyTy88LwZq1JzujYi2k8QiLLhFIf\nFEv9Bg==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICsDCCAjagAwIBAgIRAMgApnfGYPpK/fD0dbN2U4YwCgYIKoZIzj0EAwMwgZcx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwnQW1h\nem9uIFJEUyBldS1zb3V0aC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMCAXDTIxMDUxOTE4MzgxMVoYDzIxMjEwNTE5MTkzODExWjCBlzELMAkG\nA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4xEzAR\nBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6b24g\nUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1NlYXR0\nbGUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQfEWl6d4qSuIoECdZPp+39LaKsfsX7\nTHs3/RrtT0+h/jl3bjZ7Qc68k16x+HGcHbaayHfqD0LPdzH/kKtNSfQKqemdxDQh\nZ4pwkixJu8T1VpXZ5zzCvBXCl75UqgEFS92jQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFFPrSNtWS5JU+Tvi6ABV231XbjbEMA4GA1UdDwEB/wQEAwIBhjAK\nBggqhkjOPQQDAwNoADBlAjEA+a7hF1IrNkBd2N/l7IQYAQw8chnRZDzh4wiGsZsC\n6A83maaKFWUKIb3qZYXFSi02AjAbp3wxH3myAmF8WekDHhKcC2zDvyOiKLkg9Y6v\nZVmyMR043dscQbcsVoacOYv198c=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICtDCCAjqgAwIBAgIRAPhVkIsQ51JFhD2kjFK5uAkwCgYIKoZIzj0EAwMwgZkx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEyMDAGA1UEAwwpQW1h\nem9uIFJEUyBldS1jZW50cmFsLTIgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjIwNjA2MjEyOTE3WhgPMjEyMjA2MDYyMjI5MTdaMIGZMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMjAwBgNVBAMMKUFtYXpv\nbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEA5xnIEBtG5b2nmbj49UEwQza\nyX0844fXjccYzZ8xCDUe9dS2XOUi0aZlGblgSe/3lwjg8fMcKXLObGGQfgIx1+5h\nAIBjORis/dlyN5q/yH4U5sjS8tcR0GDGVHrsRUZCo0IwQDAPBgNVHRMBAf8EBTAD\nAQH/MB0GA1UdDgQWBBRK+lSGutXf4DkTjR3WNfv4+KeNFTAOBgNVHQ8BAf8EBAMC\nAYYwCgYIKoZIzj0EAwMDaAAwZQIxAJ4NxQ1Gerqr70ZrnUqc62Vl8NNqTzInamCG\nKce3FTsMWbS9qkgrjZkO9QqOcGIw/gIwSLrwUT+PKr9+H9eHyGvpq9/3AIYSnFkb\nCf3dyWPiLKoAtLFwjzB/CkJlsAS1c8dS\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/jCCA+agAwIBAgIQGZH12Q7x41qIh9vDu9ikTjANBgkqhkiG9w0BAQwFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIGV1LXdlc3QtMyBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTI1MjIyMjMzWhgPMjEyMTA1MjUyMzIyMzNaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgZXUtd2VzdC0zIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMqE47sHXWzdpuqj\nJHb+6jM9tDbQLDFnYjDWpq4VpLPZhb7xPNh9gnYYTPKG4avG421EblAHqzy9D2pN\n1z90yKbIfUb/Sy2MhQbmZomsObhONEra06fJ0Dydyjswf1iYRp2kwpx5AgkVoNo7\n3dlws73zFjD7ImKvUx2C7B75bhnw2pJWkFnGcswl8fZt9B5Yt95sFOKEz2MSJE91\nkZlHtya19OUxZ/cSGci4MlOySzqzbGwUqGxEIDlY8I39VMwXaYQ8uXUN4G780VcL\nu46FeyRGxZGz2n3hMc805WAA1V5uir87vuirTvoSVREET97HVRGVVNJJ/FM6GXr1\nVKtptybbo81nefYJg9KBysxAa2Ao2x2ry/2ZxwhS6VZ6v1+90bpZA1BIYFEDXXn/\ndW07HSCFnYSlgPtSc+Muh15mdr94LspYeDqNIierK9i4tB6ep7llJAnq0BU91fM2\nJPeqyoTtc3m06QhLf68ccSxO4l8Hmq9kLSHO7UXgtdjfRVaffngopTNk8qK7bIb7\nLrgkqhiQw/PRCZjUdyXL153/fUcsj9nFNe25gM4vcFYwH6c5trd2tUl31NTi1MfG\nMgp3d2dqxQBIYANkEjtBDMy3SqQLIo9EymqmVP8xx2A/gCBgaxvMAsI6FSWRoC7+\nhqJ8XH4mFnXSHKtYMe6WPY+/XZgtAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8w\nHQYDVR0OBBYEFIkXqTnllT/VJnI2NqipA4XV8rh1MA4GA1UdDwEB/wQEAwIBhjAN\nBgkqhkiG9w0BAQwFAAOCAgEAKjSle8eenGeHgT8pltWCw/HzWyQruVKhfYIBfKJd\nMhV4EnH5BK7LxBIvpXGsFUrb0ThzSw0fn0zoA9jBs3i/Sj6KyeZ9qUF6b8ycDXd+\nwHonmJiQ7nk7UuMefaYAfs06vosgl1rI7eBHC0itexIQmKh0aX+821l4GEgEoSMf\nloMFTLXv2w36fPHHCsZ67ODldgcZbKNnpCTX0YrCwEYO3Pz/L398btiRcWGrewrK\njdxAAyietra8DRno1Zl87685tfqc6HsL9v8rVw58clAo9XAQvT+fmSOFw/PogRZ7\nOMHUat3gu/uQ1M5S64nkLLFsKu7jzudBuoNmcJysPlzIbqJ7vYc82OUGe9ucF3wi\n3tbKQ983hdJiTExVRBLX/fYjPsGbG3JtPTv89eg2tjWHlPhCDMMxyRKl6isu2RTq\n6VT489Z2zQrC33MYF8ZqO1NKjtyMAMIZwxVu4cGLkVsqFmEV2ScDHa5RadDyD3Ok\nm+mqybhvEVm5tPgY6p0ILPMN3yvJsMSPSvuBXhO/X5ppNnpw9gnxpwbjQKNhkFaG\nM5pkADZ14uRguOLM4VthSwUSEAr5VQYCFZhEwK+UOyJAGiB/nJz6IxL5XBNUXmRM\nHl8Xvz4riq48LMQbjcVQj0XvH941yPh+P8xOi00SGaQRaWp55Vyr4YKGbV0mEDz1\nr1o=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIF/zCCA+egAwIBAgIRAKwYju1QWxUZpn6D1gOtwgQwDQYJKoZIhvcNAQEMBQAw\ngZcxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEwMC4GA1UEAwwn\nQW1hem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBSU0E0MDk2IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyMDE2NTM1NFoYDzIxMjEwNTIwMTc1MzU0WjCBlzEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdBbWF6\nb24gUkRTIGV1LXdlc3QtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCKdBP1U4lqWWkc\nCb25/BKRTsvNVnISiKocva8GAzJyKfcGRa85gmgu41U+Hz6+39K+XkRfM0YS4BvQ\nF1XxWT0bNyypuvwCvmYShSTjN1TY0ltncDddahTajE/4MdSOZb/c98u0yt03cH+G\nhVwRyT50h0v/UEol50VfwcVAEZEgcQQYhf1IFUFlIvKpmDOqLuFakOnc7c9akK+i\nivST+JO1tgowbnNkn2iLlSSgUWgb1gjaOsNfysagv1RXdlyPw3EyfwkFifAQvF2P\nQ0ayYZfYS640cccv7efM1MSVyFHR9PrrDsF/zr2S2sGPbeHr7R/HwLl+S5J/l9N9\ny0rk6IHAWV4dEkOvgpnuJKURwA48iu1Hhi9e4moNS6eqoK2KmY3VFpuiyWcA73nH\nGSmyaH+YuMrF7Fnuu7GEHZL/o6+F5cL3mj2SJJhL7sz0ryf5Cs5R4yN9BIEj/f49\nwh84pM6nexoI0Q4wiSFCxWiBpjSmOK6h7z6+2utaB5p20XDZHhxAlmlx4vMuWtjh\nXckgRFxc+ZpVMU3cAHUpVEoO49e/+qKEpPzp8Xg4cToKw2+AfTk3cmyyXQfGwXMQ\nZUHNZ3w9ILMWihGCM2aGUsLcGDRennvNmnmin/SENsOQ8Ku0/a3teEzwV9cmmdYz\n5iYs1YtgPvKFobY6+T2RXXh+A5kprwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/\nMB0GA1UdDgQWBBSyUrsQVnKmA8z6/2Ech0rCvqpNmTAOBgNVHQ8BAf8EBAMCAYYw\nDQYJKoZIhvcNAQEMBQADggIBAFlj3IFmgiFz5lvTzFTRizhVofhTJsGr14Yfkuc7\nUrXPuXOwJomd4uot2d/VIeGJpfnuS84qGdmQyGewGTJ9inatHsGZgHl9NHNWRwKZ\nlTKTbBiq7aqgtUSFa06v202wpzU+1kadxJJePrbABxiXVfOmIW/a1a4hPNcT3syH\nFIEg1+CGsp71UNjBuwg3JTKWna0sLSKcxLOSOvX1fzxK5djzVpEsvQMB4PSAzXca\nvENgg2ErTwgTA+4s6rRtiBF9pAusN1QVuBahYP3ftrY6f3ycS4K65GnqscyfvKt5\nYgjtEKO3ZeeX8NpubMbzC+0Z6tVKfPFk/9TXuJtwvVeqow0YMrLLyRiYvK7EzJ97\nrrkxoKnHYQSZ+rH2tZ5SE392/rfk1PJL0cdHnkpDkUDO+8cKsFjjYKAQSNC52sKX\n74AVh6wMwxYwVZZJf2/2XxkjMWWhKNejsZhUkTISSmiLs+qPe3L67IM7GyKm9/m6\nR3r8x6NGjhTsKH64iYJg7AeKeax4b2e4hBb6GXFftyOs7unpEOIVkJJgM6gh3mwn\nR7v4gwFbLKADKt1vHuerSZMiTuNTGhSfCeDM53XI/mjZl2HeuCKP1mCDLlaO+gZR\nQ/G+E0sBKgEX4xTkAc3kgkuQGfExdGtnN2U2ehF80lBHB8+2y2E+xWWXih/ZyIcW\nwOx+\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGBDCCA+ygAwIBAgIQM4C8g5iFRucSWdC8EdqHeDANBgkqhkiG9w0BAQwFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMSBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjEwNTIxMjIyODI2WhgPMjEyMTA1MjEyMzI4MjZaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgZXUtY2VudHJhbC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANeTsD/u\n6saPiY4Sg0GlJlMXMBltnrcGAEkwq34OKQ0bCXqcoNJ2rcAMmuFC5x9Ho1Y3YzB7\nNO2GpIh6bZaO76GzSv4cnimcv9n/sQSYXsGbPD+bAtnN/RvNW1avt4C0q0/ghgF1\nVFS8JihIrgPYIArAmDtGNEdl5PUrdi9y6QGggbRfidMDdxlRdZBe1C18ZdgERSEv\nUgSTPRlVczONG5qcQkUGCH83MMqL5MKQiby/Br5ZyPq6rxQMwRnQ7tROuElzyYzL\n7d6kke+PNzG1mYy4cbYdjebwANCtZ2qYRSUHAQsOgybRcSoarv2xqcjO9cEsDiRU\nl97ToadGYa4VVERuTaNZxQwrld4mvzpyKuirqZltOqg0eoy8VUsaRPL3dc5aChR0\ndSrBgRYmSAClcR2/2ZCWpXemikwgt031Dsc0A/+TmVurrsqszwbr0e5xqMow9LzO\nMI/JtLd0VFtoOkL/7GG2tN8a+7gnLFxpv+AQ0DH5n4k/BY/IyS+H1erqSJhOTQ11\nvDOFTM5YplB9hWV9fp5PRs54ILlHTlZLpWGs3I2BrJwzRtg/rOlvsosqcge9ryai\nAKm2j+JBg5wJ19R8oxRy8cfrNTftZePpISaLTyV2B16w/GsSjqixjTQe9LRN2DHk\ncC+HPqYyzW2a3pUVyTGHhW6a7YsPBs9yzt6hAgMBAAGjQjBAMA8GA1UdEwEB/wQF\nMAMBAf8wHQYDVR0OBBYEFIqA8QkOs2cSirOpCuKuOh9VDfJfMA4GA1UdDwEB/wQE\nAwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAOUI90mEIsa+vNJku0iUwdBMnHiO4gm7E\n5JloP7JG0xUr7d0hypDorMM3zVDAL+aZRHsq8n934Cywj7qEp1304UF6538ByGdz\ntkfacJsUSYfdlNJE9KbA4T+U+7SNhj9jvePpVjdQbhgzxITE9f8CxY/eM40yluJJ\nPhbaWvOiRagzo74wttlcDerzLT6Y/JrVpWhnB7IY8HvzK+BwAdaCsBUPC3HF+kth\nCIqLq7J3YArTToejWZAp5OOI6DLPM1MEudyoejL02w0jq0CChmZ5i55ElEMnapRX\n7GQTARHmjgAOqa95FjbHEZzRPqZ72AtZAWKFcYFNk+grXSeWiDgPFOsq6mDg8DDB\n0kfbYwKLFFCC9YFmYzR2YrWw2NxAScccUc2chOWAoSNHiqBbHR8ofrlJSWrtmKqd\nYRCXzn8wqXnTS3NNHNccqJ6dN+iMr9NGnytw8zwwSchiev53Fpc1mGrJ7BKTWH0t\nZrA6m32wzpMymtKozlOPYoE5mtZEzrzHEXfa44Rns7XIHxVQSXVWyBHLtIsZOrvW\nU5F41rQaFEpEeUQ7sQvqUoISfTUVRNDn6GK6YaccEhCji14APLFIvhRQUDyYMIiM\n4vll0F/xgVRHTgDVQ8b8sxdhSYlqB4Wc2Ym41YRz+X2yPqk3typEZBpc4P5Tt1/N\n89cEIGdbjsA=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQYjbPSg4+RNRD3zNxO1fuKDANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUyNDIwNTkyMVoYDzIwNjEwNTI0MjE1OTIxWjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LW5vcnRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA179eQHxcV0YL\nXMkqEmhSBazHhnRVd8yICbMq82PitE3BZcnv1Z5Zs/oOgNmMkOKae4tCXO/41JCX\nwAgbs/eWWi+nnCfpQ/FqbLPg0h3dqzAgeszQyNl9IzTzX4Nd7JFRBVJXPIIKzlRf\n+GmFsAhi3rYgDgO27pz3ciahVSN+CuACIRYnA0K0s9lhYdddmrW/SYeWyoB7jPa2\nLmWpAs7bDOgS4LlP2H3eFepBPgNufRytSQUVA8f58lsE5w25vNiUSnrdlvDrIU5n\nQwzc7NIZCx4qJpRbSKWrUtbyJriWfAkGU7i0IoainHLn0eHp9bWkwb9D+C/tMk1X\nERZw2PDGkwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSFmR7s\ndAblusFN+xhf1ae0KUqhWTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAHsXOpjPMyH9lDhPM61zYdja1ebcMVgfUvsDvt+w0xKMKPhBzYDMs/cFOi1N\nQ8LV79VNNfI2NuvFmGygcvTIR+4h0pqqZ+wjWl3Kk5jVxCrbHg3RBX02QLumKd/i\nkwGcEtTUvTssn3SM8bgM0/1BDXgImZPC567ciLvWDo0s/Fe9dJJC3E0G7d/4s09n\nOMdextcxFuWBZrBm/KK3QF0ByA8MG3//VXaGO9OIeeOJCpWn1G1PjT1UklYhkg61\nEbsTiZVA2DLd1BGzfU4o4M5mo68l0msse/ndR1nEY6IywwpgIFue7+rEleDh6b9d\nPYkG1rHVw2I0XDG4o17aOn5E94I=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQC6W4HFghUkkgyQw14a6JljANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIyMDUyMzE4MTYzMloYDzIwNjIwNTIzMTkxNjMyWjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LXNvdXRoLTIgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAiM/t4FV2R9Nx\nUQG203UY83jInTa/6TMq0SPyg617FqYZxvz2kkx09x3dmxepUg9ttGMlPgjsRZM5\nLCFEi1FWk+hxHzt7vAdhHES5tdjwds3aIkgNEillmRDVrUsbrDwufLaa+MMDO2E1\nwQ/JYFXw16WBCCi2g1EtyQ2Xp+tZDX5IWOTnvhZpW8vVDptZ2AcJ5rMhfOYO3OsK\n5EF0GGA5ldzuezP+BkrBYGJ4wVKGxeaq9+5AT8iVZrypjwRkD7Y5CurywK3+aBwm\ns9Q5Nd8t45JCOUzYp92rFKsCriD86n/JnEvgDfdP6Hvtm0/DkwXK40Wz2q0Zrd0k\nmjP054NRPwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRR7yqd\nSfKcX2Q8GzhcVucReIpewTAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAEszBRDwXcZyNm07VcFwI1Im94oKwKccuKYeJEsizTBsVon8VpEiMwDs+yGu\n3p8kBhvkLwWybkD/vv6McH7T5b9jDX2DoOudqYnnaYeypsPH/00Vh3LvKagqzQza\norWLx+0tLo8xW4BtU+Wrn3JId8LvAhxyYXTn9bm+EwPcStp8xGLwu53OPD1RXYuy\nuu+3ps/2piP7GVfou7H6PRaqbFHNfiGg6Y+WA0HGHiJzn8uLmrRJ5YRdIOOG9/xi\nqTmAZloUNM7VNuurcMM2hWF494tQpsQ6ysg2qPjbBqzlGoOt3GfBTOZmqmwmqtam\nK7juWM/mdMQAJ3SMlE5wI8nVdx4=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIICrjCCAjSgAwIBAgIRAL9SdzVPcpq7GOpvdGoM80IwCgYIKoZIzj0EAwMwgZYx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTEvMC0GA1UEAwwmQW1h\nem9uIFJEUyBldS13ZXN0LTEgUm9vdCBDQSBFQ0MzODQgRzExEDAOBgNVBAcMB1Nl\nYXR0bGUwIBcNMjEwNTIwMTY1ODA3WhgPMjEyMTA1MjAxNzU4MDdaMIGWMQswCQYD\nVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjETMBEG\nA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExLzAtBgNVBAMMJkFtYXpvbiBS\nRFMgZXUtd2VzdC0xIFJvb3QgQ0EgRUNDMzg0IEcxMRAwDgYDVQQHDAdTZWF0dGxl\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEJWDgXebvwjR+Ce+hxKOLbnsfN5W5dOlP\nZn8kwWnD+SLkU81Eac/BDJsXGrMk6jFD1vg16PEkoSevsuYWlC8xR6FmT6F6pmeh\nfsMGOyJpfK4fyoEPhKeQoT23lFIc5Orjo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G\nA1UdDgQWBBSVNAN1CHAz0eZ77qz2adeqjm31TzAOBgNVHQ8BAf8EBAMCAYYwCgYI\nKoZIzj0EAwMDaAAwZQIxAMlQeHbcjor49jqmcJ9gRLWdEWpXG8thIf6zfYQ/OEAg\nd7GDh4fR/OUk0VfjsBUN/gIwZB0bGdXvK38s6AAE/9IT051cz/wMe9GIrX1MnL1T\n1F5OqnXJdiwfZRRTHsRQ/L00\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGBDCCA+ygAwIBAgIQalr16vDfX4Rsr+gfQ4iVFDANBgkqhkiG9w0BAQwFADCB\nmjELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTMwMQYDVQQDDCpB\nbWF6b24gUkRTIGV1LWNlbnRyYWwtMiBSb290IENBIFJTQTQwOTYgRzExEDAOBgNV\nBAcMB1NlYXR0bGUwIBcNMjIwNjA2MjEyNTIzWhgPMjEyMjA2MDYyMjI1MjNaMIGa\nMQswCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5j\nLjETMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMzAxBgNVBAMMKkFt\nYXpvbiBSRFMgZXUtY2VudHJhbC0yIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANbHbFg7\n2VhZor1YNtez0VlNFaobS3PwOMcEn45BE3y7HONnElIIWXGQa0811M8V2FnyqnE8\nZ5aO1EuvijvWf/3D8DPZkdmAkIfh5hlZYY6Aatr65kEOckwIAm7ZZzrwFogYuaFC\nz/q0CW+8gxNK+98H/zeFx+IxiVoPPPX6UlrLvn+R6XYNERyHMLNgoZbbS5gGHk43\nKhENVv3AWCCcCc85O4rVd+DGb2vMVt6IzXdTQt6Kih28+RGph+WDwYmf+3txTYr8\nxMcCBt1+whyCPlMbC+Yn/ivtCO4LRf0MPZDRQrqTTrFf0h/V0BGEUmMGwuKgmzf5\nKl9ILdWv6S956ioZin2WgAxhcn7+z//sN++zkqLreSf90Vgv+A7xPRqIpTdJ/nWG\nJaAOUofBfsDsk4X4SUFE7xJa1FZAiu2lqB/E+y7jnWOvFRalzxVJ2Y+D/ZfUfrnK\n4pfKtyD1C6ni1celrZrAwLrJ3PoXPSg4aJKh8+CHex477SRsGj8KP19FG8r0P5AG\n8lS1V+enFCNvT5KqEBpDZ/Y5SQAhAYFUX+zH4/n4ql0l/emS+x23kSRrF+yMkB9q\nlhC/fMk6Pi3tICBjrDQ8XAxv56hfud9w6+/ljYB2uQ1iUYtlE3JdIiuE+3ws26O8\ni7PLMD9zQmo+sVi12pLHfBHQ6RRHtdVRXbXRAgMBAAGjQjBAMA8GA1UdEwEB/wQF\nMAMBAf8wHQYDVR0OBBYEFBFot08ipEL9ZUXCG4lagmF53C0/MA4GA1UdDwEB/wQE\nAwIBhjANBgkqhkiG9w0BAQwFAAOCAgEAi2mcZi6cpaeqJ10xzMY0F3L2eOKYnlEQ\nh6QyhmNKCUF05q5u+cok5KtznzqMwy7TFOZtbVHl8uUX+xvgq/MQCxqFAnuStBXm\ngr2dg1h509ZwvTdk7TDxGdftvPCfnPNJBFbMSq4CZtNcOFBg9Rj8c3Yj+Qvwd56V\nzWs65BUkDNJrXmxdvhJZjUkMa9vi/oFN+M84xXeZTaC5YDYNZZeW9706QqDbAVES\n5ulvKLavB8waLI/lhRBK5/k0YykCMl0A8Togt8D1QsQ0eWWbIM8/HYJMPVFhJ8Wj\nvT1p/YVeDA3Bo1iKDOttgC5vILf5Rw1ZEeDxjf/r8A7VS13D3OLjBmc31zxRTs3n\nXvHKP9MieQHn9GE44tEYPjK3/yC6BDFzCBlvccYHmqGb+jvDEXEBXKzimdC9mcDl\nf4BBQWGJBH5jkbU9p6iti19L/zHhz7qU6UJWbxY40w92L9jS9Utljh4A0LCTjlnR\nNQUgjnGC6K+jkw8hj0LTC5Ip87oqoT9w7Av5EJ3VJ4hcnmNMXJJ1DkWYdnytcGpO\nDMVITQzzDZRwhbitCVPHagTN2wdi9TEuYE33J0VmFeTc6FSI50wP2aOAZ0Q1/8Aj\nbxeM5jS25eaHc2CQAuhrc/7GLnxOcPwdWQb2XWT8eHudhMnoRikVv/KSK3mf6om4\n1YfpdH2jp30=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID/jCCAuagAwIBAgIQTDc+UgTRtYO7ZGTQ8UWKDDANBgkqhkiG9w0BAQsFADCB\nlzELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTAwLgYDVQQDDCdB\nbWF6b24gUkRTIGV1LXdlc3QtMiBSb290IENBIFJTQTIwNDggRzExEDAOBgNVBAcM\nB1NlYXR0bGUwIBcNMjEwNTIxMjI0NjI0WhgPMjA2MTA1MjEyMzQ2MjRaMIGXMQsw\nCQYDVQQGEwJVUzEiMCAGA1UECgwZQW1hem9uIFdlYiBTZXJ2aWNlcywgSW5jLjET\nMBEGA1UECwwKQW1hem9uIFJEUzELMAkGA1UECAwCV0ExMDAuBgNVBAMMJ0FtYXpv\nbiBSRFMgZXUtd2VzdC0yIFJvb3QgQ0EgUlNBMjA0OCBHMTEQMA4GA1UEBwwHU2Vh\ndHRsZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAM1oGtthQ1YiVIC2\ni4u4swMAGxAjc/BZp0yq0eP5ZQFaxnxs7zFAPabEWsrjeDzrRhdVO0h7zskrertP\ngblGhfD20JfjvCHdP1RUhy/nzG+T+hn6Takan/GIgs8grlBMRHMgBYHW7tklhjaH\n3F7LujhceAHhhgp6IOrpb6YTaTTaJbF3GTmkqxSJ3l1LtEoWz8Al/nL/Ftzxrtez\nVs6ebpvd7sw37sxmXBWX2OlvUrPCTmladw9OrllGXtCFw4YyLe3zozBlZ3cHzQ0q\nlINhpRcajTMfZrsiGCkQtoJT+AqVJPS2sHjqsEH8yiySW9Jbq4zyMbM1yqQ2vnnx\nMJgoYMcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUaQG88UnV\nJPTI+Pcti1P+q3H7pGYwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IB\nAQBAkgr75V0sEJimC6QRiTVWEuj2Khy7unjSfudbM6zumhXEU2/sUaVLiYy6cA/x\n3v0laDle6T07x9g64j5YastE/4jbzrGgIINFlY0JnaYmR3KZEjgi1s1fkRRf3llL\nPJm9u4Q1mbwAMQK/ZjLuuRcL3uRIHJek18nRqT5h43GB26qXyvJqeYYpYfIjL9+/\nYiZAbSRRZG+Li23cmPWrbA1CJY121SB+WybCbysbOXzhD3Sl2KSZRwSw4p2HrFtV\n1Prk0dOBtZxCG9luf87ultuDZpfS0w6oNBAMXocgswk24ylcADkkFxBWW+7BETn1\nEpK+t1Lm37mU4sxtuha00XAi\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIEADCCAuigAwIBAgIQcY44/8NUvBwr6LlHfRy7KjANBgkqhkiG9w0BAQsFADCB\nmDELMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIElu\nYy4xEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChB\nbWF6b24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQH\nDAdTZWF0dGxlMCAXDTIxMDUxOTE4MjcxOFoYDzIwNjEwNTE5MTkyNzE4WjCBmDEL\nMAkGA1UEBhMCVVMxIjAgBgNVBAoMGUFtYXpvbiBXZWIgU2VydmljZXMsIEluYy4x\nEzARBgNVBAsMCkFtYXpvbiBSRFMxCzAJBgNVBAgMAldBMTEwLwYDVQQDDChBbWF6\nb24gUkRTIGV1LXNvdXRoLTEgUm9vdCBDQSBSU0EyMDQ4IEcxMRAwDgYDVQQHDAdT\nZWF0dGxlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0UaBeC+Usalu\nEtXnV7+PnH+gi7/71tI/jkKVGKuhD2JDVvqLVoqbMHRh3+wGMvqKCjbHPcC2XMWv\n566fpAj4UZ9CLB5fVzss+QVNTl+FH2XhEzigopp+872ajsNzcZxrMkifxGb4i0U+\nt0Zi+UrbL5tsfP2JonKR1crOrbS6/DlzHBjIiJazGOQcMsJjNuTOItLbMohLpraA\n/nApa3kOvI7Ufool1/34MG0+wL3UUA4YkZ6oBJVxjZvvs6tI7Lzz/SnhK2widGdc\nsnbLqBpHNIZQSorVoiwcFaRBGYX/uzYkiw44Yfa4cK2V/B5zgu1Fbr0gbI2am4eh\nyVYyg4jPawIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS9gM1m\nIIjyh9O5H/7Vj0R/akI7UzAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD\nggEBAF0Sm9HC2AUyedBVnwgkVXMibnYChOzz7T+0Y+fOLXYAEXex2s8oqGeZdGYX\nJHkjBn7JXu7LM+TpTbPbFFDoc1sgMguD/ls+8XsqAl1CssW+amryIL+jfcfbgQ+P\nICwEUD9hGdjBgJ5WcuS+qqxHsEIlFNci3HxcxfBa9VsWs5TjI7Vsl4meL5lf7ZyL\nwDV7dHRuU+cImqG1MIvPRIlvPnT7EghrCYi2VCPhP2pM/UvShuwVnkz4MJ29ebIk\nWR9kpblFxFdE92D5UUvMCjC2kmtgzNiErvTcwIvOO9YCbBHzRB1fFiWrXUHhJWq9\nIkaxR5icb/IpAV0A1lYZEWMVsfQ=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIGATCCA+mgAwIBAgIRAMa0TPL+QgbWfUPpYXQkf8wwDQYJKoZIhvcNAQEMBQAw\ngZgxCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJ\nbmMuMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwo\nQW1hem9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UE\nBwwHU2VhdHRsZTAgFw0yMTA1MjQyMTAzMjBaGA8yMTIxMDUyNDIyMDMyMFowgZgx\nCzAJBgNVBAYTAlVTMSIwIAYDVQQKDBlBbWF6b24gV2ViIFNlcnZpY2VzLCBJbmMu\nMRMwEQYDVQQLDApBbWF6b24gUkRTMQswCQYDVQQIDAJXQTExMC8GA1UEAwwoQW1h\nem9uIFJEUyBldS1ub3J0aC0xIFJvb3QgQ0EgUlNBNDA5NiBHMTEQMA4GA1UEBwwH\nU2VhdHRsZTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANhS9LJVJyWp\n6Rudy9t47y6kzvgnFYDrvJVtgEK0vFn5ifdlHE7xqMz4LZqWBFTnS+3oidwVRqo7\ntqsuuElsouStO8m315/YUzKZEPmkw8h5ufWt/lg3NTCoUZNkB4p4skr7TspyMUwE\nVdlKQuWTCOLtofwmWT+BnFF3To6xTh3XPlT3ssancw27Gob8kJegD7E0TSMVsecP\nB8je65+3b8CGwcD3QB3kCTGLy87tXuS2+07pncHvjMRMBdDQQQqhXWsRSeUNg0IP\nxdHTWcuwMldYPWK5zus9M4dCNBDlmZjKdcZZVUOKeBBAm7Uo7CbJCk8r/Fvfr6mw\nnXXDtuWhqn/WhJiI/y0QU27M+Hy5CQMxBwFsfAjJkByBpdXmyYxUgTmMpLf43p7H\noWfH1xN0cT0OQEVmAQjMakauow4AQLNkilV+X6uAAu3STQVFRSrpvMen9Xx3EPC3\nG9flHueTa71bU65Xe8ZmEmFhGeFYHY0GrNPAFhq9RThPRY0IPyCZe0Th8uGejkek\njQjm0FHPOqs5jc8CD8eJs4jSEFt9lasFLVDcAhx0FkacLKQjGHvKAnnbRwhN/dF3\nxt4oL8Z4JGPCLau056gKnYaEyviN7PgO+IFIVOVIdKEBu2ASGE8/+QJB5bcHefNj\n04hEkDW0UYJbSfPpVbGAR0gFI/QpycKnAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wHQYDVR0OBBYEFFMXvvjoaGGUcul8GA3FT05DLbZcMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQwFAAOCAgEAQLwFhd2JKn4K/6salLyIA4mP58qbA/9BTB/r\nD9l0bEwDlVPSdY7R3gZCe6v7SWLfA9RjE5tdWDrQMi5IU6W2OVrVsZS/yGJfwnwe\na/9iUAYprA5QYKDg37h12XhVsDKlYCekHdC+qa5WwB1SL3YUprDLPWeaIQdg+Uh2\n+LxvpZGoxoEbca0fc7flwq9ke/3sXt/3V4wJDyY6AL2YNdjFzC+FtYjHHx8rYxHs\naesP7yunuN17KcfOZBBnSFRrx96k+Xm95VReTEEpwiBqAECqEpMbd+R0mFAayMb1\ncE77GaK5yeC2f67NLYGpkpIoPbO9p9rzoXLE5GpSizMjimnz6QCbXPFAFBDfSzim\nu6azp40kEUO6kWd7rBhqRwLc43D3TtNWQYxMve5mTRG4Od+eMKwYZmQz89BQCeqm\naZiJP9y9uwJw4p/A5V3lYHTDQqzmbOyhGUk6OdpdE8HXs/1ep1xTT20QDYOx3Ekt\nr4mmNYfH/8v9nHNRlYJOqFhmoh1i85IUl5IHhg6OT5ZTTwsGTSxvgQQXrmmHVrgZ\nrZIqyBKllCgVeB9sMEsntn4bGLig7CS/N1y2mYdW/745yCLZv2gj0NXhPqgEIdVV\nf9DhFD4ohE1C63XP0kOQee+LYg/MY5vH8swpCSWxQgX5icv5jVDz8YTdCKgUc5u8\nrM2p0kk=\n-----END CERTIFICATE-----\n"
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/aws-ssl-profiles@1.1.2/node_modules/aws-ssl-profiles/lib/profiles/ca/proxies.js
+var require_proxies = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/aws-ssl-profiles@1.1.2/node_modules/aws-ssl-profiles/lib/profiles/ca/proxies.js": ((exports) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	exports.proxies = void 0;
+	/**
+	* CA Certificates for **Amazon RDS Proxy** (2024)
+	*
+	* - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.howitworks.html#rds-proxy-security.tls
+	* - https://www.amazontrust.com/repository/
+	*/
+	exports.proxies = [
+		"-----BEGIN CERTIFICATE-----\nMIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF\nADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\nb24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL\nMAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\nb3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj\nca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM\n9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw\nIFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6\nVOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L\n93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm\njgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC\nAYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA\nA4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI\nU5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs\nN+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv\no/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU\n5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy\nrqXRfboQnoZsG4q5WTP468SQvvG5\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIFQTCCAymgAwIBAgITBmyf0pY1hp8KD+WGePhbJruKNzANBgkqhkiG9w0BAQwF\nADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\nb24gUm9vdCBDQSAyMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTEL\nMAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv\nb3QgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK2Wny2cSkxK\ngXlRmeyKy2tgURO8TW0G/LAIjd0ZEGrHJgw12MBvIITplLGbhQPDW9tK6Mj4kHbZ\nW0/jTOgGNk3Mmqw9DJArktQGGWCsN0R5hYGCrVo34A3MnaZMUnbqQ523BNFQ9lXg\n1dKmSYXpN+nKfq5clU1Imj+uIFptiJXZNLhSGkOQsL9sBbm2eLfq0OQ6PBJTYv9K\n8nu+NQWpEjTj82R0Yiw9AElaKP4yRLuH3WUnAnE72kr3H9rN9yFVkE8P7K6C4Z9r\n2UXTu/Bfh+08LDmG2j/e7HJV63mjrdvdfLC6HM783k81ds8P+HgfajZRRidhW+me\nz/CiVX18JYpvL7TFz4QuK/0NURBs+18bvBt+xa47mAExkv8LV/SasrlX6avvDXbR\n8O70zoan4G7ptGmh32n2M8ZpLpcTnqWHsFcQgTfJU7O7f/aS0ZzQGPSSbtqDT6Zj\nmUyl+17vIWR6IF9sZIUVyzfpYgwLKhbcAS4y2j5L9Z469hdAlO+ekQiG+r5jqFoz\n7Mt0Q5X5bGlSNscpb/xVA1wf+5+9R+vnSUeVC06JIglJ4PVhHvG/LopyboBZ/1c6\n+XUyo05f7O0oYtlNc/LMgRdg7c3r3NunysV+Ar3yVAhU/bQtCSwXVEqY0VThUWcI\n0u1ufm8/0i2BWSlmy5A5lREedCf+3euvAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB\nAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSwDPBMMPQFWAJI/TPlUq9LhONm\nUjANBgkqhkiG9w0BAQwFAAOCAgEAqqiAjw54o+Ci1M3m9Zh6O+oAA7CXDpO8Wqj2\nLIxyh6mx/H9z/WNxeKWHWc8w4Q0QshNabYL1auaAn6AFC2jkR2vHat+2/XcycuUY\n+gn0oJMsXdKMdYV2ZZAMA3m3MSNjrXiDCYZohMr/+c8mmpJ5581LxedhpxfL86kS\nk5Nrp+gvU5LEYFiwzAJRGFuFjWJZY7attN6a+yb3ACfAXVU3dJnJUH/jWS5E4ywl\n7uxMMne0nxrpS10gxdr9HIcWxkPo1LsmmkVwXqkLN1PiRnsn/eBG8om3zEK2yygm\nbtmlyTrIQRNg91CMFa6ybRoVGld45pIq2WWQgj9sAq+uEjonljYE1x2igGOpm/Hl\nurR8FLBOybEfdF849lHqm/osohHUqS0nGkWxr7JOcQ3AWEbWaQbLU8uz/mtBzUF+\nfUwPfHJ5elnNXkoOrJupmHN5fLT0zLm4BwyydFy4x2+IoZCn9Kr5v2c69BoVYh63\nn749sSmvZ6ES8lgQGVMDMBu4Gon2nL2XA46jCfMdiyHxtN/kHNGfZQIG6lzWE7OE\n76KlXIx3KadowGuuQNKotOrN8I1LOJwZmhsoVLiJkO/KdYE+HvJkJMcYr07/R54H\n9jVlpNMKVv/1F2Rs76giJUmTtt8AF9pYfl3uxRuw0dFfIRDH+fO6AgonB8Xx1sfT\n4PsJYGw=\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5\nMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\nUm9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\nA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\nQ0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl\nui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j\nQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr\nttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr\nBqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM\nYyRIHN8wfdVoOw==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5\nMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\nUm9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG\nA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg\nQ0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi\n9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk\nM6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB\n/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB\nMAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw\nCkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW\n1KyLa2tJElMzrdfkviT8tQp21KW8EA==\n-----END CERTIFICATE-----\n",
+		"-----BEGIN CERTIFICATE-----\nMIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx\nEDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT\nHFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs\nZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5\nMDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD\nVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy\nZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy\ndmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p\nOsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2\n8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K\nTs9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe\nhRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk\n6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw\nDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q\nAdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI\nbw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB\nve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z\nqwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd\niEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn\n0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN\nsSi6\n-----END CERTIFICATE-----\n"
+	];
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/aws-ssl-profiles@1.1.2/node_modules/aws-ssl-profiles/lib/index.js
+var require_lib = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/aws-ssl-profiles@1.1.2/node_modules/aws-ssl-profiles/lib/index.js": ((exports, module) => {
+	Object.defineProperty(exports, "__esModule", { value: true });
+	const defaults_js_1 = require_defaults();
+	const proxies_js_1 = require_proxies();
+	const proxyBundle = { ca: proxies_js_1.proxies };
+	const profiles = { ca: [...defaults_js_1.defaults, ...proxies_js_1.proxies] };
+	module.exports = profiles;
+	module.exports.proxyBundle = proxyBundle;
+	module.exports.default = profiles;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/ssl_profiles.js
+var require_ssl_profiles = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/constants/ssl_profiles.js": ((exports) => {
+	const awsCaBundle = require_lib();
+	/**
+	* @deprecated
+	* Please, use [**aws-ssl-profiles**](https://github.com/mysqljs/aws-ssl-profiles).
+	*/
+	exports["Amazon RDS"] = { ca: awsCaBundle.ca };
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/connection_config.js
+var require_connection_config = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/connection_config.js": ((exports, module) => {
+	const { URL } = __require("url");
+	const ClientConstants = require_client();
+	const Charsets = require_charsets();
+	const { version } = require_package();
+	let SSLProfiles = null;
+	const validOptions = {
+		authPlugins: 1,
+		authSwitchHandler: 1,
+		bigNumberStrings: 1,
+		charset: 1,
+		charsetNumber: 1,
+		compress: 1,
+		connectAttributes: 1,
+		connectTimeout: 1,
+		database: 1,
+		dateStrings: 1,
+		debug: 1,
+		decimalNumbers: 1,
+		enableKeepAlive: 1,
+		flags: 1,
+		host: 1,
+		insecureAuth: 1,
+		infileStreamFactory: 1,
+		isServer: 1,
+		keepAliveInitialDelay: 1,
+		localAddress: 1,
+		maxPreparedStatements: 1,
+		multipleStatements: 1,
+		namedPlaceholders: 1,
+		nestTables: 1,
+		password: 1,
+		password1: 1,
+		password2: 1,
+		password3: 1,
+		passwordSha1: 1,
+		pool: 1,
+		port: 1,
+		queryFormat: 1,
+		rowsAsArray: 1,
+		socketPath: 1,
+		ssl: 1,
+		stream: 1,
+		stringifyObjects: 1,
+		supportBigNumbers: 1,
+		timezone: 1,
+		trace: 1,
+		typeCast: 1,
+		uri: 1,
+		user: 1,
+		disableEval: 1,
+		connectionLimit: 1,
+		maxIdle: 1,
+		idleTimeout: 1,
+		Promise: 1,
+		queueLimit: 1,
+		waitForConnections: 1,
+		jsonStrings: 1
+	};
+	var ConnectionConfig$3 = class ConnectionConfig$3 {
+		constructor(options) {
+			if (typeof options === "string") options = ConnectionConfig$3.parseUrl(options);
+			else if (options && options.uri) {
+				const uriOptions = ConnectionConfig$3.parseUrl(options.uri);
+				for (const key$1 in uriOptions) {
+					if (!Object.prototype.hasOwnProperty.call(uriOptions, key$1)) continue;
+					if (options[key$1]) continue;
+					options[key$1] = uriOptions[key$1];
+				}
+			}
+			for (const key$1 in options) {
+				if (!Object.prototype.hasOwnProperty.call(options, key$1)) continue;
+				if (validOptions[key$1] !== 1) console.error(`Ignoring invalid configuration option passed to Connection: ${key$1}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`);
+			}
+			this.isServer = options.isServer;
+			this.stream = options.stream;
+			this.host = options.host || "localhost";
+			this.port = (typeof options.port === "string" ? parseInt(options.port, 10) : options.port) || 3306;
+			this.localAddress = options.localAddress;
+			this.socketPath = options.socketPath;
+			this.user = options.user || void 0;
+			this.password = options.password || options.password1 || void 0;
+			this.password2 = options.password2 || void 0;
+			this.password3 = options.password3 || void 0;
+			this.passwordSha1 = options.passwordSha1 || void 0;
+			this.database = options.database;
+			this.connectTimeout = isNaN(options.connectTimeout) ? 10 * 1e3 : options.connectTimeout;
+			this.insecureAuth = options.insecureAuth || false;
+			this.infileStreamFactory = options.infileStreamFactory || void 0;
+			this.supportBigNumbers = options.supportBigNumbers || false;
+			this.bigNumberStrings = options.bigNumberStrings || false;
+			this.decimalNumbers = options.decimalNumbers || false;
+			this.dateStrings = options.dateStrings || false;
+			this.debug = options.debug;
+			this.trace = options.trace !== false;
+			this.stringifyObjects = options.stringifyObjects || false;
+			this.enableKeepAlive = options.enableKeepAlive !== false;
+			this.keepAliveInitialDelay = options.keepAliveInitialDelay;
+			if (options.timezone && !/^(?:local|Z|[ +-]\d\d:\d\d)$/.test(options.timezone)) {
+				console.error(`Ignoring invalid timezone passed to Connection: ${options.timezone}. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection`);
+				this.timezone = "Z";
+			} else this.timezone = options.timezone || "local";
+			this.queryFormat = options.queryFormat;
+			this.pool = options.pool || void 0;
+			this.ssl = typeof options.ssl === "string" ? ConnectionConfig$3.getSSLProfile(options.ssl) : options.ssl || false;
+			this.multipleStatements = options.multipleStatements || false;
+			this.rowsAsArray = options.rowsAsArray || false;
+			this.namedPlaceholders = options.namedPlaceholders || false;
+			this.nestTables = options.nestTables === void 0 ? void 0 : options.nestTables;
+			this.typeCast = options.typeCast === void 0 ? true : options.typeCast;
+			this.disableEval = Boolean(options.disableEval);
+			if (this.timezone[0] === " ") this.timezone = `+${this.timezone.slice(1)}`;
+			if (this.ssl) {
+				if (typeof this.ssl !== "object") throw new TypeError(`SSL profile must be an object, instead it's a ${typeof this.ssl}`);
+				this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;
+			}
+			this.maxPacketSize = 0;
+			this.charsetNumber = options.charset ? ConnectionConfig$3.getCharsetNumber(options.charset) : options.charsetNumber || Charsets.UTF8MB4_UNICODE_CI;
+			this.compress = options.compress || false;
+			this.authPlugins = options.authPlugins;
+			this.authSwitchHandler = options.authSwitchHandler;
+			this.clientFlags = ConnectionConfig$3.mergeFlags(ConnectionConfig$3.getDefaultFlags(options), options.flags || "");
+			this.connectAttributes = {
+				_client_name: "Node-MySQL-2",
+				_client_version: version,
+				...options.connectAttributes || {}
+			};
+			this.maxPreparedStatements = options.maxPreparedStatements || 16e3;
+			this.jsonStrings = options.jsonStrings || false;
+		}
+		static mergeFlags(default_flags, user_flags) {
+			let flags = 0, i$4;
+			if (!Array.isArray(user_flags)) user_flags = String(user_flags || "").toUpperCase().split(/\s*,+\s*/);
+			for (i$4 in default_flags) {
+				if (user_flags.indexOf(`-${default_flags[i$4]}`) >= 0) continue;
+				flags |= ClientConstants[default_flags[i$4]] || 0;
+			}
+			for (i$4 in user_flags) {
+				if (user_flags[i$4][0] === "-") continue;
+				if (default_flags.indexOf(user_flags[i$4]) >= 0) continue;
+				flags |= ClientConstants[user_flags[i$4]] || 0;
+			}
+			return flags;
+		}
+		static getDefaultFlags(options) {
+			const defaultFlags = [
+				"LONG_PASSWORD",
+				"FOUND_ROWS",
+				"LONG_FLAG",
+				"CONNECT_WITH_DB",
+				"ODBC",
+				"LOCAL_FILES",
+				"IGNORE_SPACE",
+				"PROTOCOL_41",
+				"IGNORE_SIGPIPE",
+				"TRANSACTIONS",
+				"RESERVED",
+				"SECURE_CONNECTION",
+				"MULTI_RESULTS",
+				"TRANSACTIONS",
+				"SESSION_TRACK",
+				"CONNECT_ATTRS"
+			];
+			if (options && options.multipleStatements) defaultFlags.push("MULTI_STATEMENTS");
+			defaultFlags.push("PLUGIN_AUTH");
+			defaultFlags.push("PLUGIN_AUTH_LENENC_CLIENT_DATA");
+			return defaultFlags;
+		}
+		static getCharsetNumber(charset) {
+			const num = Charsets[charset.toUpperCase()];
+			if (num === void 0) throw new TypeError(`Unknown charset '${charset}'`);
+			return num;
+		}
+		static getSSLProfile(name) {
+			if (!SSLProfiles) SSLProfiles = require_ssl_profiles();
+			const ssl = SSLProfiles[name];
+			if (ssl === void 0) throw new TypeError(`Unknown SSL profile '${name}'`);
+			return ssl;
+		}
+		static parseUrl(url) {
+			const parsedUrl = new URL(url);
+			const options = {
+				host: decodeURIComponent(parsedUrl.hostname),
+				port: parseInt(parsedUrl.port, 10),
+				database: decodeURIComponent(parsedUrl.pathname.slice(1)),
+				user: decodeURIComponent(parsedUrl.username),
+				password: decodeURIComponent(parsedUrl.password)
+			};
+			parsedUrl.searchParams.forEach((value, key$1) => {
+				try {
+					options[key$1] = JSON.parse(value);
+				} catch (err) {
+					options[key$1] = value;
+				}
+			});
+			return options;
+		}
+	};
+	module.exports = ConnectionConfig$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/lru-cache@7.18.3/node_modules/lru-cache/index.js
+var require_lru_cache = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/lru-cache@7.18.3/node_modules/lru-cache/index.js": ((exports, module) => {
+	const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
+	const AC = typeof AbortController === "function" ? AbortController : class AbortController$1 {
+		constructor() {
+			this.signal = new AS();
+		}
+		abort(reason = /* @__PURE__ */ new Error("This operation was aborted")) {
+			this.signal.reason = this.signal.reason || reason;
+			this.signal.aborted = true;
+			this.signal.dispatchEvent({
+				type: "abort",
+				target: this.signal
+			});
+		}
+	};
+	const hasAbortSignal = typeof AbortSignal === "function";
+	const hasACAbortSignal = typeof AC.AbortSignal === "function";
+	const AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal$1 {
+		constructor() {
+			this.reason = void 0;
+			this.aborted = false;
+			this._listeners = [];
+		}
+		dispatchEvent(e) {
+			if (e.type === "abort") {
+				this.aborted = true;
+				this.onabort(e);
+				this._listeners.forEach((f) => f(e), this);
+			}
+		}
+		onabort() {}
+		addEventListener(ev, fn) {
+			if (ev === "abort") this._listeners.push(fn);
+		}
+		removeEventListener(ev, fn) {
+			if (ev === "abort") this._listeners = this._listeners.filter((f) => f !== fn);
+		}
+	};
+	const warned = /* @__PURE__ */ new Set();
+	const deprecatedOption = (opt, instead) => {
+		const code = `LRU_CACHE_OPTION_${opt}`;
+		if (shouldWarn(code)) warn(code, `${opt} option`, `options.${instead}`, LRUCache);
+	};
+	const deprecatedMethod = (method, instead) => {
+		const code = `LRU_CACHE_METHOD_${method}`;
+		if (shouldWarn(code)) {
+			const { prototype } = LRUCache;
+			const { get } = Object.getOwnPropertyDescriptor(prototype, method);
+			warn(code, `${method} method`, `cache.${instead}()`, get);
+		}
+	};
+	const deprecatedProperty = (field, instead) => {
+		const code = `LRU_CACHE_PROPERTY_${field}`;
+		if (shouldWarn(code)) {
+			const { prototype } = LRUCache;
+			const { get } = Object.getOwnPropertyDescriptor(prototype, field);
+			warn(code, `${field} property`, `cache.${instead}`, get);
+		}
+	};
+	const emitWarning = (...a) => {
+		typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
+	};
+	const shouldWarn = (code) => !warned.has(code);
+	const warn = (code, what, instead, fn) => {
+		warned.add(code);
+		emitWarning(`The ${what} is deprecated. Please use ${instead} instead.`, "DeprecationWarning", code, fn);
+	};
+	const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
+	/* istanbul ignore next - This is a little bit ridiculous, tbh.
+	* The maximum array length is 2^32-1 or thereabouts on most JS impls.
+	* And well before that point, you're caching the entire world, I mean,
+	* that's ~32GB of just integers for the next/prev links, plus whatever
+	* else to hold that many keys and values.  Just filling the memory with
+	* zeroes at init time is brutal when you get that big.
+	* But why not be complete?
+	* Maybe in the future, these limits will have expanded. */
+	const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
+	var ZeroArray = class extends Array {
+		constructor(size) {
+			super(size);
+			this.fill(0);
+		}
+	};
+	var Stack = class {
+		constructor(max) {
+			if (max === 0) return [];
+			this.heap = new (getUintArray(max))(max);
+			this.length = 0;
+		}
+		push(n) {
+			this.heap[this.length++] = n;
+		}
+		pop() {
+			return this.heap[--this.length];
+		}
+	};
+	var LRUCache = class LRUCache {
+		constructor(options = {}) {
+			const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, fetchContext, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
+			const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;
+			if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
+			const UintArray = max ? getUintArray(max) : Array;
+			if (!UintArray) throw new Error("invalid max value: " + max);
+			this.max = max;
+			this.maxSize = maxSize;
+			this.maxEntrySize = maxEntrySize || this.maxSize;
+			this.sizeCalculation = sizeCalculation || length;
+			if (this.sizeCalculation) {
+				if (!this.maxSize && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
+				if (typeof this.sizeCalculation !== "function") throw new TypeError("sizeCalculation set to non-function");
+			}
+			this.fetchMethod = fetchMethod || null;
+			if (this.fetchMethod && typeof this.fetchMethod !== "function") throw new TypeError("fetchMethod must be a function if specified");
+			this.fetchContext = fetchContext;
+			if (!this.fetchMethod && fetchContext !== void 0) throw new TypeError("cannot set fetchContext without fetchMethod");
+			this.keyMap = /* @__PURE__ */ new Map();
+			this.keyList = new Array(max).fill(null);
+			this.valList = new Array(max).fill(null);
+			this.next = new UintArray(max);
+			this.prev = new UintArray(max);
+			this.head = 0;
+			this.tail = 0;
+			this.free = new Stack(max);
+			this.initialFill = 1;
+			this.size = 0;
+			if (typeof dispose === "function") this.dispose = dispose;
+			if (typeof disposeAfter === "function") {
+				this.disposeAfter = disposeAfter;
+				this.disposed = [];
+			} else {
+				this.disposeAfter = null;
+				this.disposed = null;
+			}
+			this.noDisposeOnSet = !!noDisposeOnSet;
+			this.noUpdateTTL = !!noUpdateTTL;
+			this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
+			this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
+			this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
+			this.ignoreFetchAbort = !!ignoreFetchAbort;
+			if (this.maxEntrySize !== 0) {
+				if (this.maxSize !== 0) {
+					if (!isPosInt(this.maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
+				}
+				if (!isPosInt(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
+				this.initializeSizeTracking();
+			}
+			this.allowStale = !!allowStale || !!stale;
+			this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
+			this.updateAgeOnGet = !!updateAgeOnGet;
+			this.updateAgeOnHas = !!updateAgeOnHas;
+			this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
+			this.ttlAutopurge = !!ttlAutopurge;
+			this.ttl = ttl || maxAge || 0;
+			if (this.ttl) {
+				if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
+				this.initializeTTLTracking();
+			}
+			if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
+			if (!this.ttlAutopurge && !this.max && !this.maxSize) {
+				const code = "LRU_CACHE_UNBOUNDED";
+				if (shouldWarn(code)) {
+					warned.add(code);
+					emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache);
+				}
+			}
+			if (stale) deprecatedOption("stale", "allowStale");
+			if (maxAge) deprecatedOption("maxAge", "ttl");
+			if (length) deprecatedOption("length", "sizeCalculation");
+		}
+		getRemainingTTL(key$1) {
+			return this.has(key$1, { updateAgeOnHas: false }) ? Infinity : 0;
+		}
+		initializeTTLTracking() {
+			this.ttls = new ZeroArray(this.max);
+			this.starts = new ZeroArray(this.max);
+			this.setItemTTL = (index, ttl, start = perf.now()) => {
+				this.starts[index] = ttl !== 0 ? start : 0;
+				this.ttls[index] = ttl;
+				if (ttl !== 0 && this.ttlAutopurge) {
+					const t = setTimeout(() => {
+						if (this.isStale(index)) this.delete(this.keyList[index]);
+					}, ttl + 1);
+					/* istanbul ignore else - unref() not supported on all platforms */
+					if (t.unref) t.unref();
+				}
+			};
+			this.updateItemAge = (index) => {
+				this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
+			};
+			this.statusTTL = (status, index) => {
+				if (status) {
+					status.ttl = this.ttls[index];
+					status.start = this.starts[index];
+					status.now = cachedNow || getNow();
+					status.remainingTTL = status.now + status.ttl - status.start;
+				}
+			};
+			let cachedNow = 0;
+			const getNow = () => {
+				const n = perf.now();
+				if (this.ttlResolution > 0) {
+					cachedNow = n;
+					const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
+					/* istanbul ignore else - not available on all platforms */
+					if (t.unref) t.unref();
+				}
+				return n;
+			};
+			this.getRemainingTTL = (key$1) => {
+				const index = this.keyMap.get(key$1);
+				if (index === void 0) return 0;
+				return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
+			};
+			this.isStale = (index) => {
+				return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
+			};
+		}
+		updateItemAge(_index) {}
+		statusTTL(_status, _index) {}
+		setItemTTL(_index, _ttl, _start) {}
+		isStale(_index) {
+			return false;
+		}
+		initializeSizeTracking() {
+			this.calculatedSize = 0;
+			this.sizes = new ZeroArray(this.max);
+			this.removeItemSize = (index) => {
+				this.calculatedSize -= this.sizes[index];
+				this.sizes[index] = 0;
+			};
+			this.requireSize = (k, v, size, sizeCalculation) => {
+				if (this.isBackgroundFetch(v)) return 0;
+				if (!isPosInt(size)) if (sizeCalculation) {
+					if (typeof sizeCalculation !== "function") throw new TypeError("sizeCalculation must be a function");
+					size = sizeCalculation(v, k);
+					if (!isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
+				} else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
+				return size;
+			};
+			this.addItemSize = (index, size, status) => {
+				this.sizes[index] = size;
+				if (this.maxSize) {
+					const maxSize = this.maxSize - this.sizes[index];
+					while (this.calculatedSize > maxSize) this.evict(true);
+				}
+				this.calculatedSize += this.sizes[index];
+				if (status) {
+					status.entrySize = size;
+					status.totalCalculatedSize = this.calculatedSize;
+				}
+			};
+		}
+		removeItemSize(_index) {}
+		addItemSize(_index, _size) {}
+		requireSize(_k, _v, size, sizeCalculation) {
+			if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
+		}
+		*indexes({ allowStale = this.allowStale } = {}) {
+			if (this.size) for (let i$4 = this.tail;;) {
+				if (!this.isValidIndex(i$4)) break;
+				if (allowStale || !this.isStale(i$4)) yield i$4;
+				if (i$4 === this.head) break;
+				else i$4 = this.prev[i$4];
+			}
+		}
+		*rindexes({ allowStale = this.allowStale } = {}) {
+			if (this.size) for (let i$4 = this.head;;) {
+				if (!this.isValidIndex(i$4)) break;
+				if (allowStale || !this.isStale(i$4)) yield i$4;
+				if (i$4 === this.tail) break;
+				else i$4 = this.next[i$4];
+			}
+		}
+		isValidIndex(index) {
+			return index !== void 0 && this.keyMap.get(this.keyList[index]) === index;
+		}
+		*entries() {
+			for (const i$4 of this.indexes()) if (this.valList[i$4] !== void 0 && this.keyList[i$4] !== void 0 && !this.isBackgroundFetch(this.valList[i$4])) yield [this.keyList[i$4], this.valList[i$4]];
+		}
+		*rentries() {
+			for (const i$4 of this.rindexes()) if (this.valList[i$4] !== void 0 && this.keyList[i$4] !== void 0 && !this.isBackgroundFetch(this.valList[i$4])) yield [this.keyList[i$4], this.valList[i$4]];
+		}
+		*keys() {
+			for (const i$4 of this.indexes()) if (this.keyList[i$4] !== void 0 && !this.isBackgroundFetch(this.valList[i$4])) yield this.keyList[i$4];
+		}
+		*rkeys() {
+			for (const i$4 of this.rindexes()) if (this.keyList[i$4] !== void 0 && !this.isBackgroundFetch(this.valList[i$4])) yield this.keyList[i$4];
+		}
+		*values() {
+			for (const i$4 of this.indexes()) if (this.valList[i$4] !== void 0 && !this.isBackgroundFetch(this.valList[i$4])) yield this.valList[i$4];
+		}
+		*rvalues() {
+			for (const i$4 of this.rindexes()) if (this.valList[i$4] !== void 0 && !this.isBackgroundFetch(this.valList[i$4])) yield this.valList[i$4];
+		}
+		[Symbol.iterator]() {
+			return this.entries();
+		}
+		find(fn, getOptions) {
+			for (const i$4 of this.indexes()) {
+				const v = this.valList[i$4];
+				const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
+				if (value === void 0) continue;
+				if (fn(value, this.keyList[i$4], this)) return this.get(this.keyList[i$4], getOptions);
+			}
+		}
+		forEach(fn, thisp = this) {
+			for (const i$4 of this.indexes()) {
+				const v = this.valList[i$4];
+				const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
+				if (value === void 0) continue;
+				fn.call(thisp, value, this.keyList[i$4], this);
+			}
+		}
+		rforEach(fn, thisp = this) {
+			for (const i$4 of this.rindexes()) {
+				const v = this.valList[i$4];
+				const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
+				if (value === void 0) continue;
+				fn.call(thisp, value, this.keyList[i$4], this);
+			}
+		}
+		get prune() {
+			deprecatedMethod("prune", "purgeStale");
+			return this.purgeStale;
+		}
+		purgeStale() {
+			let deleted = false;
+			for (const i$4 of this.rindexes({ allowStale: true })) if (this.isStale(i$4)) {
+				this.delete(this.keyList[i$4]);
+				deleted = true;
+			}
+			return deleted;
+		}
+		dump() {
+			const arr = [];
+			for (const i$4 of this.indexes({ allowStale: true })) {
+				const key$1 = this.keyList[i$4];
+				const v = this.valList[i$4];
+				const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
+				if (value === void 0) continue;
+				const entry = { value };
+				if (this.ttls) {
+					entry.ttl = this.ttls[i$4];
+					const age = perf.now() - this.starts[i$4];
+					entry.start = Math.floor(Date.now() - age);
+				}
+				if (this.sizes) entry.size = this.sizes[i$4];
+				arr.unshift([key$1, entry]);
+			}
+			return arr;
+		}
+		load(arr) {
+			this.clear();
+			for (const [key$1, entry] of arr) {
+				if (entry.start) {
+					const age = Date.now() - entry.start;
+					entry.start = perf.now() - age;
+				}
+				this.set(key$1, entry.value, entry);
+			}
+		}
+		dispose(_v, _k, _reason) {}
+		set(k, v, { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, status } = {}) {
+			size = this.requireSize(k, v, size, sizeCalculation);
+			if (this.maxEntrySize && size > this.maxEntrySize) {
+				if (status) {
+					status.set = "miss";
+					status.maxEntrySizeExceeded = true;
+				}
+				this.delete(k);
+				return this;
+			}
+			let index = this.size === 0 ? void 0 : this.keyMap.get(k);
+			if (index === void 0) {
+				index = this.newIndex();
+				this.keyList[index] = k;
+				this.valList[index] = v;
+				this.keyMap.set(k, index);
+				this.next[this.tail] = index;
+				this.prev[index] = this.tail;
+				this.tail = index;
+				this.size++;
+				this.addItemSize(index, size, status);
+				if (status) status.set = "add";
+				noUpdateTTL = false;
+			} else {
+				this.moveToTail(index);
+				const oldVal = this.valList[index];
+				if (v !== oldVal) {
+					if (this.isBackgroundFetch(oldVal)) oldVal.__abortController.abort(/* @__PURE__ */ new Error("replaced"));
+					else if (!noDisposeOnSet) {
+						this.dispose(oldVal, k, "set");
+						if (this.disposeAfter) this.disposed.push([
+							oldVal,
+							k,
+							"set"
+						]);
+					}
+					this.removeItemSize(index);
+					this.valList[index] = v;
+					this.addItemSize(index, size, status);
+					if (status) {
+						status.set = "replace";
+						const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
+						if (oldValue !== void 0) status.oldValue = oldValue;
+					}
+				} else if (status) status.set = "update";
+			}
+			if (ttl !== 0 && this.ttl === 0 && !this.ttls) this.initializeTTLTracking();
+			if (!noUpdateTTL) this.setItemTTL(index, ttl, start);
+			this.statusTTL(status, index);
+			if (this.disposeAfter) while (this.disposed.length) this.disposeAfter(...this.disposed.shift());
+			return this;
+		}
+		newIndex() {
+			if (this.size === 0) return this.tail;
+			if (this.size === this.max && this.max !== 0) return this.evict(false);
+			if (this.free.length !== 0) return this.free.pop();
+			return this.initialFill++;
+		}
+		pop() {
+			if (this.size) {
+				const val = this.valList[this.head];
+				this.evict(true);
+				return val;
+			}
+		}
+		evict(free) {
+			const head = this.head;
+			const k = this.keyList[head];
+			const v = this.valList[head];
+			if (this.isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("evicted"));
+			else {
+				this.dispose(v, k, "evict");
+				if (this.disposeAfter) this.disposed.push([
+					v,
+					k,
+					"evict"
+				]);
+			}
+			this.removeItemSize(head);
+			if (free) {
+				this.keyList[head] = null;
+				this.valList[head] = null;
+				this.free.push(head);
+			}
+			this.head = this.next[head];
+			this.keyMap.delete(k);
+			this.size--;
+			return head;
+		}
+		has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
+			const index = this.keyMap.get(k);
+			if (index !== void 0) {
+				if (!this.isStale(index)) {
+					if (updateAgeOnHas) this.updateItemAge(index);
+					if (status) status.has = "hit";
+					this.statusTTL(status, index);
+					return true;
+				} else if (status) {
+					status.has = "stale";
+					this.statusTTL(status, index);
+				}
+			} else if (status) status.has = "miss";
+			return false;
+		}
+		peek(k, { allowStale = this.allowStale } = {}) {
+			const index = this.keyMap.get(k);
+			if (index !== void 0 && (allowStale || !this.isStale(index))) {
+				const v = this.valList[index];
+				return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
+			}
+		}
+		backgroundFetch(k, index, options, context) {
+			const v = index === void 0 ? void 0 : this.valList[index];
+			if (this.isBackgroundFetch(v)) return v;
+			const ac = new AC();
+			if (options.signal) options.signal.addEventListener("abort", () => ac.abort(options.signal.reason));
+			const fetchOpts = {
+				signal: ac.signal,
+				options,
+				context
+			};
+			const cb = (v$1, updateCache = false) => {
+				const { aborted } = ac.signal;
+				const ignoreAbort = options.ignoreFetchAbort && v$1 !== void 0;
+				if (options.status) if (aborted && !updateCache) {
+					options.status.fetchAborted = true;
+					options.status.fetchError = ac.signal.reason;
+					if (ignoreAbort) options.status.fetchAbortIgnored = true;
+				} else options.status.fetchResolved = true;
+				if (aborted && !ignoreAbort && !updateCache) return fetchFail(ac.signal.reason);
+				if (this.valList[index] === p) if (v$1 === void 0) if (p.__staleWhileFetching) this.valList[index] = p.__staleWhileFetching;
+				else this.delete(k);
+				else {
+					if (options.status) options.status.fetchUpdated = true;
+					this.set(k, v$1, fetchOpts.options);
+				}
+				return v$1;
+			};
+			const eb = (er) => {
+				if (options.status) {
+					options.status.fetchRejected = true;
+					options.status.fetchError = er;
+				}
+				return fetchFail(er);
+			};
+			const fetchFail = (er) => {
+				const { aborted } = ac.signal;
+				const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
+				const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
+				const noDelete = allowStale || options.noDeleteOnFetchRejection;
+				if (this.valList[index] === p) {
+					if (!noDelete || p.__staleWhileFetching === void 0) this.delete(k);
+					else if (!allowStaleAborted) this.valList[index] = p.__staleWhileFetching;
+				}
+				if (allowStale) {
+					if (options.status && p.__staleWhileFetching !== void 0) options.status.returnedStale = true;
+					return p.__staleWhileFetching;
+				} else if (p.__returned === p) throw er;
+			};
+			const pcall = (res, rej) => {
+				this.fetchMethod(k, v, fetchOpts).then((v$1) => res(v$1), rej);
+				ac.signal.addEventListener("abort", () => {
+					if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
+						res();
+						if (options.allowStaleOnFetchAbort) res = (v$1) => cb(v$1, true);
+					}
+				});
+			};
+			if (options.status) options.status.fetchDispatched = true;
+			const p = new Promise(pcall).then(cb, eb);
+			p.__abortController = ac;
+			p.__staleWhileFetching = v;
+			p.__returned = null;
+			if (index === void 0) {
+				this.set(k, p, {
+					...fetchOpts.options,
+					status: void 0
+				});
+				index = this.keyMap.get(k);
+			} else this.valList[index] = p;
+			return p;
+		}
+		isBackgroundFetch(p) {
+			return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
+		}
+		async fetch(k, { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, fetchContext = this.fetchContext, forceRefresh = false, status, signal } = {}) {
+			if (!this.fetchMethod) {
+				if (status) status.fetch = "get";
+				return this.get(k, {
+					allowStale,
+					updateAgeOnGet,
+					noDeleteOnStaleGet,
+					status
+				});
+			}
+			const options = {
+				allowStale,
+				updateAgeOnGet,
+				noDeleteOnStaleGet,
+				ttl,
+				noDisposeOnSet,
+				size,
+				sizeCalculation,
+				noUpdateTTL,
+				noDeleteOnFetchRejection,
+				allowStaleOnFetchRejection,
+				allowStaleOnFetchAbort,
+				ignoreFetchAbort,
+				status,
+				signal
+			};
+			let index = this.keyMap.get(k);
+			if (index === void 0) {
+				if (status) status.fetch = "miss";
+				const p = this.backgroundFetch(k, index, options, fetchContext);
+				return p.__returned = p;
+			} else {
+				const v = this.valList[index];
+				if (this.isBackgroundFetch(v)) {
+					const stale = allowStale && v.__staleWhileFetching !== void 0;
+					if (status) {
+						status.fetch = "inflight";
+						if (stale) status.returnedStale = true;
+					}
+					return stale ? v.__staleWhileFetching : v.__returned = v;
+				}
+				const isStale = this.isStale(index);
+				if (!forceRefresh && !isStale) {
+					if (status) status.fetch = "hit";
+					this.moveToTail(index);
+					if (updateAgeOnGet) this.updateItemAge(index);
+					this.statusTTL(status, index);
+					return v;
+				}
+				const p = this.backgroundFetch(k, index, options, fetchContext);
+				const hasStale = p.__staleWhileFetching !== void 0;
+				const staleVal = hasStale && allowStale;
+				if (status) {
+					status.fetch = hasStale && isStale ? "stale" : "refresh";
+					if (staleVal && isStale) status.returnedStale = true;
+				}
+				return staleVal ? p.__staleWhileFetching : p.__returned = p;
+			}
+		}
+		get(k, { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = {}) {
+			const index = this.keyMap.get(k);
+			if (index !== void 0) {
+				const value = this.valList[index];
+				const fetching = this.isBackgroundFetch(value);
+				this.statusTTL(status, index);
+				if (this.isStale(index)) {
+					if (status) status.get = "stale";
+					if (!fetching) {
+						if (!noDeleteOnStaleGet) this.delete(k);
+						if (status) status.returnedStale = allowStale;
+						return allowStale ? value : void 0;
+					} else {
+						if (status) status.returnedStale = allowStale && value.__staleWhileFetching !== void 0;
+						return allowStale ? value.__staleWhileFetching : void 0;
+					}
+				} else {
+					if (status) status.get = "hit";
+					if (fetching) return value.__staleWhileFetching;
+					this.moveToTail(index);
+					if (updateAgeOnGet) this.updateItemAge(index);
+					return value;
+				}
+			} else if (status) status.get = "miss";
+		}
+		connect(p, n) {
+			this.prev[n] = p;
+			this.next[p] = n;
+		}
+		moveToTail(index) {
+			if (index !== this.tail) {
+				if (index === this.head) this.head = this.next[index];
+				else this.connect(this.prev[index], this.next[index]);
+				this.connect(this.tail, index);
+				this.tail = index;
+			}
+		}
+		get del() {
+			deprecatedMethod("del", "delete");
+			return this.delete;
+		}
+		delete(k) {
+			let deleted = false;
+			if (this.size !== 0) {
+				const index = this.keyMap.get(k);
+				if (index !== void 0) {
+					deleted = true;
+					if (this.size === 1) this.clear();
+					else {
+						this.removeItemSize(index);
+						const v = this.valList[index];
+						if (this.isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
+						else {
+							this.dispose(v, k, "delete");
+							if (this.disposeAfter) this.disposed.push([
+								v,
+								k,
+								"delete"
+							]);
+						}
+						this.keyMap.delete(k);
+						this.keyList[index] = null;
+						this.valList[index] = null;
+						if (index === this.tail) this.tail = this.prev[index];
+						else if (index === this.head) this.head = this.next[index];
+						else {
+							this.next[this.prev[index]] = this.next[index];
+							this.prev[this.next[index]] = this.prev[index];
+						}
+						this.size--;
+						this.free.push(index);
+					}
+				}
+			}
+			if (this.disposed) while (this.disposed.length) this.disposeAfter(...this.disposed.shift());
+			return deleted;
+		}
+		clear() {
+			for (const index of this.rindexes({ allowStale: true })) {
+				const v = this.valList[index];
+				if (this.isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
+				else {
+					const k = this.keyList[index];
+					this.dispose(v, k, "delete");
+					if (this.disposeAfter) this.disposed.push([
+						v,
+						k,
+						"delete"
+					]);
+				}
+			}
+			this.keyMap.clear();
+			this.valList.fill(null);
+			this.keyList.fill(null);
+			if (this.ttls) {
+				this.ttls.fill(0);
+				this.starts.fill(0);
+			}
+			if (this.sizes) this.sizes.fill(0);
+			this.head = 0;
+			this.tail = 0;
+			this.initialFill = 1;
+			this.free.length = 0;
+			this.calculatedSize = 0;
+			this.size = 0;
+			if (this.disposed) while (this.disposed.length) this.disposeAfter(...this.disposed.shift());
+		}
+		get reset() {
+			deprecatedMethod("reset", "clear");
+			return this.clear;
+		}
+		get length() {
+			deprecatedProperty("length", "size");
+			return this.size;
+		}
+		static get AbortController() {
+			return AC;
+		}
+		static get AbortSignal() {
+			return AS;
+		}
+	};
+	module.exports = LRUCache;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/named-placeholders@1.1.3/node_modules/named-placeholders/index.js
+var require_named_placeholders = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/named-placeholders@1.1.3/node_modules/named-placeholders/index.js": ((exports, module) => {
+	const RE_PARAM = /(?:\?)|(?::(\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g, DQUOTE = 34, SQUOTE = 39, BSLASH = 92;
+	function parse(query) {
+		let ppos = RE_PARAM.exec(query);
+		let curpos = 0;
+		let start = 0;
+		let end;
+		const parts = [];
+		let inQuote = false;
+		let escape = false;
+		let qchr;
+		const tokens = [];
+		let qcnt = 0;
+		let lastTokenEndPos = 0;
+		let i$4;
+		if (ppos) {
+			do {
+				for (i$4 = curpos, end = ppos.index; i$4 < end; ++i$4) {
+					let chr = query.charCodeAt(i$4);
+					if (chr === BSLASH) escape = !escape;
+					else {
+						if (escape) {
+							escape = false;
+							continue;
+						}
+						if (inQuote && chr === qchr) {
+							if (query.charCodeAt(i$4 + 1) === qchr) {
+								++i$4;
+								continue;
+							}
+							inQuote = false;
+						} else if (chr === DQUOTE || chr === SQUOTE) {
+							inQuote = true;
+							qchr = chr;
+						}
+					}
+				}
+				if (!inQuote) {
+					parts.push(query.substring(start, end));
+					tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);
+					start = end + ppos[0].length;
+					lastTokenEndPos = start;
+				}
+				curpos = end + ppos[0].length;
+			} while (ppos = RE_PARAM.exec(query));
+			if (tokens.length) {
+				if (curpos < query.length) parts.push(query.substring(lastTokenEndPos));
+				return [parts, tokens];
+			}
+		}
+		return [query];
+	}
+	function createCompiler(config) {
+		if (!config) config = {};
+		if (!config.placeholder) config.placeholder = "?";
+		let ncache = 100;
+		let cache;
+		if (typeof config.cache === "number") ncache = config.cache;
+		if (typeof config.cache === "object") cache = config.cache;
+		if (config.cache !== false && !cache) cache = new (require_lru_cache())({ max: ncache });
+		function toArrayParams(tree, params) {
+			const arr = [];
+			if (tree.length == 1) return [tree[0], []];
+			if (typeof params == "undefined") throw new Error("Named query contains placeholders, but parameters object is undefined");
+			const tokens = tree[1];
+			for (let i$4 = 0; i$4 < tokens.length; ++i$4) arr.push(params[tokens[i$4]]);
+			return [tree[0], arr];
+		}
+		function noTailingSemicolon(s) {
+			if (s.slice(-1) == ":") return s.slice(0, -1);
+			return s;
+		}
+		function join(tree) {
+			if (tree.length == 1) return tree;
+			let unnamed = noTailingSemicolon(tree[0][0]);
+			for (let i$4 = 1; i$4 < tree[0].length; ++i$4) {
+				if (tree[0][i$4 - 1].slice(-1) == ":") unnamed += config.placeholder;
+				unnamed += config.placeholder;
+				unnamed += noTailingSemicolon(tree[0][i$4]);
+			}
+			const last = tree[0][tree[0].length - 1];
+			if (tree[0].length == tree[1].length) {
+				if (last.slice(-1) == ":") unnamed += config.placeholder;
+				unnamed += config.placeholder;
+			}
+			return [unnamed, tree[1]];
+		}
+		function compile$2(query, paramsObj) {
+			let tree;
+			if (cache && (tree = cache.get(query))) return toArrayParams(tree, paramsObj);
+			tree = join(parse(query));
+			if (cache) cache.set(query, tree);
+			return toArrayParams(tree, paramsObj);
+		}
+		compile$2.parse = parse;
+		return compile$2;
+	}
+	function toNumbered(q, params) {
+		const tree = parse(q);
+		const paramsArr = [];
+		if (tree.length == 1) return [tree[0], paramsArr];
+		const pIndexes = {};
+		let pLastIndex = 0;
+		let qs = "";
+		let varIndex;
+		const varNames = [];
+		for (let i$4 = 0; i$4 < tree[0].length; ++i$4) {
+			varIndex = pIndexes[tree[1][i$4]];
+			if (!varIndex) {
+				varIndex = ++pLastIndex;
+				pIndexes[tree[1][i$4]] = varIndex;
+			}
+			if (tree[1][i$4]) {
+				varNames[varIndex - 1] = tree[1][i$4];
+				qs += tree[0][i$4] + "$" + varIndex;
+			} else qs += tree[0][i$4];
+		}
+		return [qs, varNames.map((n) => params[n])];
+	}
+	module.exports = createCompiler;
+	module.exports.toNumbered = toNumbered;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/base/connection.js
+var require_connection$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/base/connection.js": ((exports, module) => {
+	const Net = __require("net");
+	const Tls = __require("tls");
+	const Timers = __require("timers");
+	const EventEmitter$5 = __require("events").EventEmitter;
+	const Readable = __require("stream").Readable;
+	const Queue$1 = require_denque();
+	const SqlString$2 = require_sqlstring();
+	const { createLRU } = require_lib$2();
+	const PacketParser = require_packet_parser();
+	const Packets = require_packets();
+	const Commands = require_commands();
+	const ConnectionConfig$2 = require_connection_config();
+	const CharsetToEncoding = require_charset_encodings();
+	let _connectionId = 0;
+	let convertNamedPlaceholders = null;
+	var BaseConnection$4 = class BaseConnection$4 extends EventEmitter$5 {
+		constructor(opts) {
+			super();
+			this.config = opts.config;
+			if (!opts.config.stream) if (opts.config.socketPath) this.stream = Net.connect(opts.config.socketPath);
+			else {
+				this.stream = Net.connect(opts.config.port, opts.config.host);
+				if (this.config.enableKeepAlive) this.stream.on("connect", () => {
+					this.stream.setKeepAlive(true, this.config.keepAliveInitialDelay);
+				});
+				this.stream.setNoDelay(true);
+			}
+			else if (typeof opts.config.stream === "function") this.stream = opts.config.stream(opts);
+			else this.stream = opts.config.stream;
+			this._internalId = _connectionId++;
+			this._commands = new Queue$1();
+			this._command = null;
+			this._paused = false;
+			this._paused_packets = new Queue$1();
+			this._statements = createLRU({
+				max: this.config.maxPreparedStatements,
+				onEviction: function(_, statement) {
+					statement.close();
+				}
+			});
+			this.serverCapabilityFlags = 0;
+			this.authorized = false;
+			this.sequenceId = 0;
+			this.compressedSequenceId = 0;
+			this.threadId = null;
+			this._handshakePacket = null;
+			this._fatalError = null;
+			this._protocolError = null;
+			this._outOfOrderPackets = [];
+			this.clientEncoding = CharsetToEncoding[this.config.charsetNumber];
+			this.stream.on("error", this._handleNetworkError.bind(this));
+			this.packetParser = new PacketParser((p) => {
+				this.handlePacket(p);
+			});
+			this.stream.on("data", (data) => {
+				if (this.connectTimeout) {
+					Timers.clearTimeout(this.connectTimeout);
+					this.connectTimeout = null;
+				}
+				this.packetParser.execute(data);
+			});
+			this.stream.on("end", () => {
+				this.emit("end");
+			});
+			this.stream.on("close", () => {
+				if (this._closing) return;
+				if (!this._protocolError) {
+					this._protocolError = /* @__PURE__ */ new Error("Connection lost: The server closed the connection.");
+					this._protocolError.fatal = true;
+					this._protocolError.code = "PROTOCOL_CONNECTION_LOST";
+				}
+				this._notifyError(this._protocolError);
+			});
+			let handshakeCommand;
+			if (!this.config.isServer) {
+				handshakeCommand = new Commands.ClientHandshake(this.config.clientFlags);
+				handshakeCommand.on("end", () => {
+					if (!handshakeCommand.handshake || this._fatalError || this._protocolError) return;
+					this._handshakePacket = handshakeCommand.handshake;
+					this.threadId = handshakeCommand.handshake.connectionId;
+					this.emit("connect", handshakeCommand.handshake);
+				});
+				handshakeCommand.on("error", (err) => {
+					this._closing = true;
+					this._notifyError(err);
+				});
+				this.addCommand(handshakeCommand);
+			}
+			this.serverEncoding = "utf8";
+			if (this.config.connectTimeout) {
+				const timeoutHandler = this._handleTimeoutError.bind(this);
+				this.connectTimeout = Timers.setTimeout(timeoutHandler, this.config.connectTimeout);
+			}
+		}
+		_addCommandClosedState(cmd) {
+			const err = /* @__PURE__ */ new Error("Can't add new command when connection is in closed state");
+			err.fatal = true;
+			if (cmd.onResult) cmd.onResult(err);
+			else this.emit("error", err);
+		}
+		_handleFatalError(err) {
+			err.fatal = true;
+			this.stream.removeAllListeners("data");
+			this.addCommand = this._addCommandClosedState;
+			this.write = () => {
+				this.emit("error", /* @__PURE__ */ new Error("Can't write in closed state"));
+			};
+			this._notifyError(err);
+			this._fatalError = err;
+		}
+		_handleNetworkError(err) {
+			if (this.connectTimeout) {
+				Timers.clearTimeout(this.connectTimeout);
+				this.connectTimeout = null;
+			}
+			if (err.code === "ECONNRESET" && this._closing) return;
+			this._handleFatalError(err);
+		}
+		_handleTimeoutError() {
+			if (this.connectTimeout) {
+				Timers.clearTimeout(this.connectTimeout);
+				this.connectTimeout = null;
+			}
+			this.stream.destroy && this.stream.destroy();
+			const err = /* @__PURE__ */ new Error("connect ETIMEDOUT");
+			err.errorno = "ETIMEDOUT";
+			err.code = "ETIMEDOUT";
+			err.syscall = "connect";
+			this._handleNetworkError(err);
+		}
+		_notifyError(err) {
+			if (this.connectTimeout) {
+				Timers.clearTimeout(this.connectTimeout);
+				this.connectTimeout = null;
+			}
+			if (this._fatalError) return;
+			let command;
+			let bubbleErrorToConnection = !this._command;
+			if (this._command && this._command.onResult) {
+				this._command.onResult(err);
+				this._command = null;
+			} else if (!(this._command && this._command.constructor === Commands.ClientHandshake && this._commands.length > 0)) bubbleErrorToConnection = true;
+			while (command = this._commands.shift()) if (command.onResult) command.onResult(err);
+			else bubbleErrorToConnection = true;
+			if (bubbleErrorToConnection || this._pool) this.emit("error", err);
+			if (err.fatal) this.close();
+		}
+		write(buffer$1) {
+			if (!this.stream.write(buffer$1, (err) => {
+				if (err) this._handleNetworkError(err);
+			})) this.stream.emit("pause");
+		}
+		_resetSequenceId() {
+			this.sequenceId = 0;
+			this.compressedSequenceId = 0;
+		}
+		_bumpCompressedSequenceId(numPackets) {
+			this.compressedSequenceId += numPackets;
+			this.compressedSequenceId %= 256;
+		}
+		_bumpSequenceId(numPackets) {
+			this.sequenceId += numPackets;
+			this.sequenceId %= 256;
+		}
+		writePacket(packet) {
+			const MAX_PACKET_LENGTH$1 = 16777215;
+			const length = packet.length();
+			let chunk, offset, header;
+			if (length < MAX_PACKET_LENGTH$1) {
+				packet.writeHeader(this.sequenceId);
+				if (this.config.debug) {
+					console.log(`${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[
+						this.sequenceId,
+						packet._name,
+						packet.length()
+					].join(",")})`);
+					console.log(`${this._internalId} ${this.connectionId} <== ${packet.buffer.toString("hex")}`);
+				}
+				this._bumpSequenceId(1);
+				this.write(packet.buffer);
+			} else {
+				if (this.config.debug) {
+					console.log(`${this._internalId} ${this.connectionId} <== Writing large packet, raw content not written:`);
+					console.log(`${this._internalId} ${this.connectionId} <== ${this._command._commandName}#${this._command.stateName()}(${[
+						this.sequenceId,
+						packet._name,
+						packet.length()
+					].join(",")})`);
+				}
+				for (offset = 4; offset < 4 + length; offset += MAX_PACKET_LENGTH$1) {
+					chunk = packet.buffer.slice(offset, offset + MAX_PACKET_LENGTH$1);
+					if (chunk.length === MAX_PACKET_LENGTH$1) header = Buffer.from([
+						255,
+						255,
+						255,
+						this.sequenceId
+					]);
+					else header = Buffer.from([
+						chunk.length & 255,
+						chunk.length >> 8 & 255,
+						chunk.length >> 16 & 255,
+						this.sequenceId
+					]);
+					this._bumpSequenceId(1);
+					this.write(header);
+					this.write(chunk);
+				}
+			}
+		}
+		startTLS(onSecure) {
+			if (this.config.debug) console.log("Upgrading connection to TLS");
+			const secureContext = Tls.createSecureContext({
+				ca: this.config.ssl.ca,
+				cert: this.config.ssl.cert,
+				ciphers: this.config.ssl.ciphers,
+				key: this.config.ssl.key,
+				passphrase: this.config.ssl.passphrase,
+				minVersion: this.config.ssl.minVersion,
+				maxVersion: this.config.ssl.maxVersion
+			});
+			const rejectUnauthorized = this.config.ssl.rejectUnauthorized;
+			const verifyIdentity = this.config.ssl.verifyIdentity;
+			const servername = this.config.host;
+			let secureEstablished = false;
+			this.stream.removeAllListeners("data");
+			const secureSocket = Tls.connect({
+				rejectUnauthorized,
+				requestCert: rejectUnauthorized,
+				checkServerIdentity: verifyIdentity ? Tls.checkServerIdentity : function() {},
+				secureContext,
+				isServer: false,
+				socket: this.stream,
+				servername
+			}, () => {
+				secureEstablished = true;
+				if (rejectUnauthorized) {
+					if (typeof servername === "string" && verifyIdentity) {
+						const cert = secureSocket.getPeerCertificate(true);
+						const serverIdentityCheckError = Tls.checkServerIdentity(servername, cert);
+						if (serverIdentityCheckError) {
+							onSecure(serverIdentityCheckError);
+							return;
+						}
+					}
+				}
+				onSecure();
+			});
+			secureSocket.on("error", (err) => {
+				if (secureEstablished) this._handleNetworkError(err);
+				else onSecure(err);
+			});
+			secureSocket.on("data", (data) => {
+				this.packetParser.execute(data);
+			});
+			this.stream = secureSocket;
+		}
+		protocolError(message, code) {
+			if (this._closing) return;
+			const err = new Error(message);
+			err.fatal = true;
+			err.code = code || "PROTOCOL_ERROR";
+			this.emit("error", err);
+		}
+		get fatalError() {
+			return this._fatalError;
+		}
+		handlePacket(packet) {
+			if (this._paused) {
+				this._paused_packets.push(packet);
+				return;
+			}
+			if (this.config.debug) {
+				if (packet) {
+					console.log(` raw: ${packet.buffer.slice(packet.offset, packet.offset + packet.length()).toString("hex")}`);
+					console.trace();
+					const commandName = this._command ? this._command._commandName : "(no command)";
+					const stateName = this._command ? this._command.stateName() : "(no command)";
+					console.log(`${this._internalId} ${this.connectionId} ==> ${commandName}#${stateName}(${[
+						packet.sequenceId,
+						packet.type(),
+						packet.length()
+					].join(",")})`);
+				}
+			}
+			if (!this._command) {
+				if (packet.peekByte() === 255) {
+					const error = Packets.Error.fromPacket(packet);
+					this.protocolError(error.message, error.code);
+				} else this.protocolError("Unexpected packet while no commands in the queue", "PROTOCOL_UNEXPECTED_PACKET");
+				this.close();
+				return;
+			}
+			if (packet) {
+				if (this.sequenceId !== packet.sequenceId) {
+					const err = /* @__PURE__ */ new Error(`Warning: got packets out of order. Expected ${this.sequenceId} but received ${packet.sequenceId}`);
+					err.expected = this.sequenceId;
+					err.received = packet.sequenceId;
+					this.emit("warn", err);
+					console.error(err.message);
+				}
+				this._bumpSequenceId(packet.numPackets);
+			}
+			try {
+				if (this._fatalError) return;
+				if (this._command.execute(packet, this)) {
+					this._command = this._commands.shift();
+					if (this._command) {
+						this.sequenceId = 0;
+						this.compressedSequenceId = 0;
+						this.handlePacket();
+					}
+				}
+			} catch (err) {
+				this._handleFatalError(err);
+				this.stream.destroy();
+			}
+		}
+		addCommand(cmd) {
+			if (this.config.debug) {
+				const commandName = cmd.constructor.name;
+				console.log(`Add command: ${commandName}`);
+				cmd._commandName = commandName;
+			}
+			if (!this._command) {
+				this._command = cmd;
+				this.handlePacket();
+			} else this._commands.push(cmd);
+			return cmd;
+		}
+		format(sql, values) {
+			if (typeof this.config.queryFormat === "function") return this.config.queryFormat.call(this, sql, values, this.config.timezone);
+			const opts = {
+				sql,
+				values
+			};
+			this._resolveNamedPlaceholders(opts);
+			return SqlString$2.format(opts.sql, opts.values, this.config.stringifyObjects, this.config.timezone);
+		}
+		escape(value) {
+			return SqlString$2.escape(value, false, this.config.timezone);
+		}
+		escapeId(value) {
+			return SqlString$2.escapeId(value, false);
+		}
+		raw(sql) {
+			return SqlString$2.raw(sql);
+		}
+		_resolveNamedPlaceholders(options) {
+			let unnamed;
+			if (this.config.namedPlaceholders || options.namedPlaceholders) {
+				if (Array.isArray(options.values)) return;
+				if (convertNamedPlaceholders === null) convertNamedPlaceholders = require_named_placeholders()();
+				unnamed = convertNamedPlaceholders(options.sql, options.values);
+				options.sql = unnamed[0];
+				options.values = unnamed[1];
+			}
+		}
+		query(sql, values, cb) {
+			let cmdQuery;
+			if (sql.constructor === Commands.Query) cmdQuery = sql;
+			else cmdQuery = BaseConnection$4.createQuery(sql, values, cb, this.config);
+			this._resolveNamedPlaceholders(cmdQuery);
+			cmdQuery.sql = this.format(cmdQuery.sql, cmdQuery.values !== void 0 ? cmdQuery.values : []);
+			return this.addCommand(cmdQuery);
+		}
+		pause() {
+			this._paused = true;
+			this.stream.pause();
+		}
+		resume() {
+			let packet;
+			this._paused = false;
+			while (packet = this._paused_packets.shift()) {
+				this.handlePacket(packet);
+				if (this._paused) return;
+			}
+			this.stream.resume();
+		}
+		prepare(options, cb) {
+			if (typeof options === "string") options = { sql: options };
+			return this.addCommand(new Commands.Prepare(options, cb));
+		}
+		unprepare(sql) {
+			let options = {};
+			if (typeof sql === "object") options = sql;
+			else options.sql = sql;
+			const key$1 = BaseConnection$4.statementKey(options);
+			const stmt = this._statements.get(key$1);
+			if (stmt) {
+				this._statements.delete(key$1);
+				stmt.close();
+			}
+			return stmt;
+		}
+		execute(sql, values, cb) {
+			let options = { infileStreamFactory: this.config.infileStreamFactory };
+			if (typeof sql === "object") {
+				options = {
+					...options,
+					...sql,
+					sql: sql.sql,
+					values: sql.values
+				};
+				if (typeof values === "function") cb = values;
+				else options.values = options.values || values;
+			} else if (typeof values === "function") {
+				cb = values;
+				options.sql = sql;
+				options.values = void 0;
+			} else {
+				options.sql = sql;
+				options.values = values;
+			}
+			this._resolveNamedPlaceholders(options);
+			if (options.values) {
+				if (!Array.isArray(options.values)) throw new TypeError("Bind parameters must be array if namedPlaceholders parameter is not enabled");
+				options.values.forEach((val) => {
+					if (!Array.isArray(options.values)) throw new TypeError("Bind parameters must be array if namedPlaceholders parameter is not enabled");
+					if (val === void 0) throw new TypeError("Bind parameters must not contain undefined. To pass SQL NULL specify JS null");
+					if (typeof val === "function") throw new TypeError("Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first");
+				});
+			}
+			const executeCommand = new Commands.Execute(options, cb);
+			const prepareCommand = new Commands.Prepare(options, (err, stmt) => {
+				if (err) {
+					executeCommand.start = function() {
+						return null;
+					};
+					if (cb) cb(err);
+					else executeCommand.emit("error", err);
+					executeCommand.emit("end");
+					return;
+				}
+				executeCommand.statement = stmt;
+			});
+			this.addCommand(prepareCommand);
+			this.addCommand(executeCommand);
+			return executeCommand;
+		}
+		changeUser(options, callback) {
+			if (!callback && typeof options === "function") {
+				callback = options;
+				options = {};
+			}
+			const charsetNumber = options.charset ? ConnectionConfig$2.getCharsetNumber(options.charset) : this.config.charsetNumber;
+			return this.addCommand(new Commands.ChangeUser({
+				user: options.user || this.config.user,
+				password: options.password || options.password1 || this.config.password || this.config.password1,
+				password2: options.password2 || this.config.password2,
+				password3: options.password3 || this.config.password3,
+				passwordSha1: options.passwordSha1 || this.config.passwordSha1,
+				database: options.database || this.config.database,
+				timeout: options.timeout,
+				charsetNumber,
+				currentConfig: this.config
+			}, (err) => {
+				if (err) err.fatal = true;
+				if (callback) callback(err);
+			}));
+		}
+		beginTransaction(cb) {
+			return this.query("START TRANSACTION", cb);
+		}
+		commit(cb) {
+			return this.query("COMMIT", cb);
+		}
+		rollback(cb) {
+			return this.query("ROLLBACK", cb);
+		}
+		ping(cb) {
+			return this.addCommand(new Commands.Ping(cb));
+		}
+		_registerSlave(opts, cb) {
+			return this.addCommand(new Commands.RegisterSlave(opts, cb));
+		}
+		_binlogDump(opts, cb) {
+			return this.addCommand(new Commands.BinlogDump(opts, cb));
+		}
+		destroy() {
+			this.close();
+		}
+		close() {
+			if (this.connectTimeout) {
+				Timers.clearTimeout(this.connectTimeout);
+				this.connectTimeout = null;
+			}
+			this._closing = true;
+			this.stream.end();
+			this.addCommand = this._addCommandClosedState;
+		}
+		createBinlogStream(opts) {
+			let test = 1;
+			const stream = new Readable({ objectMode: true });
+			stream._read = function() {
+				return { data: test++ };
+			};
+			this._registerSlave(opts, () => {
+				const dumpCmd = this._binlogDump(opts);
+				dumpCmd.on("event", (ev) => {
+					stream.push(ev);
+				});
+				dumpCmd.on("eof", () => {
+					stream.push(null);
+					if (opts.flags && opts.flags & 1) this.close();
+				});
+			});
+			return stream;
+		}
+		connect(cb) {
+			if (!cb) return;
+			if (this._fatalError || this._protocolError) return cb(this._fatalError || this._protocolError);
+			if (this._handshakePacket) return cb(null, this);
+			let connectCalled = 0;
+			function callbackOnce(isErrorHandler) {
+				return function(param) {
+					if (!connectCalled) if (isErrorHandler) cb(param);
+					else cb(null, param);
+					connectCalled = 1;
+				};
+			}
+			this.once("error", callbackOnce(true));
+			this.once("connect", callbackOnce(false));
+		}
+		writeColumns(columns) {
+			this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));
+			columns.forEach((column) => {
+				this.writePacket(Packets.ColumnDefinition.toPacket(column, this.serverConfig.encoding));
+			});
+			this.writeEof();
+		}
+		writeTextRow(column) {
+			this.writePacket(Packets.TextRow.toPacket(column, this.serverConfig.encoding));
+		}
+		writeBinaryRow(column) {
+			this.writePacket(Packets.BinaryRow.toPacket(column, this.serverConfig.encoding));
+		}
+		writeTextResult(rows, columns, binary = false) {
+			this.writeColumns(columns);
+			rows.forEach((row) => {
+				const arrayRow = new Array(columns.length);
+				columns.forEach((column) => {
+					arrayRow.push(row[column.name]);
+				});
+				if (binary) this.writeBinaryRow(arrayRow);
+				else this.writeTextRow(arrayRow);
+			});
+			this.writeEof();
+		}
+		writeEof(warnings, statusFlags) {
+			this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));
+		}
+		writeOk(args) {
+			if (!args) args = { affectedRows: 0 };
+			this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));
+		}
+		writeError(args) {
+			const encoding = this.serverConfig ? this.serverConfig.encoding : "cesu8";
+			this.writePacket(Packets.Error.toPacket(args, encoding));
+		}
+		serverHandshake(args) {
+			this.serverConfig = args;
+			this.serverConfig.encoding = CharsetToEncoding[this.serverConfig.characterSet];
+			return this.addCommand(new Commands.ServerHandshake(args));
+		}
+		end(callback) {
+			if (this.config.isServer) {
+				this._closing = true;
+				const quitCmd$1 = new EventEmitter$5();
+				setImmediate(() => {
+					this.stream.end();
+					quitCmd$1.emit("end");
+				});
+				return quitCmd$1;
+			}
+			const quitCmd = this.addCommand(new Commands.Quit(callback));
+			this.addCommand = this._addCommandClosedState;
+			return quitCmd;
+		}
+		static createQuery(sql, values, cb, config) {
+			let options = {
+				rowsAsArray: config.rowsAsArray,
+				infileStreamFactory: config.infileStreamFactory
+			};
+			if (typeof sql === "object") {
+				options = {
+					...options,
+					...sql,
+					sql: sql.sql,
+					values: sql.values
+				};
+				if (typeof values === "function") cb = values;
+				else if (values !== void 0) options.values = values;
+			} else if (typeof values === "function") {
+				cb = values;
+				options.sql = sql;
+				options.values = void 0;
+			} else {
+				options.sql = sql;
+				options.values = values;
+			}
+			return new Commands.Query(options, cb);
+		}
+		static statementKey(options) {
+			return `${typeof options.nestTables}/${options.nestTables}/${options.rowsAsArray}${options.sql}`;
+		}
+	};
+	module.exports = BaseConnection$4;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/base/pool_connection.js
+var require_pool_connection$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/base/pool_connection.js": ((exports, module) => {
+	const BaseConnection$3 = require_connection$2();
+	var BasePoolConnection$2 = class extends BaseConnection$3 {
+		constructor(pool, options) {
+			super(options);
+			this._pool = pool;
+			this.lastActiveTime = Date.now();
+			this.once("end", () => {
+				this._removeFromPool();
+			});
+			this.once("error", () => {
+				this._removeFromPool();
+			});
+		}
+		release() {
+			if (!this._pool || this._pool._closed) return;
+			this.lastActiveTime = Date.now();
+			this._pool.releaseConnection(this);
+		}
+		end() {
+			const err = /* @__PURE__ */ new Error("Calling conn.end() to release a pooled connection is deprecated. In next version calling conn.end() will be restored to default conn.end() behavior. Use conn.release() instead.");
+			this.emit("warn", err);
+			console.warn(err.message);
+			this.release();
+		}
+		destroy() {
+			this._removeFromPool();
+			super.destroy();
+		}
+		_removeFromPool() {
+			if (!this._pool || this._pool._closed) return;
+			const pool = this._pool;
+			this._pool = null;
+			pool._removeConnection(this);
+		}
+	};
+	BasePoolConnection$2.statementKey = BaseConnection$3.statementKey;
+	module.exports = BasePoolConnection$2;
+	BasePoolConnection$2.prototype._realEnd = BaseConnection$3.prototype.end;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/make_done_cb.js
+var require_make_done_cb = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/make_done_cb.js": ((exports, module) => {
+	function makeDoneCb$5(resolve, reject, localErr) {
+		return function(err, rows, fields$1) {
+			if (err) {
+				localErr.message = err.message;
+				localErr.code = err.code;
+				localErr.errno = err.errno;
+				localErr.sql = err.sql;
+				localErr.sqlState = err.sqlState;
+				localErr.sqlMessage = err.sqlMessage;
+				reject(localErr);
+			} else resolve([rows, fields$1]);
+		};
+	}
+	module.exports = makeDoneCb$5;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/prepared_statement_info.js
+var require_prepared_statement_info = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/prepared_statement_info.js": ((exports, module) => {
+	const makeDoneCb$4 = require_make_done_cb();
+	var PromisePreparedStatementInfo$1 = class {
+		constructor(statement, promiseImpl) {
+			this.statement = statement;
+			this.Promise = promiseImpl;
+		}
+		execute(parameters) {
+			const s = this.statement;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$4(resolve, reject, localErr);
+				if (parameters) s.execute(parameters, done);
+				else s.execute(done);
+			});
+		}
+		close() {
+			return new this.Promise((resolve) => {
+				this.statement.close();
+				resolve();
+			});
+		}
+	};
+	module.exports = PromisePreparedStatementInfo$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/inherit_events.js
+var require_inherit_events = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/inherit_events.js": ((exports, module) => {
+	function inheritEvents$3(source, target, events) {
+		const listeners = {};
+		target.on("newListener", (eventName) => {
+			if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) source.on(eventName, listeners[eventName] = function() {
+				const args = [].slice.call(arguments);
+				args.unshift(eventName);
+				target.emit.apply(target, args);
+			});
+		}).on("removeListener", (eventName) => {
+			if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {
+				source.removeListener(eventName, listeners[eventName]);
+				delete listeners[eventName];
+			}
+		});
+	}
+	module.exports = inheritEvents$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/connection.js
+var require_connection$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/connection.js": ((exports, module) => {
+	const EventEmitter$4 = __require("events").EventEmitter;
+	const PromisePreparedStatementInfo = require_prepared_statement_info();
+	const makeDoneCb$3 = require_make_done_cb();
+	const inheritEvents$2 = require_inherit_events();
+	const BaseConnection$2 = require_connection$2();
+	var PromiseConnection$2 = class extends EventEmitter$4 {
+		constructor(connection, promiseImpl) {
+			super();
+			this.connection = connection;
+			this.Promise = promiseImpl || Promise;
+			inheritEvents$2(connection, this, [
+				"error",
+				"drain",
+				"connect",
+				"end",
+				"enqueue"
+			]);
+		}
+		release() {
+			this.connection.release();
+		}
+		query(query, params) {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof params === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$3(resolve, reject, localErr);
+				if (params !== void 0) c.query(query, params, done);
+				else c.query(query, done);
+			});
+		}
+		execute(query, params) {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof params === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$3(resolve, reject, localErr);
+				if (params !== void 0) c.execute(query, params, done);
+				else c.execute(query, done);
+			});
+		}
+		end() {
+			return new this.Promise((resolve) => {
+				this.connection.end(resolve);
+			});
+		}
+		beginTransaction() {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$3(resolve, reject, localErr);
+				c.beginTransaction(done);
+			});
+		}
+		commit() {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$3(resolve, reject, localErr);
+				c.commit(done);
+			});
+		}
+		rollback() {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$3(resolve, reject, localErr);
+				c.rollback(done);
+			});
+		}
+		ping() {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				c.ping((err) => {
+					if (err) {
+						localErr.message = err.message;
+						localErr.code = err.code;
+						localErr.errno = err.errno;
+						localErr.sqlState = err.sqlState;
+						localErr.sqlMessage = err.sqlMessage;
+						reject(localErr);
+					} else resolve(true);
+				});
+			});
+		}
+		connect() {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				c.connect((err, param) => {
+					if (err) {
+						localErr.message = err.message;
+						localErr.code = err.code;
+						localErr.errno = err.errno;
+						localErr.sqlState = err.sqlState;
+						localErr.sqlMessage = err.sqlMessage;
+						reject(localErr);
+					} else resolve(param);
+				});
+			});
+		}
+		prepare(options) {
+			const c = this.connection;
+			const promiseImpl = this.Promise;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				c.prepare(options, (err, statement) => {
+					if (err) {
+						localErr.message = err.message;
+						localErr.code = err.code;
+						localErr.errno = err.errno;
+						localErr.sqlState = err.sqlState;
+						localErr.sqlMessage = err.sqlMessage;
+						reject(localErr);
+					} else resolve(new PromisePreparedStatementInfo(statement, promiseImpl));
+				});
+			});
+		}
+		changeUser(options) {
+			const c = this.connection;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				c.changeUser(options, (err) => {
+					if (err) {
+						localErr.message = err.message;
+						localErr.code = err.code;
+						localErr.errno = err.errno;
+						localErr.sqlState = err.sqlState;
+						localErr.sqlMessage = err.sqlMessage;
+						reject(localErr);
+					} else resolve();
+				});
+			});
+		}
+		get config() {
+			return this.connection.config;
+		}
+		get threadId() {
+			return this.connection.threadId;
+		}
+	};
+	(function(functionsToWrap) {
+		for (let i$4 = 0; functionsToWrap && i$4 < functionsToWrap.length; i$4++) {
+			const func = functionsToWrap[i$4];
+			if (typeof BaseConnection$2.prototype[func] === "function" && PromiseConnection$2.prototype[func] === void 0) PromiseConnection$2.prototype[func] = (function factory(funcName) {
+				return function() {
+					return BaseConnection$2.prototype[funcName].apply(this.connection, arguments);
+				};
+			})(func);
+		}
+	})([
+		"close",
+		"createBinlogStream",
+		"destroy",
+		"escape",
+		"escapeId",
+		"format",
+		"pause",
+		"pipe",
+		"resume",
+		"unprepare"
+	]);
+	module.exports = PromiseConnection$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/pool_connection.js
+var require_pool_connection$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/pool_connection.js": ((exports, module) => {
+	const PromiseConnection$1 = require_connection$1();
+	const BasePoolConnection$1 = require_pool_connection$2();
+	var PromisePoolConnection$3 = class extends PromiseConnection$1 {
+		constructor(connection, promiseImpl) {
+			super(connection, promiseImpl);
+		}
+		destroy() {
+			return BasePoolConnection$1.prototype.destroy.apply(this.connection, arguments);
+		}
+	};
+	module.exports = PromisePoolConnection$3;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool_connection.js
+var require_pool_connection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool_connection.js": ((exports, module) => {
+	const BasePoolConnection = require_pool_connection$2();
+	var PoolConnection$1 = class extends BasePoolConnection {
+		promise(promiseImpl) {
+			return new (require_pool_connection$1())(this, promiseImpl);
+		}
+	};
+	module.exports = PoolConnection$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/base/pool.js
+var require_pool$2 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/base/pool.js": ((exports, module) => {
+	const process$2 = __require("process");
+	const SqlString$1 = require_sqlstring();
+	const EventEmitter$3 = __require("events").EventEmitter;
+	const PoolConnection = require_pool_connection();
+	const Queue = require_denque();
+	const BaseConnection$1 = require_connection$2();
+	function spliceConnection(queue, connection) {
+		const len = queue.length;
+		for (let i$4 = 0; i$4 < len; i$4++) if (queue.get(i$4) === connection) {
+			queue.removeOne(i$4);
+			break;
+		}
+	}
+	var BasePool$2 = class extends EventEmitter$3 {
+		constructor(options) {
+			super();
+			this.config = options.config;
+			this.config.connectionConfig.pool = this;
+			this._allConnections = new Queue();
+			this._freeConnections = new Queue();
+			this._connectionQueue = new Queue();
+			this._closed = false;
+			if (this.config.maxIdle < this.config.connectionLimit) this._removeIdleTimeoutConnections();
+		}
+		getConnection(cb) {
+			if (this._closed) return process$2.nextTick(() => cb(/* @__PURE__ */ new Error("Pool is closed.")));
+			let connection;
+			if (this._freeConnections.length > 0) {
+				connection = this._freeConnections.pop();
+				this.emit("acquire", connection);
+				return process$2.nextTick(() => cb(null, connection));
+			}
+			if (this.config.connectionLimit === 0 || this._allConnections.length < this.config.connectionLimit) {
+				connection = new PoolConnection(this, { config: this.config.connectionConfig });
+				this._allConnections.push(connection);
+				return connection.connect((err) => {
+					if (this._closed) return cb(/* @__PURE__ */ new Error("Pool is closed."));
+					if (err) return cb(err);
+					this.emit("connection", connection);
+					this.emit("acquire", connection);
+					return cb(null, connection);
+				});
+			}
+			if (!this.config.waitForConnections) return process$2.nextTick(() => cb(/* @__PURE__ */ new Error("No connections available.")));
+			if (this.config.queueLimit && this._connectionQueue.length >= this.config.queueLimit) return cb(/* @__PURE__ */ new Error("Queue limit reached."));
+			this.emit("enqueue");
+			return this._connectionQueue.push(cb);
+		}
+		releaseConnection(connection) {
+			let cb;
+			if (!connection._pool) {
+				if (this._connectionQueue.length) {
+					cb = this._connectionQueue.shift();
+					process$2.nextTick(this.getConnection.bind(this, cb));
+				}
+			} else if (this._connectionQueue.length) {
+				cb = this._connectionQueue.shift();
+				process$2.nextTick(cb.bind(null, null, connection));
+			} else {
+				this._freeConnections.push(connection);
+				this.emit("release", connection);
+			}
+		}
+		end(cb) {
+			this._closed = true;
+			clearTimeout(this._removeIdleTimeoutConnectionsTimer);
+			if (typeof cb !== "function") cb = function(err) {
+				if (err) throw err;
+			};
+			let calledBack = false;
+			let closedConnections = 0;
+			let connection;
+			const endCB = function(err) {
+				if (calledBack) return;
+				if (err || ++closedConnections >= this._allConnections.length) {
+					calledBack = true;
+					cb(err);
+					return;
+				}
+			}.bind(this);
+			if (this._allConnections.length === 0) {
+				endCB();
+				return;
+			}
+			for (let i$4 = 0; i$4 < this._allConnections.length; i$4++) {
+				connection = this._allConnections.get(i$4);
+				connection._realEnd(endCB);
+			}
+		}
+		query(sql, values, cb) {
+			const cmdQuery = BaseConnection$1.createQuery(sql, values, cb, this.config.connectionConfig);
+			if (typeof cmdQuery.namedPlaceholders === "undefined") cmdQuery.namedPlaceholders = this.config.connectionConfig.namedPlaceholders;
+			this.getConnection((err, conn) => {
+				if (err) {
+					if (typeof cmdQuery.onResult === "function") cmdQuery.onResult(err);
+					else cmdQuery.emit("error", err);
+					return;
+				}
+				try {
+					conn.query(cmdQuery).once("end", () => {
+						conn.release();
+					});
+				} catch (e) {
+					conn.release();
+					throw e;
+				}
+			});
+			return cmdQuery;
+		}
+		execute(sql, values, cb) {
+			if (typeof values === "function") {
+				cb = values;
+				values = [];
+			}
+			this.getConnection((err, conn) => {
+				if (err) return cb(err);
+				try {
+					conn.execute(sql, values, cb).once("end", () => {
+						conn.release();
+					});
+				} catch (e) {
+					conn.release();
+					return cb(e);
+				}
+			});
+		}
+		_removeConnection(connection) {
+			spliceConnection(this._allConnections, connection);
+			spliceConnection(this._freeConnections, connection);
+			this.releaseConnection(connection);
+		}
+		_removeIdleTimeoutConnections() {
+			if (this._removeIdleTimeoutConnectionsTimer) clearTimeout(this._removeIdleTimeoutConnectionsTimer);
+			this._removeIdleTimeoutConnectionsTimer = setTimeout(() => {
+				try {
+					while (this._freeConnections.length > this.config.maxIdle || this._freeConnections.length > 0 && Date.now() - this._freeConnections.get(0).lastActiveTime > this.config.idleTimeout) this._freeConnections.get(0).destroy();
+				} finally {
+					this._removeIdleTimeoutConnections();
+				}
+			}, 1e3);
+		}
+		format(sql, values) {
+			return SqlString$1.format(sql, values, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);
+		}
+		escape(value) {
+			return SqlString$1.escape(value, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);
+		}
+		escapeId(value) {
+			return SqlString$1.escapeId(value, false);
+		}
+	};
+	module.exports = BasePool$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/pool.js
+var require_pool$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/pool.js": ((exports, module) => {
+	const EventEmitter$2 = __require("events").EventEmitter;
+	const makeDoneCb$2 = require_make_done_cb();
+	const PromisePoolConnection$2 = require_pool_connection$1();
+	const inheritEvents$1 = require_inherit_events();
+	const BasePool$1 = require_pool$2();
+	var PromisePool$1 = class extends EventEmitter$2 {
+		constructor(pool, thePromise) {
+			super();
+			this.pool = pool;
+			this.Promise = thePromise || Promise;
+			inheritEvents$1(pool, this, [
+				"acquire",
+				"connection",
+				"enqueue",
+				"release"
+			]);
+		}
+		getConnection() {
+			const corePool = this.pool;
+			return new this.Promise((resolve, reject) => {
+				corePool.getConnection((err, coreConnection) => {
+					if (err) reject(err);
+					else resolve(new PromisePoolConnection$2(coreConnection, this.Promise));
+				});
+			});
+		}
+		releaseConnection(connection) {
+			if (connection instanceof PromisePoolConnection$2) connection.release();
+		}
+		query(sql, args) {
+			const corePool = this.pool;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof args === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$2(resolve, reject, localErr);
+				if (args !== void 0) corePool.query(sql, args, done);
+				else corePool.query(sql, done);
+			});
+		}
+		execute(sql, args) {
+			const corePool = this.pool;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof args === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$2(resolve, reject, localErr);
+				if (args) corePool.execute(sql, args, done);
+				else corePool.execute(sql, done);
+			});
+		}
+		end() {
+			const corePool = this.pool;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				corePool.end((err) => {
+					if (err) {
+						localErr.message = err.message;
+						localErr.code = err.code;
+						localErr.errno = err.errno;
+						localErr.sqlState = err.sqlState;
+						localErr.sqlMessage = err.sqlMessage;
+						reject(localErr);
+					} else resolve();
+				});
+			});
+		}
+	};
+	(function(functionsToWrap) {
+		for (let i$4 = 0; functionsToWrap && i$4 < functionsToWrap.length; i$4++) {
+			const func = functionsToWrap[i$4];
+			if (typeof BasePool$1.prototype[func] === "function" && PromisePool$1.prototype[func] === void 0) PromisePool$1.prototype[func] = (function factory(funcName) {
+				return function() {
+					return BasePool$1.prototype[funcName].apply(this.pool, arguments);
+				};
+			})(func);
+		}
+	})([
+		"escape",
+		"escapeId",
+		"format"
+	]);
+	module.exports = PromisePool$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool.js
+var require_pool = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool.js": ((exports, module) => {
+	const BasePool = require_pool$2();
+	var Pool$2 = class extends BasePool {
+		promise(promiseImpl) {
+			return new (require_pool$1())(this, promiseImpl);
+		}
+	};
+	module.exports = Pool$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool_config.js
+var require_pool_config = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool_config.js": ((exports, module) => {
+	const ConnectionConfig$1 = require_connection_config();
+	var PoolConfig$2 = class {
+		constructor(options) {
+			if (typeof options === "string") options = ConnectionConfig$1.parseUrl(options);
+			this.connectionConfig = new ConnectionConfig$1(options);
+			this.waitForConnections = options.waitForConnections === void 0 ? true : Boolean(options.waitForConnections);
+			this.connectionLimit = isNaN(options.connectionLimit) ? 10 : Number(options.connectionLimit);
+			this.maxIdle = isNaN(options.maxIdle) ? this.connectionLimit : Number(options.maxIdle);
+			this.idleTimeout = isNaN(options.idleTimeout) ? 6e4 : Number(options.idleTimeout);
+			this.queueLimit = isNaN(options.queueLimit) ? 0 : Number(options.queueLimit);
+		}
+	};
+	module.exports = PoolConfig$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/connection.js
+var require_connection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/connection.js": ((exports, module) => {
+	const BaseConnection = require_connection$2();
+	var Connection$2 = class extends BaseConnection {
+		promise(promiseImpl) {
+			return new (require_connection$1())(this, promiseImpl);
+		}
+	};
+	module.exports = Connection$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool_cluster.js
+var require_pool_cluster$1 = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/pool_cluster.js": ((exports, module) => {
+	const process$1 = __require("process");
+	const Pool$1 = require_pool();
+	const PoolConfig$1 = require_pool_config();
+	const Connection$1 = require_connection();
+	const EventEmitter$1 = __require("events").EventEmitter;
+	/**
+	* Selector
+	*/
+	const makeSelector = {
+		RR() {
+			let index = 0;
+			return (clusterIds) => clusterIds[index++ % clusterIds.length];
+		},
+		RANDOM() {
+			return (clusterIds) => clusterIds[Math.floor(Math.random() * clusterIds.length)];
+		},
+		ORDER() {
+			return (clusterIds) => clusterIds[0];
+		}
+	};
+	const getMonotonicMilliseconds = function() {
+		let ms;
+		if (typeof process$1.hrtime === "function") {
+			ms = process$1.hrtime();
+			ms = ms[0] * 1e3 + ms[1] * 1e-6;
+		} else ms = process$1.uptime() * 1e3;
+		return Math.floor(ms);
+	};
+	const patternRegExp = function(pattern) {
+		if (pattern instanceof RegExp) return pattern;
+		const source = pattern.replace(/([.+?^=!:${}()|[\]/\\])/g, "\\$1").replace(/\*/g, ".*");
+		return /* @__PURE__ */ new RegExp(`^${source}$`);
+	};
+	var PoolNamespace = class {
+		constructor(cluster, pattern, selector) {
+			this._cluster = cluster;
+			this._pattern = pattern;
+			this._selector = makeSelector[selector]();
+		}
+		getConnection(cb) {
+			const clusterNode = this._getClusterNode();
+			if (clusterNode === null) {
+				let err = /* @__PURE__ */ new Error("Pool does Not exist.");
+				err.code = "POOL_NOEXIST";
+				if (this._cluster._findNodeIds(this._pattern, true).length !== 0) {
+					err = /* @__PURE__ */ new Error("Pool does Not have online node.");
+					err.code = "POOL_NONEONLINE";
+				}
+				return cb(err);
+			}
+			return this._cluster._getConnection(clusterNode, (err, connection) => {
+				if (err) {
+					if (this._cluster._canRetry && this._cluster._findNodeIds(this._pattern).length !== 0) {
+						this._cluster.emit("warn", err);
+						return this.getConnection(cb);
+					}
+					return cb(err);
+				}
+				return cb(null, connection);
+			});
+		}
+		/**
+		* pool cluster query
+		* @param {*} sql
+		* @param {*} values
+		* @param {*} cb
+		* @returns query
+		*/
+		query(sql, values, cb) {
+			const query = Connection$1.createQuery(sql, values, cb, {});
+			this.getConnection((err, conn) => {
+				if (err) {
+					if (typeof query.onResult === "function") query.onResult(err);
+					else query.emit("error", err);
+					return;
+				}
+				try {
+					conn.query(query).once("end", () => {
+						conn.release();
+					});
+				} catch (e) {
+					conn.release();
+					throw e;
+				}
+			});
+			return query;
+		}
+		/**
+		* pool cluster execute
+		* @param {*} sql
+		* @param {*} values
+		* @param {*} cb
+		*/
+		execute(sql, values, cb) {
+			if (typeof values === "function") {
+				cb = values;
+				values = [];
+			}
+			this.getConnection((err, conn) => {
+				if (err) return cb(err);
+				try {
+					conn.execute(sql, values, cb).once("end", () => {
+						conn.release();
+					});
+				} catch (e) {
+					conn.release();
+					throw e;
+				}
+			});
+		}
+		_getClusterNode() {
+			const foundNodeIds = this._cluster._findNodeIds(this._pattern);
+			if (foundNodeIds.length === 0) return null;
+			const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);
+			return this._cluster._getNode(nodeId);
+		}
+	};
+	var PoolCluster$2 = class extends EventEmitter$1 {
+		constructor(config) {
+			super();
+			config = config || {};
+			this._canRetry = typeof config.canRetry === "undefined" ? true : config.canRetry;
+			this._removeNodeErrorCount = config.removeNodeErrorCount || 5;
+			this._restoreNodeTimeout = config.restoreNodeTimeout || 0;
+			this._defaultSelector = config.defaultSelector || "RR";
+			this._closed = false;
+			this._lastId = 0;
+			this._nodes = {};
+			this._serviceableNodeIds = [];
+			this._namespaces = {};
+			this._findCaches = {};
+		}
+		of(pattern, selector) {
+			pattern = pattern || "*";
+			selector = selector || this._defaultSelector;
+			selector = selector.toUpperCase();
+			if (!makeSelector[selector] === "undefined") selector = this._defaultSelector;
+			const key$1 = pattern + selector;
+			if (typeof this._namespaces[key$1] === "undefined") this._namespaces[key$1] = new PoolNamespace(this, pattern, selector);
+			return this._namespaces[key$1];
+		}
+		add(id, config) {
+			if (typeof id === "object") {
+				config = id;
+				id = `CLUSTER::${++this._lastId}`;
+			}
+			if (typeof this._nodes[id] === "undefined") {
+				this._nodes[id] = {
+					id,
+					errorCount: 0,
+					pool: new Pool$1({ config: new PoolConfig$1(config) }),
+					_offlineUntil: 0
+				};
+				this._serviceableNodeIds.push(id);
+				this._clearFindCaches();
+			}
+		}
+		remove(pattern) {
+			const foundNodeIds = this._findNodeIds(pattern, true);
+			for (let i$4 = 0; i$4 < foundNodeIds.length; i$4++) {
+				const node = this._getNode(foundNodeIds[i$4]);
+				if (node) this._removeNode(node);
+			}
+		}
+		getConnection(pattern, selector, cb) {
+			let namespace;
+			if (typeof pattern === "function") {
+				cb = pattern;
+				namespace = this.of();
+			} else {
+				if (typeof selector === "function") {
+					cb = selector;
+					selector = this._defaultSelector;
+				}
+				namespace = this.of(pattern, selector);
+			}
+			namespace.getConnection(cb);
+		}
+		end(callback) {
+			const cb = callback !== void 0 ? callback : (err) => {
+				if (err) throw err;
+			};
+			if (this._closed) {
+				process$1.nextTick(cb);
+				return;
+			}
+			this._closed = true;
+			let calledBack = false;
+			let waitingClose = 0;
+			const onEnd = (err) => {
+				if (!calledBack && (err || --waitingClose <= 0)) {
+					calledBack = true;
+					return cb(err);
+				}
+			};
+			for (const id in this._nodes) {
+				waitingClose++;
+				this._nodes[id].pool.end(onEnd);
+			}
+			if (waitingClose === 0) process$1.nextTick(onEnd);
+		}
+		_findNodeIds(pattern, includeOffline) {
+			let currentTime = 0;
+			let foundNodeIds = this._findCaches[pattern];
+			if (foundNodeIds === void 0) {
+				const expression = patternRegExp(pattern);
+				foundNodeIds = this._serviceableNodeIds.filter((id) => id.match(expression));
+			}
+			this._findCaches[pattern] = foundNodeIds;
+			if (includeOffline) return foundNodeIds;
+			return foundNodeIds.filter((nodeId) => {
+				const node = this._getNode(nodeId);
+				if (!node._offlineUntil) return true;
+				if (!currentTime) currentTime = getMonotonicMilliseconds();
+				return node._offlineUntil <= currentTime;
+			});
+		}
+		_getNode(id) {
+			return this._nodes[id] || null;
+		}
+		_increaseErrorCount(node) {
+			const errorCount = ++node.errorCount;
+			if (this._removeNodeErrorCount > errorCount) return;
+			if (this._restoreNodeTimeout > 0) {
+				node._offlineUntil = getMonotonicMilliseconds() + this._restoreNodeTimeout;
+				this.emit("offline", node.id);
+				return;
+			}
+			this._removeNode(node);
+			this.emit("remove", node.id);
+		}
+		_decreaseErrorCount(node) {
+			let errorCount = node.errorCount;
+			if (errorCount > this._removeNodeErrorCount) errorCount = this._removeNodeErrorCount;
+			if (errorCount < 1) errorCount = 1;
+			node.errorCount = errorCount - 1;
+			if (node._offlineUntil) {
+				node._offlineUntil = 0;
+				this.emit("online", node.id);
+			}
+		}
+		_getConnection(node, cb) {
+			node.pool.getConnection((err, connection) => {
+				if (err) {
+					this._increaseErrorCount(node);
+					return cb(err);
+				}
+				this._decreaseErrorCount(node);
+				connection._clusterId = node.id;
+				return cb(null, connection);
+			});
+		}
+		_removeNode(node) {
+			const index = this._serviceableNodeIds.indexOf(node.id);
+			if (index !== -1) {
+				this._serviceableNodeIds.splice(index, 1);
+				delete this._nodes[node.id];
+				this._clearFindCaches();
+				node.pool.end();
+			}
+		}
+		_clearFindCaches() {
+			this._findCaches = {};
+		}
+	};
+	module.exports = PoolCluster$2;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/create_connection.js
+var require_create_connection = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/create_connection.js": ((exports, module) => {
+	const Connection = require_connection();
+	const ConnectionConfig = require_connection_config();
+	function createConnection$1(opts) {
+		return new Connection({ config: new ConnectionConfig(opts) });
+	}
+	module.exports = createConnection$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/create_pool.js
+var require_create_pool = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/create_pool.js": ((exports, module) => {
+	const Pool = require_pool();
+	const PoolConfig = require_pool_config();
+	function createPool$1(config) {
+		return new Pool({ config: new PoolConfig(config) });
+	}
+	module.exports = createPool$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/create_pool_cluster.js
+var require_create_pool_cluster = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/create_pool_cluster.js": ((exports, module) => {
+	const PoolCluster$1 = require_pool_cluster$1();
+	function createPoolCluster$1(config) {
+		return new PoolCluster$1(config);
+	}
+	module.exports = createPoolCluster$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/pool_cluster.js
+var require_pool_cluster = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/lib/promise/pool_cluster.js": ((exports, module) => {
+	const PromisePoolConnection$1 = require_pool_connection$1();
+	const makeDoneCb$1 = require_make_done_cb();
+	var PromisePoolNamespace$1 = class {
+		constructor(poolNamespace, thePromise) {
+			this.poolNamespace = poolNamespace;
+			this.Promise = thePromise || Promise;
+		}
+		getConnection() {
+			const corePoolNamespace = this.poolNamespace;
+			return new this.Promise((resolve, reject) => {
+				corePoolNamespace.getConnection((err, coreConnection) => {
+					if (err) reject(err);
+					else resolve(new PromisePoolConnection$1(coreConnection, this.Promise));
+				});
+			});
+		}
+		query(sql, values) {
+			const corePoolNamespace = this.poolNamespace;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof values === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$1(resolve, reject, localErr);
+				corePoolNamespace.query(sql, values, done);
+			});
+		}
+		execute(sql, values) {
+			const corePoolNamespace = this.poolNamespace;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof values === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb$1(resolve, reject, localErr);
+				corePoolNamespace.execute(sql, values, done);
+			});
+		}
+	};
+	module.exports = PromisePoolNamespace$1;
+}) });
+
+//#endregion
+//#region ../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/promise.js
+var require_promise = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/mysql2@3.14.4/node_modules/mysql2/promise.js": ((exports) => {
+	const SqlString = require_sqlstring();
+	const EventEmitter = __require("events").EventEmitter;
+	const parserCache = require_parser_cache();
+	const PoolCluster = require_pool_cluster$1();
+	const createConnection = require_create_connection();
+	const createPool = require_create_pool();
+	const createPoolCluster = require_create_pool_cluster();
+	const PromiseConnection = require_connection$1();
+	const PromisePool = require_pool$1();
+	const makeDoneCb = require_make_done_cb();
+	const PromisePoolConnection = require_pool_connection$1();
+	const inheritEvents = require_inherit_events();
+	const PromisePoolNamespace = require_pool_cluster();
+	function createConnectionPromise(opts) {
+		const coreConnection = createConnection(opts);
+		const createConnectionErr = /* @__PURE__ */ new Error();
+		const thePromise = opts.Promise || Promise;
+		if (!thePromise) throw new Error("no Promise implementation available.Use promise-enabled node version or pass userland Promise implementation as parameter, for example: { Promise: require('bluebird') }");
+		return new thePromise((resolve, reject) => {
+			coreConnection.once("connect", () => {
+				resolve(new PromiseConnection(coreConnection, thePromise));
+			});
+			coreConnection.once("error", (err) => {
+				createConnectionErr.message = err.message;
+				createConnectionErr.code = err.code;
+				createConnectionErr.errno = err.errno;
+				createConnectionErr.sqlState = err.sqlState;
+				reject(createConnectionErr);
+			});
+		});
+	}
+	function createPromisePool(opts) {
+		const corePool = createPool(opts);
+		const thePromise = opts.Promise || Promise;
+		if (!thePromise) throw new Error("no Promise implementation available.Use promise-enabled node version or pass userland Promise implementation as parameter, for example: { Promise: require('bluebird') }");
+		return new PromisePool(corePool, thePromise);
+	}
+	var PromisePoolCluster = class extends EventEmitter {
+		constructor(poolCluster, thePromise) {
+			super();
+			this.poolCluster = poolCluster;
+			this.Promise = thePromise || Promise;
+			inheritEvents(poolCluster, this, [
+				"warn",
+				"remove",
+				"online",
+				"offline"
+			]);
+		}
+		getConnection(pattern, selector) {
+			const corePoolCluster = this.poolCluster;
+			return new this.Promise((resolve, reject) => {
+				corePoolCluster.getConnection(pattern, selector, (err, coreConnection) => {
+					if (err) reject(err);
+					else resolve(new PromisePoolConnection(coreConnection, this.Promise));
+				});
+			});
+		}
+		query(sql, args) {
+			const corePoolCluster = this.poolCluster;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof args === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb(resolve, reject, localErr);
+				corePoolCluster.query(sql, args, done);
+			});
+		}
+		execute(sql, args) {
+			const corePoolCluster = this.poolCluster;
+			const localErr = /* @__PURE__ */ new Error();
+			if (typeof args === "function") throw new Error("Callback function is not available with promise clients.");
+			return new this.Promise((resolve, reject) => {
+				const done = makeDoneCb(resolve, reject, localErr);
+				corePoolCluster.execute(sql, args, done);
+			});
+		}
+		of(pattern, selector) {
+			return new PromisePoolNamespace(this.poolCluster.of(pattern, selector), this.Promise);
+		}
+		end() {
+			const corePoolCluster = this.poolCluster;
+			const localErr = /* @__PURE__ */ new Error();
+			return new this.Promise((resolve, reject) => {
+				corePoolCluster.end((err) => {
+					if (err) {
+						localErr.message = err.message;
+						localErr.code = err.code;
+						localErr.errno = err.errno;
+						localErr.sqlState = err.sqlState;
+						localErr.sqlMessage = err.sqlMessage;
+						reject(localErr);
+					} else resolve();
+				});
+			});
+		}
+	};
+	/**
+	* proxy poolCluster synchronous functions
+	*/
+	(function(functionsToWrap) {
+		for (let i$4 = 0; functionsToWrap && i$4 < functionsToWrap.length; i$4++) {
+			const func = functionsToWrap[i$4];
+			if (typeof PoolCluster.prototype[func] === "function" && PromisePoolCluster.prototype[func] === void 0) PromisePoolCluster.prototype[func] = (function factory(funcName) {
+				return function() {
+					return PoolCluster.prototype[funcName].apply(this.poolCluster, arguments);
+				};
+			})(func);
+		}
+	})(["add", "remove"]);
+	function createPromisePoolCluster(opts) {
+		const corePoolCluster = createPoolCluster(opts);
+		const thePromise = opts && opts.Promise || Promise;
+		if (!thePromise) throw new Error("no Promise implementation available.Use promise-enabled node version or pass userland Promise implementation as parameter, for example: { Promise: require('bluebird') }");
+		return new PromisePoolCluster(corePoolCluster, thePromise);
+	}
+	exports.createConnection = createConnectionPromise;
+	exports.createPool = createPromisePool;
+	exports.createPoolCluster = createPromisePoolCluster;
+	exports.escape = SqlString.escape;
+	exports.escapeId = SqlString.escapeId;
+	exports.format = SqlString.format;
+	exports.raw = SqlString.raw;
+	exports.PromisePool = PromisePool;
+	exports.PromiseConnection = PromiseConnection;
+	exports.PromisePoolConnection = PromisePoolConnection;
+	exports.__defineGetter__("Types", () => require_types());
+	exports.__defineGetter__("Charsets", () => require_charsets());
+	exports.__defineGetter__("CharsetToEncoding", () => require_charset_encodings());
+	exports.setMaxParserCache = function(max) {
+		parserCache.setMaxCache(max);
+	};
+	exports.clearParserCache = function() {
+		parserCache.clearCache();
+	};
+}) });
+
+//#endregion
+export default require_promise();
+
+export {  };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/proxy-CH2wKnFj.mjs.bak b/node_modules/better-auth/dist/proxy-CH2wKnFj.mjs.bak
new file mode 100644
index 0000000..969c252
--- /dev/null
+++ b/node_modules/better-auth/dist/proxy-CH2wKnFj.mjs.bak
@@ -0,0 +1,441 @@
+import { t as getBaseURL } from "./url-SXU3XD3W.mjs";
+import { t as parseJSON } from "./parser-DcrIEuXE.mjs";
+import { BetterFetchError, createFetch } from "@better-fetch/fetch";
+import { atom, onMount } from "nanostores";
+
+//#region src/client/broadcast-channel.ts
+const now$1 = () => Math.floor(Date.now() / 1e3);
+function createBroadcastChannel(name = "better-auth.message") {
+	return {
+		receive(onReceive) {
+			const handler = (event) => {
+				if (event.key !== name) return;
+				const message = JSON.parse(event.newValue ?? "{}");
+				if (message?.event !== "session" || !message?.data) return;
+				onReceive(message);
+			};
+			window.addEventListener("storage", handler);
+			return () => window.removeEventListener("storage", handler);
+		},
+		post(message) {
+			if (typeof window === "undefined") return;
+			try {
+				localStorage.setItem(name, JSON.stringify({
+					...message,
+					timestamp: now$1()
+				}));
+			} catch {}
+		}
+	};
+}
+
+//#endregion
+//#region src/client/query.ts
+const isServer = () => typeof window === "undefined";
+const useAuthQuery = (initializedAtom, path, $fetch, options) => {
+	const value = atom({
+		data: null,
+		error: null,
+		isPending: true,
+		isRefetching: false,
+		refetch: (queryParams) => {
+			return fn(queryParams);
+		}
+	});
+	const fn = (queryParams) => {
+		const opts = typeof options === "function" ? options({
+			data: value.get().data,
+			error: value.get().error,
+			isPending: value.get().isPending
+		}) : options;
+		$fetch(path, {
+			...opts,
+			query: {
+				...opts?.query,
+				...queryParams?.query
+			},
+			async onSuccess(context) {
+				value.set({
+					data: context.data,
+					error: null,
+					isPending: false,
+					isRefetching: false,
+					refetch: value.value.refetch
+				});
+				await opts?.onSuccess?.(context);
+			},
+			async onError(context) {
+				const { request } = context;
+				const retryAttempts = typeof request.retry === "number" ? request.retry : request.retry?.attempts;
+				const retryAttempt = request.retryAttempt || 0;
+				if (retryAttempts && retryAttempt < retryAttempts) return;
+				value.set({
+					error: context.error,
+					data: null,
+					isPending: false,
+					isRefetching: false,
+					refetch: value.value.refetch
+				});
+				await opts?.onError?.(context);
+			},
+			async onRequest(context) {
+				const currentValue = value.get();
+				value.set({
+					isPending: currentValue.data === null,
+					data: currentValue.data,
+					error: null,
+					isRefetching: true,
+					refetch: value.value.refetch
+				});
+				await opts?.onRequest?.(context);
+			}
+		}).catch((error) => {
+			value.set({
+				error,
+				data: null,
+				isPending: false,
+				isRefetching: false,
+				refetch: value.value.refetch
+			});
+		});
+	};
+	initializedAtom = Array.isArray(initializedAtom) ? initializedAtom : [initializedAtom];
+	let isMounted = false;
+	for (const initAtom of initializedAtom) initAtom.subscribe(() => {
+		if (isServer()) return;
+		if (isMounted) fn();
+		else onMount(value, () => {
+			const timeoutId = setTimeout(() => {
+				if (!isMounted) {
+					fn();
+					isMounted = true;
+				}
+			}, 0);
+			return () => {
+				value.off();
+				initAtom.off();
+				clearTimeout(timeoutId);
+			};
+		});
+	});
+	return value;
+};
+
+//#endregion
+//#region src/client/session-refresh.ts
+const now = () => Math.floor(Date.now() / 1e3);
+function createSessionRefreshManager(opts) {
+	const { sessionAtom, sessionSignal, options = {} } = opts;
+	const { refetchInterval = 0, refetchOnWindowFocus = true, refetchWhenOffline = false } = options?.sessionOptions || {};
+	const state = {
+		lastSync: 0,
+		cachedSession: void 0
+	};
+	let isOnline = typeof navigator !== "undefined" ? navigator.onLine : true;
+	const broadcast = createBroadcastChannel();
+	const shouldRefetch = () => {
+		if (typeof window === "undefined") return false;
+		return refetchWhenOffline || isOnline;
+	};
+	const triggerRefetch = (event) => {
+		if (!shouldRefetch()) return;
+		if (event?.event === "storage") {
+			state.lastSync = now();
+			sessionSignal.set(!sessionSignal.get());
+			return;
+		}
+		const currentSession = sessionAtom.get();
+		if (currentSession?.data === null || currentSession?.data === void 0 || event?.event === "poll" || event?.event === "visibilitychange") {
+			state.lastSync = now();
+			sessionSignal.set(!sessionSignal.get());
+		}
+	};
+	const broadcastSessionUpdate = (trigger) => {
+		broadcast.post({
+			event: "session",
+			data: { trigger },
+			clientId: Math.random().toString(36).substring(7)
+		});
+	};
+	const setupPolling = () => {
+		if (refetchInterval && refetchInterval > 0) state.pollInterval = setInterval(() => {
+			if (sessionAtom.get()?.data) triggerRefetch({ event: "poll" });
+		}, refetchInterval * 1e3);
+	};
+	const setupBroadcast = () => {
+		state.unsubscribeBroadcast = broadcast.receive(() => {
+			triggerRefetch({ event: "storage" });
+		});
+	};
+	const setupVisibilityChange = () => {
+		if (!refetchOnWindowFocus) return;
+		if (typeof document === "undefined") return;
+		const visibilityHandler = () => {
+			if (document.visibilityState === "visible") triggerRefetch({ event: "visibilitychange" });
+		};
+		document.addEventListener("visibilitychange", visibilityHandler, false);
+		state.unsubscribeVisibility = () => {
+			document.removeEventListener("visibilitychange", visibilityHandler, false);
+		};
+	};
+	const setupOnlineDetection = () => {
+		if (typeof window === "undefined") return;
+		const setOnline = () => {
+			isOnline = true;
+			triggerRefetch({ event: "visibilitychange" });
+		};
+		const setOffline = () => {
+			isOnline = false;
+		};
+		window.addEventListener("online", setOnline);
+		window.addEventListener("offline", setOffline);
+		state.unsubscribeOnline = () => window.removeEventListener("online", setOnline);
+		state.unsubscribeOffline = () => window.removeEventListener("offline", setOffline);
+	};
+	const init = () => {
+		if (typeof window === "undefined") return;
+		setupPolling();
+		setupBroadcast();
+		setupVisibilityChange();
+		setupOnlineDetection();
+	};
+	const cleanup = () => {
+		if (state.pollInterval) {
+			clearInterval(state.pollInterval);
+			state.pollInterval = void 0;
+		}
+		if (state.unsubscribeBroadcast) {
+			state.unsubscribeBroadcast();
+			state.unsubscribeBroadcast = void 0;
+		}
+		if (state.unsubscribeVisibility) {
+			state.unsubscribeVisibility();
+			state.unsubscribeVisibility = void 0;
+		}
+		if (state.unsubscribeOnline) {
+			state.unsubscribeOnline();
+			state.unsubscribeOnline = void 0;
+		}
+		if (state.unsubscribeOffline) {
+			state.unsubscribeOffline();
+			state.unsubscribeOffline = void 0;
+		}
+		state.lastSync = 0;
+		state.cachedSession = void 0;
+	};
+	return {
+		init,
+		cleanup,
+		triggerRefetch,
+		broadcastSessionUpdate
+	};
+}
+
+//#endregion
+//#region src/client/fetch-plugins.ts
+const redirectPlugin = {
+	id: "redirect",
+	name: "Redirect",
+	hooks: { onSuccess(context) {
+		if (context.data?.url && context.data?.redirect) {
+			if (typeof window !== "undefined" && window.location) {
+				if (window.location) try {
+					window.location.href = context.data.url;
+				} catch {}
+			}
+		}
+	} }
+};
+const userAgentPlugin = {
+	id: "user-agent",
+	name: "UserAgent",
+	hooks: { onRequest(context) {
+		context.headers.append("user-agent", "better-auth");
+	} }
+};
+
+//#endregion
+//#region src/client/session-atom.ts
+function getSessionAtom($fetch, options) {
+	const $signal = atom(false);
+	const session = useAuthQuery($signal, "/get-session", $fetch, { method: "GET" });
+	if (typeof window !== "undefined") onMount(session, () => {
+		const refreshManager = createSessionRefreshManager({
+			sessionAtom: session,
+			sessionSignal: $signal,
+			$fetch,
+			options
+		});
+		refreshManager.init();
+		return () => {
+			refreshManager.cleanup();
+		};
+	});
+	return {
+		session,
+		$sessionSignal: $signal
+	};
+}
+
+//#endregion
+//#region src/client/config.ts
+const getClientConfig = (options, loadEnv) => {
+	const isCredentialsSupported = "credentials" in Request.prototype;
+	const baseURL = getBaseURL(options?.baseURL, options?.basePath, void 0, loadEnv) ?? "/api/auth";
+	const pluginsFetchPlugins = options?.plugins?.flatMap((plugin) => plugin.fetchPlugins).filter((pl) => pl !== void 0) || [];
+	const lifeCyclePlugin = {
+		id: "lifecycle-hooks",
+		name: "lifecycle-hooks",
+		hooks: {
+			onSuccess: options?.fetchOptions?.onSuccess,
+			onError: options?.fetchOptions?.onError,
+			onRequest: options?.fetchOptions?.onRequest,
+			onResponse: options?.fetchOptions?.onResponse
+		}
+	};
+	const { onSuccess, onError, onRequest, onResponse,...restOfFetchOptions } = options?.fetchOptions || {};
+	const $fetch = createFetch({
+		baseURL,
+		...isCredentialsSupported ? { credentials: "include" } : {},
+		method: "GET",
+		jsonParser(text) {
+			if (!text) return null;
+			return parseJSON(text, { strict: false });
+		},
+		customFetchImpl: fetch,
+		...restOfFetchOptions,
+		plugins: [
+			lifeCyclePlugin,
+			userAgentPlugin,
+			...restOfFetchOptions.plugins || [],
+			...options?.disableDefaultFetchPlugins ? [] : [redirectPlugin],
+			...pluginsFetchPlugins
+		]
+	});
+	const { $sessionSignal, session } = getSessionAtom($fetch, options);
+	const plugins = options?.plugins || [];
+	let pluginsActions = {};
+	let pluginsAtoms = {
+		$sessionSignal,
+		session
+	};
+	let pluginPathMethods = {
+		"/sign-out": "POST",
+		"/revoke-sessions": "POST",
+		"/revoke-other-sessions": "POST",
+		"/delete-user": "POST"
+	};
+	const atomListeners = [{
+		signal: "$sessionSignal",
+		matcher(path) {
+			return path === "/sign-out" || path === "/update-user" || path === "/sign-up/email" || path === "/sign-in/email" || path === "/delete-user" || path === "/verify-email" || path === "/revoke-sessions" || path === "/revoke-session" || path === "/change-email";
+		}
+	}];
+	for (const plugin of plugins) {
+		if (plugin.getAtoms) Object.assign(pluginsAtoms, plugin.getAtoms?.($fetch));
+		if (plugin.pathMethods) Object.assign(pluginPathMethods, plugin.pathMethods);
+		if (plugin.atomListeners) atomListeners.push(...plugin.atomListeners);
+	}
+	const $store = {
+		notify: (signal) => {
+			pluginsAtoms[signal].set(!pluginsAtoms[signal].get());
+		},
+		listen: (signal, listener) => {
+			pluginsAtoms[signal].subscribe(listener);
+		},
+		atoms: pluginsAtoms
+	};
+	for (const plugin of plugins) if (plugin.getActions) Object.assign(pluginsActions, plugin.getActions?.($fetch, $store, options));
+	return {
+		get baseURL() {
+			return baseURL;
+		},
+		pluginsActions,
+		pluginsAtoms,
+		pluginPathMethods,
+		atomListeners,
+		$fetch,
+		$store
+	};
+};
+
+//#endregion
+//#region src/utils/is-atom.ts
+function isAtom(value) {
+	return typeof value === "object" && value !== null && "get" in value && typeof value.get === "function" && "lc" in value && typeof value.lc === "number";
+}
+
+//#endregion
+//#region src/client/proxy.ts
+function getMethod(path, knownPathMethods, args) {
+	const method = knownPathMethods[path];
+	const { fetchOptions, query,...body } = args || {};
+	if (method) return method;
+	if (fetchOptions?.method) return fetchOptions.method;
+	if (body && Object.keys(body).length > 0) return "POST";
+	return "GET";
+}
+function createDynamicPathProxy(routes, client, knownPathMethods, atoms, atomListeners) {
+	function createProxy(path = []) {
+		return new Proxy(function() {}, {
+			get(_, prop) {
+				if (typeof prop !== "string") return;
+				if (prop === "then" || prop === "catch" || prop === "finally") return;
+				const fullPath = [...path, prop];
+				let current = routes;
+				for (const segment of fullPath) if (current && typeof current === "object" && segment in current) current = current[segment];
+				else {
+					current = void 0;
+					break;
+				}
+				if (typeof current === "function") return current;
+				if (isAtom(current)) return current;
+				return createProxy(fullPath);
+			},
+			apply: async (_, __, args) => {
+				const routePath = "/" + path.map((segment) => segment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`)).join("/");
+				const arg = args[0] || {};
+				const fetchOptions = args[1] || {};
+				const { query, fetchOptions: argFetchOptions,...body } = arg;
+				const options = {
+					...fetchOptions,
+					...argFetchOptions
+				};
+				const method = getMethod(routePath, knownPathMethods, arg);
+				return await client(routePath, {
+					...options,
+					body: method === "GET" ? void 0 : {
+						...body,
+						...options?.body || {}
+					},
+					query: query || options?.query,
+					method,
+					async onSuccess(context) {
+						await options?.onSuccess?.(context);
+						if (!atomListeners) return;
+						/**
+						* We trigger listeners
+						*/
+						const matches = atomListeners.filter((s) => s.matcher(routePath));
+						if (!matches.length) return;
+						for (const match of matches) {
+							const signal = atoms[match.signal];
+							if (!signal) return;
+							/**
+							* To avoid race conditions we set the signal in a setTimeout
+							*/
+							const val = signal.get();
+							setTimeout(() => {
+								signal.set(!val);
+							}, 10);
+						}
+					}
+				});
+			}
+		});
+	}
+	return createProxy();
+}
+
+//#endregion
+export { createBroadcastChannel as a, useAuthQuery as i, getClientConfig as n, createSessionRefreshManager as r, createDynamicPathProxy as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/schema-BevzneML.mjs.bak b/node_modules/better-auth/dist/schema-BevzneML.mjs.bak
new file mode 100644
index 0000000..a77d80f
--- /dev/null
+++ b/node_modules/better-auth/dist/schema-BevzneML.mjs.bak
@@ -0,0 +1,115 @@
+import { APIError } from "better-call";
+
+//#region src/utils/date.ts
+const getDate = (span, unit = "ms") => {
+	return new Date(Date.now() + (unit === "sec" ? span * 1e3 : span));
+};
+
+//#endregion
+//#region src/db/schema.ts
+const cache = /* @__PURE__ */ new WeakMap();
+function parseOutputData(data, schema) {
+	const fields = schema.fields;
+	const parsedData = {};
+	for (const key in data) {
+		const field = fields[key];
+		if (!field) {
+			parsedData[key] = data[key];
+			continue;
+		}
+		if (field.returned === false) continue;
+		parsedData[key] = data[key];
+	}
+	return parsedData;
+}
+function getAllFields(options, table) {
+	if (!cache.has(options)) cache.set(options, /* @__PURE__ */ new Map());
+	const tableCache = cache.get(options);
+	if (tableCache.has(table)) return tableCache.get(table);
+	let schema = {
+		...table === "user" ? options.user?.additionalFields : {},
+		...table === "session" ? options.session?.additionalFields : {}
+	};
+	for (const plugin of options.plugins || []) if (plugin.schema && plugin.schema[table]) schema = {
+		...schema,
+		...plugin.schema[table].fields
+	};
+	cache.get(options).set(table, schema);
+	return schema;
+}
+function parseUserOutput(options, user) {
+	return parseOutputData(user, { fields: getAllFields(options, "user") });
+}
+function parseAccountOutput(options, account) {
+	return parseOutputData(account, { fields: getAllFields(options, "account") });
+}
+function parseSessionOutput(options, session) {
+	return parseOutputData(session, { fields: getAllFields(options, "session") });
+}
+function parseInputData(data, schema) {
+	const action = schema.action || "create";
+	const fields = schema.fields;
+	const parsedData = Object.assign(Object.create(null), null);
+	for (const key in fields) {
+		if (key in data) {
+			if (fields[key].input === false) {
+				if (fields[key].defaultValue !== void 0) {
+					if (action !== "update") {
+						parsedData[key] = fields[key].defaultValue;
+						continue;
+					}
+				}
+				if (data[key]) throw new APIError("BAD_REQUEST", { message: `${key} is not allowed to be set` });
+				continue;
+			}
+			if (fields[key].validator?.input && data[key] !== void 0) {
+				parsedData[key] = fields[key].validator.input["~standard"].validate(data[key]);
+				continue;
+			}
+			if (fields[key].transform?.input && data[key] !== void 0) {
+				parsedData[key] = fields[key].transform?.input(data[key]);
+				continue;
+			}
+			parsedData[key] = data[key];
+			continue;
+		}
+		if (fields[key].defaultValue !== void 0 && action === "create") {
+			parsedData[key] = fields[key].defaultValue;
+			continue;
+		}
+		if (fields[key].required && action === "create") throw new APIError("BAD_REQUEST", { message: `${key} is required` });
+	}
+	return parsedData;
+}
+function parseUserInput(options, user = {}, action) {
+	return parseInputData(user, {
+		fields: getAllFields(options, "user"),
+		action
+	});
+}
+function parseAdditionalUserInput(options, user) {
+	const schema = getAllFields(options, "user");
+	return parseInputData(user || {}, { fields: schema });
+}
+function parseAccountInput(options, account) {
+	return parseInputData(account, { fields: getAllFields(options, "account") });
+}
+function parseSessionInput(options, session) {
+	return parseInputData(session, { fields: getAllFields(options, "session") });
+}
+function mergeSchema(schema, newSchema) {
+	if (!newSchema) return schema;
+	for (const table in newSchema) {
+		const newModelName = newSchema[table]?.modelName;
+		if (newModelName) schema[table].modelName = newModelName;
+		for (const field in schema[table].fields) {
+			const newField = newSchema[table]?.fields?.[field];
+			if (!newField) continue;
+			schema[table].fields[field].fieldName = newField;
+		}
+	}
+	return schema;
+}
+
+//#endregion
+export { parseInputData as a, parseUserInput as c, parseAdditionalUserInput as i, parseUserOutput as l, parseAccountInput as n, parseSessionInput as o, parseAccountOutput as r, parseSessionOutput as s, mergeSchema as t, getDate as u };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/session-Efap-vxj.mjs b/node_modules/better-auth/dist/session-Efap-vxj.mjs
index 18dbdf3..f28a9b6 100644
--- a/node_modules/better-auth/dist/session-Efap-vxj.mjs
+++ b/node_modules/better-auth/dist/session-Efap-vxj.mjs
@@ -318,7 +318,7 @@ const listSessions = () => createAuthEndpoint("/list-sessions", {
 */
 const revokeSession = createAuthEndpoint("/revoke-session", {
 	method: "POST",
-	body: z.object({ token: z.string().meta({ description: "The token to revoke" }) }),
+	body: z.object({ token: z.string() }),
 	use: [sensitiveSessionMiddleware],
 	requireHeaders: true,
 	metadata: { openapi: {
diff --git a/node_modules/better-auth/dist/session-Efap-vxj.mjs.bak b/node_modules/better-auth/dist/session-Efap-vxj.mjs.bak
new file mode 100644
index 0000000..18dbdf3
--- /dev/null
+++ b/node_modules/better-auth/dist/session-Efap-vxj.mjs.bak
@@ -0,0 +1,418 @@
+import { i as verifyJWT, n as symmetricDecodeJWT } from "./jwt-CmxZAGe2.mjs";
+import { l as parseUserOutput, s as parseSessionOutput, u as getDate } from "./schema-BevzneML.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { c as setSessionCookie, f as getChunkedCookie, n as deleteSessionCookie, p as getSessionQuerySchema, s as setCookieCache } from "./cookies-Cl2L38B1.mjs";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+import { base64Url } from "@better-auth/utils/base64";
+import { binary } from "@better-auth/utils/binary";
+import { createHMAC } from "@better-auth/utils/hmac";
+
+//#region src/api/routes/session.ts
+const getSession = () => createAuthEndpoint("/get-session", {
+	method: "GET",
+	operationId: "getSession",
+	query: getSessionQuerySchema,
+	requireHeaders: true,
+	metadata: { openapi: {
+		operationId: "getSession",
+		description: "Get the current session",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: {
+					session: { $ref: "#/components/schemas/Session" },
+					user: { $ref: "#/components/schemas/User" }
+				},
+				required: ["session", "user"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	try {
+		const sessionCookieToken = await ctx.getSignedCookie(ctx.context.authCookies.sessionToken.name, ctx.context.secret);
+		if (!sessionCookieToken) return null;
+		const sessionDataCookie = getChunkedCookie(ctx, ctx.context.authCookies.sessionData.name);
+		let sessionDataPayload = null;
+		if (sessionDataCookie) {
+			const strategy = ctx.context.options.session?.cookieCache?.strategy || "compact";
+			if (strategy === "jwe") {
+				const payload = await symmetricDecodeJWT(sessionDataCookie, ctx.context.secret, "better-auth-session");
+				if (payload && payload.session && payload.user) sessionDataPayload = {
+					session: {
+						session: payload.session,
+						user: payload.user,
+						updatedAt: payload.updatedAt,
+						version: payload.version
+					},
+					expiresAt: payload.exp ? payload.exp * 1e3 : Date.now()
+				};
+				else {
+					const dataCookie = ctx.context.authCookies.sessionData.name;
+					ctx.setCookie(dataCookie, "", { maxAge: 0 });
+					return ctx.json(null);
+				}
+			} else if (strategy === "jwt") {
+				const payload = await verifyJWT(sessionDataCookie, ctx.context.secret);
+				if (payload && payload.session && payload.user) sessionDataPayload = {
+					session: {
+						session: payload.session,
+						user: payload.user,
+						updatedAt: payload.updatedAt,
+						version: payload.version
+					},
+					expiresAt: payload.exp ? payload.exp * 1e3 : Date.now()
+				};
+				else {
+					const dataCookie = ctx.context.authCookies.sessionData.name;
+					ctx.setCookie(dataCookie, "", { maxAge: 0 });
+					return ctx.json(null);
+				}
+			} else {
+				const parsed = safeJSONParse(binary.decode(base64Url.decode(sessionDataCookie)));
+				if (parsed) if (await createHMAC("SHA-256", "base64urlnopad").verify(ctx.context.secret, JSON.stringify({
+					...parsed.session,
+					expiresAt: parsed.expiresAt
+				}), parsed.signature)) sessionDataPayload = parsed;
+				else {
+					const dataCookie = ctx.context.authCookies.sessionData.name;
+					ctx.setCookie(dataCookie, "", { maxAge: 0 });
+					return ctx.json(null);
+				}
+			}
+		}
+		const dontRememberMe = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
+		/**
+		* If session data is present in the cookie, check if it should be used or refreshed
+		*/
+		if (sessionDataPayload?.session && ctx.context.options.session?.cookieCache?.enabled && !ctx.query?.disableCookieCache) {
+			const session$1 = sessionDataPayload.session;
+			const versionConfig = ctx.context.options.session?.cookieCache?.version;
+			let expectedVersion = "1";
+			if (versionConfig) {
+				if (typeof versionConfig === "string") expectedVersion = versionConfig;
+				else if (typeof versionConfig === "function") {
+					const result = versionConfig(session$1.session, session$1.user);
+					expectedVersion = result instanceof Promise ? await result : result;
+				}
+			}
+			if ((session$1.version || "1") !== expectedVersion) {
+				const dataCookie = ctx.context.authCookies.sessionData.name;
+				ctx.setCookie(dataCookie, "", { maxAge: 0 });
+			} else if (sessionDataPayload.expiresAt < Date.now() || session$1.session.expiresAt < /* @__PURE__ */ new Date()) {
+				const dataCookie = ctx.context.authCookies.sessionData.name;
+				ctx.setCookie(dataCookie, "", { maxAge: 0 });
+			} else {
+				const cookieRefreshCache = ctx.context.sessionConfig.cookieRefreshCache;
+				if (cookieRefreshCache === false) {
+					ctx.context.session = session$1;
+					return ctx.json({
+						session: session$1.session,
+						user: session$1.user
+					});
+				}
+				if (sessionDataPayload.expiresAt - Date.now() < cookieRefreshCache.updateAge * 1e3) {
+					const newExpiresAt = getDate(ctx.context.options.session?.cookieCache?.maxAge || 300, "sec");
+					const refreshedSession = {
+						session: {
+							...session$1.session,
+							expiresAt: newExpiresAt
+						},
+						user: session$1.user,
+						updatedAt: Date.now()
+					};
+					await setCookieCache(ctx, refreshedSession, false);
+					const parsedRefreshedSession = parseSessionOutput(ctx.context.options, {
+						...refreshedSession.session,
+						expiresAt: new Date(refreshedSession.session.expiresAt),
+						createdAt: new Date(refreshedSession.session.createdAt),
+						updatedAt: new Date(refreshedSession.session.updatedAt)
+					});
+					const parsedRefreshedUser = parseUserOutput(ctx.context.options, {
+						...refreshedSession.user,
+						createdAt: new Date(refreshedSession.user.createdAt),
+						updatedAt: new Date(refreshedSession.user.updatedAt)
+					});
+					ctx.context.session = {
+						session: parsedRefreshedSession,
+						user: parsedRefreshedUser
+					};
+					return ctx.json({
+						session: parsedRefreshedSession,
+						user: parsedRefreshedUser
+					});
+				}
+				const parsedSession = parseSessionOutput(ctx.context.options, {
+					...session$1.session,
+					expiresAt: new Date(session$1.session.expiresAt),
+					createdAt: new Date(session$1.session.createdAt),
+					updatedAt: new Date(session$1.session.updatedAt)
+				});
+				const parsedUser = parseUserOutput(ctx.context.options, {
+					...session$1.user,
+					createdAt: new Date(session$1.user.createdAt),
+					updatedAt: new Date(session$1.user.updatedAt)
+				});
+				ctx.context.session = {
+					session: parsedSession,
+					user: parsedUser
+				};
+				return ctx.json({
+					session: parsedSession,
+					user: parsedUser
+				});
+			}
+		}
+		const session = await ctx.context.internalAdapter.findSession(sessionCookieToken);
+		ctx.context.session = session;
+		if (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {
+			deleteSessionCookie(ctx);
+			if (session)
+ /**
+			* if session expired clean up the session
+			*/
+			await ctx.context.internalAdapter.deleteSession(session.session.token);
+			return ctx.json(null);
+		}
+		/**
+		* We don't need to update the session if the user doesn't want to be remembered
+		* or if the session refresh is disabled
+		*/
+		if (dontRememberMe || ctx.query?.disableRefresh) {
+			const parsedSession = parseSessionOutput(ctx.context.options, session.session);
+			const parsedUser = parseUserOutput(ctx.context.options, session.user);
+			return ctx.json({
+				session: parsedSession,
+				user: parsedUser
+			});
+		}
+		const expiresIn = ctx.context.sessionConfig.expiresIn;
+		const updateAge = ctx.context.sessionConfig.updateAge;
+		if (session.session.expiresAt.valueOf() - expiresIn * 1e3 + updateAge * 1e3 <= Date.now() && (!ctx.query?.disableRefresh || !ctx.context.options.session?.disableSessionRefresh)) {
+			const updatedSession = await ctx.context.internalAdapter.updateSession(session.session.token, {
+				expiresAt: getDate(ctx.context.sessionConfig.expiresIn, "sec"),
+				updatedAt: /* @__PURE__ */ new Date()
+			});
+			if (!updatedSession) {
+				/**
+				* Handle case where session update fails (e.g., concurrent deletion)
+				*/
+				deleteSessionCookie(ctx);
+				return ctx.json(null, { status: 401 });
+			}
+			const maxAge = (updatedSession.expiresAt.valueOf() - Date.now()) / 1e3;
+			await setSessionCookie(ctx, {
+				session: updatedSession,
+				user: session.user
+			}, false, { maxAge });
+			const parsedUpdatedSession = parseSessionOutput(ctx.context.options, updatedSession);
+			const parsedUser = parseUserOutput(ctx.context.options, session.user);
+			return ctx.json({
+				session: parsedUpdatedSession,
+				user: parsedUser
+			});
+		}
+		await setCookieCache(ctx, session, !!dontRememberMe);
+		return ctx.json(session);
+	} catch (error) {
+		ctx.context.logger.error("INTERNAL_SERVER_ERROR", error);
+		throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_GET_SESSION });
+	}
+});
+const getSessionFromCtx = async (ctx, config) => {
+	if (ctx.context.session) return ctx.context.session;
+	const session = await getSession()({
+		...ctx,
+		asResponse: false,
+		headers: ctx.headers,
+		returnHeaders: false,
+		returnStatus: false,
+		query: {
+			...config,
+			...ctx.query
+		}
+	}).catch((e) => {
+		return null;
+	});
+	ctx.context.session = session;
+	return session;
+};
+/**
+* The middleware forces the endpoint to require a valid session.
+*/
+const sessionMiddleware = createAuthMiddleware(async (ctx) => {
+	const session = await getSessionFromCtx(ctx);
+	if (!session?.session) throw new APIError("UNAUTHORIZED");
+	return { session };
+});
+/**
+* This middleware forces the endpoint to require a valid session and ignores cookie cache.
+* This should be used for sensitive operations like password changes, account deletion, etc.
+* to ensure that revoked sessions cannot be used even if they're still cached in cookies.
+*/
+const sensitiveSessionMiddleware = createAuthMiddleware(async (ctx) => {
+	const session = await getSessionFromCtx(ctx, { disableCookieCache: true });
+	if (!session?.session) throw new APIError("UNAUTHORIZED");
+	return { session };
+});
+/**
+* This middleware allows you to call the endpoint on the client if session is valid.
+* However, if called on the server, no session is required.
+*/
+const requestOnlySessionMiddleware = createAuthMiddleware(async (ctx) => {
+	const session = await getSessionFromCtx(ctx);
+	if (!session?.session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
+	return { session };
+});
+/**
+* This middleware forces the endpoint to require a valid session,
+* as well as making sure the session is fresh before proceeding.
+*
+* Session freshness check will be skipped if the session config's freshAge
+* is set to 0
+*/
+const freshSessionMiddleware = createAuthMiddleware(async (ctx) => {
+	const session = await getSessionFromCtx(ctx);
+	if (!session?.session) throw new APIError("UNAUTHORIZED");
+	if (ctx.context.sessionConfig.freshAge === 0) return { session };
+	const freshAge = ctx.context.sessionConfig.freshAge;
+	const lastUpdated = session.session.updatedAt?.valueOf() || session.session.createdAt.valueOf();
+	if (!(Date.now() - lastUpdated < freshAge * 1e3)) throw new APIError("FORBIDDEN", { message: "Session is not fresh" });
+	return { session };
+});
+/**
+* user active sessions list
+*/
+const listSessions = () => createAuthEndpoint("/list-sessions", {
+	method: "GET",
+	operationId: "listUserSessions",
+	use: [sessionMiddleware],
+	requireHeaders: true,
+	metadata: { openapi: {
+		operationId: "listUserSessions",
+		description: "List all active sessions for the user",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "array",
+				items: { $ref: "#/components/schemas/Session" }
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	try {
+		const activeSessions = (await ctx.context.internalAdapter.listSessions(ctx.context.session.user.id)).filter((session) => {
+			return session.expiresAt > /* @__PURE__ */ new Date();
+		});
+		return ctx.json(activeSessions);
+	} catch (e) {
+		ctx.context.logger.error(e);
+		throw ctx.error("INTERNAL_SERVER_ERROR");
+	}
+});
+/**
+* revoke a single session
+*/
+const revokeSession = createAuthEndpoint("/revoke-session", {
+	method: "POST",
+	body: z.object({ token: z.string().meta({ description: "The token to revoke" }) }),
+	use: [sensitiveSessionMiddleware],
+	requireHeaders: true,
+	metadata: { openapi: {
+		description: "Revoke a single session",
+		requestBody: { content: { "application/json": { schema: {
+			type: "object",
+			properties: { token: {
+				type: "string",
+				description: "The token to revoke"
+			} },
+			required: ["token"]
+		} } } },
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { status: {
+					type: "boolean",
+					description: "Indicates if the session was revoked successfully"
+				} },
+				required: ["status"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const token = ctx.body.token;
+	const findSession = await ctx.context.internalAdapter.findSession(token);
+	if (!findSession) throw new APIError("BAD_REQUEST", { message: "Session not found" });
+	if (findSession.session.userId !== ctx.context.session.user.id) throw new APIError("UNAUTHORIZED");
+	try {
+		await ctx.context.internalAdapter.deleteSession(token);
+	} catch (error) {
+		ctx.context.logger.error(error && typeof error === "object" && "name" in error ? error.name : "", error);
+		throw new APIError("INTERNAL_SERVER_ERROR");
+	}
+	return ctx.json({ status: true });
+});
+/**
+* revoke all user sessions
+*/
+const revokeSessions = createAuthEndpoint("/revoke-sessions", {
+	method: "POST",
+	use: [sensitiveSessionMiddleware],
+	requireHeaders: true,
+	metadata: { openapi: {
+		description: "Revoke all sessions for the user",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { status: {
+					type: "boolean",
+					description: "Indicates if all sessions were revoked successfully"
+				} },
+				required: ["status"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	try {
+		await ctx.context.internalAdapter.deleteSessions(ctx.context.session.user.id);
+	} catch (error) {
+		ctx.context.logger.error(error && typeof error === "object" && "name" in error ? error.name : "", error);
+		throw new APIError("INTERNAL_SERVER_ERROR");
+	}
+	return ctx.json({ status: true });
+});
+const revokeOtherSessions = createAuthEndpoint("/revoke-other-sessions", {
+	method: "POST",
+	requireHeaders: true,
+	use: [sensitiveSessionMiddleware],
+	metadata: { openapi: {
+		description: "Revoke all other sessions for the user except the current one",
+		responses: { "200": {
+			description: "Success",
+			content: { "application/json": { schema: {
+				type: "object",
+				properties: { status: {
+					type: "boolean",
+					description: "Indicates if all other sessions were revoked successfully"
+				} },
+				required: ["status"]
+			} } }
+		} }
+	} }
+}, async (ctx) => {
+	const session = ctx.context.session;
+	if (!session.user) throw new APIError("UNAUTHORIZED");
+	const otherSessions = (await ctx.context.internalAdapter.listSessions(session.user.id)).filter((session$1) => {
+		return session$1.expiresAt > /* @__PURE__ */ new Date();
+	}).filter((session$1) => session$1.token !== ctx.context.session.session.token);
+	await Promise.all(otherSessions.map((session$1) => ctx.context.internalAdapter.deleteSession(session$1.token)));
+	return ctx.json({ status: true });
+});
+
+//#endregion
+export { requestOnlySessionMiddleware as a, revokeSessions as c, listSessions as i, sensitiveSessionMiddleware as l, getSession as n, revokeOtherSessions as o, getSessionFromCtx as r, revokeSession as s, freshSessionMiddleware as t, sessionMiddleware as u };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/sign-wCNCtKGh.mjs.bak b/node_modules/better-auth/dist/sign-wCNCtKGh.mjs.bak
new file mode 100644
index 0000000..caa0aa0
--- /dev/null
+++ b/node_modules/better-auth/dist/sign-wCNCtKGh.mjs.bak
@@ -0,0 +1,211 @@
+import { n as symmetricEncrypt, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { BetterAuthError } from "@better-auth/core/error";
+import { SignJWT, exportJWK, generateKeyPair, importJWK } from "jose";
+import { base64 } from "@better-auth/utils/base64";
+import { getWebcryptoSubtle } from "@better-auth/utils";
+
+//#region src/plugins/jwt/adapter.ts
+const getJwksAdapter = (adapter, options) => {
+	return {
+		getAllKeys: async (ctx) => {
+			if (options?.adapter?.getJwks) return await options.adapter.getJwks(ctx);
+			return await adapter.findMany({ model: "jwks" });
+		},
+		getLatestKey: async (ctx) => {
+			if (options?.adapter?.getLatestKey) return await options.adapter.getLatestKey(ctx);
+			return (await adapter.findMany({
+				model: "jwks",
+				sortBy: {
+					field: "createdAt",
+					direction: "desc"
+				},
+				limit: 1
+			}))[0];
+		},
+		createJwk: async (ctx, webKey) => {
+			if (options?.adapter?.createJwk) return await options.adapter.createJwk(webKey, ctx);
+			return await adapter.create({
+				model: "jwks",
+				data: {
+					...webKey,
+					createdAt: /* @__PURE__ */ new Date()
+				}
+			});
+		}
+	};
+};
+
+//#endregion
+//#region src/utils/time.ts
+const minute = 60;
+const hour = minute * 60;
+const day = hour * 24;
+const week = day * 7;
+const year = day * 365.25;
+const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
+/**
+* https://github.com/panva/jose/blob/723ee6152d7ee2fc81852d2d26777e86df6fce01/src/lib/secs.ts
+*/
+function joseSecs(str) {
+	const matched = REGEX.exec(str);
+	if (!matched || matched[4] && matched[1]) throw new TypeError("Invalid time period format");
+	const value = parseFloat(matched[2]);
+	const unit = matched[3].toLowerCase();
+	let numericDate;
+	switch (unit) {
+		case "sec":
+		case "secs":
+		case "second":
+		case "seconds":
+		case "s":
+			numericDate = Math.round(value);
+			break;
+		case "minute":
+		case "minutes":
+		case "min":
+		case "mins":
+		case "m":
+			numericDate = Math.round(value * minute);
+			break;
+		case "hour":
+		case "hours":
+		case "hr":
+		case "hrs":
+		case "h":
+			numericDate = Math.round(value * hour);
+			break;
+		case "day":
+		case "days":
+		case "d":
+			numericDate = Math.round(value * day);
+			break;
+		case "week":
+		case "weeks":
+		case "w":
+			numericDate = Math.round(value * week);
+			break;
+		default:
+			numericDate = Math.round(value * year);
+			break;
+	}
+	if (matched[1] === "-" || matched[4] === "ago") return -numericDate;
+	return numericDate;
+}
+
+//#endregion
+//#region src/plugins/jwt/utils.ts
+/**
+* Converts an expirationTime to ISO seconds expiration time (the format of JWT exp)
+*
+* See https://github.com/panva/jose/blob/main/src/lib/jwt_claims_set.ts#L245
+*
+* @param expirationTime - see options.jwt.expirationTime
+* @param iat - the iat time to consolidate on
+* @returns
+*/
+function toExpJWT(expirationTime, iat) {
+	if (typeof expirationTime === "number") return expirationTime;
+	else if (expirationTime instanceof Date) return Math.floor(expirationTime.getTime() / 1e3);
+	else return iat + joseSecs(expirationTime);
+}
+async function generateExportedKeyPair(options) {
+	const { alg,...cfg } = options?.jwks?.keyPairConfig ?? {
+		alg: "EdDSA",
+		crv: "Ed25519"
+	};
+	const { publicKey, privateKey } = await generateKeyPair(alg, {
+		...cfg,
+		extractable: true
+	});
+	return {
+		publicWebKey: await exportJWK(publicKey),
+		privateWebKey: await exportJWK(privateKey),
+		alg,
+		cfg
+	};
+}
+/**
+* Creates a Jwk on the database
+*
+* @param ctx
+* @param options
+* @returns
+*/
+async function createJwk(ctx, options) {
+	const { publicWebKey, privateWebKey, alg, cfg } = await generateExportedKeyPair(options);
+	const stringifiedPrivateWebKey = JSON.stringify(privateWebKey);
+	const privateKeyEncryptionEnabled = !options?.jwks?.disablePrivateKeyEncryption;
+	let jwk = {
+		alg,
+		...cfg && "crv" in cfg ? { crv: cfg.crv } : {},
+		publicKey: JSON.stringify(publicWebKey),
+		privateKey: privateKeyEncryptionEnabled ? JSON.stringify(await symmetricEncrypt({
+			key: ctx.context.secret,
+			data: stringifiedPrivateWebKey
+		})) : stringifiedPrivateWebKey,
+		createdAt: /* @__PURE__ */ new Date()
+	};
+	return await getJwksAdapter(ctx.context.adapter, options).createJwk(ctx, jwk);
+}
+
+//#endregion
+//#region src/plugins/jwt/sign.ts
+async function signJWT(ctx, config) {
+	const { options, payload } = config;
+	const nowSeconds = Math.floor(Date.now() / 1e3);
+	const iat = payload.iat;
+	let exp = payload.exp;
+	const defaultExp = toExpJWT(options?.jwt?.expirationTime ?? "15m", iat ?? nowSeconds);
+	exp = exp ?? defaultExp;
+	const nbf = payload.nbf;
+	const iss = payload.iss;
+	const defaultIss = options?.jwt?.issuer ?? ctx.context.options.baseURL;
+	const aud = payload.aud;
+	const defaultAud = options?.jwt?.audience ?? ctx.context.options.baseURL;
+	if (options?.jwt?.sign) {
+		const jwtPayload = {
+			...payload,
+			iat,
+			exp,
+			nbf,
+			iss: iss ?? defaultIss,
+			aud: aud ?? defaultAud
+		};
+		return options.jwt.sign(jwtPayload);
+	}
+	let key = await getJwksAdapter(ctx.context.adapter, options).getLatestKey(ctx);
+	if (!key) key = await createJwk(ctx, options);
+	const privateKeyEncryptionEnabled = !options?.jwks?.disablePrivateKeyEncryption;
+	if (key === void 0) key = await createJwk(ctx, options);
+	let privateWebKey = privateKeyEncryptionEnabled ? await symmetricDecrypt({
+		key: ctx.context.secret,
+		data: JSON.parse(key.privateKey)
+	}).catch(() => {
+		throw new BetterAuthError("Failed to decrypt private key. Make sure the secret currently in use is the same as the one used to encrypt the private key. If you are using a different secret, either clean up your JWKS or disable private key encryption.");
+	}) : key.privateKey;
+	const alg = key.alg ?? options?.jwks?.keyPairConfig?.alg ?? "EdDSA";
+	const privateKey = await importJWK(JSON.parse(privateWebKey), alg);
+	const jwt = new SignJWT(payload).setProtectedHeader({
+		alg,
+		kid: key.id
+	}).setExpirationTime(exp).setIssuer(iss ?? defaultIss).setAudience(aud ?? defaultAud);
+	if (iat) jwt.setIssuedAt(iat);
+	if (payload.sub) jwt.setSubject(payload.sub);
+	if (payload.nbf) jwt.setNotBefore(payload.nbf);
+	if (payload.jti) jwt.setJti(payload.jti);
+	return await jwt.sign(privateKey);
+}
+async function getJwtToken(ctx, options) {
+	const payload = !options?.jwt?.definePayload ? ctx.context.session.user : await options?.jwt.definePayload(ctx.context.session);
+	return await signJWT(ctx, {
+		options,
+		payload: {
+			iat: Math.floor(Date.now() / 1e3),
+			...payload,
+			sub: await options?.jwt?.getSubject?.(ctx.context.session) ?? ctx.context.session.user.id
+		}
+	});
+}
+
+//#endregion
+export { getJwksAdapter as a, generateExportedKeyPair as i, signJWT as n, createJwk as r, getJwtToken as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/siwe-__fBpXPo.mjs b/node_modules/better-auth/dist/siwe-__fBpXPo.mjs
index d171ec5..d7fd530 100644
--- a/node_modules/better-auth/dist/siwe-__fBpXPo.mjs
+++ b/node_modules/better-auth/dist/siwe-__fBpXPo.mjs
@@ -82,7 +82,7 @@ const siwe = (options) => ({
 				signature: z.string().min(1),
 				walletAddress: z.string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),
 				chainId: z.number().int().positive().max(2147483647).optional().default(1),
-				email: z.email().optional()
+				email: z.string().email().optional()
 			}).refine((data) => options.anonymous !== false || !!data.email, {
 				message: "Email is required when the anonymous plugin option is disabled.",
 				path: ["email"]
diff --git a/node_modules/better-auth/dist/siwe-__fBpXPo.mjs.bak b/node_modules/better-auth/dist/siwe-__fBpXPo.mjs.bak
new file mode 100644
index 0000000..d7fd530
--- /dev/null
+++ b/node_modules/better-auth/dist/siwe-__fBpXPo.mjs.bak
@@ -0,0 +1,246 @@
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { r as getOrigin } from "./url-SXU3XD3W.mjs";
+import { t as APIError } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import * as z from "zod";
+import { utf8ToBytes } from "@noble/hashes/utils.js";
+import { createAuthEndpoint } from "@better-auth/core/api";
+import { keccak_256 } from "@noble/hashes/sha3.js";
+
+//#region src/utils/hashing.ts
+/**
+* TS implementation of ERC-55 ("Mixed-case checksum address encoding") using @noble/hashes
+* @param address - The address to convert to a checksum address
+* @returns The checksummed address
+*/
+function toChecksumAddress(address) {
+	address = address.toLowerCase().replace("0x", "");
+	const hash = [...keccak_256(utf8ToBytes(address))].map((v) => v.toString(16).padStart(2, "0")).join("");
+	let ret = "0x";
+	for (let i = 0; i < 40; i++) if (parseInt(hash[i], 16) >= 8) ret += address[i].toUpperCase();
+	else ret += address[i];
+	return ret;
+}
+
+//#endregion
+//#region src/plugins/siwe/schema.ts
+const schema = { walletAddress: { fields: {
+	userId: {
+		type: "string",
+		references: {
+			model: "user",
+			field: "id"
+		},
+		required: true,
+		index: true
+	},
+	address: {
+		type: "string",
+		required: true
+	},
+	chainId: {
+		type: "number",
+		required: true
+	},
+	isPrimary: {
+		type: "boolean",
+		defaultValue: false
+	},
+	createdAt: {
+		type: "date",
+		required: true
+	}
+} } };
+
+//#endregion
+//#region src/plugins/siwe/index.ts
+const siwe = (options) => ({
+	id: "siwe",
+	schema: mergeSchema(schema, options?.schema),
+	endpoints: {
+		getSiweNonce: createAuthEndpoint("/siwe/nonce", {
+			method: "POST",
+			body: z.object({
+				walletAddress: z.string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),
+				chainId: z.number().int().positive().max(2147483647).optional().default(1)
+			})
+		}, async (ctx) => {
+			const { walletAddress: rawWalletAddress, chainId } = ctx.body;
+			const walletAddress = toChecksumAddress(rawWalletAddress);
+			const nonce = await options.getNonce();
+			await ctx.context.internalAdapter.createVerificationValue({
+				identifier: `siwe:${walletAddress}:${chainId}`,
+				value: nonce,
+				expiresAt: new Date(Date.now() + 900 * 1e3)
+			});
+			return ctx.json({ nonce });
+		}),
+		verifySiweMessage: createAuthEndpoint("/siwe/verify", {
+			method: "POST",
+			body: z.object({
+				message: z.string().min(1),
+				signature: z.string().min(1),
+				walletAddress: z.string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),
+				chainId: z.number().int().positive().max(2147483647).optional().default(1),
+				email: z.string().email().optional()
+			}).refine((data) => options.anonymous !== false || !!data.email, {
+				message: "Email is required when the anonymous plugin option is disabled.",
+				path: ["email"]
+			}),
+			requireRequest: true
+		}, async (ctx) => {
+			const { message, signature, walletAddress: rawWalletAddress, chainId, email } = ctx.body;
+			const walletAddress = toChecksumAddress(rawWalletAddress);
+			const isAnon = options.anonymous ?? true;
+			if (!isAnon && !email) throw new APIError("BAD_REQUEST", {
+				message: "Email is required when anonymous is disabled.",
+				status: 400
+			});
+			try {
+				const verification = await ctx.context.internalAdapter.findVerificationValue(`siwe:${walletAddress}:${chainId}`);
+				if (!verification || /* @__PURE__ */ new Date() > verification.expiresAt) throw new APIError("UNAUTHORIZED", {
+					message: "Unauthorized: Invalid or expired nonce",
+					status: 401,
+					code: "UNAUTHORIZED_INVALID_OR_EXPIRED_NONCE"
+				});
+				const { value: nonce } = verification;
+				if (!await options.verifyMessage({
+					message,
+					signature,
+					address: walletAddress,
+					chainId,
+					cacao: {
+						h: { t: "caip122" },
+						p: {
+							domain: options.domain,
+							aud: options.domain,
+							nonce,
+							iss: options.domain,
+							version: "1"
+						},
+						s: {
+							t: "eip191",
+							s: signature
+						}
+					}
+				})) throw new APIError("UNAUTHORIZED", {
+					message: "Unauthorized: Invalid SIWE signature",
+					status: 401
+				});
+				await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
+				let user = null;
+				const existingWalletAddress = await ctx.context.adapter.findOne({
+					model: "walletAddress",
+					where: [{
+						field: "address",
+						operator: "eq",
+						value: walletAddress
+					}, {
+						field: "chainId",
+						operator: "eq",
+						value: chainId
+					}]
+				});
+				if (existingWalletAddress) user = await ctx.context.adapter.findOne({
+					model: "user",
+					where: [{
+						field: "id",
+						operator: "eq",
+						value: existingWalletAddress.userId
+					}]
+				});
+				else {
+					const anyWalletAddress = await ctx.context.adapter.findOne({
+						model: "walletAddress",
+						where: [{
+							field: "address",
+							operator: "eq",
+							value: walletAddress
+						}]
+					});
+					if (anyWalletAddress) user = await ctx.context.adapter.findOne({
+						model: "user",
+						where: [{
+							field: "id",
+							operator: "eq",
+							value: anyWalletAddress.userId
+						}]
+					});
+				}
+				if (!user) {
+					const domain = options.emailDomainName ?? getOrigin(ctx.context.baseURL);
+					const userEmail = !isAnon && email ? email : `${walletAddress}@${domain}`;
+					const { name, avatar } = await options.ensLookup?.({ walletAddress }) ?? {};
+					user = await ctx.context.internalAdapter.createUser({
+						name: name ?? walletAddress,
+						email: userEmail,
+						image: avatar ?? ""
+					});
+					await ctx.context.adapter.create({
+						model: "walletAddress",
+						data: {
+							userId: user.id,
+							address: walletAddress,
+							chainId,
+							isPrimary: true,
+							createdAt: /* @__PURE__ */ new Date()
+						}
+					});
+					await ctx.context.internalAdapter.createAccount({
+						userId: user.id,
+						providerId: "siwe",
+						accountId: `${walletAddress}:${chainId}`,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					});
+				} else if (!existingWalletAddress) {
+					await ctx.context.adapter.create({
+						model: "walletAddress",
+						data: {
+							userId: user.id,
+							address: walletAddress,
+							chainId,
+							isPrimary: false,
+							createdAt: /* @__PURE__ */ new Date()
+						}
+					});
+					await ctx.context.internalAdapter.createAccount({
+						userId: user.id,
+						providerId: "siwe",
+						accountId: `${walletAddress}:${chainId}`,
+						createdAt: /* @__PURE__ */ new Date(),
+						updatedAt: /* @__PURE__ */ new Date()
+					});
+				}
+				const session = await ctx.context.internalAdapter.createSession(user.id);
+				if (!session) throw new APIError("INTERNAL_SERVER_ERROR", {
+					message: "Internal Server Error",
+					status: 500
+				});
+				await setSessionCookie(ctx, {
+					session,
+					user
+				});
+				return ctx.json({
+					token: session.token,
+					success: true,
+					user: {
+						id: user.id,
+						walletAddress,
+						chainId
+					}
+				});
+			} catch (error) {
+				if (error instanceof APIError) throw error;
+				throw new APIError("UNAUTHORIZED", {
+					message: "Something went wrong. Please try again later.",
+					error: error instanceof Error ? error.message : "Unknown error",
+					status: 401
+				});
+			}
+		})
+	}
+});
+
+//#endregion
+export { siwe as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/social-providers/index.mjs.bak b/node_modules/better-auth/dist/social-providers/index.mjs.bak
new file mode 100644
index 0000000..fa00b59
--- /dev/null
+++ b/node_modules/better-auth/dist/social-providers/index.mjs.bak
@@ -0,0 +1,3 @@
+export * from "@better-auth/core/social-providers"
+
+export {  };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/test-utils/index.mjs.bak b/node_modules/better-auth/dist/test-utils/index.mjs.bak
new file mode 100644
index 0000000..4de3d01
--- /dev/null
+++ b/node_modules/better-auth/dist/test-utils/index.mjs.bak
@@ -0,0 +1,274 @@
+import { a as __toDynamicImportESM } from "../chunk-BK_LfMhE.mjs";
+import "../dialect-BhkkSrrx.mjs";
+import "../get-model-name-nJd9iPTo.mjs";
+import { t as getMigrations, u as getAdapter } from "../get-migration-C1tgKlQ6.mjs";
+import "../types-BReKsBV6.mjs";
+import "../utils-F62c-ieM.mjs";
+import "../crypto-DZW3hrq1.mjs";
+import "../jwt-CmxZAGe2.mjs";
+import "../misc-CADLxPeM.mjs";
+import "../schema-BevzneML.mjs";
+import "../get-request-ip-kbu825ez.mjs";
+import "../json-BS-nL3f-.mjs";
+import { t as getBaseURL } from "../url-SXU3XD3W.mjs";
+import "../api-C0IsrmGz.mjs";
+import { l as parseSetCookieHeader, u as setCookieToHeader } from "../cookies-Cl2L38B1.mjs";
+import "../session-Efap-vxj.mjs";
+import "../base-DtHhS6VT.mjs";
+import "../password-DWi8yN3A.mjs";
+import { t as betterAuth } from "../auth-DG0t9Q_P.mjs";
+import "../proxy-CH2wKnFj.mjs";
+import "../parser-DcrIEuXE.mjs";
+import { r as createAuthClient } from "../client-DQywG8SE.mjs";
+import "../access-6c2-Np4U.mjs";
+import "../plugin-helper-RJJBTOba.mjs";
+import "../access-BYnrn7CR.mjs";
+import "../admin-CJ3jncSX.mjs";
+import "../has-permission-DhpFBOUO.mjs";
+import "../anonymous-DCfvRfoL.mjs";
+import "../plugins-D9JjA_z3.mjs";
+import { t as bearer } from "../bearer-DRqPkgUx.mjs";
+import "../captcha-CU0p6qrj.mjs";
+import "../custom-session-BDpuPRbk.mjs";
+import "../device-authorization-CIxU2CCU.mjs";
+import "../client-WiN43tAS.mjs";
+import "../email-otp-C08WNTNC.mjs";
+import "../generic-oauth-BI8Iz1pK.mjs";
+import "../haveibeenpwned-lb4pgDiK.mjs";
+import "../sign-wCNCtKGh.mjs";
+import "../jwt-CLg_nnrd.mjs";
+import "../magic-link-DCBndC0L.mjs";
+import "../oidc-provider-ComEKSEi.mjs";
+import "../multi-session-CxgwAYRM.mjs";
+import "../oauth-proxy-Dsp9ntvU.mjs";
+import "../one-tap-thuUsT_P.mjs";
+import "../open-api-Cb5nhhNu.mjs";
+import "../organization-D-mvr_hy.mjs";
+import "../access-HdxSBEa0.mjs";
+import "../permission-CDDWgA_O.mjs";
+import "../phone-number-WeAgIbHL.mjs";
+import "../siwe-__fBpXPo.mjs";
+import "../two-factor-2QtPvfKI.mjs";
+import "../client-CuoyvYUC.mjs";
+import "../username-DI2v-O3q.mjs";
+import { sql } from "kysely";
+import { afterAll } from "vitest";
+import { AsyncLocalStorage } from "node:async_hooks";
+
+//#region src/test-utils/headers.ts
+/**
+* converts set cookie containing headers to
+* cookie containing headers
+*/
+function convertSetCookieToCookie(headers) {
+	const setCookieHeaders = [];
+	headers.forEach((value, name) => {
+		if (name.toLowerCase() === "set-cookie") setCookieHeaders.push(value);
+	});
+	if (setCookieHeaders.length === 0) return headers;
+	const existingCookies = headers.get("cookie") || "";
+	const cookies = existingCookies ? existingCookies.split("; ") : [];
+	setCookieHeaders.forEach((setCookie) => {
+		const cookiePair = setCookie.split(";")[0];
+		cookies.push(cookiePair.trim());
+	});
+	headers.set("cookie", cookies.join("; "));
+	return headers;
+}
+
+//#endregion
+//#region src/test-utils/test-instance.ts
+const cleanupSet = /* @__PURE__ */ new Set();
+const currentUserContextStorage = new AsyncLocalStorage();
+afterAll(async () => {
+	for (const cleanup of cleanupSet) {
+		await cleanup();
+		cleanupSet.delete(cleanup);
+	}
+});
+async function getTestInstance(options, config) {
+	const testWith = config?.testWith || "sqlite";
+	async function getPostgres() {
+		const { Kysely: Kysely$1, PostgresDialect: PostgresDialect$1 } = await import("kysely");
+		const { Pool } = await import("../esm-DVsZ1UYe.mjs");
+		return new Kysely$1({ dialect: new PostgresDialect$1({ pool: new Pool({ connectionString: "postgres://user:password@localhost:5432/better_auth" }) }) });
+	}
+	async function getSqlite() {
+		const { default: Database } = await import("better-sqlite3");
+		return new Database(":memory:");
+	}
+	async function getMysql() {
+		const { Kysely: Kysely$1, MysqlDialect: MysqlDialect$1 } = await import("kysely");
+		const { createPool } = await import("../promise-BvQ0gTog.mjs").then(__toDynamicImportESM(1));
+		return new Kysely$1({ dialect: new MysqlDialect$1(createPool("mysql://user:password@localhost:3306/better_auth")) });
+	}
+	async function mongodbClient() {
+		const { MongoClient } = await import("mongodb");
+		const dbClient = async (connectionString, dbName) => {
+			const client$1 = new MongoClient(connectionString);
+			await client$1.connect();
+			return client$1.db(dbName);
+		};
+		return await dbClient("mongodb://127.0.0.1:27017", "better-auth");
+	}
+	const opts = {
+		socialProviders: {
+			github: {
+				clientId: "test",
+				clientSecret: "test"
+			},
+			google: {
+				clientId: "test",
+				clientSecret: "test"
+			}
+		},
+		secret: "better-auth.secret",
+		database: testWith === "postgres" ? {
+			db: await getPostgres(),
+			type: "postgres"
+		} : testWith === "mongodb" ? await Promise.all([mongodbClient(), await import("../adapters/mongodb-adapter/index.mjs")]).then(([db, { mongodbAdapter }]) => mongodbAdapter(db)) : testWith === "mysql" ? {
+			db: await getMysql(),
+			type: "mysql"
+		} : await getSqlite(),
+		emailAndPassword: { enabled: true },
+		rateLimit: { enabled: false },
+		advanced: { cookies: {} },
+		logger: { level: "debug" }
+	};
+	const auth = betterAuth({
+		baseURL: "http://localhost:" + (config?.port || 3e3),
+		...opts,
+		...options,
+		plugins: [bearer(), ...options?.plugins || []]
+	});
+	const testUser = {
+		email: "test@test.com",
+		password: "test123456",
+		name: "test user",
+		...config?.testUser
+	};
+	async function createTestUser() {
+		if (config?.disableTestUser) return;
+		await auth.api.signUpEmail({ body: testUser });
+	}
+	if (testWith !== "mongodb") {
+		const { runMigrations } = await getMigrations({
+			...auth.options,
+			database: opts.database
+		});
+		await runMigrations();
+	}
+	await createTestUser();
+	const cleanup = async () => {
+		if (testWith === "mongodb") {
+			await (await mongodbClient()).dropDatabase();
+			return;
+		}
+		if (testWith === "postgres") {
+			const postgres = await getPostgres();
+			await sql`DROP SCHEMA public CASCADE; CREATE SCHEMA public;`.execute(postgres);
+			await postgres.destroy();
+			return;
+		}
+		if (testWith === "mysql") {
+			const mysql = await getMysql();
+			await sql`SET FOREIGN_KEY_CHECKS = 0;`.execute(mysql);
+			const tables = await mysql.introspection.getTables();
+			for (const table of tables) await mysql.deleteFrom(table.name).execute();
+			await sql`SET FOREIGN_KEY_CHECKS = 1;`.execute(mysql);
+			return;
+		}
+		if (testWith === "sqlite") {
+			(await getSqlite()).close();
+			return;
+		}
+	};
+	cleanupSet.add(cleanup);
+	const customFetchImpl = async (url, init) => {
+		const headers = init?.headers || {};
+		const storageHeaders = currentUserContextStorage.getStore()?.headers;
+		return auth.handler(new Request(url, init ? {
+			...init,
+			headers: new Headers({
+				...storageHeaders ? Object.fromEntries(storageHeaders.entries()) : {},
+				...headers instanceof Headers ? Object.fromEntries(headers.entries()) : typeof headers === "object" ? headers : {}
+			})
+		} : { headers }));
+	};
+	const client = createAuthClient({
+		...config?.clientOptions,
+		baseURL: getBaseURL(options?.baseURL || "http://localhost:" + (config?.port || 3e3), options?.basePath || "/api/auth"),
+		fetchOptions: { customFetchImpl }
+	});
+	async function signInWithTestUser() {
+		if (config?.disableTestUser) throw new Error("Test user is disabled");
+		let headers = new Headers();
+		const setCookie = (name, value) => {
+			const current = headers.get("cookie");
+			headers.set("cookie", `${current || ""}; ${name}=${value}`);
+		};
+		const { data, error } = await client.signIn.email({
+			email: testUser.email,
+			password: testUser.password,
+			fetchOptions: { onSuccess(context) {
+				const signedCookie = parseSetCookieHeader(context.response.headers.get("set-cookie") || "").get("better-auth.session_token")?.value;
+				headers.set("cookie", `better-auth.session_token=${signedCookie}`);
+			} }
+		});
+		return {
+			session: data.session,
+			user: data.user,
+			headers,
+			setCookie,
+			runWithUser: async (fn) => {
+				return currentUserContextStorage.run({ headers }, async () => {
+					await fn(headers);
+				});
+			}
+		};
+	}
+	async function signInWithUser(email, password) {
+		const headers = new Headers();
+		const { data } = await client.signIn.email({
+			email,
+			password,
+			fetchOptions: { onSuccess(context) {
+				const signedCookie = parseSetCookieHeader(context.response.headers.get("set-cookie") || "").get("better-auth.session_token")?.value;
+				headers.set("cookie", `better-auth.session_token=${signedCookie}`);
+			} }
+		});
+		return {
+			res: data,
+			headers
+		};
+	}
+	function sessionSetter(headers) {
+		return (context) => {
+			const header = context.response.headers.get("set-cookie");
+			if (header) {
+				const signedCookie = parseSetCookieHeader(header || "").get("better-auth.session_token")?.value;
+				headers.set("cookie", `better-auth.session_token=${signedCookie}`);
+			}
+		};
+	}
+	return {
+		auth,
+		client,
+		testUser,
+		signInWithTestUser,
+		signInWithUser,
+		cookieSetter: setCookieToHeader,
+		customFetchImpl,
+		sessionSetter,
+		db: await getAdapter(auth.options),
+		runWithUser: async (email, password, fn) => {
+			const { headers } = await signInWithUser(email, password);
+			return currentUserContextStorage.run({ headers }, async () => {
+				await fn(headers);
+			});
+		}
+	};
+}
+
+//#endregion
+export { convertSetCookieToCookie, getTestInstance };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/two-factor-2QtPvfKI.mjs b/node_modules/better-auth/dist/two-factor-2QtPvfKI.mjs
index cbbe7da..449e68b 100644
--- a/node_modules/better-auth/dist/two-factor-2QtPvfKI.mjs
+++ b/node_modules/better-auth/dist/two-factor-2QtPvfKI.mjs
@@ -160,9 +160,9 @@ const backupCode2fa = (opts) => {
 			verifyBackupCode: createAuthEndpoint("/two-factor/verify-backup-code", {
 				method: "POST",
 				body: z.object({
-					code: z.string().meta({ description: `A backup code to verify. Eg: "123456"` }),
-					disableSession: z.boolean().meta({ description: "If true, the session cookie will not be set." }).optional(),
-					trustDevice: z.boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
+					code: z.string(),
+					disableSession: z.boolean().optional(),
+					trustDevice: z.boolean().optional()
 				}),
 				metadata: { openapi: {
 					description: "Verify a backup code for two-factor authentication",
@@ -302,7 +302,7 @@ const backupCode2fa = (opts) => {
 			}),
 			generateBackupCodes: createAuthEndpoint("/two-factor/generate-backup-codes", {
 				method: "POST",
-				body: z.object({ password: z.string().meta({ description: "The users password." }) }),
+				body: z.object({ password: z.string() }),
 				use: [sessionMiddleware],
 				metadata: { openapi: {
 					description: "Generate new backup codes for two-factor authentication",
@@ -346,7 +346,7 @@ const backupCode2fa = (opts) => {
 			}),
 			viewBackupCodes: createAuthEndpoint("/two-factor/view-backup-codes", {
 				method: "POST",
-				body: z.object({ userId: z.coerce.string().meta({ description: `The user ID to view all backup codes. Eg: "user-id"` }) }),
+				body: z.object({ userId: z.coerce.string() }),
 				metadata: { SERVER_ONLY: true }
 			}, async (ctx) => {
 				const twoFactor$1 = await ctx.context.adapter.findOne({
@@ -412,7 +412,7 @@ const otp2fa = (options) => {
 		endpoints: {
 			sendTwoFactorOTP: createAuthEndpoint("/two-factor/send-otp", {
 				method: "POST",
-				body: z.object({ trustDevice: z.boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }) }).optional(),
+				body: z.object({ trustDevice: z.boolean().optional() }).optional(),
 				metadata: { openapi: {
 					summary: "Send two factor OTP",
 					description: "Send two factor OTP to the user",
@@ -447,8 +447,8 @@ const otp2fa = (options) => {
 			verifyTwoFactorOTP: createAuthEndpoint("/two-factor/verify-otp", {
 				method: "POST",
 				body: z.object({
-					code: z.string().meta({ description: "The otp code to verify. Eg: \"012345\"" }),
-					trustDevice: z.boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" })
+					code: z.string(),
+					trustDevice: z.boolean().optional()
 				}),
 				metadata: { openapi: {
 					summary: "Verify two factor OTP",
@@ -609,7 +609,7 @@ const totp2fa = (options) => {
 		endpoints: {
 			generateTOTP: createAuthEndpoint("/totp/generate", {
 				method: "POST",
-				body: z.object({ secret: z.string().meta({ description: "The secret to generate the TOTP code" }) }),
+				body: z.object({ secret: z.string() }),
 				metadata: {
 					openapi: {
 						summary: "Generate TOTP code",
@@ -637,7 +637,7 @@ const totp2fa = (options) => {
 			getTOTPURI: createAuthEndpoint("/two-factor/get-totp-uri", {
 				method: "POST",
 				use: [sessionMiddleware],
-				body: z.object({ password: z.string().meta({ description: "User password" }) }),
+				body: z.object({ password: z.string() }),
 				metadata: { openapi: {
 					summary: "Get TOTP URI",
 					description: "Use this endpoint to get the TOTP URI",
@@ -676,8 +676,8 @@ const totp2fa = (options) => {
 			verifyTOTP: createAuthEndpoint("/two-factor/verify-totp", {
 				method: "POST",
 				body: z.object({
-					code: z.string().meta({ description: "The otp code to verify. Eg: \"012345\"" }),
-					trustDevice: z.boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
+					code: z.string(),
+					trustDevice: z.boolean().optional()
 				}),
 				metadata: { openapi: {
 					summary: "Verify two factor TOTP",
@@ -750,8 +750,8 @@ const twoFactor = (options) => {
 			enableTwoFactor: createAuthEndpoint("/two-factor/enable", {
 				method: "POST",
 				body: z.object({
-					password: z.string().meta({ description: "User password" }),
-					issuer: z.string().meta({ description: "Custom issuer for the TOTP URI" }).optional()
+					password: z.string(),
+					issuer: z.string().optional()
 				}),
 				use: [sessionMiddleware],
 				metadata: { openapi: {
@@ -825,7 +825,7 @@ const twoFactor = (options) => {
 			}),
 			disableTwoFactor: createAuthEndpoint("/two-factor/disable", {
 				method: "POST",
-				body: z.object({ password: z.string().meta({ description: "User password" }) }),
+				body: z.object({ password: z.string() }),
 				use: [sessionMiddleware],
 				metadata: { openapi: {
 					summary: "Disable two factor authentication",
diff --git a/node_modules/better-auth/dist/two-factor-2QtPvfKI.mjs.bak b/node_modules/better-auth/dist/two-factor-2QtPvfKI.mjs.bak
new file mode 100644
index 0000000..cbbe7da
--- /dev/null
+++ b/node_modules/better-auth/dist/two-factor-2QtPvfKI.mjs.bak
@@ -0,0 +1,917 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { t as safeJSONParse } from "./json-BS-nL3f-.mjs";
+import { c as setSessionCookie, n as deleteSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { r as getSessionFromCtx, u as sessionMiddleware } from "./session-Efap-vxj.mjs";
+import { n as validatePassword } from "./password-DWi8yN3A.mjs";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createHash } from "@better-auth/utils/hash";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+import { base64Url } from "@better-auth/utils/base64";
+import { createHMAC } from "@better-auth/utils/hmac";
+import { createOTP } from "@better-auth/utils/otp";
+
+//#region src/plugins/two-factor/error-code.ts
+const TWO_FACTOR_ERROR_CODES = defineErrorCodes({
+	OTP_NOT_ENABLED: "OTP not enabled",
+	OTP_HAS_EXPIRED: "OTP has expired",
+	TOTP_NOT_ENABLED: "TOTP not enabled",
+	TWO_FACTOR_NOT_ENABLED: "Two factor isn't enabled",
+	BACKUP_CODES_NOT_ENABLED: "Backup codes aren't enabled",
+	INVALID_BACKUP_CODE: "Invalid backup code",
+	INVALID_CODE: "Invalid code",
+	TOO_MANY_ATTEMPTS_REQUEST_NEW_CODE: "Too many attempts. Please request a new code.",
+	INVALID_TWO_FACTOR_COOKIE: "Invalid two factor cookie"
+});
+
+//#endregion
+//#region src/plugins/two-factor/constant.ts
+const TWO_FACTOR_COOKIE_NAME = "two_factor";
+const TRUST_DEVICE_COOKIE_NAME = "trust_device";
+const TRUST_DEVICE_COOKIE_MAX_AGE = 720 * 60 * 60;
+
+//#endregion
+//#region src/plugins/two-factor/verify-two-factor.ts
+async function verifyTwoFactor(ctx) {
+	const invalid = (errorKey) => {
+		throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES[errorKey] });
+	};
+	const session = await getSessionFromCtx(ctx);
+	if (!session) {
+		const cookieName = ctx.context.createAuthCookie(TWO_FACTOR_COOKIE_NAME);
+		const twoFactorCookie = await ctx.getSignedCookie(cookieName.name, ctx.context.secret);
+		if (!twoFactorCookie) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });
+		const verificationToken = await ctx.context.internalAdapter.findVerificationValue(twoFactorCookie);
+		if (!verificationToken) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });
+		const user = await ctx.context.internalAdapter.findUserById(verificationToken.value);
+		if (!user) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });
+		const dontRememberMe = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
+		return {
+			valid: async (ctx$1) => {
+				const session$1 = await ctx$1.context.internalAdapter.createSession(verificationToken.value, !!dontRememberMe);
+				if (!session$1) throw new APIError("INTERNAL_SERVER_ERROR", { message: "failed to create session" });
+				await setSessionCookie(ctx$1, {
+					session: session$1,
+					user
+				});
+				if (ctx$1.body.trustDevice) {
+					const trustDeviceCookie = ctx$1.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });
+					/**
+					* create a token that will be used to
+					* verify the device
+					*/
+					const token = await createHMAC("SHA-256", "base64urlnopad").sign(ctx$1.context.secret, `${user.id}!${session$1.token}`);
+					await ctx$1.setSignedCookie(trustDeviceCookie.name, `${token}!${session$1.token}`, ctx$1.context.secret, trustDeviceCookie.attributes);
+					ctx$1.setCookie(ctx$1.context.authCookies.dontRememberToken.name, "", { maxAge: 0 });
+					ctx$1.setCookie(cookieName.name, "", { maxAge: 0 });
+				}
+				return ctx$1.json({
+					token: session$1.token,
+					user: {
+						id: user.id,
+						email: user.email,
+						emailVerified: user.emailVerified,
+						name: user.name,
+						image: user.image,
+						createdAt: user.createdAt,
+						updatedAt: user.updatedAt
+					}
+				});
+			},
+			invalid,
+			session: {
+				session: null,
+				user
+			},
+			key: twoFactorCookie
+		};
+	}
+	return {
+		valid: async (ctx$1) => {
+			return ctx$1.json({
+				token: session.session.token,
+				user: {
+					id: session.user.id,
+					email: session.user.email,
+					emailVerified: session.user.emailVerified,
+					name: session.user.name,
+					image: session.user.image,
+					createdAt: session.user.createdAt,
+					updatedAt: session.user.updatedAt
+				}
+			});
+		},
+		invalid,
+		session,
+		key: `${session.user.id}!${session.session.id}`
+	};
+}
+
+//#endregion
+//#region src/plugins/two-factor/backup-codes/index.ts
+function generateBackupCodesFn(options) {
+	return Array.from({ length: options?.amount ?? 10 }).fill(null).map(() => generateRandomString(options?.length ?? 10, "a-z", "0-9", "A-Z")).map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);
+}
+async function generateBackupCodes(secret, options) {
+	const backupCodes = options?.customBackupCodesGenerate ? options.customBackupCodesGenerate() : generateBackupCodesFn(options);
+	if (options?.storeBackupCodes === "encrypted") return {
+		backupCodes,
+		encryptedBackupCodes: await symmetricEncrypt({
+			data: JSON.stringify(backupCodes),
+			key: secret
+		})
+	};
+	if (typeof options?.storeBackupCodes === "object" && "encrypt" in options?.storeBackupCodes) return {
+		backupCodes,
+		encryptedBackupCodes: await options?.storeBackupCodes.encrypt(JSON.stringify(backupCodes))
+	};
+	return {
+		backupCodes,
+		encryptedBackupCodes: JSON.stringify(backupCodes)
+	};
+}
+async function verifyBackupCode(data, key, options) {
+	const codes = await getBackupCodes(data.backupCodes, key, options);
+	if (!codes) return {
+		status: false,
+		updated: null
+	};
+	return {
+		status: codes.includes(data.code),
+		updated: codes.filter((code) => code !== data.code)
+	};
+}
+async function getBackupCodes(backupCodes, key, options) {
+	if (options?.storeBackupCodes === "encrypted") return safeJSONParse(await symmetricDecrypt({
+		key,
+		data: backupCodes
+	}));
+	if (typeof options?.storeBackupCodes === "object" && "decrypt" in options?.storeBackupCodes) return safeJSONParse(await options?.storeBackupCodes.decrypt(backupCodes));
+	return safeJSONParse(backupCodes);
+}
+const backupCode2fa = (opts) => {
+	const twoFactorTable = "twoFactor";
+	return {
+		id: "backup_code",
+		endpoints: {
+			verifyBackupCode: createAuthEndpoint("/two-factor/verify-backup-code", {
+				method: "POST",
+				body: z.object({
+					code: z.string().meta({ description: `A backup code to verify. Eg: "123456"` }),
+					disableSession: z.boolean().meta({ description: "If true, the session cookie will not be set." }).optional(),
+					trustDevice: z.boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
+				}),
+				metadata: { openapi: {
+					description: "Verify a backup code for two-factor authentication",
+					responses: { "200": {
+						description: "Backup code verified successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								user: {
+									type: "object",
+									properties: {
+										id: {
+											type: "string",
+											description: "Unique identifier of the user"
+										},
+										email: {
+											type: "string",
+											format: "email",
+											nullable: true,
+											description: "User's email address"
+										},
+										emailVerified: {
+											type: "boolean",
+											nullable: true,
+											description: "Whether the email is verified"
+										},
+										name: {
+											type: "string",
+											nullable: true,
+											description: "User's name"
+										},
+										image: {
+											type: "string",
+											format: "uri",
+											nullable: true,
+											description: "User's profile image URL"
+										},
+										twoFactorEnabled: {
+											type: "boolean",
+											description: "Whether two-factor authentication is enabled for the user"
+										},
+										createdAt: {
+											type: "string",
+											format: "date-time",
+											description: "Timestamp when the user was created"
+										},
+										updatedAt: {
+											type: "string",
+											format: "date-time",
+											description: "Timestamp when the user was last updated"
+										}
+									},
+									required: [
+										"id",
+										"twoFactorEnabled",
+										"createdAt",
+										"updatedAt"
+									],
+									description: "The authenticated user object with two-factor details"
+								},
+								session: {
+									type: "object",
+									properties: {
+										token: {
+											type: "string",
+											description: "Session token"
+										},
+										userId: {
+											type: "string",
+											description: "ID of the user associated with the session"
+										},
+										createdAt: {
+											type: "string",
+											format: "date-time",
+											description: "Timestamp when the session was created"
+										},
+										expiresAt: {
+											type: "string",
+											format: "date-time",
+											description: "Timestamp when the session expires"
+										}
+									},
+									required: [
+										"token",
+										"userId",
+										"createdAt",
+										"expiresAt"
+									],
+									description: "The current session object, included unless disableSession is true"
+								}
+							},
+							required: ["user", "session"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { session, valid } = await verifyTwoFactor(ctx);
+				const user = session.user;
+				const twoFactor$1 = await ctx.context.adapter.findOne({
+					model: twoFactorTable,
+					where: [{
+						field: "userId",
+						value: user.id
+					}]
+				});
+				if (!twoFactor$1) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.BACKUP_CODES_NOT_ENABLED });
+				const validate = await verifyBackupCode({
+					backupCodes: twoFactor$1.backupCodes,
+					code: ctx.body.code
+				}, ctx.context.secret, opts);
+				if (!validate.status) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_BACKUP_CODE });
+				const updatedBackupCodes = await symmetricEncrypt({
+					key: ctx.context.secret,
+					data: JSON.stringify(validate.updated)
+				});
+				await ctx.context.adapter.updateMany({
+					model: twoFactorTable,
+					update: { backupCodes: updatedBackupCodes },
+					where: [{
+						field: "userId",
+						value: user.id
+					}]
+				});
+				if (!ctx.body.disableSession) return valid(ctx);
+				return ctx.json({
+					token: session.session?.token,
+					user: {
+						id: session.user?.id,
+						email: session.user.email,
+						emailVerified: session.user.emailVerified,
+						name: session.user.name,
+						image: session.user.image,
+						createdAt: session.user.createdAt,
+						updatedAt: session.user.updatedAt
+					}
+				});
+			}),
+			generateBackupCodes: createAuthEndpoint("/two-factor/generate-backup-codes", {
+				method: "POST",
+				body: z.object({ password: z.string().meta({ description: "The users password." }) }),
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					description: "Generate new backup codes for two-factor authentication",
+					responses: { "200": {
+						description: "Backup codes generated successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								status: {
+									type: "boolean",
+									description: "Indicates if the backup codes were generated successfully",
+									enum: [true]
+								},
+								backupCodes: {
+									type: "array",
+									items: { type: "string" },
+									description: "Array of generated backup codes in plain text"
+								}
+							},
+							required: ["status", "backupCodes"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const user = ctx.context.session.user;
+				if (!user.twoFactorEnabled) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TWO_FACTOR_NOT_ENABLED });
+				await ctx.context.password.checkPassword(user.id, ctx);
+				const backupCodes = await generateBackupCodes(ctx.context.secret, opts);
+				await ctx.context.adapter.updateMany({
+					model: twoFactorTable,
+					update: { backupCodes: backupCodes.encryptedBackupCodes },
+					where: [{
+						field: "userId",
+						value: ctx.context.session.user.id
+					}]
+				});
+				return ctx.json({
+					status: true,
+					backupCodes: backupCodes.backupCodes
+				});
+			}),
+			viewBackupCodes: createAuthEndpoint("/two-factor/view-backup-codes", {
+				method: "POST",
+				body: z.object({ userId: z.coerce.string().meta({ description: `The user ID to view all backup codes. Eg: "user-id"` }) }),
+				metadata: { SERVER_ONLY: true }
+			}, async (ctx) => {
+				const twoFactor$1 = await ctx.context.adapter.findOne({
+					model: twoFactorTable,
+					where: [{
+						field: "userId",
+						value: ctx.body.userId
+					}]
+				});
+				if (!twoFactor$1) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.BACKUP_CODES_NOT_ENABLED });
+				const decryptedBackupCodes = await getBackupCodes(twoFactor$1.backupCodes, ctx.context.secret, opts);
+				if (!decryptedBackupCodes) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.INVALID_BACKUP_CODE });
+				return ctx.json({
+					status: true,
+					backupCodes: decryptedBackupCodes
+				});
+			})
+		}
+	};
+};
+
+//#endregion
+//#region src/plugins/two-factor/utils.ts
+const defaultKeyHasher = async (token) => {
+	const hash = await createHash("SHA-256").digest(new TextEncoder().encode(token));
+	return base64Url.encode(new Uint8Array(hash), { padding: false });
+};
+
+//#endregion
+//#region src/plugins/two-factor/otp/index.ts
+/**
+* The otp adapter is created from the totp adapter.
+*/
+const otp2fa = (options) => {
+	const opts = {
+		storeOTP: "plain",
+		digits: 6,
+		...options,
+		period: (options?.period || 3) * 60 * 1e3
+	};
+	async function storeOTP(ctx, otp) {
+		if (opts.storeOTP === "hashed") return await defaultKeyHasher(otp);
+		if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return await opts.storeOTP.hash(otp);
+		if (typeof opts.storeOTP === "object" && "encrypt" in opts.storeOTP) return await opts.storeOTP.encrypt(otp);
+		if (opts.storeOTP === "encrypted") return await symmetricEncrypt({
+			key: ctx.context.secret,
+			data: otp
+		});
+		return otp;
+	}
+	async function decryptOTP(ctx, otp) {
+		if (opts.storeOTP === "hashed") return await defaultKeyHasher(otp);
+		if (opts.storeOTP === "encrypted") return await symmetricDecrypt({
+			key: ctx.context.secret,
+			data: otp
+		});
+		if (typeof opts.storeOTP === "object" && "encrypt" in opts.storeOTP) return await opts.storeOTP.decrypt(otp);
+		if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return await opts.storeOTP.hash(otp);
+		return otp;
+	}
+	return {
+		id: "otp",
+		endpoints: {
+			sendTwoFactorOTP: createAuthEndpoint("/two-factor/send-otp", {
+				method: "POST",
+				body: z.object({ trustDevice: z.boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }) }).optional(),
+				metadata: { openapi: {
+					summary: "Send two factor OTP",
+					description: "Send two factor OTP to the user",
+					responses: { 200: {
+						description: "Successful response",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (!options || !options.sendOTP) {
+					ctx.context.logger.error("send otp isn't configured. Please configure the send otp function on otp options.");
+					throw new APIError("BAD_REQUEST", { message: "otp isn't configured" });
+				}
+				const { session, key } = await verifyTwoFactor(ctx);
+				if (!session.user.twoFactorEnabled) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.OTP_NOT_ENABLED });
+				const code = generateRandomString(opts.digits, "0-9");
+				const hashedCode = await storeOTP(ctx, code);
+				await ctx.context.internalAdapter.createVerificationValue({
+					value: `${hashedCode}:0`,
+					identifier: `2fa-otp-${key}`,
+					expiresAt: new Date(Date.now() + opts.period)
+				});
+				await options.sendOTP({
+					user: session.user,
+					otp: code
+				}, ctx);
+				return ctx.json({ status: true });
+			}),
+			verifyTwoFactorOTP: createAuthEndpoint("/two-factor/verify-otp", {
+				method: "POST",
+				body: z.object({
+					code: z.string().meta({ description: "The otp code to verify. Eg: \"012345\"" }),
+					trustDevice: z.boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" })
+				}),
+				metadata: { openapi: {
+					summary: "Verify two factor OTP",
+					description: "Verify two factor OTP",
+					responses: { "200": {
+						description: "Two-factor OTP verified successfully",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								token: {
+									type: "string",
+									description: "Session token for the authenticated session"
+								},
+								user: {
+									type: "object",
+									properties: {
+										id: {
+											type: "string",
+											description: "Unique identifier of the user"
+										},
+										email: {
+											type: "string",
+											format: "email",
+											nullable: true,
+											description: "User's email address"
+										},
+										emailVerified: {
+											type: "boolean",
+											nullable: true,
+											description: "Whether the email is verified"
+										},
+										name: {
+											type: "string",
+											nullable: true,
+											description: "User's name"
+										},
+										image: {
+											type: "string",
+											format: "uri",
+											nullable: true,
+											description: "User's profile image URL"
+										},
+										createdAt: {
+											type: "string",
+											format: "date-time",
+											description: "Timestamp when the user was created"
+										},
+										updatedAt: {
+											type: "string",
+											format: "date-time",
+											description: "Timestamp when the user was last updated"
+										}
+									},
+									required: [
+										"id",
+										"createdAt",
+										"updatedAt"
+									],
+									description: "The authenticated user object"
+								}
+							},
+							required: ["token", "user"]
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const { session, key, valid, invalid } = await verifyTwoFactor(ctx);
+				const toCheckOtp = await ctx.context.internalAdapter.findVerificationValue(`2fa-otp-${key}`);
+				const [otp, counter] = toCheckOtp?.value?.split(":") ?? [];
+				const decryptedOtp = await decryptOTP(ctx, otp);
+				if (!toCheckOtp || toCheckOtp.expiresAt < /* @__PURE__ */ new Date()) {
+					if (toCheckOtp) await ctx.context.internalAdapter.deleteVerificationValue(toCheckOtp.id);
+					throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.OTP_HAS_EXPIRED });
+				}
+				const allowedAttempts = options?.allowedAttempts || 5;
+				if (parseInt(counter) >= allowedAttempts) {
+					await ctx.context.internalAdapter.deleteVerificationValue(toCheckOtp.id);
+					throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TOO_MANY_ATTEMPTS_REQUEST_NEW_CODE });
+				}
+				if (decryptedOtp === ctx.body.code) {
+					if (!session.user.twoFactorEnabled) {
+						if (!session.session) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
+						const updatedUser = await ctx.context.internalAdapter.updateUser(session.user.id, { twoFactorEnabled: true });
+						const newSession = await ctx.context.internalAdapter.createSession(session.user.id, false, session.session);
+						await ctx.context.internalAdapter.deleteSession(session.session.token);
+						await setSessionCookie(ctx, {
+							session: newSession,
+							user: updatedUser
+						});
+						return ctx.json({
+							token: newSession.token,
+							user: {
+								id: updatedUser.id,
+								email: updatedUser.email,
+								emailVerified: updatedUser.emailVerified,
+								name: updatedUser.name,
+								image: updatedUser.image,
+								createdAt: updatedUser.createdAt,
+								updatedAt: updatedUser.updatedAt
+							}
+						});
+					}
+					return valid(ctx);
+				} else {
+					await ctx.context.internalAdapter.updateVerificationValue(toCheckOtp.id, { value: `${otp}:${(parseInt(counter, 10) || 0) + 1}` });
+					return invalid("INVALID_CODE");
+				}
+			})
+		}
+	};
+};
+
+//#endregion
+//#region src/plugins/two-factor/schema.ts
+const schema = {
+	user: { fields: { twoFactorEnabled: {
+		type: "boolean",
+		required: false,
+		defaultValue: false,
+		input: false
+	} } },
+	twoFactor: { fields: {
+		secret: {
+			type: "string",
+			required: true,
+			returned: false,
+			index: true
+		},
+		backupCodes: {
+			type: "string",
+			required: true,
+			returned: false
+		},
+		userId: {
+			type: "string",
+			required: true,
+			returned: false,
+			references: {
+				model: "user",
+				field: "id"
+			},
+			index: true
+		}
+	} }
+};
+
+//#endregion
+//#region src/plugins/two-factor/totp/index.ts
+const totp2fa = (options) => {
+	const opts = {
+		...options,
+		digits: options?.digits || 6,
+		period: options?.period || 30
+	};
+	const twoFactorTable = "twoFactor";
+	return {
+		id: "totp",
+		endpoints: {
+			generateTOTP: createAuthEndpoint("/totp/generate", {
+				method: "POST",
+				body: z.object({ secret: z.string().meta({ description: "The secret to generate the TOTP code" }) }),
+				metadata: {
+					openapi: {
+						summary: "Generate TOTP code",
+						description: "Use this endpoint to generate a TOTP code",
+						responses: { 200: {
+							description: "Successful response",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { code: { type: "string" } }
+							} } }
+						} }
+					},
+					SERVER_ONLY: true
+				}
+			}, async (ctx) => {
+				if (options?.disable) {
+					ctx.context.logger.error("totp isn't configured. please pass totp option on two factor plugin to enable totp");
+					throw new APIError("BAD_REQUEST", { message: "totp isn't configured" });
+				}
+				return { code: await createOTP(ctx.body.secret, {
+					period: opts.period,
+					digits: opts.digits
+				}).totp() };
+			}),
+			getTOTPURI: createAuthEndpoint("/two-factor/get-totp-uri", {
+				method: "POST",
+				use: [sessionMiddleware],
+				body: z.object({ password: z.string().meta({ description: "User password" }) }),
+				metadata: { openapi: {
+					summary: "Get TOTP URI",
+					description: "Use this endpoint to get the TOTP URI",
+					responses: { 200: {
+						description: "Successful response",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { totpURI: { type: "string" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (options?.disable) {
+					ctx.context.logger.error("totp isn't configured. please pass totp option on two factor plugin to enable totp");
+					throw new APIError("BAD_REQUEST", { message: "totp isn't configured" });
+				}
+				const user = ctx.context.session.user;
+				const twoFactor$1 = await ctx.context.adapter.findOne({
+					model: twoFactorTable,
+					where: [{
+						field: "userId",
+						value: user.id
+					}]
+				});
+				if (!twoFactor$1) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TOTP_NOT_ENABLED });
+				const secret = await symmetricDecrypt({
+					key: ctx.context.secret,
+					data: twoFactor$1.secret
+				});
+				await ctx.context.password.checkPassword(user.id, ctx);
+				return { totpURI: createOTP(secret, {
+					digits: opts.digits,
+					period: opts.period
+				}).url(options?.issuer || ctx.context.appName, user.email) };
+			}),
+			verifyTOTP: createAuthEndpoint("/two-factor/verify-totp", {
+				method: "POST",
+				body: z.object({
+					code: z.string().meta({ description: "The otp code to verify. Eg: \"012345\"" }),
+					trustDevice: z.boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
+				}),
+				metadata: { openapi: {
+					summary: "Verify two factor TOTP",
+					description: "Verify two factor TOTP",
+					responses: { 200: {
+						description: "Successful response",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				if (options?.disable) {
+					ctx.context.logger.error("totp isn't configured. please pass totp option on two factor plugin to enable totp");
+					throw new APIError("BAD_REQUEST", { message: "totp isn't configured" });
+				}
+				const { session, valid, invalid } = await verifyTwoFactor(ctx);
+				const user = session.user;
+				const twoFactor$1 = await ctx.context.adapter.findOne({
+					model: twoFactorTable,
+					where: [{
+						field: "userId",
+						value: user.id
+					}]
+				});
+				if (!twoFactor$1) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TOTP_NOT_ENABLED });
+				if (!await createOTP(await symmetricDecrypt({
+					key: ctx.context.secret,
+					data: twoFactor$1.secret
+				}), {
+					period: opts.period,
+					digits: opts.digits
+				}).verify(ctx.body.code)) return invalid("INVALID_CODE");
+				if (!user.twoFactorEnabled) {
+					if (!session.session) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
+					const updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: true });
+					const newSession = await ctx.context.internalAdapter.createSession(user.id, false, session.session).catch((e) => {
+						throw e;
+					});
+					await ctx.context.internalAdapter.deleteSession(session.session.token);
+					await setSessionCookie(ctx, {
+						session: newSession,
+						user: updatedUser
+					});
+				}
+				return valid(ctx);
+			})
+		}
+	};
+};
+
+//#endregion
+//#region src/plugins/two-factor/index.ts
+const twoFactor = (options) => {
+	const opts = { twoFactorTable: "twoFactor" };
+	const backupCodeOptions = {
+		storeBackupCodes: "encrypted",
+		...options?.backupCodeOptions
+	};
+	const totp = totp2fa(options?.totpOptions);
+	const backupCode = backupCode2fa(backupCodeOptions);
+	const otp = otp2fa(options?.otpOptions);
+	return {
+		id: "two-factor",
+		endpoints: {
+			...totp.endpoints,
+			...otp.endpoints,
+			...backupCode.endpoints,
+			enableTwoFactor: createAuthEndpoint("/two-factor/enable", {
+				method: "POST",
+				body: z.object({
+					password: z.string().meta({ description: "User password" }),
+					issuer: z.string().meta({ description: "Custom issuer for the TOTP URI" }).optional()
+				}),
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					summary: "Enable two factor authentication",
+					description: "Use this endpoint to enable two factor authentication. This will generate a TOTP URI and backup codes. Once the user verifies the TOTP URI, the two factor authentication will be enabled.",
+					responses: { 200: {
+						description: "Successful response",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: {
+								totpURI: {
+									type: "string",
+									description: "TOTP URI"
+								},
+								backupCodes: {
+									type: "array",
+									items: { type: "string" },
+									description: "Backup codes"
+								}
+							}
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const user = ctx.context.session.user;
+				const { password, issuer } = ctx.body;
+				if (!await validatePassword(ctx, {
+					password,
+					userId: user.id
+				})) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
+				const secret = generateRandomString(32);
+				const encryptedSecret = await symmetricEncrypt({
+					key: ctx.context.secret,
+					data: secret
+				});
+				const backupCodes = await generateBackupCodes(ctx.context.secret, backupCodeOptions);
+				if (options?.skipVerificationOnEnable) {
+					const updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: true });
+					/**
+					* Update the session cookie with the new user data
+					*/
+					await setSessionCookie(ctx, {
+						session: await ctx.context.internalAdapter.createSession(updatedUser.id, false, ctx.context.session.session),
+						user: updatedUser
+					});
+					await ctx.context.internalAdapter.deleteSession(ctx.context.session.session.token);
+				}
+				await ctx.context.adapter.deleteMany({
+					model: opts.twoFactorTable,
+					where: [{
+						field: "userId",
+						value: user.id
+					}]
+				});
+				await ctx.context.adapter.create({
+					model: opts.twoFactorTable,
+					data: {
+						secret: encryptedSecret,
+						backupCodes: backupCodes.encryptedBackupCodes,
+						userId: user.id
+					}
+				});
+				const totpURI = createOTP(secret, {
+					digits: options?.totpOptions?.digits || 6,
+					period: options?.totpOptions?.period
+				}).url(issuer || options?.issuer || ctx.context.appName, user.email);
+				return ctx.json({
+					totpURI,
+					backupCodes: backupCodes.backupCodes
+				});
+			}),
+			disableTwoFactor: createAuthEndpoint("/two-factor/disable", {
+				method: "POST",
+				body: z.object({ password: z.string().meta({ description: "User password" }) }),
+				use: [sessionMiddleware],
+				metadata: { openapi: {
+					summary: "Disable two factor authentication",
+					description: "Use this endpoint to disable two factor authentication.",
+					responses: { 200: {
+						description: "Successful response",
+						content: { "application/json": { schema: {
+							type: "object",
+							properties: { status: { type: "boolean" } }
+						} } }
+					} }
+				} }
+			}, async (ctx) => {
+				const user = ctx.context.session.user;
+				const { password } = ctx.body;
+				if (!await validatePassword(ctx, {
+					password,
+					userId: user.id
+				})) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
+				const updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: false });
+				await ctx.context.adapter.delete({
+					model: opts.twoFactorTable,
+					where: [{
+						field: "userId",
+						value: updatedUser.id
+					}]
+				});
+				/**
+				* Update the session cookie with the new user data
+				*/
+				await setSessionCookie(ctx, {
+					session: await ctx.context.internalAdapter.createSession(updatedUser.id, false, ctx.context.session.session),
+					user: updatedUser
+				});
+				await ctx.context.internalAdapter.deleteSession(ctx.context.session.session.token);
+				return ctx.json({ status: true });
+			})
+		},
+		options,
+		hooks: { after: [{
+			matcher(context) {
+				return context.path === "/sign-in/email" || context.path === "/sign-in/username" || context.path === "/sign-in/phone-number";
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const data = ctx.context.newSession;
+				if (!data) return;
+				if (!data?.user.twoFactorEnabled) return;
+				const trustDeviceCookieAttrs = ctx.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });
+				const trustDeviceCookie = await ctx.getSignedCookie(trustDeviceCookieAttrs.name, ctx.context.secret);
+				if (trustDeviceCookie) {
+					const [token, sessionToken] = trustDeviceCookie.split("!");
+					if (token === await createHMAC("SHA-256", "base64urlnopad").sign(ctx.context.secret, `${data.user.id}!${sessionToken}`)) {
+						const newTrustDeviceCookie = ctx.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });
+						const newToken = await createHMAC("SHA-256", "base64urlnopad").sign(ctx.context.secret, `${data.user.id}!${data.session.token}`);
+						await ctx.setSignedCookie(newTrustDeviceCookie.name, `${newToken}!${data.session.token}`, ctx.context.secret, trustDeviceCookieAttrs.attributes);
+						return;
+					}
+				}
+				/**
+				* remove the session cookie. It's set by the sign in credential
+				*/
+				deleteSessionCookie(ctx, true);
+				await ctx.context.internalAdapter.deleteSession(data.session.token);
+				const maxAge = (options?.otpOptions?.period ?? 3) * 60;
+				const twoFactorCookie = ctx.context.createAuthCookie(TWO_FACTOR_COOKIE_NAME, { maxAge });
+				const identifier = `2fa-${generateRandomString(20)}`;
+				await ctx.context.internalAdapter.createVerificationValue({
+					value: data.user.id,
+					identifier,
+					expiresAt: new Date(Date.now() + maxAge * 1e3)
+				});
+				await ctx.setSignedCookie(twoFactorCookie.name, identifier, ctx.context.secret, twoFactorCookie.attributes);
+				return ctx.json({ twoFactorRedirect: true });
+			})
+		}] },
+		schema: mergeSchema(schema, options?.schema),
+		rateLimit: [{
+			pathMatcher(path) {
+				return path.startsWith("/two-factor/");
+			},
+			window: 10,
+			max: 3
+		}],
+		$ERROR_CODES: TWO_FACTOR_ERROR_CODES
+	};
+};
+
+//#endregion
+export { TWO_FACTOR_ERROR_CODES as n, twoFactor as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/types-BReKsBV6.mjs.bak b/node_modules/better-auth/dist/types-BReKsBV6.mjs.bak
new file mode 100644
index 0000000..3001d89
--- /dev/null
+++ b/node_modules/better-auth/dist/types-BReKsBV6.mjs.bak
@@ -0,0 +1 @@
+export {  };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/types/index.mjs.bak b/node_modules/better-auth/dist/types/index.mjs.bak
new file mode 100644
index 0000000..4875e69
--- /dev/null
+++ b/node_modules/better-auth/dist/types/index.mjs.bak
@@ -0,0 +1,3 @@
+import "../types-BReKsBV6.mjs";
+
+export {  };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/url-SXU3XD3W.mjs.bak b/node_modules/better-auth/dist/url-SXU3XD3W.mjs.bak
new file mode 100644
index 0000000..281101b
--- /dev/null
+++ b/node_modules/better-auth/dist/url-SXU3XD3W.mjs.bak
@@ -0,0 +1,69 @@
+import { env } from "@better-auth/core/env";
+import { BetterAuthError } from "@better-auth/core/error";
+
+//#region src/utils/url.ts
+function checkHasPath(url) {
+	try {
+		return (new URL(url).pathname.replace(/\/+$/, "") || "/") !== "/";
+	} catch (error) {
+		throw new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`);
+	}
+}
+function assertHasProtocol(url) {
+	try {
+		const parsedUrl = new URL(url);
+		if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") throw new BetterAuthError(`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`);
+	} catch (error) {
+		if (error instanceof BetterAuthError) throw error;
+		throw new BetterAuthError(`Invalid base URL: ${url}. Please provide a valid base URL.`, String(error));
+	}
+}
+function withPath(url, path = "/api/auth") {
+	assertHasProtocol(url);
+	if (checkHasPath(url)) return url;
+	const trimmedUrl = url.replace(/\/+$/, "");
+	if (!path || path === "/") return trimmedUrl;
+	path = path.startsWith("/") ? path : `/${path}`;
+	return `${trimmedUrl}${path}`;
+}
+function getBaseURL(url, path, request, loadEnv) {
+	if (url) return withPath(url, path);
+	if (loadEnv !== false) {
+		const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : void 0);
+		if (fromEnv) return withPath(fromEnv, path);
+	}
+	const fromRequest = request?.headers.get("x-forwarded-host");
+	const fromRequestProto = request?.headers.get("x-forwarded-proto");
+	if (fromRequest && fromRequestProto) return withPath(`${fromRequestProto}://${fromRequest}`, path);
+	if (request) {
+		const url$1 = getOrigin(request.url);
+		if (!url$1) throw new BetterAuthError("Could not get origin from request. Please provide a valid base URL.");
+		return withPath(url$1, path);
+	}
+	if (typeof window !== "undefined" && window.location) return withPath(window.location.origin, path);
+}
+function getOrigin(url) {
+	try {
+		const parsedUrl = new URL(url);
+		return parsedUrl.origin === "null" ? null : parsedUrl.origin;
+	} catch (error) {
+		return null;
+	}
+}
+function getProtocol(url) {
+	try {
+		return new URL(url).protocol;
+	} catch (error) {
+		return null;
+	}
+}
+function getHost(url) {
+	try {
+		return new URL(url).host;
+	} catch (error) {
+		return null;
+	}
+}
+
+//#endregion
+export { getProtocol as i, getHost as n, getOrigin as r, getBaseURL as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/username-DI2v-O3q.mjs b/node_modules/better-auth/dist/username-DI2v-O3q.mjs
index ec47f51..9438c7e 100644
--- a/node_modules/better-auth/dist/username-DI2v-O3q.mjs
+++ b/node_modules/better-auth/dist/username-DI2v-O3q.mjs
@@ -85,10 +85,10 @@ const username = (options) => {
 			signInUsername: createAuthEndpoint("/sign-in/username", {
 				method: "POST",
 				body: z.object({
-					username: z.string().meta({ description: "The username of the user" }),
-					password: z.string().meta({ description: "The password of the user" }),
-					rememberMe: z.boolean().meta({ description: "Remember the user session" }).optional(),
-					callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
+					username: z.string(),
+					password: z.string(),
+					rememberMe: z.boolean().optional(),
+					callbackURL: z.string().optional()
 				}),
 				metadata: { openapi: {
 					summary: "Sign in with username",
@@ -208,7 +208,7 @@ const username = (options) => {
 			}),
 			isUsernameAvailable: createAuthEndpoint("/is-username-available", {
 				method: "POST",
-				body: z.object({ username: z.string().meta({ description: "The username to check" }) })
+				body: z.object({ username: z.string() })
 			}, async (ctx) => {
 				const username$1 = ctx.body.username;
 				if (!username$1) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
diff --git a/node_modules/better-auth/dist/username-DI2v-O3q.mjs.bak b/node_modules/better-auth/dist/username-DI2v-O3q.mjs.bak
new file mode 100644
index 0000000..ec47f51
--- /dev/null
+++ b/node_modules/better-auth/dist/username-DI2v-O3q.mjs.bak
@@ -0,0 +1,278 @@
+import { t as mergeSchema } from "./schema-BevzneML.mjs";
+import { C as createEmailVerificationToken } from "./api-C0IsrmGz.mjs";
+import { c as setSessionCookie } from "./cookies-Cl2L38B1.mjs";
+import { BASE_ERROR_CODES } from "@better-auth/core/error";
+import { defineErrorCodes } from "@better-auth/core/utils";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createAuthEndpoint, createAuthMiddleware } from "@better-auth/core/api";
+
+//#region src/plugins/username/error-codes.ts
+const USERNAME_ERROR_CODES = defineErrorCodes({
+	INVALID_USERNAME_OR_PASSWORD: "Invalid username or password",
+	EMAIL_NOT_VERIFIED: "Email not verified",
+	UNEXPECTED_ERROR: "Unexpected error",
+	USERNAME_IS_ALREADY_TAKEN: "Username is already taken. Please try another.",
+	USERNAME_TOO_SHORT: "Username is too short",
+	USERNAME_TOO_LONG: "Username is too long",
+	INVALID_USERNAME: "Username is invalid",
+	INVALID_DISPLAY_USERNAME: "Display username is invalid"
+});
+
+//#endregion
+//#region src/plugins/username/schema.ts
+const getSchema = (normalizer) => {
+	return { user: { fields: {
+		username: {
+			type: "string",
+			required: false,
+			sortable: true,
+			unique: true,
+			returned: true,
+			transform: { input(value) {
+				return typeof value !== "string" ? value : normalizer.username(value);
+			} }
+		},
+		displayUsername: {
+			type: "string",
+			required: false,
+			transform: { input(value) {
+				return typeof value !== "string" ? value : normalizer.displayUsername(value);
+			} }
+		}
+	} } };
+};
+
+//#endregion
+//#region src/plugins/username/index.ts
+function defaultUsernameValidator(username$1) {
+	return /^[a-zA-Z0-9_.]+$/.test(username$1);
+}
+const username = (options) => {
+	const normalizer = (username$1) => {
+		if (options?.usernameNormalization === false) return username$1;
+		if (options?.usernameNormalization) return options.usernameNormalization(username$1);
+		return username$1.toLowerCase();
+	};
+	const displayUsernameNormalizer = (displayUsername) => {
+		return options?.displayUsernameNormalization ? options.displayUsernameNormalization(displayUsername) : displayUsername;
+	};
+	return {
+		id: "username",
+		init(ctx) {
+			return { options: { databaseHooks: { user: {
+				create: { async before(user, context) {
+					const username$1 = "username" in user ? user.username : null;
+					const displayUsername = "displayUsername" in user ? user.displayUsername : null;
+					return { data: {
+						...user,
+						...username$1 ? { username: normalizer(username$1) } : {},
+						...displayUsername ? { displayUsername: displayUsernameNormalizer(displayUsername) } : {}
+					} };
+				} },
+				update: { async before(user, context) {
+					const username$1 = "username" in user ? user.username : null;
+					const displayUsername = "displayUsername" in user ? user.displayUsername : null;
+					return { data: {
+						...user,
+						...username$1 ? { username: normalizer(username$1) } : {},
+						...displayUsername ? { displayUsername: displayUsernameNormalizer(displayUsername) } : {}
+					} };
+				} }
+			} } } };
+		},
+		endpoints: {
+			signInUsername: createAuthEndpoint("/sign-in/username", {
+				method: "POST",
+				body: z.object({
+					username: z.string().meta({ description: "The username of the user" }),
+					password: z.string().meta({ description: "The password of the user" }),
+					rememberMe: z.boolean().meta({ description: "Remember the user session" }).optional(),
+					callbackURL: z.string().meta({ description: "The URL to redirect to after email verification" }).optional()
+				}),
+				metadata: { openapi: {
+					summary: "Sign in with username",
+					description: "Sign in with username",
+					responses: {
+						200: {
+							description: "Success",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: {
+									token: {
+										type: "string",
+										description: "Session token for the authenticated session"
+									},
+									user: { $ref: "#/components/schemas/User" }
+								},
+								required: ["token", "user"]
+							} } }
+						},
+						422: {
+							description: "Unprocessable Entity. Validation error",
+							content: { "application/json": { schema: {
+								type: "object",
+								properties: { message: { type: "string" } }
+							} } }
+						}
+					}
+				} }
+			}, async (ctx) => {
+				if (!ctx.body.username || !ctx.body.password) {
+					ctx.context.logger.error("Username or password not found");
+					throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
+				}
+				const username$1 = options?.validationOrder?.username === "pre-normalization" ? normalizer(ctx.body.username) : ctx.body.username;
+				const minUsernameLength = options?.minUsernameLength || 3;
+				const maxUsernameLength = options?.maxUsernameLength || 30;
+				if (username$1.length < minUsernameLength) {
+					ctx.context.logger.error("Username too short", { username: username$1 });
+					throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT });
+				}
+				if (username$1.length > maxUsernameLength) {
+					ctx.context.logger.error("Username too long", { username: username$1 });
+					throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });
+				}
+				if (!(options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
+				const user = await ctx.context.adapter.findOne({
+					model: "user",
+					where: [{
+						field: "username",
+						value: normalizer(username$1)
+					}]
+				});
+				if (!user) {
+					await ctx.context.password.hash(ctx.body.password);
+					ctx.context.logger.error("User not found", { username: username$1 });
+					throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
+				}
+				const account = await ctx.context.adapter.findOne({
+					model: "account",
+					where: [{
+						field: "userId",
+						value: user.id
+					}, {
+						field: "providerId",
+						value: "credential"
+					}]
+				});
+				if (!account) throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
+				const currentPassword = account?.password;
+				if (!currentPassword) {
+					ctx.context.logger.error("Password not found", { username: username$1 });
+					throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
+				}
+				if (!await ctx.context.password.verify({
+					hash: currentPassword,
+					password: ctx.body.password
+				})) {
+					ctx.context.logger.error("Invalid password");
+					throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
+				}
+				if (ctx.context.options?.emailAndPassword?.requireEmailVerification && !user.emailVerified) {
+					if (!ctx.context.options?.emailVerification?.sendVerificationEmail) throw new APIError("FORBIDDEN", { message: USERNAME_ERROR_CODES.EMAIL_NOT_VERIFIED });
+					if (ctx.context.options?.emailVerification?.sendOnSignIn) {
+						const token = await createEmailVerificationToken(ctx.context.secret, user.email, void 0, ctx.context.options.emailVerification?.expiresIn);
+						const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
+						await ctx.context.options.emailVerification.sendVerificationEmail({
+							user,
+							url,
+							token
+						}, ctx.request);
+					}
+					throw new APIError("FORBIDDEN", { message: USERNAME_ERROR_CODES.EMAIL_NOT_VERIFIED });
+				}
+				const session = await ctx.context.internalAdapter.createSession(user.id, ctx.body.rememberMe === false);
+				if (!session) return ctx.json(null, {
+					status: 500,
+					body: { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION }
+				});
+				await setSessionCookie(ctx, {
+					session,
+					user
+				}, ctx.body.rememberMe === false);
+				return ctx.json({
+					token: session.token,
+					user: {
+						id: user.id,
+						email: user.email,
+						emailVerified: user.emailVerified,
+						username: user.username,
+						displayUsername: user.displayUsername,
+						name: user.name,
+						image: user.image,
+						createdAt: user.createdAt,
+						updatedAt: user.updatedAt
+					}
+				});
+			}),
+			isUsernameAvailable: createAuthEndpoint("/is-username-available", {
+				method: "POST",
+				body: z.object({ username: z.string().meta({ description: "The username to check" }) })
+			}, async (ctx) => {
+				const username$1 = ctx.body.username;
+				if (!username$1) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
+				const minUsernameLength = options?.minUsernameLength || 3;
+				const maxUsernameLength = options?.maxUsernameLength || 30;
+				if (username$1.length < minUsernameLength) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT });
+				if (username$1.length > maxUsernameLength) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });
+				if (!await (options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
+				if (await ctx.context.adapter.findOne({
+					model: "user",
+					where: [{
+						field: "username",
+						value: normalizer(username$1)
+					}]
+				})) return ctx.json({ available: false });
+				return ctx.json({ available: true });
+			})
+		},
+		schema: mergeSchema(getSchema({
+			username: normalizer,
+			displayUsername: displayUsernameNormalizer
+		}), options?.schema),
+		hooks: { before: [{
+			matcher(context) {
+				return context.path === "/sign-up/email" || context.path === "/update-user";
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				const username$1 = typeof ctx.body.username === "string" && options?.validationOrder?.username === "post-normalization" ? normalizer(ctx.body.username) : ctx.body.username;
+				if (username$1 !== void 0 && typeof username$1 === "string") {
+					const minUsernameLength = options?.minUsernameLength || 3;
+					const maxUsernameLength = options?.maxUsernameLength || 30;
+					if (username$1.length < minUsernameLength) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT });
+					if (username$1.length > maxUsernameLength) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });
+					if (!await (options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
+					const user = await ctx.context.adapter.findOne({
+						model: "user",
+						where: [{
+							field: "username",
+							value: username$1
+						}]
+					});
+					const blockChangeSignUp = ctx.path === "/sign-up/email" && user;
+					const blockChangeUpdateUser = ctx.path === "/update-user" && user && ctx.context.session && user.id !== ctx.context.session.session.userId;
+					if (blockChangeSignUp || blockChangeUpdateUser) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.USERNAME_IS_ALREADY_TAKEN });
+				}
+				const displayUsername = typeof ctx.body.displayUsername === "string" && options?.validationOrder?.displayUsername === "post-normalization" ? displayUsernameNormalizer(ctx.body.displayUsername) : ctx.body.displayUsername;
+				if (displayUsername !== void 0 && typeof displayUsername === "string") {
+					if (options?.displayUsernameValidator) {
+						if (!await options.displayUsernameValidator(displayUsername)) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.INVALID_DISPLAY_USERNAME });
+					}
+				}
+			})
+		}, {
+			matcher(context) {
+				return context.path === "/sign-up/email" || context.path === "/update-user";
+			},
+			handler: createAuthMiddleware(async (ctx) => {
+				if (ctx.body.username && !ctx.body.displayUsername) ctx.body.displayUsername = ctx.body.username;
+				if (ctx.body.displayUsername && !ctx.body.username) ctx.body.username = ctx.body.displayUsername;
+			})
+		}] },
+		$ERROR_CODES: USERNAME_ERROR_CODES
+	};
+};
+
+//#endregion
+export { USERNAME_ERROR_CODES as n, username as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/utils-F62c-ieM.mjs b/node_modules/better-auth/dist/utils-F62c-ieM.mjs
index dce448d..dc664e3 100644
--- a/node_modules/better-auth/dist/utils-F62c-ieM.mjs
+++ b/node_modules/better-auth/dist/utils-F62c-ieM.mjs
@@ -59,7 +59,7 @@ async function generateState(c, link, additionalData) {
 async function parseState(c) {
 	const state = c.query.state || c.body.state;
 	const storeStateStrategy = c.context.oauthConfig.storeStateStrategy || "cookie";
-	const stateDataSchema = z.looseObject({
+	const stateDataSchema = z.object({
 		callbackURL: z.string(),
 		codeVerifier: z.string(),
 		errorURL: z.string().optional(),
@@ -70,7 +70,7 @@ async function parseState(c) {
 			userId: z.coerce.string()
 		}).optional(),
 		requestSignUp: z.boolean().optional()
-	});
+	}).passthrough();
 	let parsedData;
 	if (storeStateStrategy === "cookie") {
 		const stateCookie = c.context.createAuthCookie("oauth_state");
diff --git a/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak
new file mode 100644
index 0000000..dc664e3
--- /dev/null
+++ b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak
@@ -0,0 +1,132 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { defineRequestState } from "@better-auth/core/context";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createRandomStringGenerator } from "@better-auth/utils/random";
+
+//#region src/api/middlewares/oauth.ts
+const { get: getOAuthState, set: setOAuthState } = defineRequestState(() => null);
+
+//#endregion
+//#region src/oauth2/state.ts
+async function generateState(c, link, additionalData) {
+	const callbackURL = c.body?.callbackURL || c.context.options.baseURL;
+	if (!callbackURL) throw new APIError("BAD_REQUEST", { message: "callbackURL is required" });
+	const codeVerifier = generateRandomString(128);
+	const state = generateRandomString(32);
+	const storeStateStrategy = c.context.oauthConfig?.storeStateStrategy || "cookie";
+	const stateData = {
+		...additionalData ? additionalData : {},
+		callbackURL,
+		codeVerifier,
+		errorURL: c.body?.errorCallbackURL,
+		newUserURL: c.body?.newUserCallbackURL,
+		link,
+		expiresAt: Date.now() + 600 * 1e3,
+		requestSignUp: c.body?.requestSignUp
+	};
+	await setOAuthState(stateData);
+	if (storeStateStrategy === "cookie") {
+		const encryptedData = await symmetricEncrypt({
+			key: c.context.secret,
+			data: JSON.stringify(stateData)
+		});
+		const stateCookie$1 = c.context.createAuthCookie("oauth_state", { maxAge: 600 * 1e3 });
+		c.setCookie(stateCookie$1.name, encryptedData, stateCookie$1.attributes);
+		return {
+			state,
+			codeVerifier
+		};
+	}
+	const stateCookie = c.context.createAuthCookie("state", { maxAge: 300 * 1e3 });
+	await c.setSignedCookie(stateCookie.name, state, c.context.secret, stateCookie.attributes);
+	const expiresAt = /* @__PURE__ */ new Date();
+	expiresAt.setMinutes(expiresAt.getMinutes() + 10);
+	const verification = await c.context.internalAdapter.createVerificationValue({
+		value: JSON.stringify(stateData),
+		identifier: state,
+		expiresAt
+	});
+	if (!verification) {
+		c.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database");
+		throw new APIError("INTERNAL_SERVER_ERROR", { message: "Unable to create verification" });
+	}
+	return {
+		state: verification.identifier,
+		codeVerifier
+	};
+}
+async function parseState(c) {
+	const state = c.query.state || c.body.state;
+	const storeStateStrategy = c.context.oauthConfig.storeStateStrategy || "cookie";
+	const stateDataSchema = z.object({
+		callbackURL: z.string(),
+		codeVerifier: z.string(),
+		errorURL: z.string().optional(),
+		newUserURL: z.string().optional(),
+		expiresAt: z.number(),
+		link: z.object({
+			email: z.string(),
+			userId: z.coerce.string()
+		}).optional(),
+		requestSignUp: z.boolean().optional()
+	}).passthrough();
+	let parsedData;
+	if (storeStateStrategy === "cookie") {
+		const stateCookie = c.context.createAuthCookie("oauth_state");
+		const encryptedData = c.getCookie(stateCookie.name);
+		if (!encryptedData) {
+			c.context.logger.error("State Mismatch. OAuth state cookie not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		try {
+			const decryptedData = await symmetricDecrypt({
+				key: c.context.secret,
+				data: encryptedData
+			});
+			parsedData = stateDataSchema.parse(JSON.parse(decryptedData));
+		} catch (error) {
+			c.context.logger.error("Failed to decrypt or parse OAuth state cookie", { error });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+	} else {
+		const data = await c.context.internalAdapter.findVerificationValue(state);
+		if (!data) {
+			c.context.logger.error("State Mismatch. Verification not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		parsedData = stateDataSchema.parse(JSON.parse(data.value));
+		const stateCookie = c.context.createAuthCookie("state");
+		const stateCookieValue = await c.getSignedCookie(stateCookie.name, c.context.secret);
+		if (!c.context.oauthConfig?.skipStateCookieCheck && (!stateCookieValue || stateCookieValue !== state)) {
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=state_mismatch`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+		await c.context.internalAdapter.deleteVerificationValue(data.id);
+	}
+	if (!parsedData.errorURL) parsedData.errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+	if (parsedData.expiresAt < Date.now()) {
+		const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+		throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+	}
+	if (parsedData) await setOAuthState(parsedData);
+	return parsedData;
+}
+
+//#endregion
+//#region src/utils/hide-metadata.ts
+const HIDE_METADATA = { isAction: false };
+
+//#endregion
+//#region src/utils/id.ts
+const generateId = (size) => {
+	return createRandomStringGenerator("a-z", "A-Z", "0-9")(size || 32);
+};
+
+//#endregion
+export { getOAuthState as a, parseState as i, HIDE_METADATA as n, generateState as r, generateId as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak2 b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak2
new file mode 100644
index 0000000..7d9c0a1
--- /dev/null
+++ b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak2
@@ -0,0 +1,132 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { defineRequestState } from "@better-auth/core/context";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createRandomStringGenerator } from "@better-auth/utils/random";
+
+//#region src/api/middlewares/oauth.ts
+const { get: getOAuthState, set: setOAuthState } = defineRequestState(() => null);
+
+//#endregion
+//#region src/oauth2/state.ts
+async function generateState(c, link, additionalData) {
+	const callbackURL = c.body?.callbackURL || c.context.options.baseURL;
+	if (!callbackURL) throw new APIError("BAD_REQUEST", { message: "callbackURL is required" });
+	const codeVerifier = generateRandomString(128);
+	const state = generateRandomString(32);
+	const storeStateStrategy = c.context.oauthConfig?.storeStateStrategy || "cookie";
+	const stateData = {
+		...additionalData ? additionalData : {},
+		callbackURL,
+		codeVerifier,
+		errorURL: c.body?.errorCallbackURL,
+		newUserURL: c.body?.newUserCallbackURL,
+		link,
+		expiresAt: Date.now() + 600 * 1e3,
+		requestSignUp: c.body?.requestSignUp
+	};
+	await setOAuthState(stateData);
+	if (storeStateStrategy === "cookie") {
+		const encryptedData = await symmetricEncrypt({
+			key: c.context.secret,
+			data: JSON.stringify(stateData)
+		});
+		const stateCookie$1 = c.context.createAuthCookie("oauth_state", { maxAge: 600 * 1e3 });
+		c.setCookie(stateCookie$1.name, encryptedData, stateCookie$1.attributes);
+		return {
+			state,
+			codeVerifier
+		};
+	}
+	const stateCookie = c.context.createAuthCookie("state", { maxAge: 300 * 1e3 });
+	await c.setSignedCookie(stateCookie.name, state, c.context.secret, stateCookie.attributes);
+	const expiresAt = /* @__PURE__ */ new Date();
+	expiresAt.setMinutes(expiresAt.getMinutes() + 10);
+	const verification = await c.context.internalAdapter.createVerificationValue({
+		value: JSON.stringify(stateData),
+		identifier: state,
+		expiresAt
+	});
+	if (!verification) {
+		c.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database");
+		throw new APIError("INTERNAL_SERVER_ERROR", { message: "Unable to create verification" });
+	}
+	return {
+		state: verification.identifier,
+		codeVerifier
+	};
+}
+async function parseState(c) {
+	const state = c.query.state || c.body.state;
+	const storeStateStrategy = c.context.oauthConfig.storeStateStrategy || "cookie";
+	const stateDataSchema = z.object({
+		callbackURL: z.string(),
+		codeVerifier: z.string(),
+		errorURL: z.string().optional(),
+		newUserURL: z.string().optional(),
+		expiresAt: z.number(),
+		link: z.object({
+			email: z.string(),
+			userId: z.coerce.string()
+		}).optional(),
+		requestSignUp: z.boolean().optional()
+	});
+	let parsedData;
+	if (storeStateStrategy === "cookie") {
+		const stateCookie = c.context.createAuthCookie("oauth_state");
+		const encryptedData = c.getCookie(stateCookie.name);
+		if (!encryptedData) {
+			c.context.logger.error("State Mismatch. OAuth state cookie not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		try {
+			const decryptedData = await symmetricDecrypt({
+				key: c.context.secret,
+				data: encryptedData
+			});
+			parsedData = stateDataSchema.parse(JSON.parse(decryptedData));
+		} catch (error) {
+			c.context.logger.error("Failed to decrypt or parse OAuth state cookie", { error });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+	} else {
+		const data = await c.context.internalAdapter.findVerificationValue(state);
+		if (!data) {
+			c.context.logger.error("State Mismatch. Verification not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		parsedData = stateDataSchema.parse(JSON.parse(data.value));
+		const stateCookie = c.context.createAuthCookie("state");
+		const stateCookieValue = await c.getSignedCookie(stateCookie.name, c.context.secret);
+		if (!c.context.oauthConfig?.skipStateCookieCheck && (!stateCookieValue || stateCookieValue !== state)) {
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=state_mismatch`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+		await c.context.internalAdapter.deleteVerificationValue(data.id);
+	}
+	if (!parsedData.errorURL) parsedData.errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+	if (parsedData.expiresAt < Date.now()) {
+		const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+		throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+	}
+	if (parsedData) await setOAuthState(parsedData);
+	return parsedData;
+}
+
+//#endregion
+//#region src/utils/hide-metadata.ts
+const HIDE_METADATA = { isAction: false };
+
+//#endregion
+//#region src/utils/id.ts
+const generateId = (size) => {
+	return createRandomStringGenerator("a-z", "A-Z", "0-9")(size || 32);
+};
+
+//#endregion
+export { getOAuthState as a, parseState as i, HIDE_METADATA as n, generateState as r, generateId as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak3 b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak3
new file mode 100644
index 0000000..7d9c0a1
--- /dev/null
+++ b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak3
@@ -0,0 +1,132 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { defineRequestState } from "@better-auth/core/context";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createRandomStringGenerator } from "@better-auth/utils/random";
+
+//#region src/api/middlewares/oauth.ts
+const { get: getOAuthState, set: setOAuthState } = defineRequestState(() => null);
+
+//#endregion
+//#region src/oauth2/state.ts
+async function generateState(c, link, additionalData) {
+	const callbackURL = c.body?.callbackURL || c.context.options.baseURL;
+	if (!callbackURL) throw new APIError("BAD_REQUEST", { message: "callbackURL is required" });
+	const codeVerifier = generateRandomString(128);
+	const state = generateRandomString(32);
+	const storeStateStrategy = c.context.oauthConfig?.storeStateStrategy || "cookie";
+	const stateData = {
+		...additionalData ? additionalData : {},
+		callbackURL,
+		codeVerifier,
+		errorURL: c.body?.errorCallbackURL,
+		newUserURL: c.body?.newUserCallbackURL,
+		link,
+		expiresAt: Date.now() + 600 * 1e3,
+		requestSignUp: c.body?.requestSignUp
+	};
+	await setOAuthState(stateData);
+	if (storeStateStrategy === "cookie") {
+		const encryptedData = await symmetricEncrypt({
+			key: c.context.secret,
+			data: JSON.stringify(stateData)
+		});
+		const stateCookie$1 = c.context.createAuthCookie("oauth_state", { maxAge: 600 * 1e3 });
+		c.setCookie(stateCookie$1.name, encryptedData, stateCookie$1.attributes);
+		return {
+			state,
+			codeVerifier
+		};
+	}
+	const stateCookie = c.context.createAuthCookie("state", { maxAge: 300 * 1e3 });
+	await c.setSignedCookie(stateCookie.name, state, c.context.secret, stateCookie.attributes);
+	const expiresAt = /* @__PURE__ */ new Date();
+	expiresAt.setMinutes(expiresAt.getMinutes() + 10);
+	const verification = await c.context.internalAdapter.createVerificationValue({
+		value: JSON.stringify(stateData),
+		identifier: state,
+		expiresAt
+	});
+	if (!verification) {
+		c.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database");
+		throw new APIError("INTERNAL_SERVER_ERROR", { message: "Unable to create verification" });
+	}
+	return {
+		state: verification.identifier,
+		codeVerifier
+	};
+}
+async function parseState(c) {
+	const state = c.query.state || c.body.state;
+	const storeStateStrategy = c.context.oauthConfig.storeStateStrategy || "cookie";
+	const stateDataSchema = z.object({
+		callbackURL: z.string(),
+		codeVerifier: z.string(),
+		errorURL: z.string().optional(),
+		newUserURL: z.string().optional(),
+		expiresAt: z.number(),
+		link: z.object({
+			email: z.string(),
+			userId: z.coerce.string()
+		}).optional(),
+		requestSignUp: z.boolean().optional()
+	});
+	let parsedData;
+	if (storeStateStrategy === "cookie") {
+		const stateCookie = c.context.createAuthCookie("oauth_state");
+		const encryptedData = c.getCookie(stateCookie.name);
+		if (!encryptedData) {
+			c.context.logger.error("State Mismatch. OAuth state cookie not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		try {
+			const decryptedData = await symmetricDecrypt({
+				key: c.context.secret,
+				data: encryptedData
+			});
+			parsedData = stateDataSchema.parse(JSON.parse(decryptedData));
+		} catch (error) {
+			c.context.logger.error("Failed to decrypt or parse OAuth state cookie", { error });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+	} else {
+		const data = await c.context.internalAdapter.findVerificationValue(state);
+		if (!data) {
+			c.context.logger.error("State Mismatch. Verification not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		parsedData = stateDataSchema.parse(JSON.parse(data.value));
+		const stateCookie = c.context.createAuthCookie("state");
+		const stateCookieValue = await c.getSignedCookie(stateCookie.name, c.context.secret);
+		if (!c.context.oauthConfig?.skipStateCookieCheck && (!stateCookieValue || stateCookieValue !== state)) {
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=state_mismatch`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+		await c.context.internalAdapter.deleteVerificationValue(data.id);
+	}
+	if (!parsedData.errorURL) parsedData.errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+	if (parsedData.expiresAt < Date.now()) {
+		const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+		throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+	}
+	if (parsedData) await setOAuthState(parsedData);
+	return parsedData;
+}
+
+//#endregion
+//#region src/utils/hide-metadata.ts
+const HIDE_METADATA = { isAction: false };
+
+//#endregion
+//#region src/utils/id.ts
+const generateId = (size) => {
+	return createRandomStringGenerator("a-z", "A-Z", "0-9")(size || 32);
+};
+
+//#endregion
+export { getOAuthState as a, parseState as i, HIDE_METADATA as n, generateState as r, generateId as t };
\ No newline at end of file
diff --git a/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak4 b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak4
new file mode 100644
index 0000000..7d9c0a1
--- /dev/null
+++ b/node_modules/better-auth/dist/utils-F62c-ieM.mjs.bak4
@@ -0,0 +1,132 @@
+import { n as symmetricEncrypt, r as generateRandomString, t as symmetricDecrypt } from "./crypto-DZW3hrq1.mjs";
+import { defineRequestState } from "@better-auth/core/context";
+import { APIError } from "better-call";
+import * as z from "zod";
+import { createRandomStringGenerator } from "@better-auth/utils/random";
+
+//#region src/api/middlewares/oauth.ts
+const { get: getOAuthState, set: setOAuthState } = defineRequestState(() => null);
+
+//#endregion
+//#region src/oauth2/state.ts
+async function generateState(c, link, additionalData) {
+	const callbackURL = c.body?.callbackURL || c.context.options.baseURL;
+	if (!callbackURL) throw new APIError("BAD_REQUEST", { message: "callbackURL is required" });
+	const codeVerifier = generateRandomString(128);
+	const state = generateRandomString(32);
+	const storeStateStrategy = c.context.oauthConfig?.storeStateStrategy || "cookie";
+	const stateData = {
+		...additionalData ? additionalData : {},
+		callbackURL,
+		codeVerifier,
+		errorURL: c.body?.errorCallbackURL,
+		newUserURL: c.body?.newUserCallbackURL,
+		link,
+		expiresAt: Date.now() + 600 * 1e3,
+		requestSignUp: c.body?.requestSignUp
+	};
+	await setOAuthState(stateData);
+	if (storeStateStrategy === "cookie") {
+		const encryptedData = await symmetricEncrypt({
+			key: c.context.secret,
+			data: JSON.stringify(stateData)
+		});
+		const stateCookie$1 = c.context.createAuthCookie("oauth_state", { maxAge: 600 * 1e3 });
+		c.setCookie(stateCookie$1.name, encryptedData, stateCookie$1.attributes);
+		return {
+			state,
+			codeVerifier
+		};
+	}
+	const stateCookie = c.context.createAuthCookie("state", { maxAge: 300 * 1e3 });
+	await c.setSignedCookie(stateCookie.name, state, c.context.secret, stateCookie.attributes);
+	const expiresAt = /* @__PURE__ */ new Date();
+	expiresAt.setMinutes(expiresAt.getMinutes() + 10);
+	const verification = await c.context.internalAdapter.createVerificationValue({
+		value: JSON.stringify(stateData),
+		identifier: state,
+		expiresAt
+	});
+	if (!verification) {
+		c.context.logger.error("Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database");
+		throw new APIError("INTERNAL_SERVER_ERROR", { message: "Unable to create verification" });
+	}
+	return {
+		state: verification.identifier,
+		codeVerifier
+	};
+}
+async function parseState(c) {
+	const state = c.query.state || c.body.state;
+	const storeStateStrategy = c.context.oauthConfig.storeStateStrategy || "cookie";
+	const stateDataSchema = z.object({
+		callbackURL: z.string(),
+		codeVerifier: z.string(),
+		errorURL: z.string().optional(),
+		newUserURL: z.string().optional(),
+		expiresAt: z.number(),
+		link: z.object({
+			email: z.string(),
+			userId: z.coerce.string()
+		}).optional(),
+		requestSignUp: z.boolean().optional()
+	});
+	let parsedData;
+	if (storeStateStrategy === "cookie") {
+		const stateCookie = c.context.createAuthCookie("oauth_state");
+		const encryptedData = c.getCookie(stateCookie.name);
+		if (!encryptedData) {
+			c.context.logger.error("State Mismatch. OAuth state cookie not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		try {
+			const decryptedData = await symmetricDecrypt({
+				key: c.context.secret,
+				data: encryptedData
+			});
+			parsedData = stateDataSchema.parse(JSON.parse(decryptedData));
+		} catch (error) {
+			c.context.logger.error("Failed to decrypt or parse OAuth state cookie", { error });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+	} else {
+		const data = await c.context.internalAdapter.findVerificationValue(state);
+		if (!data) {
+			c.context.logger.error("State Mismatch. Verification not found", { state });
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+		}
+		parsedData = stateDataSchema.parse(JSON.parse(data.value));
+		const stateCookie = c.context.createAuthCookie("state");
+		const stateCookieValue = await c.getSignedCookie(stateCookie.name, c.context.secret);
+		if (!c.context.oauthConfig?.skipStateCookieCheck && (!stateCookieValue || stateCookieValue !== state)) {
+			const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+			throw c.redirect(`${errorURL}?error=state_mismatch`);
+		}
+		c.setCookie(stateCookie.name, "", { maxAge: 0 });
+		await c.context.internalAdapter.deleteVerificationValue(data.id);
+	}
+	if (!parsedData.errorURL) parsedData.errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+	if (parsedData.expiresAt < Date.now()) {
+		const errorURL = c.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;
+		throw c.redirect(`${errorURL}?error=please_restart_the_process`);
+	}
+	if (parsedData) await setOAuthState(parsedData);
+	return parsedData;
+}
+
+//#endregion
+//#region src/utils/hide-metadata.ts
+const HIDE_METADATA = { isAction: false };
+
+//#endregion
+//#region src/utils/id.ts
+const generateId = (size) => {
+	return createRandomStringGenerator("a-z", "A-Z", "0-9")(size || 32);
+};
+
+//#endregion
+export { getOAuthState as a, parseState as i, HIDE_METADATA as n, generateState as r, generateId as t };
\ No newline at end of file
